<html>
<head>
<title>node-entry.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-entry.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
  @license 
    Rollup.js v3.21.0 
    Sun, 23 Apr 2023 19:43:51 GMT - commit b79b73cd8bb98c10ab7eedae154bb5c1e03ced7d 
 
    https://github.com/rollup/rollup 
 
    Released under the MIT License. 
*/</span>
<span class="s2">import </span><span class="s1">{ resolve</span><span class="s2">, </span><span class="s1">basename</span><span class="s2">, </span><span class="s1">extname</span><span class="s2">, </span><span class="s1">dirname</span><span class="s2">, </span><span class="s1">relative as relative$1 } from </span><span class="s3">'node:path'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">require$$0$1</span><span class="s2">, </span><span class="s1">{ win32</span><span class="s2">, </span><span class="s1">posix</span><span class="s2">, </span><span class="s1">isAbsolute as isAbsolute$1</span><span class="s2">, </span><span class="s1">resolve as resolve$1 } from </span><span class="s3">'path'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">process$1</span><span class="s2">, </span><span class="s1">{ env as env$1 } from </span><span class="s3">'node:process'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">{ performance } from </span><span class="s3">'node:perf_hooks'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">{ createHash as createHash$1 } from </span><span class="s3">'node:crypto'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">{ lstat</span><span class="s2">, </span><span class="s1">realpath</span><span class="s2">, </span><span class="s1">readdir</span><span class="s2">, </span><span class="s1">readFile</span><span class="s2">, </span><span class="s1">mkdir</span><span class="s2">, </span><span class="s1">writeFile } from </span><span class="s3">'node:fs/promises'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">{ EventEmitter } from </span><span class="s3">'node:events'</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">* as tty from </span><span class="s3">'tty'</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">version$1 = </span><span class="s3">&quot;3.21.0&quot;</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">comma = </span><span class="s3">','</span><span class="s1">.charCodeAt(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">semicolon = </span><span class="s3">';'</span><span class="s1">.charCodeAt(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">chars$1 = </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">intToChar = </span><span class="s2">new </span><span class="s1">Uint8Array(</span><span class="s4">64</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// 64 possible chars.</span>
<span class="s2">const </span><span class="s1">charToInt = </span><span class="s2">new </span><span class="s1">Uint8Array(</span><span class="s4">128</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// z is 122 in ASCII</span>
<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; chars$1.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">c = chars$1.charCodeAt(i)</span><span class="s2">;</span>
    <span class="s1">intToChar[i] = c</span><span class="s2">;</span>
    <span class="s1">charToInt[c] = i</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">// Provide a fallback for older environments.</span>
<span class="s2">const </span><span class="s1">td = </span><span class="s2">typeof </span><span class="s1">TextDecoder !== </span><span class="s3">'undefined'</span>
    <span class="s1">? </span><span class="s0">/* #__PURE__ */ </span><span class="s2">new </span><span class="s1">TextDecoder()</span>
    <span class="s1">: </span><span class="s2">typeof </span><span class="s1">Buffer !== </span><span class="s3">'undefined'</span>
        <span class="s1">? {</span>
            <span class="s1">decode(buf) {</span>
                <span class="s2">const </span><span class="s1">out = Buffer.from(buf.buffer</span><span class="s2">, </span><span class="s1">buf.byteOffset</span><span class="s2">, </span><span class="s1">buf.byteLength)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">out.toString()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">: {</span>
            <span class="s1">decode(buf) {</span>
                <span class="s2">let </span><span class="s1">out = </span><span class="s3">''</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; buf.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s1">out += String.fromCharCode(buf[i])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">out</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">decode(mappings) {</span>
    <span class="s2">const </span><span class="s1">state = </span><span class="s2">new </span><span class="s1">Int32Array(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">decoded = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">semi = indexOf(mappings</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">line = []</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">sorted = </span><span class="s2">true;</span>
        <span class="s2">let </span><span class="s1">lastCol = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">state[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = index</span><span class="s2">; </span><span class="s1">i &lt; semi</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">let </span><span class="s1">seg</span><span class="s2">;</span>
            <span class="s1">i = decodeInteger(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// genColumn</span>
            <span class="s2">const </span><span class="s1">col = state[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(col &lt; lastCol)</span>
                <span class="s1">sorted = </span><span class="s2">false;</span>
            <span class="s1">lastCol = col</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(hasMoreVlq(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">semi)) {</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourcesIndex</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourceLine</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourceColumn</span>
                <span class="s2">if </span><span class="s1">(hasMoreVlq(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">semi)) {</span>
                    <span class="s1">i = decodeInteger(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// namesIndex</span>
                    <span class="s1">seg = [col</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">4</span><span class="s1">]]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">seg = [col</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">3</span><span class="s1">]]</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">seg = [col]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">line.push(seg)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!sorted)</span>
            <span class="s1">sort(line)</span><span class="s2">;</span>
        <span class="s1">decoded.push(line)</span><span class="s2">;</span>
        <span class="s1">index = semi + </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(index &lt;= mappings.length)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">decoded</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">indexOf(mappings</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s2">const </span><span class="s1">idx = mappings.indexOf(</span><span class="s3">';'</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">idx === -</span><span class="s4">1 </span><span class="s1">? mappings.length : idx</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">decodeInteger(mappings</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">j) {</span>
    <span class="s2">let </span><span class="s1">value = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">shift = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">integer = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">c = mappings.charCodeAt(pos++)</span><span class="s2">;</span>
        <span class="s1">integer = charToInt[c]</span><span class="s2">;</span>
        <span class="s1">value |= (integer &amp; </span><span class="s4">31</span><span class="s1">) &lt;&lt; shift</span><span class="s2">;</span>
        <span class="s1">shift += </span><span class="s4">5</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(integer &amp; </span><span class="s4">32</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">shouldNegate = value &amp; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">value &gt;&gt;&gt;= </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shouldNegate) {</span>
        <span class="s1">value = -</span><span class="s4">0x80000000 </span><span class="s1">| -value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state[j] += value</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">pos</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasMoreVlq(mappings</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">length) {</span>
    <span class="s2">if </span><span class="s1">(i &gt;= length)</span>
        <span class="s2">return false;</span>
    <span class="s2">return </span><span class="s1">mappings.charCodeAt(i) !== comma</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sort(line) {</span>
    <span class="s1">line.sort(sortComparator)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sortComparator(a</span><span class="s2">, </span><span class="s1">b) {</span>
    <span class="s2">return </span><span class="s1">a[</span><span class="s4">0</span><span class="s1">] - b[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">encode(decoded) {</span>
    <span class="s2">const </span><span class="s1">state = </span><span class="s2">new </span><span class="s1">Int32Array(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">bufLength = </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">16</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">subLength = bufLength - </span><span class="s4">36</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">buf = </span><span class="s2">new </span><span class="s1">Uint8Array(bufLength)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">sub = buf.subarray(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">subLength)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">pos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">out = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; decoded.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">line = decoded[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(i &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(pos === bufLength) {</span>
                <span class="s1">out += td.decode(buf)</span><span class="s2">;</span>
                <span class="s1">pos = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">buf[pos++] = semicolon</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(line.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">continue;</span>
        <span class="s1">state[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">j &lt; line.length</span><span class="s2">; </span><span class="s1">j++) {</span>
            <span class="s2">const </span><span class="s1">segment = line[j]</span><span class="s2">;</span>
            <span class="s0">// We can push up to 5 ints, each int can take at most 7 chars, and we</span>
            <span class="s0">// may push a comma.</span>
            <span class="s2">if </span><span class="s1">(pos &gt; subLength) {</span>
                <span class="s1">out += td.decode(sub)</span><span class="s2">;</span>
                <span class="s1">buf.copyWithin(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">subLength</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
                <span class="s1">pos -= subLength</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(j &gt; </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">buf[pos++] = comma</span><span class="s2">;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// genColumn</span>
            <span class="s2">if </span><span class="s1">(segment.length === </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourcesIndex</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourceLine</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// sourceColumn</span>
            <span class="s2">if </span><span class="s1">(segment.length === </span><span class="s4">4</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">; </span><span class="s0">// namesIndex</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">out + td.decode(buf.subarray(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">pos))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">encodeInteger(buf</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">segment</span><span class="s2">, </span><span class="s1">j) {</span>
    <span class="s2">const </span><span class="s1">next = segment[j]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">num = next - state[j]</span><span class="s2">;</span>
    <span class="s1">state[j] = next</span><span class="s2">;</span>
    <span class="s1">num = num &lt; </span><span class="s4">0 </span><span class="s1">? (-num &lt;&lt; </span><span class="s4">1</span><span class="s1">) | </span><span class="s4">1 </span><span class="s1">: num &lt;&lt; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">clamped = num &amp; </span><span class="s4">0b011111</span><span class="s2">;</span>
        <span class="s1">num &gt;&gt;&gt;= </span><span class="s4">5</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(num &gt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">clamped |= </span><span class="s4">0b100000</span><span class="s2">;</span>
        <span class="s1">buf[pos++] = intToChar[clamped]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(num &gt; </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">pos</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">BitSet {</span>
	<span class="s1">constructor(arg) {</span>
		<span class="s2">this</span><span class="s1">.bits = arg </span><span class="s2">instanceof </span><span class="s1">BitSet ? arg.bits.slice() : []</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">add(n) {</span>
		<span class="s2">this</span><span class="s1">.bits[n &gt;&gt; </span><span class="s4">5</span><span class="s1">] |= </span><span class="s4">1 </span><span class="s1">&lt;&lt; (n &amp; </span><span class="s4">31</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">has(n) {</span>
		<span class="s2">return </span><span class="s1">!!(</span><span class="s2">this</span><span class="s1">.bits[n &gt;&gt; </span><span class="s4">5</span><span class="s1">] &amp; (</span><span class="s4">1 </span><span class="s1">&lt;&lt; (n &amp; </span><span class="s4">31</span><span class="s1">)))</span><span class="s2">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">Chunk$1 = </span><span class="s2">class </span><span class="s1">Chunk {</span>
	<span class="s1">constructor(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">this</span><span class="s1">.start = start</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.end = end</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.original = content</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s3">''</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s3">''</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.content = content</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.storeName = </span><span class="s2">false;</span>
		<span class="s2">this</span><span class="s1">.edited = </span><span class="s2">false;</span>

		<span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.previous = </span><span class="s2">null;</span>
			<span class="s2">this</span><span class="s1">.next = </span><span class="s2">null;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">appendLeft(content) {</span>
		<span class="s2">this</span><span class="s1">.outro += content</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">appendRight(content) {</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro + content</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, this</span><span class="s1">.original)</span><span class="s2">;</span>

		<span class="s1">chunk.intro = </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
		<span class="s1">chunk.outro = </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
		<span class="s1">chunk.content = </span><span class="s2">this</span><span class="s1">.content</span><span class="s2">;</span>
		<span class="s1">chunk.storeName = </span><span class="s2">this</span><span class="s1">.storeName</span><span class="s2">;</span>
		<span class="s1">chunk.edited = </span><span class="s2">this</span><span class="s1">.edited</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">chunk</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">contains(index) {</span>
		<span class="s2">return this</span><span class="s1">.start &lt; index &amp;&amp; index &lt; </span><span class="s2">this</span><span class="s1">.end</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">eachNext(fn) {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">fn(chunk)</span><span class="s2">;</span>
			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">eachPrevious(fn) {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">fn(chunk)</span><span class="s2">;</span>
			<span class="s1">chunk = chunk.previous</span><span class="s2">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">edit(content</span><span class="s2">, </span><span class="s1">storeName</span><span class="s2">, </span><span class="s1">contentOnly) {</span>
		<span class="s2">this</span><span class="s1">.content = content</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(!contentOnly) {</span>
			<span class="s2">this</span><span class="s1">.intro = </span><span class="s3">''</span><span class="s2">;</span>
			<span class="s2">this</span><span class="s1">.outro = </span><span class="s3">''</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">this</span><span class="s1">.storeName = storeName</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.edited = </span><span class="s2">true;</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">prependLeft(content) {</span>
		<span class="s2">this</span><span class="s1">.outro = content + </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">prependRight(content) {</span>
		<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">split(index) {</span>
		<span class="s2">const </span><span class="s1">sliceIndex = index - </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">originalBefore = </span><span class="s2">this</span><span class="s1">.original.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">sliceIndex)</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">originalAfter = </span><span class="s2">this</span><span class="s1">.original.slice(sliceIndex)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.original = originalBefore</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">newChunk = </span><span class="s2">new </span><span class="s1">Chunk(index</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s1">originalAfter)</span><span class="s2">;</span>
		<span class="s1">newChunk.outro = </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s3">''</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.end = index</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.edited) {</span>
			<span class="s0">// TODO is this block necessary?...</span>
			<span class="s1">newChunk.edit(</span><span class="s3">''</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s2">this</span><span class="s1">.content = </span><span class="s3">''</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.content = originalBefore</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s1">newChunk.next = </span><span class="s2">this</span><span class="s1">.next</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(newChunk.next) newChunk.next.previous = newChunk</span><span class="s2">;</span>
		<span class="s1">newChunk.previous = </span><span class="s2">this;</span>
		<span class="s2">this</span><span class="s1">.next = newChunk</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">newChunk</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">return this</span><span class="s1">.intro + </span><span class="s2">this</span><span class="s1">.content + </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(rx) {</span>
		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true;</span>

		<span class="s2">const </span><span class="s1">trimmed = </span><span class="s2">this</span><span class="s1">.content.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(trimmed.length) {</span>
			<span class="s2">if </span><span class="s1">(trimmed !== </span><span class="s2">this</span><span class="s1">.content) {</span>
				<span class="s2">this</span><span class="s1">.split(</span><span class="s2">this</span><span class="s1">.start + trimmed.length).edit(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">return true;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.edit(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

			<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(rx) {</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true;</span>

		<span class="s2">const </span><span class="s1">trimmed = </span><span class="s2">this</span><span class="s1">.content.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(trimmed.length) {</span>
			<span class="s2">if </span><span class="s1">(trimmed !== </span><span class="s2">this</span><span class="s1">.content) {</span>
				<span class="s2">this</span><span class="s1">.split(</span><span class="s2">this</span><span class="s1">.end - trimmed.length)</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.edit(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">return true;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.edit(</span><span class="s3">''</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

			<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getBtoa () {</span>
	<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">window.btoa === </span><span class="s3">'function'</span><span class="s1">) {</span>
		<span class="s2">return </span><span class="s1">(str) =&gt; window.btoa(unescape(encodeURIComponent(str)))</span><span class="s2">;</span>
	<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Buffer === </span><span class="s3">'function'</span><span class="s1">) {</span>
		<span class="s2">return </span><span class="s1">(str) =&gt; Buffer.from(str</span><span class="s2">, </span><span class="s3">'utf-8'</span><span class="s1">).toString(</span><span class="s3">'base64'</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
		<span class="s2">return </span><span class="s1">() =&gt; {</span>
			<span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Unsupported environment: `window.btoa` or `Buffer` should be supported.'</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s1">}</span><span class="s2">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">btoa = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">getBtoa()</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">SourceMap {</span>
	<span class="s1">constructor(properties) {</span>
		<span class="s2">this</span><span class="s1">.version = </span><span class="s4">3</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.file = properties.file</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.sources = properties.sources</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.sourcesContent = properties.sourcesContent</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.names = properties.names</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.mappings = encode(properties.mappings)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">properties.x_google_ignoreList !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
			<span class="s2">this</span><span class="s1">.x_google_ignoreList = properties.x_google_ignoreList</span><span class="s2">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">return </span><span class="s1">JSON.stringify(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">toUrl() {</span>
		<span class="s2">return </span><span class="s3">'data:application/json;charset=utf-8;base64,' </span><span class="s1">+ btoa(</span><span class="s2">this</span><span class="s1">.toString())</span><span class="s2">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">guessIndent(code) {</span>
	<span class="s2">const </span><span class="s1">lines = code.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>

	<span class="s2">const </span><span class="s1">tabbed = lines.filter((line) =&gt; </span><span class="s4">/^\t+/</span><span class="s1">.test(line))</span><span class="s2">;</span>
	<span class="s2">const </span><span class="s1">spaced = lines.filter((line) =&gt; </span><span class="s4">/^ {2,}/</span><span class="s1">.test(line))</span><span class="s2">;</span>

	<span class="s2">if </span><span class="s1">(tabbed.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; spaced.length === </span><span class="s4">0</span><span class="s1">) {</span>
		<span class="s2">return null;</span>
	<span class="s1">}</span>

	<span class="s0">// More lines tabbed than spaced? Assume tabs, and</span>
	<span class="s0">// default to tabs in the case of a tie (or nothing</span>
	<span class="s0">// to go on)</span>
	<span class="s2">if </span><span class="s1">(tabbed.length &gt;= spaced.length) {</span>
		<span class="s2">return </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s0">// Otherwise, we need to guess the multiple</span>
	<span class="s2">const </span><span class="s1">min = spaced.reduce((previous</span><span class="s2">, </span><span class="s1">current) =&gt; {</span>
		<span class="s2">const </span><span class="s1">numSpaces = </span><span class="s4">/^ +/</span><span class="s1">.exec(current)[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
		<span class="s2">return </span><span class="s1">Math.min(numSpaces</span><span class="s2">, </span><span class="s1">previous)</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">, </span><span class="s1">Infinity)</span><span class="s2">;</span>

	<span class="s2">return new </span><span class="s1">Array(min + </span><span class="s4">1</span><span class="s1">).join(</span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getRelativePath(from</span><span class="s2">, </span><span class="s1">to) {</span>
	<span class="s2">const </span><span class="s1">fromParts = from.split(</span><span class="s4">/[/\\]/</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s2">const </span><span class="s1">toParts = to.split(</span><span class="s4">/[/\\]/</span><span class="s1">)</span><span class="s2">;</span>

	<span class="s1">fromParts.pop()</span><span class="s2">; </span><span class="s0">// get dirname</span>

	<span class="s2">while </span><span class="s1">(fromParts[</span><span class="s4">0</span><span class="s1">] === toParts[</span><span class="s4">0</span><span class="s1">]) {</span>
		<span class="s1">fromParts.shift()</span><span class="s2">;</span>
		<span class="s1">toParts.shift()</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s2">if </span><span class="s1">(fromParts.length) {</span>
		<span class="s2">let </span><span class="s1">i = fromParts.length</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(i--) fromParts[i] = </span><span class="s3">'..'</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">fromParts.concat(toParts).join(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">toString$1 = Object.prototype.toString</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">isObject$1(thing) {</span>
	<span class="s2">return </span><span class="s1">toString$1.call(thing) === </span><span class="s3">'[object Object]'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getLocator$1(source) {</span>
	<span class="s2">const </span><span class="s1">originalLines = source.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s2">const </span><span class="s1">lineOffsets = []</span><span class="s2">;</span>

	<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">pos = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; originalLines.length</span><span class="s2">; </span><span class="s1">i++) {</span>
		<span class="s1">lineOffsets.push(pos)</span><span class="s2">;</span>
		<span class="s1">pos += originalLines[i].length + </span><span class="s4">1</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s2">return function </span><span class="s1">locate(index) {</span>
		<span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">j = lineOffsets.length</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(i &lt; j) {</span>
			<span class="s2">const </span><span class="s1">m = (i + j) &gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(index &lt; lineOffsets[m]) {</span>
				<span class="s1">j = m</span><span class="s2">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">i = m + </span><span class="s4">1</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">const </span><span class="s1">line = i - </span><span class="s4">1</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">column = index - lineOffsets[line]</span><span class="s2">;</span>
		<span class="s2">return </span><span class="s1">{ line</span><span class="s2">, </span><span class="s1">column }</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Mappings {</span>
	<span class="s1">constructor(hires) {</span>
		<span class="s2">this</span><span class="s1">.hires = hires</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.generatedCodeLine = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.raw = []</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.rawSegments = </span><span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = []</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null;</span>
	<span class="s1">}</span>

	<span class="s1">addEdit(sourceIndex</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">nameIndex) {</span>
		<span class="s2">if </span><span class="s1">(content.length) {</span>
			<span class="s2">const </span><span class="s1">segment = [</span><span class="s2">this</span><span class="s1">.generatedCodeColumn</span><span class="s2">, </span><span class="s1">sourceIndex</span><span class="s2">, </span><span class="s1">loc.line</span><span class="s2">, </span><span class="s1">loc.column]</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(nameIndex &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">segment.push(nameIndex)</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">this</span><span class="s1">.rawSegments.push(segment)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pending) {</span>
			<span class="s2">this</span><span class="s1">.rawSegments.push(</span><span class="s2">this</span><span class="s1">.pending)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.advance(content)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null;</span>
	<span class="s1">}</span>

	<span class="s1">addUneditedChunk(sourceIndex</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">original</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">sourcemapLocations) {</span>
		<span class="s2">let </span><span class="s1">originalCharIndex = chunk.start</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">first = </span><span class="s2">true;</span>

		<span class="s2">while </span><span class="s1">(originalCharIndex &lt; chunk.end) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hires || first || sourcemapLocations.has(originalCharIndex)) {</span>
				<span class="s2">this</span><span class="s1">.rawSegments.push([</span><span class="s2">this</span><span class="s1">.generatedCodeColumn</span><span class="s2">, </span><span class="s1">sourceIndex</span><span class="s2">, </span><span class="s1">loc.line</span><span class="s2">, </span><span class="s1">loc.column])</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(original[originalCharIndex] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) {</span>
				<span class="s1">loc.line += </span><span class="s4">1</span><span class="s2">;</span>
				<span class="s1">loc.column = </span><span class="s4">0</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.generatedCodeLine += </span><span class="s4">1</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = </span><span class="s2">this</span><span class="s1">.rawSegments = []</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s4">0</span><span class="s2">;</span>
				<span class="s1">first = </span><span class="s2">true;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">loc.column += </span><span class="s4">1</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.generatedCodeColumn += </span><span class="s4">1</span><span class="s2">;</span>
				<span class="s1">first = </span><span class="s2">false;</span>
			<span class="s1">}</span>

			<span class="s1">originalCharIndex += </span><span class="s4">1</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.pending = </span><span class="s2">null;</span>
	<span class="s1">}</span>

	<span class="s1">advance(str) {</span>
		<span class="s2">if </span><span class="s1">(!str) </span><span class="s2">return;</span>

		<span class="s2">const </span><span class="s1">lines = str.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(lines.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
			<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; lines.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i++) {</span>
				<span class="s2">this</span><span class="s1">.generatedCodeLine++</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.raw[</span><span class="s2">this</span><span class="s1">.generatedCodeLine] = </span><span class="s2">this</span><span class="s1">.rawSegments = []</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">this</span><span class="s1">.generatedCodeColumn = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.generatedCodeColumn += lines[lines.length - </span><span class="s4">1</span><span class="s1">].length</span><span class="s2">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">n = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">warned = {</span>
	<span class="s1">insertLeft: </span><span class="s2">false,</span>
	<span class="s1">insertRight: </span><span class="s2">false,</span>
	<span class="s1">storeName: </span><span class="s2">false,</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">MagicString {</span>
	<span class="s1">constructor(string</span><span class="s2">, </span><span class="s1">options = {}) {</span>
		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk$1(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">string.length</span><span class="s2">, </span><span class="s1">string)</span><span class="s2">;</span>

		<span class="s1">Object.defineProperties(</span><span class="s2">this, </span><span class="s1">{</span>
			<span class="s1">original: { writable: </span><span class="s2">true, </span><span class="s1">value: string }</span><span class="s2">,</span>
			<span class="s1">outro: { writable: </span><span class="s2">true, </span><span class="s1">value: </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">,</span>
			<span class="s1">intro: { writable: </span><span class="s2">true, </span><span class="s1">value: </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">,</span>
			<span class="s1">firstChunk: { writable: </span><span class="s2">true, </span><span class="s1">value: chunk }</span><span class="s2">,</span>
			<span class="s1">lastChunk: { writable: </span><span class="s2">true, </span><span class="s1">value: chunk }</span><span class="s2">,</span>
			<span class="s1">lastSearchedChunk: { writable: </span><span class="s2">true, </span><span class="s1">value: chunk }</span><span class="s2">,</span>
			<span class="s1">byStart: { writable: </span><span class="s2">true, </span><span class="s1">value: {} }</span><span class="s2">,</span>
			<span class="s1">byEnd: { writable: </span><span class="s2">true, </span><span class="s1">value: {} }</span><span class="s2">,</span>
			<span class="s1">filename: { writable: </span><span class="s2">true, </span><span class="s1">value: options.filename }</span><span class="s2">,</span>
			<span class="s1">indentExclusionRanges: { writable: </span><span class="s2">true, </span><span class="s1">value: options.indentExclusionRanges }</span><span class="s2">,</span>
			<span class="s1">sourcemapLocations: { writable: </span><span class="s2">true, </span><span class="s1">value: </span><span class="s2">new </span><span class="s1">BitSet() }</span><span class="s2">,</span>
			<span class="s1">storedNames: { writable: </span><span class="s2">true, </span><span class="s1">value: {} }</span><span class="s2">,</span>
			<span class="s1">indentStr: { writable: </span><span class="s2">true, </span><span class="s1">value: undefined }</span><span class="s2">,</span>
			<span class="s1">ignoreList: { writable: </span><span class="s2">true, </span><span class="s1">value: options.ignoreList }</span><span class="s2">,</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.byStart[</span><span class="s4">0</span><span class="s1">] = chunk</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.byEnd[string.length] = chunk</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">addSourcemapLocation(char) {</span>
		<span class="s2">this</span><span class="s1">.sourcemapLocations.add(char)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">append(content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'outro content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.outro += content</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">appendLeft(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'inserted content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(index)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byEnd[index]</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.appendLeft(content)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.intro += content</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">appendRight(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'inserted content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(index)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[index]</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.appendRight(content)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.outro += content</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">cloned = </span><span class="s2">new </span><span class="s1">MagicString(</span><span class="s2">this</span><span class="s1">.original</span><span class="s2">, </span><span class="s1">{ filename: </span><span class="s2">this</span><span class="s1">.filename })</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">originalChunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone())</span><span class="s2">;</span>

		<span class="s2">while </span><span class="s1">(originalChunk) {</span>
			<span class="s1">cloned.byStart[clonedChunk.start] = clonedChunk</span><span class="s2">;</span>
			<span class="s1">cloned.byEnd[clonedChunk.end] = clonedChunk</span><span class="s2">;</span>

			<span class="s2">const </span><span class="s1">nextOriginalChunk = originalChunk.next</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">nextClonedChunk = nextOriginalChunk &amp;&amp; nextOriginalChunk.clone()</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(nextClonedChunk) {</span>
				<span class="s1">clonedChunk.next = nextClonedChunk</span><span class="s2">;</span>
				<span class="s1">nextClonedChunk.previous = clonedChunk</span><span class="s2">;</span>

				<span class="s1">clonedChunk = nextClonedChunk</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s1">originalChunk = nextOriginalChunk</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s1">cloned.lastChunk = clonedChunk</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.indentExclusionRanges) {</span>
			<span class="s1">cloned.indentExclusionRanges = </span><span class="s2">this</span><span class="s1">.indentExclusionRanges.slice()</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s1">cloned.sourcemapLocations = </span><span class="s2">new </span><span class="s1">BitSet(</span><span class="s2">this</span><span class="s1">.sourcemapLocations)</span><span class="s2">;</span>

		<span class="s1">cloned.intro = </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
		<span class="s1">cloned.outro = </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">generateDecodedMap(options) {</span>
		<span class="s1">options = options || {}</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">sourceIndex = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">names = Object.keys(</span><span class="s2">this</span><span class="s1">.storedNames)</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">mappings = </span><span class="s2">new </span><span class="s1">Mappings(options.hires)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">locate = getLocator$1(</span><span class="s2">this</span><span class="s1">.original)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.intro)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.firstChunk.eachNext((chunk) =&gt; {</span>
			<span class="s2">const </span><span class="s1">loc = locate(chunk.start)</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(chunk.intro.length) mappings.advance(chunk.intro)</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
				<span class="s1">mappings.addEdit(</span>
					<span class="s1">sourceIndex</span><span class="s2">,</span>
					<span class="s1">chunk.content</span><span class="s2">,</span>
					<span class="s1">loc</span><span class="s2">,</span>
					<span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -</span><span class="s4">1</span>
				<span class="s1">)</span><span class="s2">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">mappings.addUneditedChunk(sourceIndex</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, this</span><span class="s1">.original</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, this</span><span class="s1">.sourcemapLocations)</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.outro.length) mappings.advance(chunk.outro)</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">{</span>
			<span class="s1">file: options.file ? options.file.split(</span><span class="s4">/[/\\]/</span><span class="s1">).pop() : undefined</span><span class="s2">,</span>
			<span class="s1">sources: [options.source ? getRelativePath(options.file || </span><span class="s3">''</span><span class="s2">, </span><span class="s1">options.source) : (options.file || </span><span class="s3">''</span><span class="s1">)]</span><span class="s2">,</span>
			<span class="s1">sourcesContent: options.includeContent ? [</span><span class="s2">this</span><span class="s1">.original] : undefined</span><span class="s2">,</span>
			<span class="s1">names</span><span class="s2">,</span>
			<span class="s1">mappings: mappings.raw</span><span class="s2">,</span>
			<span class="s1">x_google_ignoreList: </span><span class="s2">this</span><span class="s1">.ignoreList ? [sourceIndex] : undefined</span>
		<span class="s1">}</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">generateMap(options) {</span>
		<span class="s2">return new </span><span class="s1">SourceMap(</span><span class="s2">this</span><span class="s1">.generateDecodedMap(options))</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">_ensureindentStr() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.indentStr === undefined) {</span>
			<span class="s2">this</span><span class="s1">.indentStr = guessIndent(</span><span class="s2">this</span><span class="s1">.original)</span><span class="s2">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_getRawIndentString() {</span>
		<span class="s2">this</span><span class="s1">._ensureindentStr()</span><span class="s2">;</span>
		<span class="s2">return this</span><span class="s1">.indentStr</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">getIndentString() {</span>
		<span class="s2">this</span><span class="s1">._ensureindentStr()</span><span class="s2">;</span>
		<span class="s2">return this</span><span class="s1">.indentStr === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">' </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.indentStr</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">indent(indentStr</span><span class="s2">, </span><span class="s1">options) {</span>
		<span class="s2">const </span><span class="s1">pattern = </span><span class="s4">/^[^\r\n]/gm</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(isObject$1(indentStr)) {</span>
			<span class="s1">options = indentStr</span><span class="s2">;</span>
			<span class="s1">indentStr = undefined</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === undefined) {</span>
			<span class="s2">this</span><span class="s1">._ensureindentStr()</span><span class="s2">;</span>
			<span class="s1">indentStr = </span><span class="s2">this</span><span class="s1">.indentStr || </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s3">''</span><span class="s1">) </span><span class="s2">return this; </span><span class="s0">// noop</span>

		<span class="s1">options = options || {}</span><span class="s2">;</span>

		<span class="s0">// Process exclusion ranges</span>
		<span class="s2">const </span><span class="s1">isExcluded = {}</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(options.exclude) {</span>
			<span class="s2">const </span><span class="s1">exclusions =</span>
				<span class="s2">typeof </span><span class="s1">options.exclude[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'number' </span><span class="s1">? [options.exclude] : options.exclude</span><span class="s2">;</span>
			<span class="s1">exclusions.forEach((exclusion) =&gt; {</span>
				<span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = exclusion[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">; </span><span class="s1">i &lt; exclusion[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
					<span class="s1">isExcluded[i] = </span><span class="s2">true;</span>
				<span class="s1">}</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">let </span><span class="s1">shouldIndentNextCharacter = options.indentStart !== </span><span class="s2">false;</span>
		<span class="s2">const </span><span class="s1">replacer = (match) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(shouldIndentNextCharacter) </span><span class="s2">return </span><span class="s3">`</span><span class="s1">${indentStr}${match}</span><span class="s3">`</span><span class="s2">;</span>
			<span class="s1">shouldIndentNextCharacter = </span><span class="s2">true;</span>
			<span class="s2">return </span><span class="s1">match</span><span class="s2">;</span>
		<span class="s1">}</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(pattern</span><span class="s2">, </span><span class="s1">replacer)</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">charIndex = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">const </span><span class="s1">end = chunk.end</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
				<span class="s2">if </span><span class="s1">(!isExcluded[charIndex]) {</span>
					<span class="s1">chunk.content = chunk.content.replace(pattern</span><span class="s2">, </span><span class="s1">replacer)</span><span class="s2">;</span>

					<span class="s2">if </span><span class="s1">(chunk.content.length) {</span>
						<span class="s1">shouldIndentNextCharacter = chunk.content[chunk.content.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">charIndex = chunk.start</span><span class="s2">;</span>

				<span class="s2">while </span><span class="s1">(charIndex &lt; end) {</span>
					<span class="s2">if </span><span class="s1">(!isExcluded[charIndex]) {</span>
						<span class="s2">const </span><span class="s1">char = </span><span class="s2">this</span><span class="s1">.original[charIndex]</span><span class="s2">;</span>

						<span class="s2">if </span><span class="s1">(char === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) {</span>
							<span class="s1">shouldIndentNextCharacter = </span><span class="s2">true;</span>
						<span class="s1">} </span><span class="s2">else if </span><span class="s1">(char !== </span><span class="s3">'</span><span class="s2">\r</span><span class="s3">' </span><span class="s1">&amp;&amp; shouldIndentNextCharacter) {</span>
							<span class="s1">shouldIndentNextCharacter = </span><span class="s2">false;</span>

							<span class="s2">if </span><span class="s1">(charIndex === chunk.start) {</span>
								<span class="s1">chunk.prependRight(indentStr)</span><span class="s2">;</span>
							<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
								<span class="s2">this</span><span class="s1">._splitChunk(chunk</span><span class="s2">, </span><span class="s1">charIndex)</span><span class="s2">;</span>
								<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
								<span class="s1">chunk.prependRight(indentStr)</span><span class="s2">;</span>
							<span class="s1">}</span>
						<span class="s1">}</span>
					<span class="s1">}</span>

					<span class="s1">charIndex += </span><span class="s4">1</span><span class="s2">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">charIndex = chunk.end</span><span class="s2">;</span>
			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(pattern</span><span class="s2">, </span><span class="s1">replacer)</span><span class="s2">;</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">insert() {</span>
		<span class="s2">throw new </span><span class="s1">Error(</span>
			<span class="s3">'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'</span>
		<span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">insertLeft(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(!warned.insertLeft) {</span>
			<span class="s1">console.warn(</span>
				<span class="s3">'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'</span>
			<span class="s1">)</span><span class="s2">; </span><span class="s0">// eslint-disable-line no-console</span>
			<span class="s1">warned.insertLeft = </span><span class="s2">true;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">.appendLeft(index</span><span class="s2">, </span><span class="s1">content)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">insertRight(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(!warned.insertRight) {</span>
			<span class="s1">console.warn(</span>
				<span class="s3">'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'</span>
			<span class="s1">)</span><span class="s2">; </span><span class="s0">// eslint-disable-line no-console</span>
			<span class="s1">warned.insertRight = </span><span class="s2">true;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">.prependRight(index</span><span class="s2">, </span><span class="s1">content)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">move(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">index) {</span>
		<span class="s2">if </span><span class="s1">(index &gt;= start &amp;&amp; index &lt;= end) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot move a selection inside itself'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(start)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">._split(end)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">._split(index)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">first = </span><span class="s2">this</span><span class="s1">.byStart[start]</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.byEnd[end]</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">oldLeft = first.previous</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">oldRight = last.next</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">newRight = </span><span class="s2">this</span><span class="s1">.byStart[index]</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(!newRight &amp;&amp; last === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">return this;</span>
		<span class="s2">const </span><span class="s1">newLeft = newRight ? newRight.previous : </span><span class="s2">this</span><span class="s1">.lastChunk</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(oldLeft) oldLeft.next = oldRight</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(oldRight) oldRight.previous = oldLeft</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(newLeft) newLeft.next = first</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(newRight) newRight.previous = last</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(!first.previous) </span><span class="s2">this</span><span class="s1">.firstChunk = last.next</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(!last.next) {</span>
			<span class="s2">this</span><span class="s1">.lastChunk = first.previous</span><span class="s2">;</span>
			<span class="s2">this</span><span class="s1">.lastChunk.next = </span><span class="s2">null;</span>
		<span class="s1">}</span>

		<span class="s1">first.previous = newLeft</span><span class="s2">;</span>
		<span class="s1">last.next = newRight || </span><span class="s2">null;</span>

		<span class="s2">if </span><span class="s1">(!newLeft) </span><span class="s2">this</span><span class="s1">.firstChunk = first</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(!newRight) </span><span class="s2">this</span><span class="s1">.lastChunk = last</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">overwrite(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">options) {</span>
		<span class="s1">options = options || {}</span><span class="s2">;</span>
		<span class="s2">return this</span><span class="s1">.update(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">{ ...options</span><span class="s2">, </span><span class="s1">overwrite: !options.contentOnly })</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">update(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">options) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'replacement content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s4">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(end &gt; </span><span class="s2">this</span><span class="s1">.original.length) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'end is out of bounds'</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(start === end)</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s3">'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'</span>
			<span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(start)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">._split(end)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(options === </span><span class="s2">true</span><span class="s1">) {</span>
			<span class="s2">if </span><span class="s1">(!warned.storeName) {</span>
				<span class="s1">console.warn(</span>
					<span class="s3">'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'</span>
				<span class="s1">)</span><span class="s2">; </span><span class="s0">// eslint-disable-line no-console</span>
				<span class="s1">warned.storeName = </span><span class="s2">true;</span>
			<span class="s1">}</span>

			<span class="s1">options = { storeName: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">const </span><span class="s1">storeName = options !== undefined ? options.storeName : </span><span class="s2">false;</span>
		<span class="s2">const </span><span class="s1">overwrite = options !== undefined ? options.overwrite : </span><span class="s2">false;</span>

		<span class="s2">if </span><span class="s1">(storeName) {</span>
			<span class="s2">const </span><span class="s1">original = </span><span class="s2">this</span><span class="s1">.original.slice(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
			<span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">.storedNames</span><span class="s2">, </span><span class="s1">original</span><span class="s2">, </span><span class="s1">{</span>
				<span class="s1">writable: </span><span class="s2">true,</span>
				<span class="s1">value: </span><span class="s2">true,</span>
				<span class="s1">enumerable: </span><span class="s2">true,</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">const </span><span class="s1">first = </span><span class="s2">this</span><span class="s1">.byStart[start]</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.byEnd[end]</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(first) {</span>
			<span class="s2">let </span><span class="s1">chunk = first</span><span class="s2">;</span>
			<span class="s2">while </span><span class="s1">(chunk !== last) {</span>
				<span class="s2">if </span><span class="s1">(chunk.next !== </span><span class="s2">this</span><span class="s1">.byStart[chunk.end]) {</span>
					<span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot overwrite across a split point'</span><span class="s1">)</span><span class="s2">;</span>
				<span class="s1">}</span>
				<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
				<span class="s1">chunk.edit(</span><span class="s3">''</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s1">first.edit(content</span><span class="s2">, </span><span class="s1">storeName</span><span class="s2">, </span><span class="s1">!overwrite)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s0">// must be inserting at the end</span>
			<span class="s2">const </span><span class="s1">newChunk = </span><span class="s2">new </span><span class="s1">Chunk$1(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).edit(content</span><span class="s2">, </span><span class="s1">storeName)</span><span class="s2">;</span>

			<span class="s0">// TODO last chunk in the array may not be the last chunk, if it's moved...</span>
			<span class="s1">last.next = newChunk</span><span class="s2">;</span>
			<span class="s1">newChunk.previous = last</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">prepend(content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'outro content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">prependLeft(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'inserted content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(index)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byEnd[index]</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.prependLeft(content)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.intro = content + </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">prependRight(index</span><span class="s2">, </span><span class="s1">content) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">content !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'inserted content must be a string'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(index)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[index]</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.prependRight(content)</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.outro = content + </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">remove(start</span><span class="s2">, </span><span class="s1">end) {</span>
		<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s4">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(start === end) </span><span class="s2">return this;</span>

		<span class="s2">if </span><span class="s1">(start &lt; </span><span class="s4">0 </span><span class="s1">|| end &gt; </span><span class="s2">this</span><span class="s1">.original.length) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Character is out of bounds'</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(start &gt; end) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'end must be greater than start'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">._split(start)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">._split(end)</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.byStart[start]</span><span class="s2">;</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">chunk.intro = </span><span class="s3">''</span><span class="s2">;</span>
			<span class="s1">chunk.outro = </span><span class="s3">''</span><span class="s2">;</span>
			<span class="s1">chunk.edit(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

			<span class="s1">chunk = end &gt; chunk.end ? </span><span class="s2">this</span><span class="s1">.byStart[chunk.end] : </span><span class="s2">null;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">lastChar() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return this</span><span class="s1">.outro[</span><span class="s2">this</span><span class="s1">.outro.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk</span><span class="s2">;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(chunk.outro.length) </span><span class="s2">return </span><span class="s1">chunk.outro[chunk.outro.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(chunk.content.length) </span><span class="s2">return </span><span class="s1">chunk.content[chunk.content.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(chunk.intro.length) </span><span class="s2">return </span><span class="s1">chunk.intro[chunk.intro.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.previous))</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return this</span><span class="s1">.intro[</span><span class="s2">this</span><span class="s1">.intro.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
		<span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">lastLine() {</span>
		<span class="s2">let </span><span class="s1">lineIndex = </span><span class="s2">this</span><span class="s1">.outro.lastIndexOf(n)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">.outro.substr(lineIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">lineStr = </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk</span><span class="s2">;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(chunk.outro.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.outro.lastIndexOf(n)</span><span class="s2">;</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.outro.substr(lineIndex + </span><span class="s4">1</span><span class="s1">) + lineStr</span><span class="s2">;</span>
				<span class="s1">lineStr = chunk.outro + lineStr</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.content.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.content.lastIndexOf(n)</span><span class="s2">;</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.content.substr(lineIndex + </span><span class="s4">1</span><span class="s1">) + lineStr</span><span class="s2">;</span>
				<span class="s1">lineStr = chunk.content + lineStr</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(chunk.intro.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">lineIndex = chunk.intro.lastIndexOf(n)</span><span class="s2">;</span>
				<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">chunk.intro.substr(lineIndex + </span><span class="s4">1</span><span class="s1">) + lineStr</span><span class="s2">;</span>
				<span class="s1">lineStr = chunk.intro + lineStr</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.previous))</span><span class="s2">;</span>
		<span class="s1">lineIndex = </span><span class="s2">this</span><span class="s1">.intro.lastIndexOf(n)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(lineIndex !== -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return this</span><span class="s1">.intro.substr(lineIndex + </span><span class="s4">1</span><span class="s1">) + lineStr</span><span class="s2">;</span>
		<span class="s2">return this</span><span class="s1">.intro + lineStr</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">slice(start = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">end = </span><span class="s2">this</span><span class="s1">.original.length) {</span>
		<span class="s2">while </span><span class="s1">(start &lt; </span><span class="s4">0</span><span class="s1">) start += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(end &lt; </span><span class="s4">0</span><span class="s1">) end += </span><span class="s2">this</span><span class="s1">.original.length</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">result = </span><span class="s3">''</span><span class="s2">;</span>

		<span class="s0">// find start chunk</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(chunk &amp;&amp; (chunk.start &gt; start || chunk.end &lt;= start)) {</span>
			<span class="s0">// found end chunk before start</span>
			<span class="s2">if </span><span class="s1">(chunk.start &lt; end &amp;&amp; chunk.end &gt;= end) {</span>
				<span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(chunk &amp;&amp; chunk.edited &amp;&amp; chunk.start !== start)</span>
			<span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Cannot use replaced character </span><span class="s1">${start} </span><span class="s3">as slice start anchor.`</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">startChunk = chunk</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">if </span><span class="s1">(chunk.intro &amp;&amp; (startChunk !== chunk || chunk.start === start)) {</span>
				<span class="s1">result += chunk.intro</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">const </span><span class="s1">containsEnd = chunk.start &lt; end &amp;&amp; chunk.end &gt;= end</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(containsEnd &amp;&amp; chunk.edited &amp;&amp; chunk.end !== end)</span>
				<span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Cannot use replaced character </span><span class="s1">${end} </span><span class="s3">as slice end anchor.`</span><span class="s1">)</span><span class="s2">;</span>

			<span class="s2">const </span><span class="s1">sliceStart = startChunk === chunk ? start - chunk.start : </span><span class="s4">0</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length</span><span class="s2">;</span>

			<span class="s1">result += chunk.content.slice(sliceStart</span><span class="s2">, </span><span class="s1">sliceEnd)</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(chunk.outro &amp;&amp; (!containsEnd || chunk.end === end)) {</span>
				<span class="s1">result += chunk.outro</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(containsEnd) {</span>
				<span class="s2">break;</span>
			<span class="s1">}</span>

			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s0">// TODO deprecate this? not really very useful</span>
	<span class="s1">snip(start</span><span class="s2">, </span><span class="s1">end) {</span>
		<span class="s2">const </span><span class="s1">clone = </span><span class="s2">this</span><span class="s1">.clone()</span><span class="s2">;</span>
		<span class="s1">clone.remove(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
		<span class="s1">clone.remove(end</span><span class="s2">, </span><span class="s1">clone.original.length)</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">clone</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">_split(index) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.byStart[index] || </span><span class="s2">this</span><span class="s1">.byEnd[index]) </span><span class="s2">return;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastSearchedChunk</span><span class="s2">;</span>
		<span class="s2">const </span><span class="s1">searchForward = index &gt; chunk.end</span><span class="s2">;</span>

		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s2">if </span><span class="s1">(chunk.contains(index)) </span><span class="s2">return this</span><span class="s1">._splitChunk(chunk</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>

			<span class="s1">chunk = searchForward ? </span><span class="s2">this</span><span class="s1">.byStart[chunk.end] : </span><span class="s2">this</span><span class="s1">.byEnd[chunk.start]</span><span class="s2">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">_splitChunk(chunk</span><span class="s2">, </span><span class="s1">index) {</span>
		<span class="s2">if </span><span class="s1">(chunk.edited &amp;&amp; chunk.content.length) {</span>
			<span class="s0">// zero-length edited chunks are a special case (overlapping replacements)</span>
			<span class="s2">const </span><span class="s1">loc = getLocator$1(</span><span class="s2">this</span><span class="s1">.original)(index)</span><span class="s2">;</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s3">`Cannot split a chunk that has already been edited (</span><span class="s1">${loc.line}</span><span class="s3">:</span><span class="s1">${loc.column} </span><span class="s3">– &quot;</span><span class="s1">${chunk.original}</span><span class="s3">&quot;)`</span>
			<span class="s1">)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">const </span><span class="s1">newChunk = chunk.split(index)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.byEnd[index] = chunk</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.byStart[index] = newChunk</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.byEnd[newChunk.end] = newChunk</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(chunk === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">this</span><span class="s1">.lastChunk = newChunk</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.lastSearchedChunk = chunk</span><span class="s2">;</span>
		<span class="s2">return true;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">let </span><span class="s1">str = </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>
		<span class="s2">while </span><span class="s1">(chunk) {</span>
			<span class="s1">str += chunk.toString()</span><span class="s2">;</span>
			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">str + </span><span class="s2">this</span><span class="s1">.outro</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">isEmpty() {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(</span>
				<span class="s1">(chunk.intro.length &amp;&amp; chunk.intro.trim()) ||</span>
				<span class="s1">(chunk.content.length &amp;&amp; chunk.content.trim()) ||</span>
				<span class="s1">(chunk.outro.length &amp;&amp; chunk.outro.trim())</span>
			<span class="s1">)</span>
				<span class="s2">return false;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.next))</span><span class="s2">;</span>
		<span class="s2">return true;</span>
	<span class="s1">}</span>

	<span class="s1">length() {</span>
		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">length = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s2">do </span><span class="s1">{</span>
			<span class="s1">length += chunk.intro.length + chunk.content.length + chunk.outro.length</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">((chunk = chunk.next))</span><span class="s2">;</span>
		<span class="s2">return </span><span class="s1">length</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trimLines() {</span>
		<span class="s2">return this</span><span class="s1">.trim(</span><span class="s3">'[</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n]'</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trim(charType) {</span>
		<span class="s2">return this</span><span class="s1">.trimStart(charType).trimEnd(charType)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trimEndAborted(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp((charType || </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">s'</span><span class="s1">) + </span><span class="s3">'+$'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.outro = </span><span class="s2">this</span><span class="s1">.outro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outro.length) </span><span class="s2">return true;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.lastChunk</span><span class="s2">;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">end = chunk.end</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">aborted = chunk.trimEnd(rx)</span><span class="s2">;</span>

			<span class="s0">// if chunk was trimmed, we have a new lastChunk</span>
			<span class="s2">if </span><span class="s1">(chunk.end !== end) {</span>
				<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lastChunk === chunk) {</span>
					<span class="s2">this</span><span class="s1">.lastChunk = chunk.next</span><span class="s2">;</span>
				<span class="s1">}</span>

				<span class="s2">this</span><span class="s1">.byEnd[chunk.end] = chunk</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.byStart[chunk.next.start] = chunk.next</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.byEnd[chunk.next.end] = chunk.next</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(aborted) </span><span class="s2">return true;</span>
			<span class="s1">chunk = chunk.previous</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(chunk)</span><span class="s2">;</span>

		<span class="s2">return false;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(charType) {</span>
		<span class="s2">this</span><span class="s1">.trimEndAborted(charType)</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>
	<span class="s1">trimStartAborted(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">'^' </span><span class="s1">+ (charType || </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">s'</span><span class="s1">) + </span><span class="s3">'+'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length) </span><span class="s2">return true;</span>

		<span class="s2">let </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.firstChunk</span><span class="s2">;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">end = chunk.end</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">aborted = chunk.trimStart(rx)</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(chunk.end !== end) {</span>
				<span class="s0">// special case...</span>
				<span class="s2">if </span><span class="s1">(chunk === </span><span class="s2">this</span><span class="s1">.lastChunk) </span><span class="s2">this</span><span class="s1">.lastChunk = chunk.next</span><span class="s2">;</span>

				<span class="s2">this</span><span class="s1">.byEnd[chunk.end] = chunk</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.byStart[chunk.next.start] = chunk.next</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.byEnd[chunk.next.end] = chunk.next</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(aborted) </span><span class="s2">return true;</span>
			<span class="s1">chunk = chunk.next</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(chunk)</span><span class="s2">;</span>

		<span class="s2">return false;</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(charType) {</span>
		<span class="s2">this</span><span class="s1">.trimStartAborted(charType)</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">hasChanged() {</span>
		<span class="s2">return this</span><span class="s1">.original !== </span><span class="s2">this</span><span class="s1">.toString()</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">_replaceRegexp(searchValue</span><span class="s2">, </span><span class="s1">replacement) {</span>
		<span class="s2">function </span><span class="s1">getReplacement(match</span><span class="s2">, </span><span class="s1">str) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">replacement === </span><span class="s3">'string'</span><span class="s1">) {</span>
				<span class="s2">return </span><span class="s1">replacement.replace(</span><span class="s4">/\$(\$|&amp;|\d+)/g</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
					<span class="s0">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter</span>
					<span class="s2">if </span><span class="s1">(i === </span><span class="s3">'$'</span><span class="s1">) </span><span class="s2">return </span><span class="s3">'$'</span><span class="s2">;</span>
					<span class="s2">if </span><span class="s1">(i === </span><span class="s3">'&amp;'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
					<span class="s2">const </span><span class="s1">num = +i</span><span class="s2">;</span>
					<span class="s2">if </span><span class="s1">(num &lt; match.length) </span><span class="s2">return </span><span class="s1">match[+i]</span><span class="s2">;</span>
					<span class="s2">return </span><span class="s3">`$</span><span class="s1">${i}</span><span class="s3">`</span><span class="s2">;</span>
				<span class="s1">})</span><span class="s2">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s2">return </span><span class="s1">replacement(...match</span><span class="s2">, </span><span class="s1">match.index</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">match.groups)</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">function </span><span class="s1">matchAll(re</span><span class="s2">, </span><span class="s1">str) {</span>
			<span class="s2">let </span><span class="s1">match</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">matches = []</span><span class="s2">;</span>
			<span class="s2">while </span><span class="s1">((match = re.exec(str))) {</span>
				<span class="s1">matches.push(match)</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">return </span><span class="s1">matches</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">if </span><span class="s1">(searchValue.global) {</span>
			<span class="s2">const </span><span class="s1">matches = matchAll(searchValue</span><span class="s2">, this</span><span class="s1">.original)</span><span class="s2">;</span>
			<span class="s1">matches.forEach((match) =&gt; {</span>
				<span class="s2">if </span><span class="s1">(match.index != </span><span class="s2">null</span><span class="s1">)</span>
					<span class="s2">this</span><span class="s1">.overwrite(</span>
						<span class="s1">match.index</span><span class="s2">,</span>
						<span class="s1">match.index + match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">,</span>
						<span class="s1">getReplacement(match</span><span class="s2">, this</span><span class="s1">.original)</span>
					<span class="s1">)</span><span class="s2">;</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">const </span><span class="s1">match = </span><span class="s2">this</span><span class="s1">.original.match(searchValue)</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(match &amp;&amp; match.index != </span><span class="s2">null</span><span class="s1">)</span>
				<span class="s2">this</span><span class="s1">.overwrite(</span>
					<span class="s1">match.index</span><span class="s2">,</span>
					<span class="s1">match.index + match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">,</span>
					<span class="s1">getReplacement(match</span><span class="s2">, this</span><span class="s1">.original)</span>
				<span class="s1">)</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">_replaceString(string</span><span class="s2">, </span><span class="s1">replacement) {</span>
		<span class="s2">const </span><span class="s1">{ original } = </span><span class="s2">this;</span>
		<span class="s2">const </span><span class="s1">index = original.indexOf(string)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
			<span class="s2">this</span><span class="s1">.overwrite(index</span><span class="s2">, </span><span class="s1">index + string.length</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">replace(searchValue</span><span class="s2">, </span><span class="s1">replacement) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">searchValue === </span><span class="s3">'string'</span><span class="s1">) {</span>
			<span class="s2">return this</span><span class="s1">._replaceString(searchValue</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">._replaceRegexp(searchValue</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">_replaceAllString(string</span><span class="s2">, </span><span class="s1">replacement) {</span>
		<span class="s2">const </span><span class="s1">{ original } = </span><span class="s2">this;</span>
		<span class="s2">const </span><span class="s1">stringLength = string.length</span><span class="s2">;</span>
		<span class="s2">for </span><span class="s1">(</span>
			<span class="s2">let </span><span class="s1">index = original.indexOf(string)</span><span class="s2">;</span>
			<span class="s1">index !== -</span><span class="s4">1</span><span class="s2">;</span>
			<span class="s1">index = original.indexOf(string</span><span class="s2">, </span><span class="s1">index + stringLength)</span>
		<span class="s1">) {</span>
			<span class="s2">this</span><span class="s1">.overwrite(index</span><span class="s2">, </span><span class="s1">index + stringLength</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">replaceAll(searchValue</span><span class="s2">, </span><span class="s1">replacement) {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">searchValue === </span><span class="s3">'string'</span><span class="s1">) {</span>
			<span class="s2">return this</span><span class="s1">._replaceAllString(searchValue</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(!searchValue.global) {</span>
			<span class="s2">throw new </span><span class="s1">TypeError(</span>
				<span class="s3">'MagicString.prototype.replaceAll called with a non-global RegExp argument'</span>
			<span class="s1">)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">._replaceRegexp(searchValue</span><span class="s2">, </span><span class="s1">replacement)</span><span class="s2">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">hasOwnProp = Object.prototype.hasOwnProperty</span><span class="s2">;</span>

<span class="s2">let </span><span class="s1">Bundle$1 = </span><span class="s2">class </span><span class="s1">Bundle {</span>
	<span class="s1">constructor(options = {}) {</span>
		<span class="s2">this</span><span class="s1">.intro = options.intro || </span><span class="s3">''</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.separator = options.separator !== undefined ? options.separator : </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.sources = []</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.uniqueSources = []</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename = {}</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">addSource(source) {</span>
		<span class="s2">if </span><span class="s1">(source </span><span class="s2">instanceof </span><span class="s1">MagicString) {</span>
			<span class="s2">return this</span><span class="s1">.addSource({</span>
				<span class="s1">content: source</span><span class="s2">,</span>
				<span class="s1">filename: source.filename</span><span class="s2">,</span>
				<span class="s1">separator: </span><span class="s2">this</span><span class="s1">.separator</span><span class="s2">,</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(!isObject$1(source) || !source.content) {</span>
			<span class="s2">throw new </span><span class="s1">Error(</span>
				<span class="s3">'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'</span>
			<span class="s1">)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s1">[</span><span class="s3">'filename'</span><span class="s2">, </span><span class="s3">'ignoreList'</span><span class="s2">, </span><span class="s3">'indentExclusionRanges'</span><span class="s2">, </span><span class="s3">'separator'</span><span class="s1">].forEach((option) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(!hasOwnProp.call(source</span><span class="s2">, </span><span class="s1">option)) source[option] = source.content[option]</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(source.separator === undefined) {</span>
			<span class="s0">// TODO there's a bunch of this sort of thing, needs cleaning up</span>
			<span class="s1">source.separator = </span><span class="s2">this</span><span class="s1">.separator</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(source.filename) {</span>
			<span class="s2">if </span><span class="s1">(!hasOwnProp.call(</span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename</span><span class="s2">, </span><span class="s1">source.filename)) {</span>
				<span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename] = </span><span class="s2">this</span><span class="s1">.uniqueSources.length</span><span class="s2">;</span>
				<span class="s2">this</span><span class="s1">.uniqueSources.push({ filename: source.filename</span><span class="s2">, </span><span class="s1">content: source.content.original })</span><span class="s2">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s2">const </span><span class="s1">uniqueSource = </span><span class="s2">this</span><span class="s1">.uniqueSources[</span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename]]</span><span class="s2">;</span>
				<span class="s2">if </span><span class="s1">(source.content.original !== uniqueSource.content) {</span>
					<span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Illegal source: same filename (</span><span class="s1">${source.filename}</span><span class="s3">), different contents`</span><span class="s1">)</span><span class="s2">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.sources.push(source)</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">append(str</span><span class="s2">, </span><span class="s1">options) {</span>
		<span class="s2">this</span><span class="s1">.addSource({</span>
			<span class="s1">content: </span><span class="s2">new </span><span class="s1">MagicString(str)</span><span class="s2">,</span>
			<span class="s1">separator: (options &amp;&amp; options.separator) || </span><span class="s3">''</span><span class="s2">,</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">clone() {</span>
		<span class="s2">const </span><span class="s1">bundle = </span><span class="s2">new </span><span class="s1">Bundle({</span>
			<span class="s1">intro: </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">,</span>
			<span class="s1">separator: </span><span class="s2">this</span><span class="s1">.separator</span><span class="s2">,</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s1">bundle.addSource({</span>
				<span class="s1">filename: source.filename</span><span class="s2">,</span>
				<span class="s1">content: source.content.clone()</span><span class="s2">,</span>
				<span class="s1">separator: source.separator</span><span class="s2">,</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">bundle</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">generateDecodedMap(options = {}) {</span>
		<span class="s2">const </span><span class="s1">names = []</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">x_google_ignoreList = undefined</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s1">Object.keys(source.content.storedNames).forEach((name) =&gt; {</span>
				<span class="s2">if </span><span class="s1">(!~names.indexOf(name)) names.push(name)</span><span class="s2">;</span>
			<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">const </span><span class="s1">mappings = </span><span class="s2">new </span><span class="s1">Mappings(options.hires)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.intro)</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
			<span class="s2">if </span><span class="s1">(i &gt; </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">mappings.advance(</span><span class="s2">this</span><span class="s1">.separator)</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">const </span><span class="s1">sourceIndex = source.filename ? </span><span class="s2">this</span><span class="s1">.uniqueSourceIndexByFilename[source.filename] : -</span><span class="s4">1</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">magicString = source.content</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">locate = getLocator$1(magicString.original)</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(magicString.intro) {</span>
				<span class="s1">mappings.advance(magicString.intro)</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s1">magicString.firstChunk.eachNext((chunk) =&gt; {</span>
				<span class="s2">const </span><span class="s1">loc = locate(chunk.start)</span><span class="s2">;</span>

				<span class="s2">if </span><span class="s1">(chunk.intro.length) mappings.advance(chunk.intro)</span><span class="s2">;</span>

				<span class="s2">if </span><span class="s1">(source.filename) {</span>
					<span class="s2">if </span><span class="s1">(chunk.edited) {</span>
						<span class="s1">mappings.addEdit(</span>
							<span class="s1">sourceIndex</span><span class="s2">,</span>
							<span class="s1">chunk.content</span><span class="s2">,</span>
							<span class="s1">loc</span><span class="s2">,</span>
							<span class="s1">chunk.storeName ? names.indexOf(chunk.original) : -</span><span class="s4">1</span>
						<span class="s1">)</span><span class="s2">;</span>
					<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
						<span class="s1">mappings.addUneditedChunk(</span>
							<span class="s1">sourceIndex</span><span class="s2">,</span>
							<span class="s1">chunk</span><span class="s2">,</span>
							<span class="s1">magicString.original</span><span class="s2">,</span>
							<span class="s1">loc</span><span class="s2">,</span>
							<span class="s1">magicString.sourcemapLocations</span>
						<span class="s1">)</span><span class="s2">;</span>
					<span class="s1">}</span>
				<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
					<span class="s1">mappings.advance(chunk.content)</span><span class="s2">;</span>
				<span class="s1">}</span>

				<span class="s2">if </span><span class="s1">(chunk.outro.length) mappings.advance(chunk.outro)</span><span class="s2">;</span>
			<span class="s1">})</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(magicString.outro) {</span>
				<span class="s1">mappings.advance(magicString.outro)</span><span class="s2">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(source.ignoreList &amp;&amp; sourceIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
				<span class="s2">if </span><span class="s1">(x_google_ignoreList === undefined) {</span>
					<span class="s1">x_google_ignoreList = []</span><span class="s2">;</span>
				<span class="s1">}</span>
				<span class="s1">x_google_ignoreList.push(sourceIndex)</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">{</span>
			<span class="s1">file: options.file ? options.file.split(</span><span class="s4">/[/\\]/</span><span class="s1">).pop() : undefined</span><span class="s2">,</span>
			<span class="s1">sources: </span><span class="s2">this</span><span class="s1">.uniqueSources.map((source) =&gt; {</span>
				<span class="s2">return </span><span class="s1">options.file ? getRelativePath(options.file</span><span class="s2">, </span><span class="s1">source.filename) : source.filename</span><span class="s2">;</span>
			<span class="s1">})</span><span class="s2">,</span>
			<span class="s1">sourcesContent: </span><span class="s2">this</span><span class="s1">.uniqueSources.map((source) =&gt; {</span>
				<span class="s2">return </span><span class="s1">options.includeContent ? source.content : </span><span class="s2">null;</span>
			<span class="s1">})</span><span class="s2">,</span>
			<span class="s1">names</span><span class="s2">,</span>
			<span class="s1">mappings: mappings.raw</span><span class="s2">,</span>
			<span class="s1">x_google_ignoreList</span><span class="s2">,</span>
		<span class="s1">}</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">generateMap(options) {</span>
		<span class="s2">return new </span><span class="s1">SourceMap(</span><span class="s2">this</span><span class="s1">.generateDecodedMap(options))</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">getIndentString() {</span>
		<span class="s2">const </span><span class="s1">indentStringCounts = {}</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source) =&gt; {</span>
			<span class="s2">const </span><span class="s1">indentStr = source.content._getRawIndentString()</span><span class="s2">;</span>

			<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return;</span>

			<span class="s2">if </span><span class="s1">(!indentStringCounts[indentStr]) indentStringCounts[indentStr] = </span><span class="s4">0</span><span class="s2">;</span>
			<span class="s1">indentStringCounts[indentStr] += </span><span class="s4">1</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">return </span><span class="s1">(</span>
			<span class="s1">Object.keys(indentStringCounts).sort((a</span><span class="s2">, </span><span class="s1">b) =&gt; {</span>
				<span class="s2">return </span><span class="s1">indentStringCounts[a] - indentStringCounts[b]</span><span class="s2">;</span>
			<span class="s1">})[</span><span class="s4">0</span><span class="s1">] || </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span>
		<span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">indent(indentStr) {</span>
		<span class="s2">if </span><span class="s1">(!arguments.length) {</span>
			<span class="s1">indentStr = </span><span class="s2">this</span><span class="s1">.getIndentString()</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(indentStr === </span><span class="s3">''</span><span class="s1">) </span><span class="s2">return this; </span><span class="s0">// noop</span>

		<span class="s2">let </span><span class="s1">trailingNewline = !</span><span class="s2">this</span><span class="s1">.intro || </span><span class="s2">this</span><span class="s1">.intro.slice(-</span><span class="s4">1</span><span class="s1">) === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>

		<span class="s2">this</span><span class="s1">.sources.forEach((source</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
			<span class="s2">const </span><span class="s1">separator = source.separator !== undefined ? source.separator : </span><span class="s2">this</span><span class="s1">.separator</span><span class="s2">;</span>
			<span class="s2">const </span><span class="s1">indentStart = trailingNewline || (i &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s4">/\r?\n$/</span><span class="s1">.test(separator))</span><span class="s2">;</span>

			<span class="s1">source.content.indent(indentStr</span><span class="s2">, </span><span class="s1">{</span>
				<span class="s1">exclude: source.indentExclusionRanges</span><span class="s2">,</span>
				<span class="s1">indentStart</span><span class="s2">, </span><span class="s0">//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )</span>
			<span class="s1">})</span><span class="s2">;</span>

			<span class="s1">trailingNewline = source.content.lastChar() === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
		<span class="s1">})</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s2">this</span><span class="s1">.intro =</span>
				<span class="s1">indentStr +</span>
				<span class="s2">this</span><span class="s1">.intro.replace(</span><span class="s4">/^[^\n]/gm</span><span class="s2">, </span><span class="s1">(match</span><span class="s2">, </span><span class="s1">index) =&gt; {</span>
					<span class="s2">return </span><span class="s1">index &gt; </span><span class="s4">0 </span><span class="s1">? indentStr + match : match</span><span class="s2">;</span>
				<span class="s1">})</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">prepend(str) {</span>
		<span class="s2">this</span><span class="s1">.intro = str + </span><span class="s2">this</span><span class="s1">.intro</span><span class="s2">;</span>
		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">toString() {</span>
		<span class="s2">const </span><span class="s1">body = </span><span class="s2">this</span><span class="s1">.sources</span>
			<span class="s1">.map((source</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
				<span class="s2">const </span><span class="s1">separator = source.separator !== undefined ? source.separator : </span><span class="s2">this</span><span class="s1">.separator</span><span class="s2">;</span>
				<span class="s2">const </span><span class="s1">str = (i &gt; </span><span class="s4">0 </span><span class="s1">? separator : </span><span class="s3">''</span><span class="s1">) + source.content.toString()</span><span class="s2">;</span>

				<span class="s2">return </span><span class="s1">str</span><span class="s2">;</span>
			<span class="s1">})</span>
			<span class="s1">.join(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">return this</span><span class="s1">.intro + body</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">isEmpty() {</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.intro.length &amp;&amp; </span><span class="s2">this</span><span class="s1">.intro.trim()) </span><span class="s2">return false;</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.sources.some((source) =&gt; !source.content.isEmpty())) </span><span class="s2">return false;</span>
		<span class="s2">return true;</span>
	<span class="s1">}</span>

	<span class="s1">length() {</span>
		<span class="s2">return this</span><span class="s1">.sources.reduce(</span>
			<span class="s1">(length</span><span class="s2">, </span><span class="s1">source) =&gt; length + source.content.length()</span><span class="s2">,</span>
			<span class="s2">this</span><span class="s1">.intro.length</span>
		<span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trimLines() {</span>
		<span class="s2">return this</span><span class="s1">.trim(</span><span class="s3">'[</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n]'</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trim(charType) {</span>
		<span class="s2">return this</span><span class="s1">.trimStart(charType).trimEnd(charType)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">trimStart(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">'^' </span><span class="s1">+ (charType || </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">s'</span><span class="s1">) + </span><span class="s3">'+'</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.intro) {</span>
			<span class="s2">let </span><span class="s1">source</span><span class="s2">;</span>
			<span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>

			<span class="s2">do </span><span class="s1">{</span>
				<span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[i++]</span><span class="s2">;</span>
				<span class="s2">if </span><span class="s1">(!source) {</span>
					<span class="s2">break;</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">while </span><span class="s1">(!source.content.trimStartAborted(charType))</span><span class="s2">;</span>
		<span class="s1">}</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>

	<span class="s1">trimEnd(charType) {</span>
		<span class="s2">const </span><span class="s1">rx = </span><span class="s2">new </span><span class="s1">RegExp((charType || </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">s'</span><span class="s1">) + </span><span class="s3">'+$'</span><span class="s1">)</span><span class="s2">;</span>

		<span class="s2">let </span><span class="s1">source</span><span class="s2">;</span>
		<span class="s2">let </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.sources.length - </span><span class="s4">1</span><span class="s2">;</span>

		<span class="s2">do </span><span class="s1">{</span>
			<span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[i--]</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(!source) {</span>
				<span class="s2">this</span><span class="s1">.intro = </span><span class="s2">this</span><span class="s1">.intro.replace(rx</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
				<span class="s2">break;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">while </span><span class="s1">(!source.content.trimEndAborted(charType))</span><span class="s2">;</span>

		<span class="s2">return this;</span>
	<span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">ANY_SLASH_REGEX = </span><span class="s4">/[/\\]/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">relative(from</span><span class="s2">, </span><span class="s1">to) {</span>
    <span class="s2">const </span><span class="s1">fromParts = from.split(ANY_SLASH_REGEX).filter(Boolean)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">toParts = to.split(ANY_SLASH_REGEX).filter(Boolean)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fromParts[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">fromParts.shift()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(toParts[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">toParts.shift()</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(fromParts[</span><span class="s4">0</span><span class="s1">] &amp;&amp; toParts[</span><span class="s4">0</span><span class="s1">] &amp;&amp; fromParts[</span><span class="s4">0</span><span class="s1">] === toParts[</span><span class="s4">0</span><span class="s1">]) {</span>
        <span class="s1">fromParts.shift()</span><span class="s2">;</span>
        <span class="s1">toParts.shift()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(toParts[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'..' </span><span class="s1">&amp;&amp; fromParts.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">toParts.shift()</span><span class="s2">;</span>
        <span class="s1">fromParts.pop()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(fromParts.pop()) {</span>
        <span class="s1">toParts.unshift(</span><span class="s3">'..'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">toParts.join(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">needsEscapeRegEx = </span><span class="s4">/[\n\r'\\\u2028\u2029]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">quoteNewlineRegEx = </span><span class="s4">/([\n\r'\u2028\u2029])/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">backSlashRegEx = </span><span class="s4">/\\/g</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">escapeId(id) {</span>
    <span class="s2">if </span><span class="s1">(!needsEscapeRegEx.test(id))</span>
        <span class="s2">return </span><span class="s1">id</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">id.replace(backSlashRegEx</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\\\\</span><span class="s3">'</span><span class="s1">).replace(quoteNewlineRegEx</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">$1'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">ABSOLUTE_PATH_REGEX = </span><span class="s4">/^(?:\/|(?:[A-Za-z]:)?[/\\|])/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RELATIVE_PATH_REGEX = </span><span class="s4">/^\.?\.(\/|$)/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isAbsolute(path) {</span>
    <span class="s2">return </span><span class="s1">ABSOLUTE_PATH_REGEX.test(path)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRelative(path) {</span>
    <span class="s2">return </span><span class="s1">RELATIVE_PATH_REGEX.test(path)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">BACKSLASH_REGEX = </span><span class="s4">/\\/g</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">normalize(path) {</span>
    <span class="s2">return </span><span class="s1">path.replace(BACKSLASH_REGEX</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getAliasName(id) {</span>
    <span class="s2">const </span><span class="s1">base = basename(id)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">base.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">Math.max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">base.length - extname(id).length))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">relativeId(id) {</span>
    <span class="s2">if </span><span class="s1">(!isAbsolute(id))</span>
        <span class="s2">return </span><span class="s1">id</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">relative(resolve()</span><span class="s2">, </span><span class="s1">id)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isPathFragment(name) {</span>
    <span class="s0">// starting with &quot;/&quot;, &quot;./&quot;, &quot;../&quot;, &quot;C:/&quot;</span>
    <span class="s2">return </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/' </span><span class="s1">|| (name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'.' </span><span class="s1">&amp;&amp; (name[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'/' </span><span class="s1">|| name[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'.'</span><span class="s1">)) || isAbsolute(name))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">UPPER_DIR_REGEX = </span><span class="s4">/^(\.\.\/)*\.\.$/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getImportPath(importerId</span><span class="s2">, </span><span class="s1">targetPath</span><span class="s2">, </span><span class="s1">stripJsExtension</span><span class="s2">, </span><span class="s1">ensureFileName) {</span>
    <span class="s2">let </span><span class="s1">relativePath = normalize(relative(dirname(importerId)</span><span class="s2">, </span><span class="s1">targetPath))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(stripJsExtension &amp;&amp; relativePath.endsWith(</span><span class="s3">'.js'</span><span class="s1">)) {</span>
        <span class="s1">relativePath = relativePath.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ensureFileName) {</span>
        <span class="s2">if </span><span class="s1">(relativePath === </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s3">'../' </span><span class="s1">+ basename(targetPath)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(UPPER_DIR_REGEX.test(relativePath)) {</span>
            <span class="s2">return </span><span class="s1">[...relativePath.split(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'..'</span><span class="s2">, </span><span class="s1">basename(targetPath)].join(</span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">relativePath ? (relativePath.startsWith(</span><span class="s3">'..'</span><span class="s1">) ? relativePath : </span><span class="s3">'./' </span><span class="s1">+ relativePath) : </span><span class="s3">'.'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExternalChunk {</span>
    <span class="s1">constructor(module</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">inputBase) {</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inputBase = inputBase</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.defaultVariableName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.namespaceVariableName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variableName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.fileName = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.importAssertions = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.id = module.id</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.moduleInfo = module.info</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.renormalizeRenderPath = module.renormalizeRenderPath</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.suggestedVariableName = module.suggestedVariableName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getFileName() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fileName) {</span>
            <span class="s2">return this</span><span class="s1">.fileName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ paths } = </span><span class="s2">this</span><span class="s1">.options</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fileName =</span>
            <span class="s1">(</span><span class="s2">typeof </span><span class="s1">paths === </span><span class="s3">'function' </span><span class="s1">? paths(</span><span class="s2">this</span><span class="s1">.id) : paths[</span><span class="s2">this</span><span class="s1">.id]) ||</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.renormalizeRenderPath ? normalize(relative$1(</span><span class="s2">this</span><span class="s1">.inputBase</span><span class="s2">, this</span><span class="s1">.id)) : </span><span class="s2">this</span><span class="s1">.id))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getImportAssertions(snippets) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.importAssertions || (</span><span class="s2">this</span><span class="s1">.importAssertions = formatAssertions$1(</span><span class="s2">this</span><span class="s1">.options.format === </span><span class="s3">'es' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.options.externalImportAssertions &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.moduleInfo.assertions</span><span class="s2">, </span><span class="s1">snippets)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getImportPath(importer) {</span>
        <span class="s2">return </span><span class="s1">escapeId(</span><span class="s2">this</span><span class="s1">.renormalizeRenderPath</span>
            <span class="s1">? getImportPath(importer</span><span class="s2">, this</span><span class="s1">.getFileName()</span><span class="s2">, this</span><span class="s1">.options.format === </span><span class="s3">'amd'</span><span class="s2">, false</span><span class="s1">)</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.getFileName())</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatAssertions$1(assertions</span><span class="s2">, </span><span class="s1">{ getObject }) {</span>
    <span class="s2">if </span><span class="s1">(!assertions) {</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">assertionEntries = Object.entries(assertions).map(([key</span><span class="s2">, </span><span class="s1">value]) =&gt; [key</span><span class="s2">, </span><span class="s3">`'</span><span class="s1">${value}</span><span class="s3">'`</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(assertionEntries.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">getObject(assertionEntries</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: </span><span class="s2">null </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getOrCreate(map</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">init) {</span>
    <span class="s2">const </span><span class="s1">existing = map.get(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(existing !== undefined) {</span>
        <span class="s2">return </span><span class="s1">existing</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">value = init()</span><span class="s2">;</span>
    <span class="s1">map.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNewSet() {</span>
    <span class="s2">return new </span><span class="s1">Set()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNewArray() {</span>
    <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">UnknownKey = Symbol(</span><span class="s3">'Unknown Key'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UnknownNonAccessorKey = Symbol(</span><span class="s3">'Unknown Non-Accessor Key'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UnknownInteger = Symbol(</span><span class="s3">'Unknown Integer'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SymbolToStringTag = Symbol(</span><span class="s3">'Symbol.toStringTag'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_PATH = []</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_PATH = [UnknownKey]</span><span class="s2">;</span>
<span class="s0">// For deoptimizations, this means we are modifying an unknown property but did</span>
<span class="s0">// not lose track of the object or are creating a setter/getter;</span>
<span class="s0">// For assignment effects it means we do not check for setter/getter effects</span>
<span class="s0">// but only if something is mutated that is included, which is relevant for</span>
<span class="s0">// Object.defineProperty</span>
<span class="s2">const </span><span class="s1">UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_INTEGER_PATH = [UnknownInteger]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EntitiesKey = Symbol(</span><span class="s3">'Entities'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">PathTracker {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.entityPaths = Object.create(</span><span class="s2">null, </span><span class="s1">{</span>
            <span class="s1">[EntitiesKey]: { value: </span><span class="s2">new </span><span class="s1">Set() }</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, </span><span class="s1">entity) {</span>
        <span class="s2">const </span><span class="s1">trackedEntities = </span><span class="s2">this</span><span class="s1">.getEntities(path)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trackedEntities.has(entity))</span>
            <span class="s2">return true;</span>
        <span class="s1">trackedEntities.add(entity)</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">withTrackedEntityAtPath(path</span><span class="s2">, </span><span class="s1">entity</span><span class="s2">, </span><span class="s1">onUntracked</span><span class="s2">, </span><span class="s1">returnIfTracked) {</span>
        <span class="s2">const </span><span class="s1">trackedEntities = </span><span class="s2">this</span><span class="s1">.getEntities(path)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trackedEntities.has(entity))</span>
            <span class="s2">return </span><span class="s1">returnIfTracked</span><span class="s2">;</span>
        <span class="s1">trackedEntities.add(entity)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">result = onUntracked()</span><span class="s2">;</span>
        <span class="s1">trackedEntities.delete(entity)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getEntities(path) {</span>
        <span class="s2">let </span><span class="s1">currentPaths = </span><span class="s2">this</span><span class="s1">.entityPaths</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathSegment of path) {</span>
            <span class="s1">currentPaths = currentPaths[pathSegment] =</span>
                <span class="s1">currentPaths[pathSegment] ||</span>
                    <span class="s1">Object.create(</span><span class="s2">null, </span><span class="s1">{ [EntitiesKey]: { value: </span><span class="s2">new </span><span class="s1">Set() } })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">currentPaths[EntitiesKey]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">SHARED_RECURSION_TRACKER = </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">DiscriminatedPathTracker {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.entityPaths = Object.create(</span><span class="s2">null, </span><span class="s1">{</span>
            <span class="s1">[EntitiesKey]: { value: </span><span class="s2">new </span><span class="s1">Map() }</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, </span><span class="s1">discriminator</span><span class="s2">, </span><span class="s1">entity) {</span>
        <span class="s2">let </span><span class="s1">currentPaths = </span><span class="s2">this</span><span class="s1">.entityPaths</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathSegment of path) {</span>
            <span class="s1">currentPaths = currentPaths[pathSegment] =</span>
                <span class="s1">currentPaths[pathSegment] ||</span>
                    <span class="s1">Object.create(</span><span class="s2">null, </span><span class="s1">{ [EntitiesKey]: { value: </span><span class="s2">new </span><span class="s1">Map() } })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">trackedEntities = getOrCreate(currentPaths[EntitiesKey]</span><span class="s2">, </span><span class="s1">discriminator</span><span class="s2">, </span><span class="s1">(getNewSet))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trackedEntities.has(entity))</span>
            <span class="s2">return true;</span>
        <span class="s1">trackedEntities.add(entity)</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">UnknownValue = Symbol(</span><span class="s3">'Unknown Value'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UnknownTruthyValue = Symbol(</span><span class="s3">'Unknown Truthy Value'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">_path</span><span class="s2">, </span><span class="s1">_recursionTracker) {</span>
        <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(_path) { }</span>
    <span class="s5">/**</span>
     <span class="s5">* If possible it returns a stringifyable literal value for this node that</span>
     <span class="s5">* can be used for inlining or comparing values. Otherwise, it should return</span>
     <span class="s5">* UnknownValue.</span>
     <span class="s5">*/</span>
    <span class="s1">getLiteralValueAtPath(_path</span><span class="s2">, </span><span class="s1">_recursionTracker</span><span class="s2">, </span><span class="s1">_origin) {</span>
        <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(_path</span><span class="s2">, </span><span class="s1">_interaction</span><span class="s2">, </span><span class="s1">_recursionTracker</span><span class="s2">, </span><span class="s1">_origin) {</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(_path</span><span class="s2">, </span><span class="s1">_interaction</span><span class="s2">, </span><span class="s1">_context) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(_context</span><span class="s2">, </span><span class="s1">_includeChildrenRecursively</span><span class="s2">, </span><span class="s1">_options) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of parameters) {</span>
            <span class="s1">argument.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">shouldBeIncluded(_context) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">UNKNOWN_EXPRESSION = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">UnknownExpression </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_RETURN_EXPRESSION = [</span>
    <span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">,</span>
    <span class="s2">false</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">deoptimizeInteraction = (interaction) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of interaction.args) {</span>
        <span class="s1">argument?.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">INTERACTION_ACCESSED = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTERACTION_ASSIGNED = </span><span class="s4">1</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTERACTION_CALLED = </span><span class="s4">2</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NODE_INTERACTION_UNKNOWN_ACCESS = {</span>
    <span class="s1">args: [</span><span class="s2">null</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">type: INTERACTION_ACCESSED</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {</span>
    <span class="s1">args: [</span><span class="s2">null, </span><span class="s1">UNKNOWN_EXPRESSION]</span><span class="s2">,</span>
    <span class="s1">type: INTERACTION_ASSIGNED</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">// While this is technically a call without arguments, we can compare against</span>
<span class="s0">// this reference in places where precise values or this argument would make a</span>
<span class="s0">// difference</span>
<span class="s2">const </span><span class="s1">NODE_INTERACTION_UNKNOWN_CALL = {</span>
    <span class="s1">args: [</span><span class="s2">null</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
    <span class="s1">withNew: </span><span class="s2">false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">Variable </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor(name) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.name = name</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.alwaysRendered = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.forbiddenNames = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.initReached = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.isId = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.isReassigned = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.kind = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.renderBaseName = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.renderName = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Binds identifiers that reference this variable to this variable.</span>
     <span class="s5">* Necessary to be able to change variable names.</span>
     <span class="s5">*/</span>
    <span class="s1">addReference(_identifier) { }</span>
    <span class="s5">/**</span>
     <span class="s5">* Prevent this variable from being renamed to this name to avoid name</span>
     <span class="s5">* collisions</span>
     <span class="s5">*/</span>
    <span class="s1">forbidName(name) {</span>
        <span class="s1">(</span><span class="s2">this</span><span class="s1">.forbiddenNames || (</span><span class="s2">this</span><span class="s1">.forbiddenNames = </span><span class="s2">new </span><span class="s1">Set())).add(name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseVariableName() {</span>
        <span class="s2">return this</span><span class="s1">.renderBaseName || </span><span class="s2">this</span><span class="s1">.renderName || </span><span class="s2">this</span><span class="s1">.name</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getName(getPropertyAccess</span><span class="s2">, </span><span class="s1">useOriginalName) {</span>
        <span class="s2">if </span><span class="s1">(useOriginalName?.(</span><span class="s2">this</span><span class="s1">)) {</span>
            <span class="s2">return this</span><span class="s1">.name</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.renderName || </span><span class="s2">this</span><span class="s1">.name</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.renderBaseName ? </span><span class="s3">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.renderBaseName}${getPropertyAccess(name)}</span><span class="s3">` </span><span class="s1">: name</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }</span><span class="s2">, </span><span class="s1">_context) {</span>
        <span class="s2">return </span><span class="s1">type !== INTERACTION_ACCESSED || path.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Marks this variable as being part of the bundle, which is usually the case when one of</span>
     <span class="s5">* its identifiers becomes part of the bundle. Returns true if it has not been included</span>
     <span class="s5">* previously.</span>
     <span class="s5">* Once a variable is included, it should take care all its declarations are included.</span>
     <span class="s5">*/</span>
    <span class="s1">include() {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">markCalledFromTryStatement() { }</span>
    <span class="s1">setRenderNames(baseName</span><span class="s2">, </span><span class="s1">name) {</span>
        <span class="s2">this</span><span class="s1">.renderBaseName = baseName</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.renderName = name</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExternalVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor(module</span><span class="s2">, </span><span class="s1">name) {</span>
        <span class="s2">super</span><span class="s1">(name)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.referenced = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.module = module</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.isNamespace = name === </span><span class="s3">'*'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addReference(identifier) {</span>
        <span class="s2">this</span><span class="s1">.referenced = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.name === </span><span class="s3">'default' </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.name === </span><span class="s3">'*'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.module.suggestName(identifier.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">type !== INTERACTION_ACCESSED || path.length &gt; (</span><span class="s2">this</span><span class="s1">.isNamespace ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.module.used = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">BLANK = Object.freeze(Object.create(</span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_OBJECT = Object.freeze({})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_ARRAY = Object.freeze([])</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_SET = Object.freeze(</span><span class="s2">new </span><span class="s1">(</span><span class="s2">class extends </span><span class="s1">Set {</span>
    <span class="s1">add() {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Cannot add to empty set'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">})())</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getLocator(source</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) { options = {}</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">offsetLine = options.offsetLine || </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">offsetColumn = options.offsetColumn || </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">originalLines = source.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">lineRanges = originalLines.map(</span><span class="s2">function </span><span class="s1">(line</span><span class="s2">, </span><span class="s1">i) {</span>
        <span class="s2">var </span><span class="s1">end = start + line.length + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">var </span><span class="s1">range = { start: start</span><span class="s2">, </span><span class="s1">end: end</span><span class="s2">, </span><span class="s1">line: i }</span><span class="s2">;</span>
        <span class="s1">start = end</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">range</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">rangeContains(range</span><span class="s2">, </span><span class="s1">index) {</span>
        <span class="s2">return </span><span class="s1">range.start &lt;= index &amp;&amp; index &lt; range.end</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getLocation(range</span><span class="s2">, </span><span class="s1">index) {</span>
        <span class="s2">return </span><span class="s1">{ line: offsetLine + range.line</span><span class="s2">, </span><span class="s1">column: offsetColumn + index - range.start</span><span class="s2">, </span><span class="s1">character: index }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">locate(search</span><span class="s2">, </span><span class="s1">startIndex) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">search === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s1">search = source.indexOf(search</span><span class="s2">, </span><span class="s1">startIndex || </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">range = lineRanges[i]</span><span class="s2">;</span>
        <span class="s2">var </span><span class="s1">d = search &gt;= range.end ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(range) {</span>
            <span class="s2">if </span><span class="s1">(rangeContains(range</span><span class="s2">, </span><span class="s1">search))</span>
                <span class="s2">return </span><span class="s1">getLocation(range</span><span class="s2">, </span><span class="s1">search)</span><span class="s2">;</span>
            <span class="s1">i += d</span><span class="s2">;</span>
            <span class="s1">range = lineRanges[i]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">locate</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">locate(source</span><span class="s2">, </span><span class="s1">search</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">getLocator(source</span><span class="s2">, </span><span class="s1">options)(search</span><span class="s2">, </span><span class="s1">options &amp;&amp; options.startIndex)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">spaces(index) {</span>
    <span class="s2">let </span><span class="s1">result = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(index--)</span>
        <span class="s1">result += </span><span class="s3">' '</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">tabsToSpaces(value) {</span>
    <span class="s2">return </span><span class="s1">value.replace(</span><span class="s4">/^\t+/</span><span class="s2">, </span><span class="s1">match =&gt; match.split(</span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">).join(</span><span class="s3">'  '</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">LINE_TRUNCATE_LENGTH = </span><span class="s4">120</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">MIN_CHARACTERS_SHOWN_AFTER_LOCATION = </span><span class="s4">10</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ELLIPSIS = </span><span class="s3">'...'</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getCodeFrame(source</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column) {</span>
    <span class="s2">let </span><span class="s1">lines = source.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">// Needed if a plugin did not generate correct sourcemaps</span>
    <span class="s2">if </span><span class="s1">(line &gt; lines.length)</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">maxLineLength = Math.max(tabsToSpaces(lines[line - </span><span class="s4">1</span><span class="s1">].slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">column)).length +</span>
        <span class="s1">MIN_CHARACTERS_SHOWN_AFTER_LOCATION +</span>
        <span class="s1">ELLIPSIS.length</span><span class="s2">, </span><span class="s1">LINE_TRUNCATE_LENGTH)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">frameStart = Math.max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">line - </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">frameEnd = Math.min(line + </span><span class="s4">2</span><span class="s2">, </span><span class="s1">lines.length)</span><span class="s2">;</span>
    <span class="s1">lines = lines.slice(frameStart</span><span class="s2">, </span><span class="s1">frameEnd)</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(!</span><span class="s4">/\S/</span><span class="s1">.test(lines[lines.length - </span><span class="s4">1</span><span class="s1">])) {</span>
        <span class="s1">lines.pop()</span><span class="s2">;</span>
        <span class="s1">frameEnd -= </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">digits = String(frameEnd).length</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">lines</span>
        <span class="s1">.map((sourceLine</span><span class="s2">, </span><span class="s1">index) =&gt; {</span>
        <span class="s2">const </span><span class="s1">isErrorLine = frameStart + index + </span><span class="s4">1 </span><span class="s1">=== line</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">lineNumber = String(index + frameStart + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(lineNumber.length &lt; digits)</span>
            <span class="s1">lineNumber = </span><span class="s3">` </span><span class="s1">${lineNumber}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">displayedLine = tabsToSpaces(sourceLine)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(displayedLine.length &gt; maxLineLength) {</span>
            <span class="s1">displayedLine = </span><span class="s3">`</span><span class="s1">${displayedLine.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">maxLineLength - ELLIPSIS.length)}${ELLIPSIS}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isErrorLine) {</span>
            <span class="s2">const </span><span class="s1">indicator = spaces(digits + </span><span class="s4">2 </span><span class="s1">+ tabsToSpaces(sourceLine.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">column)).length) + </span><span class="s3">'^'</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${lineNumber}</span><span class="s3">: </span><span class="s1">${displayedLine}</span><span class="s2">\n</span><span class="s1">${indicator}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${lineNumber}</span><span class="s3">: </span><span class="s1">${displayedLine}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">})</span>
        <span class="s1">.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">printQuotedStringList(list</span><span class="s2">, </span><span class="s1">verbs) {</span>
    <span class="s2">const </span><span class="s1">isSingleItem = list.length &lt;= </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">quotedList = list.map(item =&gt; </span><span class="s3">`&quot;</span><span class="s1">${item}</span><span class="s3">&quot;`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">output = isSingleItem</span>
        <span class="s1">? quotedList[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">: </span><span class="s3">`</span><span class="s1">${quotedList.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">).join(</span><span class="s3">', '</span><span class="s1">)} </span><span class="s3">and </span><span class="s1">${quotedList.slice(-</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(verbs) {</span>
        <span class="s1">output += </span><span class="s3">` </span><span class="s1">${isSingleItem ? verbs[</span><span class="s4">0</span><span class="s1">] : verbs[</span><span class="s4">1</span><span class="s1">]}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">output</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isValidUrl(url) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">new </span><span class="s1">URL(url)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">{</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRollupUrl(snippet) {</span>
    <span class="s2">return </span><span class="s3">`https://rollupjs.org/</span><span class="s1">${snippet}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// troubleshooting</span>
<span class="s2">const </span><span class="s1">URL_AVOIDING_EVAL = </span><span class="s3">'troubleshooting/#avoiding-eval'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_NAME_IS_NOT_EXPORTED = </span><span class="s3">'troubleshooting/#error-name-is-not-exported-by-module'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_THIS_IS_UNDEFINED = </span><span class="s3">'troubleshooting/#error-this-is-undefined'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY = </span><span class="s3">'troubleshooting/#warning-treating-module-as-external-dependency'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT = </span><span class="s3">'troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect'</span><span class="s2">;</span>
<span class="s0">// configuration-options</span>
<span class="s2">const </span><span class="s1">URL_MAXPARALLELFILEOPS = </span><span class="s3">'configuration-options/#maxparallelfileops'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_AMD_ID = </span><span class="s3">'configuration-options/#output-amd-id'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_AMD_BASEPATH = </span><span class="s3">'configuration-options/#output-amd-basepath'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_DIR = </span><span class="s3">'configuration-options/#output-dir'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_DYNAMICIMPORTFUNCTION = </span><span class="s3">'configuration-options/#output-dynamicimportfunction'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_EXPORTS = </span><span class="s3">'configuration-options/#output-exports'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_EXTEND = </span><span class="s3">'configuration-options/#output-extend'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_FORMAT = </span><span class="s3">'configuration-options/#output-format'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_GENERATEDCODE = </span><span class="s3">'configuration-options/#output-generatedcode'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_EXPERIMENTALDEEPCHUNKOPTIMIZATION = </span><span class="s3">'configuration-options/#output-experimentaldeepdynamicchunkoptimization'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS = </span><span class="s3">'configuration-options/#output-generatedcode-constbindings'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_GENERATEDCODE_SYMBOLS = </span><span class="s3">'configuration-options/#output-generatedcode-symbols'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_GLOBALS = </span><span class="s3">'configuration-options/#output-globals'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_INLINEDYNAMICIMPORTS = </span><span class="s3">'configuration-options/#output-inlinedynamicimports'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_INTEROP = </span><span class="s3">'configuration-options/#output-interop'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_MANUALCHUNKS = </span><span class="s3">'configuration-options/#output-manualchunks'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_NAME = </span><span class="s3">'configuration-options/#output-name'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_PRESERVEMODULES = </span><span class="s3">'configuration-options/#output-preservemodules'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_SOURCEMAPBASEURL = </span><span class="s3">'configuration-options/#output-sourcemapbaseurl'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_OUTPUT_SOURCEMAPFILE = </span><span class="s3">'configuration-options/#output-sourcemapfile'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_PRESERVEENTRYSIGNATURES = </span><span class="s3">'configuration-options/#preserveentrysignatures'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_TREESHAKE = </span><span class="s3">'configuration-options/#treeshake'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_TREESHAKE_MODULESIDEEFFECTS = </span><span class="s3">'configuration-options/#treeshake-modulesideeffects'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_WATCH = </span><span class="s3">'configuration-options/#watch'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_RENDERDYNAMICIMPORT = </span><span class="s3">'plugin-development/#renderdynamicimport'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_THIS_GETMODULEIDS = </span><span class="s3">'plugin-development/#this-getmoduleids'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">URL_THIS_GETMODULEINFO = </span><span class="s3">'plugin-development/#this-getmoduleinfo'</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">error(base) {</span>
    <span class="s2">if </span><span class="s1">(!(base </span><span class="s2">instanceof </span><span class="s1">Error)) {</span>
        <span class="s1">base = Object.assign(</span><span class="s2">new </span><span class="s1">Error(base.message)</span><span class="s2">, </span><span class="s1">base)</span><span class="s2">;</span>
        <span class="s1">Object.defineProperty(base</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">{ value: </span><span class="s3">'RollupError' </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">throw </span><span class="s1">base</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">augmentCodeLocation(properties</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">id) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pos === </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ line</span><span class="s2">, </span><span class="s1">column } = pos</span><span class="s2">;</span>
        <span class="s1">properties.loc = { column</span><span class="s2">, </span><span class="s1">file: id</span><span class="s2">, </span><span class="s1">line }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">properties.pos = pos</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ line</span><span class="s2">, </span><span class="s1">column } = locate(source</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">{ offsetLine: </span><span class="s4">1 </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s1">properties.loc = { column</span><span class="s2">, </span><span class="s1">file: id</span><span class="s2">, </span><span class="s1">line }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(properties.frame === undefined) {</span>
        <span class="s2">const </span><span class="s1">{ line</span><span class="s2">, </span><span class="s1">column } = properties.loc</span><span class="s2">;</span>
        <span class="s1">properties.frame = getCodeFrame(source</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// Error codes should be sorted alphabetically while errors should be sorted by</span>
<span class="s0">// error code below</span>
<span class="s2">const </span><span class="s1">ADDON_ERROR = </span><span class="s3">'ADDON_ERROR'</span><span class="s2">, </span><span class="s1">ALREADY_CLOSED = </span><span class="s3">'ALREADY_CLOSED'</span><span class="s2">, </span><span class="s1">AMBIGUOUS_EXTERNAL_NAMESPACES = </span><span class="s3">'AMBIGUOUS_EXTERNAL_NAMESPACES'</span><span class="s2">, </span><span class="s1">ANONYMOUS_PLUGIN_CACHE = </span><span class="s3">'ANONYMOUS_PLUGIN_CACHE'</span><span class="s2">, </span><span class="s1">ASSET_NOT_FINALISED = </span><span class="s3">'ASSET_NOT_FINALISED'</span><span class="s2">, </span><span class="s1">ASSET_NOT_FOUND = </span><span class="s3">'ASSET_NOT_FOUND'</span><span class="s2">, </span><span class="s1">ASSET_SOURCE_ALREADY_SET = </span><span class="s3">'ASSET_SOURCE_ALREADY_SET'</span><span class="s2">, </span><span class="s1">ASSET_SOURCE_MISSING = </span><span class="s3">'ASSET_SOURCE_MISSING'</span><span class="s2">, </span><span class="s1">BAD_LOADER = </span><span class="s3">'BAD_LOADER'</span><span class="s2">, </span><span class="s1">CANNOT_CALL_NAMESPACE = </span><span class="s3">'CANNOT_CALL_NAMESPACE'</span><span class="s2">, </span><span class="s1">CANNOT_EMIT_FROM_OPTIONS_HOOK = </span><span class="s3">'CANNOT_EMIT_FROM_OPTIONS_HOOK'</span><span class="s2">, </span><span class="s1">CHUNK_NOT_GENERATED = </span><span class="s3">'CHUNK_NOT_GENERATED'</span><span class="s2">, </span><span class="s1">CHUNK_INVALID = </span><span class="s3">'CHUNK_INVALID'</span><span class="s2">, </span><span class="s1">CIRCULAR_DEPENDENCY = </span><span class="s3">'CIRCULAR_DEPENDENCY'</span><span class="s2">, </span><span class="s1">CIRCULAR_REEXPORT = </span><span class="s3">'CIRCULAR_REEXPORT'</span><span class="s2">, </span><span class="s1">CYCLIC_CROSS_CHUNK_REEXPORT = </span><span class="s3">'CYCLIC_CROSS_CHUNK_REEXPORT'</span><span class="s2">, </span><span class="s1">DEPRECATED_FEATURE = </span><span class="s3">'DEPRECATED_FEATURE'</span><span class="s2">, </span><span class="s1">DUPLICATE_PLUGIN_NAME = </span><span class="s3">'DUPLICATE_PLUGIN_NAME'</span><span class="s2">, </span><span class="s1">EMPTY_BUNDLE = </span><span class="s3">'EMPTY_BUNDLE'</span><span class="s2">, </span><span class="s1">EVAL = </span><span class="s3">'EVAL'</span><span class="s2">, </span><span class="s1">EXTERNAL_SYNTHETIC_EXPORTS = </span><span class="s3">'EXTERNAL_SYNTHETIC_EXPORTS'</span><span class="s2">, </span><span class="s1">FILE_NAME_CONFLICT = </span><span class="s3">'FILE_NAME_CONFLICT'</span><span class="s2">, </span><span class="s1">FILE_NOT_FOUND = </span><span class="s3">'FILE_NOT_FOUND'</span><span class="s2">, </span><span class="s1">ILLEGAL_IDENTIFIER_AS_NAME = </span><span class="s3">'ILLEGAL_IDENTIFIER_AS_NAME'</span><span class="s2">, </span><span class="s1">ILLEGAL_REASSIGNMENT = </span><span class="s3">'ILLEGAL_REASSIGNMENT'</span><span class="s2">, </span><span class="s1">INCONSISTENT_IMPORT_ASSERTIONS = </span><span class="s3">'INCONSISTENT_IMPORT_ASSERTIONS'</span><span class="s2">, </span><span class="s1">INPUT_HOOK_IN_OUTPUT_PLUGIN = </span><span class="s3">'INPUT_HOOK_IN_OUTPUT_PLUGIN'</span><span class="s2">, </span><span class="s1">INVALID_CHUNK = </span><span class="s3">'INVALID_CHUNK'</span><span class="s2">, </span><span class="s1">INVALID_EXPORT_OPTION = </span><span class="s3">'INVALID_EXPORT_OPTION'</span><span class="s2">, </span><span class="s1">INVALID_EXTERNAL_ID = </span><span class="s3">'INVALID_EXTERNAL_ID'</span><span class="s2">, </span><span class="s1">INVALID_OPTION = </span><span class="s3">'INVALID_OPTION'</span><span class="s2">, </span><span class="s1">INVALID_PLUGIN_HOOK = </span><span class="s3">'INVALID_PLUGIN_HOOK'</span><span class="s2">, </span><span class="s1">INVALID_ROLLUP_PHASE = </span><span class="s3">'INVALID_ROLLUP_PHASE'</span><span class="s2">, </span><span class="s1">INVALID_SETASSETSOURCE = </span><span class="s3">'INVALID_SETASSETSOURCE'</span><span class="s2">, </span><span class="s1">INVALID_TLA_FORMAT = </span><span class="s3">'INVALID_TLA_FORMAT'</span><span class="s2">, </span><span class="s1">MISSING_EXPORT = </span><span class="s3">'MISSING_EXPORT'</span><span class="s2">, </span><span class="s1">MISSING_GLOBAL_NAME = </span><span class="s3">'MISSING_GLOBAL_NAME'</span><span class="s2">, </span><span class="s1">MISSING_IMPLICIT_DEPENDANT = </span><span class="s3">'MISSING_IMPLICIT_DEPENDANT'</span><span class="s2">, </span><span class="s1">MISSING_NAME_OPTION_FOR_IIFE_EXPORT = </span><span class="s3">'MISSING_NAME_OPTION_FOR_IIFE_EXPORT'</span><span class="s2">, </span><span class="s1">MISSING_NODE_BUILTINS = </span><span class="s3">'MISSING_NODE_BUILTINS'</span><span class="s2">, </span><span class="s1">MISSING_OPTION = </span><span class="s3">'MISSING_OPTION'</span><span class="s2">, </span><span class="s1">MIXED_EXPORTS = </span><span class="s3">'MIXED_EXPORTS'</span><span class="s2">, </span><span class="s1">MODULE_LEVEL_DIRECTIVE = </span><span class="s3">'MODULE_LEVEL_DIRECTIVE'</span><span class="s2">, </span><span class="s1">NAMESPACE_CONFLICT = </span><span class="s3">'NAMESPACE_CONFLICT'</span><span class="s2">, </span><span class="s1">NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = </span><span class="s3">'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE'</span><span class="s2">, </span><span class="s1">PARSE_ERROR = </span><span class="s3">'PARSE_ERROR'</span><span class="s2">, </span><span class="s1">PLUGIN_ERROR = </span><span class="s3">'PLUGIN_ERROR'</span><span class="s2">, </span><span class="s1">SHIMMED_EXPORT = </span><span class="s3">'SHIMMED_EXPORT'</span><span class="s2">, </span><span class="s1">SOURCEMAP_BROKEN = </span><span class="s3">'SOURCEMAP_BROKEN'</span><span class="s2">, </span><span class="s1">SOURCEMAP_ERROR = </span><span class="s3">'SOURCEMAP_ERROR'</span><span class="s2">, </span><span class="s1">SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = </span><span class="s3">'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT'</span><span class="s2">, </span><span class="s1">THIS_IS_UNDEFINED = </span><span class="s3">'THIS_IS_UNDEFINED'</span><span class="s2">, </span><span class="s1">UNEXPECTED_NAMED_IMPORT = </span><span class="s3">'UNEXPECTED_NAMED_IMPORT'</span><span class="s2">, </span><span class="s1">UNKNOWN_OPTION = </span><span class="s3">'UNKNOWN_OPTION'</span><span class="s2">, </span><span class="s1">UNRESOLVED_ENTRY = </span><span class="s3">'UNRESOLVED_ENTRY'</span><span class="s2">, </span><span class="s1">UNRESOLVED_IMPORT = </span><span class="s3">'UNRESOLVED_IMPORT'</span><span class="s2">, </span><span class="s1">UNUSED_EXTERNAL_IMPORT = </span><span class="s3">'UNUSED_EXTERNAL_IMPORT'</span><span class="s2">, </span><span class="s1">VALIDATION_ERROR = </span><span class="s3">'VALIDATION_ERROR'</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">errorAddonNotGenerated(message</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ADDON_ERROR</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Could not retrieve &quot;</span><span class="s1">${hook}</span><span class="s3">&quot;. Check configuration of plugin &quot;</span><span class="s1">${plugin}</span><span class="s3">&quot;. 
</span><span class="s2">\t</span><span class="s3">Error Message: </span><span class="s1">${message}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAlreadyClosed() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ALREADY_CLOSED</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">'Bundle is already closed, no more calls to &quot;generate&quot; or &quot;write&quot; are allowed.'</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAmbiguousExternalNamespaces(binding</span><span class="s2">, </span><span class="s1">reexportingModule</span><span class="s2">, </span><span class="s1">usedModule</span><span class="s2">, </span><span class="s1">sources) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">binding</span><span class="s2">,</span>
        <span class="s1">code: AMBIGUOUS_EXTERNAL_NAMESPACES</span><span class="s2">,</span>
        <span class="s1">ids: sources</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Ambiguous external namespace resolution: &quot;</span><span class="s1">${relativeId(reexportingModule)}</span><span class="s3">&quot; re-exports &quot;</span><span class="s1">${binding}</span><span class="s3">&quot; from one of the external modules </span><span class="s1">${printQuotedStringList(sources.map(module =&gt; relativeId(module)))}</span><span class="s3">, guessing &quot;</span><span class="s1">${relativeId(usedModule)}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
        <span class="s1">reexporter: reexportingModule</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAnonymousPluginCache() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ANONYMOUS_PLUGIN_CACHE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.'</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAssetNotFinalisedForFileName(name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ASSET_NOT_FINALISED</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Plugin error - Unable to get file name for asset &quot;</span><span class="s1">${name}</span><span class="s3">&quot;. Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_&lt;referenceId&gt;, you need to either have set their source after &quot;renderStart&quot; or need to provide an explicit &quot;fileName&quot; when emitting them.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAssetReferenceIdNotFoundForSetSource(assetReferenceId) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ASSET_NOT_FOUND</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Plugin error - Unable to set the source for unknown asset &quot;</span><span class="s1">${assetReferenceId}</span><span class="s3">&quot;.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorAssetSourceAlreadySet(name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ASSET_SOURCE_ALREADY_SET</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Unable to set the source for asset &quot;</span><span class="s1">${name}</span><span class="s3">&quot;, source already set.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorNoAssetSourceSet(assetName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ASSET_SOURCE_MISSING</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Plugin error creating asset &quot;</span><span class="s1">${assetName}</span><span class="s3">&quot; - no asset source set.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorBadLoader(id) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: BAD_LOADER</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Error loading &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot;: plugin load hook should return a string, a { code, map } object, or nothing/null.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCannotCallNamespace(name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CANNOT_CALL_NAMESPACE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Cannot call a namespace (&quot;</span><span class="s1">${name}</span><span class="s3">&quot;).`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCannotEmitFromOptionsHook() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CANNOT_EMIT_FROM_OPTIONS_HOOK</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Cannot emit files or set asset sources in the &quot;outputOptions&quot; hook, use the &quot;renderStart&quot; hook instead.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorChunkNotGeneratedForFileName(name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CHUNK_NOT_GENERATED</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Plugin error - Unable to get file name for emitted chunk &quot;</span><span class="s1">${name}</span><span class="s3">&quot;. You can only get file names once chunks have been generated after the &quot;renderStart&quot; hook.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorChunkInvalid({ fileName</span><span class="s2">, </span><span class="s1">code }</span><span class="s2">, </span><span class="s1">exception) {</span>
    <span class="s2">const </span><span class="s1">errorProperties = {</span>
        <span class="s1">code: CHUNK_INVALID</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Chunk &quot;</span><span class="s1">${fileName}</span><span class="s3">&quot; is not valid JavaScript: </span><span class="s1">${exception.message}</span><span class="s3">.`</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">augmentCodeLocation(errorProperties</span><span class="s2">, </span><span class="s1">exception.loc</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">errorProperties</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCircularDependency(cyclePath) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CIRCULAR_DEPENDENCY</span><span class="s2">,</span>
        <span class="s1">ids: cyclePath</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Circular dependency: </span><span class="s1">${cyclePath.map(relativeId).join(</span><span class="s3">' -&gt; '</span><span class="s1">)}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCircularReexport(exportName</span><span class="s2">, </span><span class="s1">exporter) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CIRCULAR_REEXPORT</span><span class="s2">,</span>
        <span class="s1">exporter</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;</span><span class="s1">${exportName}</span><span class="s3">&quot; cannot be exported from &quot;</span><span class="s1">${relativeId(exporter)}</span><span class="s3">&quot; as it is a reexport that references itself.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCyclicCrossChunkReexport(exportName</span><span class="s2">, </span><span class="s1">exporter</span><span class="s2">, </span><span class="s1">reexporter</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">preserveModules) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: CYCLIC_CROSS_CHUNK_REEXPORT</span><span class="s2">,</span>
        <span class="s1">exporter</span><span class="s2">,</span>
        <span class="s1">id: importer</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Export &quot;</span><span class="s1">${exportName}</span><span class="s3">&quot; of module &quot;</span><span class="s1">${relativeId(exporter)}</span><span class="s3">&quot; was reexported through module &quot;</span><span class="s1">${relativeId(reexporter)}</span><span class="s3">&quot; while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.</span><span class="s2">\n</span><span class="s3">Either change the import in &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot; to point directly to the exporting module or </span><span class="s1">${preserveModules ? </span><span class="s3">'do not use &quot;output.preserveModules&quot;' </span><span class="s1">: </span><span class="s3">'reconfigure &quot;output.manualChunks&quot;'</span><span class="s1">} </span><span class="s3">to ensure these modules end up in the same chunk.`</span><span class="s2">,</span>
        <span class="s1">reexporter</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorDeprecation(deprecation</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: DEPRECATED_FEATURE</span><span class="s2">,</span>
        <span class="s1">message: deprecation</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(urlSnippet)</span><span class="s2">,</span>
        <span class="s1">...(plugin ? { plugin } : {})</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorDuplicatePluginName(plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: DUPLICATE_PLUGIN_NAME</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The plugin name </span><span class="s1">${plugin} </span><span class="s3">is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorEmptyChunk(chunkName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: EMPTY_BUNDLE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Generated an empty chunk: &quot;</span><span class="s1">${chunkName}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
        <span class="s1">names: [chunkName]</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorEval(id) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: EVAL</span><span class="s2">,</span>
        <span class="s1">id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Use of eval in &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot; is strongly discouraged as it poses security risks and may cause issues with minification.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_AVOIDING_EVAL)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorExternalSyntheticExports(id</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: EXTERNAL_SYNTHETIC_EXPORTS</span><span class="s2">,</span>
        <span class="s1">exporter: id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`External &quot;</span><span class="s1">${id}</span><span class="s3">&quot; cannot have &quot;syntheticNamedExports&quot; enabled (imported by &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot;).`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorFileNameConflict(fileName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: FILE_NAME_CONFLICT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The emitted file &quot;</span><span class="s1">${fileName}</span><span class="s3">&quot; overwrites a previously emitted file of the same name.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorFileReferenceIdNotFoundForFilename(assetReferenceId) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: FILE_NOT_FOUND</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Plugin error - Unable to get file name for unknown file &quot;</span><span class="s1">${assetReferenceId}</span><span class="s3">&quot;.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorIllegalIdentifierAsName(name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ILLEGAL_IDENTIFIER_AS_NAME</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Given name &quot;</span><span class="s1">${name}</span><span class="s3">&quot; is not a legal JS identifier. If you need this, you can try &quot;output.extend: true&quot;.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_EXTEND)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorIllegalImportReassignment(name</span><span class="s2">, </span><span class="s1">importingId) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: ILLEGAL_REASSIGNMENT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Illegal reassignment of import &quot;</span><span class="s1">${name}</span><span class="s3">&quot; in &quot;</span><span class="s1">${relativeId(importingId)}</span><span class="s3">&quot;.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInconsistentImportAssertions(existingAssertions</span><span class="s2">, </span><span class="s1">newAssertions</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INCONSISTENT_IMPORT_ASSERTIONS</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot; tried to import &quot;</span><span class="s1">${relativeId(source)}</span><span class="s3">&quot; with </span><span class="s1">${formatAssertions(newAssertions)} </span><span class="s3">assertions, but it was already imported elsewhere with </span><span class="s1">${formatAssertions(existingAssertions)} </span><span class="s3">assertions. Please ensure that import assertions for the same module are always consistent.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">formatAssertions = (assertions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">entries = Object.entries(assertions)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(entries.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'no'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">entries.map(([key</span><span class="s2">, </span><span class="s1">value]) =&gt; </span><span class="s3">`&quot;</span><span class="s1">${key}</span><span class="s3">&quot;: &quot;</span><span class="s1">${value}</span><span class="s3">&quot;`</span><span class="s1">).join(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">errorInputHookInOutputPlugin(pluginName</span><span class="s2">, </span><span class="s1">hookName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INPUT_HOOK_IN_OUTPUT_PLUGIN</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The &quot;</span><span class="s1">${hookName}</span><span class="s3">&quot; hook used by the output plugin </span><span class="s1">${pluginName} </span><span class="s3">is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorCannotAssignModuleToChunk(moduleId</span><span class="s2">, </span><span class="s1">assignToAlias</span><span class="s2">, </span><span class="s1">currentAlias) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_CHUNK</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Cannot assign &quot;</span><span class="s1">${relativeId(moduleId)}</span><span class="s3">&quot; to the &quot;</span><span class="s1">${assignToAlias}</span><span class="s3">&quot; chunk as it is already in the &quot;</span><span class="s1">${currentAlias}</span><span class="s3">&quot; chunk.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidExportOptionValue(optionValue) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_EXPORT_OPTION</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;output.exports&quot; must be &quot;default&quot;, &quot;named&quot;, &quot;none&quot;, &quot;auto&quot;, or left unspecified (defaults to &quot;auto&quot;), received &quot;</span><span class="s1">${optionValue}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_EXPORTS)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorIncompatibleExportOptionValue(optionValue</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">entryModule) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_EXPORT_OPTION</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;</span><span class="s1">${optionValue}</span><span class="s3">&quot; was specified for &quot;output.exports&quot;, but entry module &quot;</span><span class="s1">${relativeId(entryModule)}</span><span class="s3">&quot; has the following exports: </span><span class="s1">${printQuotedStringList(keys)}</span><span class="s3">`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_EXPORTS)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInternalIdCannotBeExternal(source</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_EXTERNAL_ID</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;</span><span class="s1">${source}</span><span class="s3">&quot; is imported as an external by &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot;, but is already an existing non-external module id.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidOption(option</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">explanation</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_OPTION</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Invalid value </span><span class="s1">${value === undefined ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">`</span><span class="s1">${JSON.stringify(value)} </span><span class="s3">`</span><span class="s1">}</span><span class="s3">for option &quot;</span><span class="s1">${option}</span><span class="s3">&quot; - </span><span class="s1">${explanation}</span><span class="s3">.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(urlSnippet)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidAddonPluginHook(hook</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_PLUGIN_HOOK</span><span class="s2">,</span>
        <span class="s1">hook</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Error running plugin hook &quot;</span><span class="s1">${hook}</span><span class="s3">&quot; for plugin &quot;</span><span class="s1">${plugin}</span><span class="s3">&quot;, expected a string, a function hook or an object with a &quot;handler&quot; string or function.`</span><span class="s2">,</span>
        <span class="s1">plugin</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidFunctionPluginHook(hook</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_PLUGIN_HOOK</span><span class="s2">,</span>
        <span class="s1">hook</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Error running plugin hook &quot;</span><span class="s1">${hook}</span><span class="s3">&quot; for plugin &quot;</span><span class="s1">${plugin}</span><span class="s3">&quot;, expected a function hook or an object with a &quot;handler&quot; function.`</span><span class="s2">,</span>
        <span class="s1">plugin</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidRollupPhaseForAddWatchFile() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_ROLLUP_PHASE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Cannot call &quot;addWatchFile&quot; after the build has finished.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidRollupPhaseForChunkEmission() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_ROLLUP_PHASE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Cannot emit chunks after module loading has finished.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidSetAssetSourceCall() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_SETASSETSOURCE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidFormatForTopLevelAwait(id</span><span class="s2">, </span><span class="s1">format) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: INVALID_TLA_FORMAT</span><span class="s2">,</span>
        <span class="s1">id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module format &quot;</span><span class="s1">${format}</span><span class="s3">&quot; does not support top-level await. Use the &quot;es&quot; or &quot;system&quot; output formats rather.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingExport(binding</span><span class="s2">, </span><span class="s1">importingModule</span><span class="s2">, </span><span class="s1">exporter) {</span>
    <span class="s2">const </span><span class="s1">isJson = extname(exporter) === </span><span class="s3">'.json'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">binding</span><span class="s2">,</span>
        <span class="s1">code: MISSING_EXPORT</span><span class="s2">,</span>
        <span class="s1">exporter</span><span class="s2">,</span>
        <span class="s1">id: importingModule</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;</span><span class="s1">${binding}</span><span class="s3">&quot; is not exported by &quot;</span><span class="s1">${relativeId(exporter)}</span><span class="s3">&quot;, imported by &quot;</span><span class="s1">${relativeId(importingModule)}</span><span class="s3">&quot;.</span><span class="s1">${isJson ? </span><span class="s3">' (Note that you need @rollup/plugin-json to import JSON files)' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_NAME_IS_NOT_EXPORTED)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingGlobalName(externalId</span><span class="s2">, </span><span class="s1">guess) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_GLOBAL_NAME</span><span class="s2">,</span>
        <span class="s1">id: externalId</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`No name was provided for external module &quot;</span><span class="s1">${externalId}</span><span class="s3">&quot; in &quot;output.globals&quot; – guessing &quot;</span><span class="s1">${guess}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
        <span class="s1">names: [guess]</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_GLOBALS)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorImplicitDependantCannotBeExternal(unresolvedId</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_IMPLICIT_DEPENDANT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module &quot;</span><span class="s1">${relativeId(unresolvedId)}</span><span class="s3">&quot; that should be implicitly loaded before &quot;</span><span class="s1">${relativeId(implicitlyLoadedBefore)}</span><span class="s3">&quot; cannot be external.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnresolvedImplicitDependant(unresolvedId</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_IMPLICIT_DEPENDANT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module &quot;</span><span class="s1">${relativeId(unresolvedId)}</span><span class="s3">&quot; that should be implicitly loaded before &quot;</span><span class="s1">${relativeId(implicitlyLoadedBefore)}</span><span class="s3">&quot; could not be resolved.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorImplicitDependantIsNotIncluded(module) {</span>
    <span class="s2">const </span><span class="s1">implicitDependencies = [...module.implicitlyLoadedBefore]</span>
        <span class="s1">.map(dependency =&gt; relativeId(dependency.id))</span>
        <span class="s1">.sort()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_IMPLICIT_DEPENDANT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module &quot;</span><span class="s1">${relativeId(module.id)}</span><span class="s3">&quot; that should be implicitly loaded before </span><span class="s1">${printQuotedStringList(implicitDependencies)} </span><span class="s3">is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingNameOptionForIifeExport() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`If you do not supply &quot;output.name&quot;, you may not be able to access the exports of an IIFE bundle.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_NAME)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingNameOptionForUmdExport() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_NAME_OPTION_FOR_IIFE_EXPORT</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">'You must supply &quot;output.name&quot; for UMD bundles that have exports so that the exports are accessible in environments without a module loader.'</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_NAME)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMissingNodeBuiltins(externalBuiltins) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_NODE_BUILTINS</span><span class="s2">,</span>
        <span class="s1">ids: externalBuiltins</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Creating a browser bundle that depends on Node.js built-in modules (</span><span class="s1">${printQuotedStringList(externalBuiltins)}</span><span class="s3">). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">// eslint-disable-next-line unicorn/prevent-abbreviations</span>
<span class="s2">function </span><span class="s1">errorMissingFileOrDirOption() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MISSING_OPTION</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">'You must specify &quot;output.file&quot; or &quot;output.dir&quot; for the build.'</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_DIR)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorMixedExport(facadeModuleId</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MIXED_EXPORTS</span><span class="s2">,</span>
        <span class="s1">id: facadeModuleId</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Entry module &quot;</span><span class="s1">${relativeId(facadeModuleId)}</span><span class="s3">&quot; is using named and default exports together. Consumers of your bundle will have to use </span><span class="s2">\`</span><span class="s1">${name || </span><span class="s3">'chunk'</span><span class="s1">}</span><span class="s3">.default</span><span class="s2">\` </span><span class="s3">to access the default export, which may not be what you want. Use </span><span class="s2">\`</span><span class="s3">output.exports: &quot;named&quot;</span><span class="s2">\` </span><span class="s3">to disable this warning.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_EXPORTS)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorModuleLevelDirective(directive</span><span class="s2">, </span><span class="s1">id) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: MODULE_LEVEL_DIRECTIVE</span><span class="s2">,</span>
        <span class="s1">id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module level directives cause errors when bundled, &quot;</span><span class="s1">${directive}</span><span class="s3">&quot; in &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot; was ignored.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorNamespaceConflict(binding</span><span class="s2">, </span><span class="s1">reexportingModuleId</span><span class="s2">, </span><span class="s1">sources) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">binding</span><span class="s2">,</span>
        <span class="s1">code: NAMESPACE_CONFLICT</span><span class="s2">,</span>
        <span class="s1">ids: sources</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Conflicting namespaces: &quot;</span><span class="s1">${relativeId(reexportingModuleId)}</span><span class="s3">&quot; re-exports &quot;</span><span class="s1">${binding}</span><span class="s3">&quot; from one of the modules </span><span class="s1">${printQuotedStringList(sources.map(moduleId =&gt; relativeId(moduleId)))} </span><span class="s3">(will be ignored).`</span><span class="s2">,</span>
        <span class="s1">reexporter: reexportingModuleId</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorNoTransformMapOrAstWithoutCode(pluginName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The plugin &quot;</span><span class="s1">${pluginName}</span><span class="s3">&quot; returned a &quot;map&quot; or &quot;ast&quot; without returning ` </span><span class="s1">+</span>
            <span class="s3">'a &quot;code&quot;. This will be ignored.'</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorParseError(error</span><span class="s2">, </span><span class="s1">moduleId) {</span>
    <span class="s2">let </span><span class="s1">message = error.message.replace(</span><span class="s4">/ \(\d+:\d+\)$/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(moduleId.endsWith(</span><span class="s3">'.json'</span><span class="s1">)) {</span>
        <span class="s1">message += </span><span class="s3">' (Note that you need @rollup/plugin-json to import JSON files)'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!moduleId.endsWith(</span><span class="s3">'.js'</span><span class="s1">)) {</span>
        <span class="s1">message += </span><span class="s3">' (Note that you need plugins to import files that are not JavaScript)'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">cause: error</span><span class="s2">,</span>
        <span class="s1">code: PARSE_ERROR</span><span class="s2">,</span>
        <span class="s1">id: moduleId</span><span class="s2">,</span>
        <span class="s1">message</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorPluginError(error</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">{ hook</span><span class="s2">, </span><span class="s1">id } = {}) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">error === </span><span class="s3">'string'</span><span class="s1">)</span>
        <span class="s1">error = { message: error }</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(error.code &amp;&amp; error.code !== PLUGIN_ERROR) {</span>
        <span class="s1">error.pluginCode = error.code</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">error.code = PLUGIN_ERROR</span><span class="s2">;</span>
    <span class="s1">error.plugin = plugin</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hook) {</span>
        <span class="s1">error.hook = hook</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(id) {</span>
        <span class="s1">error.id = id</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">error</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorShimmedExport(id</span><span class="s2">, </span><span class="s1">binding) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">binding</span><span class="s2">,</span>
        <span class="s1">code: SHIMMED_EXPORT</span><span class="s2">,</span>
        <span class="s1">exporter: id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Missing export &quot;</span><span class="s1">${binding}</span><span class="s3">&quot; has been shimmed in module &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot;.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorSourcemapBroken(plugin) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: SOURCEMAP_BROKEN</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Sourcemap is likely to be incorrect: a plugin (</span><span class="s1">${plugin}</span><span class="s3">) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`</span><span class="s2">,</span>
        <span class="s1">plugin</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorConflictingSourcemapSources(filename) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: SOURCEMAP_BROKEN</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Multiple conflicting contents for sourcemap source </span><span class="s1">${filename}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorInvalidSourcemapForError(error</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">pos) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">cause: error</span><span class="s2">,</span>
        <span class="s1">code: SOURCEMAP_ERROR</span><span class="s2">,</span>
        <span class="s1">id</span><span class="s2">,</span>
        <span class="s1">loc: {</span>
            <span class="s1">column</span><span class="s2">,</span>
            <span class="s1">file: id</span><span class="s2">,</span>
            <span class="s1">line</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Error when using sourcemap for reporting an error: </span><span class="s1">${error.message}</span><span class="s3">`</span><span class="s2">,</span>
        <span class="s1">pos</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorSyntheticNamedExportsNeedNamespaceExport(id</span><span class="s2">, </span><span class="s1">syntheticNamedExportsOption) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT</span><span class="s2">,</span>
        <span class="s1">exporter: id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Module &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot; that is marked with </span><span class="s2">\`</span><span class="s3">syntheticNamedExports: </span><span class="s1">${JSON.stringify(syntheticNamedExportsOption)}</span><span class="s2">\` </span><span class="s3">needs </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">syntheticNamedExportsOption === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; syntheticNamedExportsOption !== </span><span class="s3">'default'</span>
            <span class="s1">? </span><span class="s3">`an explicit export named &quot;</span><span class="s1">${syntheticNamedExportsOption}</span><span class="s3">&quot;`</span>
            <span class="s1">: </span><span class="s3">'a default export'</span><span class="s1">} </span><span class="s3">that does not reexport an unresolved named export of the same module.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorThisIsUndefined() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: THIS_IS_UNDEFINED</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_THIS_IS_UNDEFINED)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnexpectedNamedImport(id</span><span class="s2">, </span><span class="s1">imported</span><span class="s2">, </span><span class="s1">isReexport) {</span>
    <span class="s2">const </span><span class="s1">importType = isReexport ? </span><span class="s3">'reexport' </span><span class="s1">: </span><span class="s3">'import'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNEXPECTED_NAMED_IMPORT</span><span class="s2">,</span>
        <span class="s1">exporter: id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`The named export &quot;</span><span class="s1">${imported}</span><span class="s3">&quot; was </span><span class="s1">${importType}</span><span class="s3">ed from the external module &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot; even though its interop type is &quot;defaultOnly&quot;. Either remove or change this </span><span class="s1">${importType} </span><span class="s3">or change the value of the &quot;output.interop&quot; option.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_INTEROP)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnexpectedNamespaceReexport(id) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNEXPECTED_NAMED_IMPORT</span><span class="s2">,</span>
        <span class="s1">exporter: id</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`There was a namespace &quot;*&quot; reexport from the external module &quot;</span><span class="s1">${relativeId(id)}</span><span class="s3">&quot; even though its interop type is &quot;defaultOnly&quot;. This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the &quot;output.interop&quot; option.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_OUTPUT_INTEROP)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnknownOption(optionType</span><span class="s2">, </span><span class="s1">unknownOptions</span><span class="s2">, </span><span class="s1">validOptions) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNKNOWN_OPTION</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Unknown </span><span class="s1">${optionType}</span><span class="s3">: </span><span class="s1">${unknownOptions.join(</span><span class="s3">', '</span><span class="s1">)}</span><span class="s3">. Allowed options: </span><span class="s1">${validOptions.join(</span><span class="s3">', '</span><span class="s1">)}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorEntryCannotBeExternal(unresolvedId) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNRESOLVED_ENTRY</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Entry module &quot;</span><span class="s1">${relativeId(unresolvedId)}</span><span class="s3">&quot; cannot be external.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnresolvedEntry(unresolvedId) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNRESOLVED_ENTRY</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Could not resolve entry module &quot;</span><span class="s1">${relativeId(unresolvedId)}</span><span class="s3">&quot;.`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnresolvedImport(source</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNRESOLVED_IMPORT</span><span class="s2">,</span>
        <span class="s1">exporter: source</span><span class="s2">,</span>
        <span class="s1">id: importer</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`Could not resolve &quot;</span><span class="s1">${source}</span><span class="s3">&quot; from &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot;`</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnresolvedImportTreatedAsExternal(source</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNRESOLVED_IMPORT</span><span class="s2">,</span>
        <span class="s1">exporter: source</span><span class="s2">,</span>
        <span class="s1">id: importer</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`&quot;</span><span class="s1">${source}</span><span class="s3">&quot; is imported by &quot;</span><span class="s1">${relativeId(importer)}</span><span class="s3">&quot;, but could not be resolved – treating it as an external dependency.`</span><span class="s2">,</span>
        <span class="s1">url: getRollupUrl(URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorUnusedExternalImports(externalId</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">importers) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: UNUSED_EXTERNAL_IMPORT</span><span class="s2">,</span>
        <span class="s1">exporter: externalId</span><span class="s2">,</span>
        <span class="s1">ids: importers</span><span class="s2">,</span>
        <span class="s1">message: </span><span class="s3">`</span><span class="s1">${printQuotedStringList(names</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s3">'is'</span><span class="s2">,</span>
            <span class="s3">'are'</span>
        <span class="s1">])} </span><span class="s3">imported from external module &quot;</span><span class="s1">${externalId}</span><span class="s3">&quot; but never used in </span><span class="s1">${printQuotedStringList(importers.map(importer =&gt; relativeId(importer)))}</span><span class="s3">.`</span><span class="s2">,</span>
        <span class="s1">names</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">errorFailedValidation(message) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code: VALIDATION_ERROR</span><span class="s2">,</span>
        <span class="s1">message</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">warnDeprecation(deprecation</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">activeDeprecation</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s1">warnDeprecationWithOptions(deprecation</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">activeDeprecation</span><span class="s2">, </span><span class="s1">options.onwarn</span><span class="s2">, </span><span class="s1">options.strictDeprecations</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">warnDeprecationWithOptions(deprecation</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">activeDeprecation</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">if </span><span class="s1">(activeDeprecation || strictDeprecations) {</span>
        <span class="s2">const </span><span class="s1">warning = errorDeprecation(deprecation</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(strictDeprecations) {</span>
            <span class="s2">return </span><span class="s1">error(warning)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">warn(warning)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">RESERVED_NAMES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s3">'await'</span><span class="s2">,</span>
    <span class="s3">'break'</span><span class="s2">,</span>
    <span class="s3">'case'</span><span class="s2">,</span>
    <span class="s3">'catch'</span><span class="s2">,</span>
    <span class="s3">'class'</span><span class="s2">,</span>
    <span class="s3">'const'</span><span class="s2">,</span>
    <span class="s3">'continue'</span><span class="s2">,</span>
    <span class="s3">'debugger'</span><span class="s2">,</span>
    <span class="s3">'default'</span><span class="s2">,</span>
    <span class="s3">'delete'</span><span class="s2">,</span>
    <span class="s3">'do'</span><span class="s2">,</span>
    <span class="s3">'else'</span><span class="s2">,</span>
    <span class="s3">'enum'</span><span class="s2">,</span>
    <span class="s3">'eval'</span><span class="s2">,</span>
    <span class="s3">'export'</span><span class="s2">,</span>
    <span class="s3">'extends'</span><span class="s2">,</span>
    <span class="s3">'false'</span><span class="s2">,</span>
    <span class="s3">'finally'</span><span class="s2">,</span>
    <span class="s3">'for'</span><span class="s2">,</span>
    <span class="s3">'function'</span><span class="s2">,</span>
    <span class="s3">'if'</span><span class="s2">,</span>
    <span class="s3">'implements'</span><span class="s2">,</span>
    <span class="s3">'import'</span><span class="s2">,</span>
    <span class="s3">'in'</span><span class="s2">,</span>
    <span class="s3">'instanceof'</span><span class="s2">,</span>
    <span class="s3">'interface'</span><span class="s2">,</span>
    <span class="s3">'let'</span><span class="s2">,</span>
    <span class="s3">'NaN'</span><span class="s2">,</span>
    <span class="s3">'new'</span><span class="s2">,</span>
    <span class="s3">'null'</span><span class="s2">,</span>
    <span class="s3">'package'</span><span class="s2">,</span>
    <span class="s3">'private'</span><span class="s2">,</span>
    <span class="s3">'protected'</span><span class="s2">,</span>
    <span class="s3">'public'</span><span class="s2">,</span>
    <span class="s3">'return'</span><span class="s2">,</span>
    <span class="s3">'static'</span><span class="s2">,</span>
    <span class="s3">'super'</span><span class="s2">,</span>
    <span class="s3">'switch'</span><span class="s2">,</span>
    <span class="s3">'this'</span><span class="s2">,</span>
    <span class="s3">'throw'</span><span class="s2">,</span>
    <span class="s3">'true'</span><span class="s2">,</span>
    <span class="s3">'try'</span><span class="s2">,</span>
    <span class="s3">'typeof'</span><span class="s2">,</span>
    <span class="s3">'undefined'</span><span class="s2">,</span>
    <span class="s3">'var'</span><span class="s2">,</span>
    <span class="s3">'void'</span><span class="s2">,</span>
    <span class="s3">'while'</span><span class="s2">,</span>
    <span class="s3">'with'</span><span class="s2">,</span>
    <span class="s3">'yield'</span>
<span class="s1">])</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RESERVED_NAMES$1 = RESERVED_NAMES</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">illegalCharacters = </span><span class="s4">/[^\w$]/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">startsWithDigit = (value) =&gt; </span><span class="s4">/\d/</span><span class="s1">.test(value[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">needsEscape = (value) =&gt; startsWithDigit(value) || RESERVED_NAMES$1.has(value) || value === </span><span class="s3">'arguments'</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isLegal(value) {</span>
    <span class="s2">if </span><span class="s1">(needsEscape(value)) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">!illegalCharacters.test(value)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeLegal(value) {</span>
    <span class="s1">value = value</span>
        <span class="s1">.replace(</span><span class="s4">/-(\w)/g</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">letter) =&gt; letter.toUpperCase())</span>
        <span class="s1">.replace(illegalCharacters</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needsEscape(value))</span>
        <span class="s1">value = </span><span class="s3">`_</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">value || </span><span class="s3">'_'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExternalModule {</span>
    <span class="s1">constructor(options</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">meta</span><span class="s2">, </span><span class="s1">renormalizeRenderPath</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id = id</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.renormalizeRenderPath = renormalizeRenderPath</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicImporters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.execIndex = Infinity</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportedVariables = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.importers = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.reexported = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.used = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.declarations = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.mostCommonSuggestion = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nameSuggestions = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.suggestedVariableName = makeLegal(id.split(</span><span class="s4">/[/\\]/</span><span class="s1">).pop())</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ importers</span><span class="s2">, </span><span class="s1">dynamicImporters } = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">info = (</span><span class="s2">this</span><span class="s1">.info = {</span>
            <span class="s1">assertions</span><span class="s2">,</span>
            <span class="s1">ast: </span><span class="s2">null,</span>
            <span class="s1">code: </span><span class="s2">null,</span>
            <span class="s1">dynamicallyImportedIdResolutions: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">dynamicallyImportedIds: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">get dynamicImporters() {</span>
                <span class="s2">return </span><span class="s1">dynamicImporters.sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">exportedBindings: </span><span class="s2">null,</span>
            <span class="s1">exports: </span><span class="s2">null,</span>
            <span class="s1">hasDefaultExport: </span><span class="s2">null,</span>
            <span class="s1">get hasModuleSideEffects() {</span>
                <span class="s1">warnDeprecation(</span><span class="s3">'Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.'</span><span class="s2">, </span><span class="s1">URL_THIS_GETMODULEINFO</span><span class="s2">, true, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">info.moduleSideEffects</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">id</span><span class="s2">,</span>
            <span class="s1">implicitlyLoadedAfterOneOf: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">implicitlyLoadedBefore: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">importedIdResolutions: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">importedIds: EMPTY_ARRAY</span><span class="s2">,</span>
            <span class="s1">get importers() {</span>
                <span class="s2">return </span><span class="s1">importers.sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">isEntry: </span><span class="s2">false,</span>
            <span class="s1">isExternal: </span><span class="s2">true,</span>
            <span class="s1">isIncluded: </span><span class="s2">null,</span>
            <span class="s1">meta</span><span class="s2">,</span>
            <span class="s1">moduleSideEffects</span><span class="s2">,</span>
            <span class="s1">syntheticNamedExports: </span><span class="s2">false</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">// Hide the deprecated key so that it only warns when accessed explicitly</span>
        <span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">.info</span><span class="s2">, </span><span class="s3">'hasModuleSideEffects'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">enumerable: </span><span class="s2">false</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getVariableForExportName(name) {</span>
        <span class="s2">const </span><span class="s1">declaration = </span><span class="s2">this</span><span class="s1">.declarations.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(declaration)</span>
            <span class="s2">return </span><span class="s1">[declaration]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">externalVariable = </span><span class="s2">new </span><span class="s1">ExternalVariable(</span><span class="s2">this, </span><span class="s1">name)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.declarations.set(name</span><span class="s2">, </span><span class="s1">externalVariable)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportedVariables.set(externalVariable</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">[externalVariable]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">suggestName(name) {</span>
        <span class="s2">const </span><span class="s1">value = (</span><span class="s2">this</span><span class="s1">.nameSuggestions.get(name) ?? </span><span class="s4">0</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nameSuggestions.set(name</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(value &gt; </span><span class="s2">this</span><span class="s1">.mostCommonSuggestion) {</span>
            <span class="s2">this</span><span class="s1">.mostCommonSuggestion = value</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.suggestedVariableName = name</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">warnUnusedImports() {</span>
        <span class="s2">const </span><span class="s1">unused = [...</span><span class="s2">this</span><span class="s1">.declarations]</span>
            <span class="s1">.filter(([name</span><span class="s2">, </span><span class="s1">declaration]) =&gt; name !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; !declaration.included &amp;&amp; !</span><span class="s2">this</span><span class="s1">.reexported &amp;&amp; !declaration.referenced)</span>
            <span class="s1">.map(([name]) =&gt; name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(unused.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return;</span>
        <span class="s2">const </span><span class="s1">importersSet = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of unused) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importer of </span><span class="s2">this</span><span class="s1">.declarations.get(name).module.importers) {</span>
                <span class="s1">importersSet.add(importer)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">importersArray = [...importersSet]</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options.onwarn(errorUnusedExternalImports(</span><span class="s2">this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">unused</span><span class="s2">, </span><span class="s1">importersArray))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getDefaultExportFromCjs (x) {</span>
	<span class="s2">return </span><span class="s1">x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x</span><span class="s2">, </span><span class="s3">'default'</span><span class="s1">) ? x[</span><span class="s3">'default'</span><span class="s1">] : x</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getAugmentedNamespace(n) {</span>
  <span class="s2">if </span><span class="s1">(n.__esModule) </span><span class="s2">return </span><span class="s1">n</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">f = n.default</span><span class="s2">;</span>
	<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">f == </span><span class="s3">&quot;function&quot;</span><span class="s1">) {</span>
		<span class="s2">var </span><span class="s1">a = </span><span class="s2">function </span><span class="s1">a () {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">this instanceof </span><span class="s1">a) {</span>
				<span class="s2">var </span><span class="s1">args = [</span><span class="s2">null</span><span class="s1">]</span><span class="s2">;</span>
				<span class="s1">args.push.apply(args</span><span class="s2">, </span><span class="s1">arguments)</span><span class="s2">;</span>
				<span class="s2">var </span><span class="s1">Ctor = Function.bind.apply(f</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
				<span class="s2">return new </span><span class="s1">Ctor()</span><span class="s2">;</span>
			<span class="s1">}</span>
			<span class="s2">return </span><span class="s1">f.apply(</span><span class="s2">this, </span><span class="s1">arguments)</span><span class="s2">;</span>
		<span class="s1">}</span><span class="s2">;</span>
		<span class="s1">a.prototype = f.prototype</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">a = {}</span><span class="s2">;</span>
  <span class="s1">Object.defineProperty(a</span><span class="s2">, </span><span class="s3">'__esModule'</span><span class="s2">, </span><span class="s1">{value: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">;</span>
	<span class="s1">Object.keys(n).forEach(</span><span class="s2">function </span><span class="s1">(k) {</span>
		<span class="s2">var </span><span class="s1">d = Object.getOwnPropertyDescriptor(n</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">;</span>
		<span class="s1">Object.defineProperty(a</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">d.get ? d : {</span>
			<span class="s1">enumerable: </span><span class="s2">true,</span>
			<span class="s1">get: </span><span class="s2">function </span><span class="s1">() {</span>
				<span class="s2">return </span><span class="s1">n[k]</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">})</span><span class="s2">;</span>
	<span class="s1">})</span><span class="s2">;</span>
	<span class="s2">return </span><span class="s1">a</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">picomatchExports = {}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">picomatch$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s2">return </span><span class="s1">picomatchExports</span><span class="s2">; </span><span class="s1">}</span><span class="s2">,</span>
  <span class="s1">set exports(v){ picomatchExports = v</span><span class="s2">; </span><span class="s1">}</span><span class="s2">,</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">utils$3 = {}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">path$1 = require$$0$1</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">WIN_SLASH = </span><span class="s3">'</span><span class="s2">\\\\</span><span class="s3">/'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">WIN_NO_SLASH = </span><span class="s3">`[^</span><span class="s1">${WIN_SLASH}</span><span class="s3">]`</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Posix glob regex</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">DOT_LITERAL = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">.'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">PLUS_LITERAL = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">+'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">QMARK_LITERAL = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">?'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SLASH_LITERAL = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">/'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ONE_CHAR = </span><span class="s3">'(?=.)'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">QMARK = </span><span class="s3">'[^/]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">END_ANCHOR = </span><span class="s3">`(?:</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">|$)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">START_ANCHOR = </span><span class="s3">`(?:^|</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">DOTS_SLASH = </span><span class="s3">`</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{1,2}</span><span class="s1">${END_ANCHOR}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NO_DOT = </span><span class="s3">`(?!</span><span class="s1">${DOT_LITERAL}</span><span class="s3">)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NO_DOTS = </span><span class="s3">`(?!</span><span class="s1">${START_ANCHOR}${DOTS_SLASH}</span><span class="s3">)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NO_DOT_SLASH = </span><span class="s3">`(?!</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{0,1}</span><span class="s1">${END_ANCHOR}</span><span class="s3">)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NO_DOTS_SLASH = </span><span class="s3">`(?!</span><span class="s1">${DOTS_SLASH}</span><span class="s3">)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">QMARK_NO_DOT = </span><span class="s3">`[^.</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">]`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">STAR = </span><span class="s3">`</span><span class="s1">${QMARK}</span><span class="s3">*?`</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">POSIX_CHARS = {</span>
  <span class="s1">DOT_LITERAL</span><span class="s2">,</span>
  <span class="s1">PLUS_LITERAL</span><span class="s2">,</span>
  <span class="s1">QMARK_LITERAL</span><span class="s2">,</span>
  <span class="s1">SLASH_LITERAL</span><span class="s2">,</span>
  <span class="s1">ONE_CHAR</span><span class="s2">,</span>
  <span class="s1">QMARK</span><span class="s2">,</span>
  <span class="s1">END_ANCHOR</span><span class="s2">,</span>
  <span class="s1">DOTS_SLASH</span><span class="s2">,</span>
  <span class="s1">NO_DOT</span><span class="s2">,</span>
  <span class="s1">NO_DOTS</span><span class="s2">,</span>
  <span class="s1">NO_DOT_SLASH</span><span class="s2">,</span>
  <span class="s1">NO_DOTS_SLASH</span><span class="s2">,</span>
  <span class="s1">QMARK_NO_DOT</span><span class="s2">,</span>
  <span class="s1">STAR</span><span class="s2">,</span>
  <span class="s1">START_ANCHOR</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Windows glob regex</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">WINDOWS_CHARS = {</span>
  <span class="s1">...POSIX_CHARS</span><span class="s2">,</span>

  <span class="s1">SLASH_LITERAL: </span><span class="s3">`[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]`</span><span class="s2">,</span>
  <span class="s1">QMARK: WIN_NO_SLASH</span><span class="s2">,</span>
  <span class="s1">STAR: </span><span class="s3">`</span><span class="s1">${WIN_NO_SLASH}</span><span class="s3">*?`</span><span class="s2">,</span>
  <span class="s1">DOTS_SLASH: </span><span class="s3">`</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{1,2}(?:[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]|$)`</span><span class="s2">,</span>
  <span class="s1">NO_DOT: </span><span class="s3">`(?!</span><span class="s1">${DOT_LITERAL}</span><span class="s3">)`</span><span class="s2">,</span>
  <span class="s1">NO_DOTS: </span><span class="s3">`(?!(?:^|[</span><span class="s1">${WIN_SLASH}</span><span class="s3">])</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{1,2}(?:[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]|$))`</span><span class="s2">,</span>
  <span class="s1">NO_DOT_SLASH: </span><span class="s3">`(?!</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{0,1}(?:[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]|$))`</span><span class="s2">,</span>
  <span class="s1">NO_DOTS_SLASH: </span><span class="s3">`(?!</span><span class="s1">${DOT_LITERAL}</span><span class="s3">{1,2}(?:[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]|$))`</span><span class="s2">,</span>
  <span class="s1">QMARK_NO_DOT: </span><span class="s3">`[^.</span><span class="s1">${WIN_SLASH}</span><span class="s3">]`</span><span class="s2">,</span>
  <span class="s1">START_ANCHOR: </span><span class="s3">`(?:^|[</span><span class="s1">${WIN_SLASH}</span><span class="s3">])`</span><span class="s2">,</span>
  <span class="s1">END_ANCHOR: </span><span class="s3">`(?:[</span><span class="s1">${WIN_SLASH}</span><span class="s3">]|$)`</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* POSIX Bracket Regex</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">POSIX_REGEX_SOURCE$1 = {</span>
  <span class="s1">alnum: </span><span class="s3">'a-zA-Z0-9'</span><span class="s2">,</span>
  <span class="s1">alpha: </span><span class="s3">'a-zA-Z'</span><span class="s2">,</span>
  <span class="s1">ascii: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">x00-</span><span class="s2">\\</span><span class="s3">x7F'</span><span class="s2">,</span>
  <span class="s1">blank: </span><span class="s3">' </span><span class="s2">\\</span><span class="s3">t'</span><span class="s2">,</span>
  <span class="s1">cntrl: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">x00-</span><span class="s2">\\</span><span class="s3">x1F</span><span class="s2">\\</span><span class="s3">x7F'</span><span class="s2">,</span>
  <span class="s1">digit: </span><span class="s3">'0-9'</span><span class="s2">,</span>
  <span class="s1">graph: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">x21-</span><span class="s2">\\</span><span class="s3">x7E'</span><span class="s2">,</span>
  <span class="s1">lower: </span><span class="s3">'a-z'</span><span class="s2">,</span>
  <span class="s1">print: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">x20-</span><span class="s2">\\</span><span class="s3">x7E '</span><span class="s2">,</span>
  <span class="s1">punct: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">-!&quot;#$%&amp;</span><span class="s2">\'</span><span class="s3">()</span><span class="s2">\\</span><span class="s3">*+,./:;&lt;=&gt;?@[</span><span class="s2">\\</span><span class="s3">]^_`{|}~'</span><span class="s2">,</span>
  <span class="s1">space: </span><span class="s3">' </span><span class="s2">\\</span><span class="s3">t</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n</span><span class="s2">\\</span><span class="s3">v</span><span class="s2">\\</span><span class="s3">f'</span><span class="s2">,</span>
  <span class="s1">upper: </span><span class="s3">'A-Z'</span><span class="s2">,</span>
  <span class="s1">word: </span><span class="s3">'A-Za-z0-9_'</span><span class="s2">,</span>
  <span class="s1">xdigit: </span><span class="s3">'A-Fa-f0-9'</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">constants$2 = {</span>
  <span class="s1">MAX_LENGTH: </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">64</span><span class="s2">,</span>
  <span class="s1">POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1</span><span class="s2">,</span>

  <span class="s0">// regular expressions</span>
  <span class="s1">REGEX_BACKSLASH: </span><span class="s4">/\\(?![*+?^${}(|)[\]])/g</span><span class="s2">,</span>
  <span class="s1">REGEX_NON_SPECIAL_CHARS: </span><span class="s4">/^[^@![\].,$*+?^{}()|\\/]+/</span><span class="s2">,</span>
  <span class="s1">REGEX_SPECIAL_CHARS: </span><span class="s4">/[-*+?.^${}(|)[\]]/</span><span class="s2">,</span>
  <span class="s1">REGEX_SPECIAL_CHARS_BACKREF: </span><span class="s4">/(\\?)((\W)(\3*))/g</span><span class="s2">,</span>
  <span class="s1">REGEX_SPECIAL_CHARS_GLOBAL: </span><span class="s4">/([-*+?.^${}(|)[\]])/g</span><span class="s2">,</span>
  <span class="s1">REGEX_REMOVE_BACKSLASH: </span><span class="s4">/(?:\[.*?[^\\]\]|\\(?=.))/g</span><span class="s2">,</span>

  <span class="s0">// Replace globs with equivalent patterns to reduce parsing time.</span>
  <span class="s1">REPLACEMENTS: {</span>
    <span class="s3">'***'</span><span class="s1">: </span><span class="s3">'*'</span><span class="s2">,</span>
    <span class="s3">'**/**'</span><span class="s1">: </span><span class="s3">'**'</span><span class="s2">,</span>
    <span class="s3">'**/**/**'</span><span class="s1">: </span><span class="s3">'**'</span>
  <span class="s1">}</span><span class="s2">,</span>

  <span class="s0">// Digits</span>
  <span class="s1">CHAR_0: </span><span class="s4">48</span><span class="s2">, </span><span class="s0">/* 0 */</span>
  <span class="s1">CHAR_9: </span><span class="s4">57</span><span class="s2">, </span><span class="s0">/* 9 */</span>

  <span class="s0">// Alphabet chars.</span>
  <span class="s1">CHAR_UPPERCASE_A: </span><span class="s4">65</span><span class="s2">, </span><span class="s0">/* A */</span>
  <span class="s1">CHAR_LOWERCASE_A: </span><span class="s4">97</span><span class="s2">, </span><span class="s0">/* a */</span>
  <span class="s1">CHAR_UPPERCASE_Z: </span><span class="s4">90</span><span class="s2">, </span><span class="s0">/* Z */</span>
  <span class="s1">CHAR_LOWERCASE_Z: </span><span class="s4">122</span><span class="s2">, </span><span class="s0">/* z */</span>

  <span class="s1">CHAR_LEFT_PARENTHESES: </span><span class="s4">40</span><span class="s2">, </span><span class="s0">/* ( */</span>
  <span class="s1">CHAR_RIGHT_PARENTHESES: </span><span class="s4">41</span><span class="s2">, </span><span class="s0">/* ) */</span>

  <span class="s1">CHAR_ASTERISK: </span><span class="s4">42</span><span class="s2">, </span><span class="s0">/* * */</span>

  <span class="s0">// Non-alphabetic chars.</span>
  <span class="s1">CHAR_AMPERSAND: </span><span class="s4">38</span><span class="s2">, </span><span class="s0">/* &amp; */</span>
  <span class="s1">CHAR_AT: </span><span class="s4">64</span><span class="s2">, </span><span class="s0">/* @ */</span>
  <span class="s1">CHAR_BACKWARD_SLASH: </span><span class="s4">92</span><span class="s2">, </span><span class="s0">/* \ */</span>
  <span class="s1">CHAR_CARRIAGE_RETURN: </span><span class="s4">13</span><span class="s2">, </span><span class="s0">/* \r */</span>
  <span class="s1">CHAR_CIRCUMFLEX_ACCENT: </span><span class="s4">94</span><span class="s2">, </span><span class="s0">/* ^ */</span>
  <span class="s1">CHAR_COLON: </span><span class="s4">58</span><span class="s2">, </span><span class="s0">/* : */</span>
  <span class="s1">CHAR_COMMA: </span><span class="s4">44</span><span class="s2">, </span><span class="s0">/* , */</span>
  <span class="s1">CHAR_DOT: </span><span class="s4">46</span><span class="s2">, </span><span class="s0">/* . */</span>
  <span class="s1">CHAR_DOUBLE_QUOTE: </span><span class="s4">34</span><span class="s2">, </span><span class="s0">/* &quot; */</span>
  <span class="s1">CHAR_EQUAL: </span><span class="s4">61</span><span class="s2">, </span><span class="s0">/* = */</span>
  <span class="s1">CHAR_EXCLAMATION_MARK: </span><span class="s4">33</span><span class="s2">, </span><span class="s0">/* ! */</span>
  <span class="s1">CHAR_FORM_FEED: </span><span class="s4">12</span><span class="s2">, </span><span class="s0">/* \f */</span>
  <span class="s1">CHAR_FORWARD_SLASH: </span><span class="s4">47</span><span class="s2">, </span><span class="s0">/* / */</span>
  <span class="s1">CHAR_GRAVE_ACCENT: </span><span class="s4">96</span><span class="s2">, </span><span class="s0">/* ` */</span>
  <span class="s1">CHAR_HASH: </span><span class="s4">35</span><span class="s2">, </span><span class="s0">/* # */</span>
  <span class="s1">CHAR_HYPHEN_MINUS: </span><span class="s4">45</span><span class="s2">, </span><span class="s0">/* - */</span>
  <span class="s1">CHAR_LEFT_ANGLE_BRACKET: </span><span class="s4">60</span><span class="s2">, </span><span class="s0">/* &lt; */</span>
  <span class="s1">CHAR_LEFT_CURLY_BRACE: </span><span class="s4">123</span><span class="s2">, </span><span class="s0">/* { */</span>
  <span class="s1">CHAR_LEFT_SQUARE_BRACKET: </span><span class="s4">91</span><span class="s2">, </span><span class="s0">/* [ */</span>
  <span class="s1">CHAR_LINE_FEED: </span><span class="s4">10</span><span class="s2">, </span><span class="s0">/* \n */</span>
  <span class="s1">CHAR_NO_BREAK_SPACE: </span><span class="s4">160</span><span class="s2">, </span><span class="s0">/* \u00A0 */</span>
  <span class="s1">CHAR_PERCENT: </span><span class="s4">37</span><span class="s2">, </span><span class="s0">/* % */</span>
  <span class="s1">CHAR_PLUS: </span><span class="s4">43</span><span class="s2">, </span><span class="s0">/* + */</span>
  <span class="s1">CHAR_QUESTION_MARK: </span><span class="s4">63</span><span class="s2">, </span><span class="s0">/* ? */</span>
  <span class="s1">CHAR_RIGHT_ANGLE_BRACKET: </span><span class="s4">62</span><span class="s2">, </span><span class="s0">/* &gt; */</span>
  <span class="s1">CHAR_RIGHT_CURLY_BRACE: </span><span class="s4">125</span><span class="s2">, </span><span class="s0">/* } */</span>
  <span class="s1">CHAR_RIGHT_SQUARE_BRACKET: </span><span class="s4">93</span><span class="s2">, </span><span class="s0">/* ] */</span>
  <span class="s1">CHAR_SEMICOLON: </span><span class="s4">59</span><span class="s2">, </span><span class="s0">/* ; */</span>
  <span class="s1">CHAR_SINGLE_QUOTE: </span><span class="s4">39</span><span class="s2">, </span><span class="s0">/* ' */</span>
  <span class="s1">CHAR_SPACE: </span><span class="s4">32</span><span class="s2">, </span><span class="s0">/*   */</span>
  <span class="s1">CHAR_TAB: </span><span class="s4">9</span><span class="s2">, </span><span class="s0">/* \t */</span>
  <span class="s1">CHAR_UNDERSCORE: </span><span class="s4">95</span><span class="s2">, </span><span class="s0">/* _ */</span>
  <span class="s1">CHAR_VERTICAL_LINE: </span><span class="s4">124</span><span class="s2">, </span><span class="s0">/* | */</span>
  <span class="s1">CHAR_ZERO_WIDTH_NOBREAK_SPACE: </span><span class="s4">65279</span><span class="s2">, </span><span class="s0">/* \uFEFF */</span>

  <span class="s1">SEP: path$1.sep</span><span class="s2">,</span>

  <span class="s5">/**</span>
   <span class="s5">* Create EXTGLOB_CHARS</span>
   <span class="s5">*/</span>

  <span class="s1">extglobChars(chars) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s3">'!'</span><span class="s1">: { type: </span><span class="s3">'negate'</span><span class="s2">, </span><span class="s1">open: </span><span class="s3">'(?:(?!(?:'</span><span class="s2">, </span><span class="s1">close: </span><span class="s3">`))</span><span class="s1">${chars.STAR}</span><span class="s3">)` </span><span class="s1">}</span><span class="s2">,</span>
      <span class="s3">'?'</span><span class="s1">: { type: </span><span class="s3">'qmark'</span><span class="s2">, </span><span class="s1">open: </span><span class="s3">'(?:'</span><span class="s2">, </span><span class="s1">close: </span><span class="s3">')?' </span><span class="s1">}</span><span class="s2">,</span>
      <span class="s3">'+'</span><span class="s1">: { type: </span><span class="s3">'plus'</span><span class="s2">, </span><span class="s1">open: </span><span class="s3">'(?:'</span><span class="s2">, </span><span class="s1">close: </span><span class="s3">')+' </span><span class="s1">}</span><span class="s2">,</span>
      <span class="s3">'*'</span><span class="s1">: { type: </span><span class="s3">'star'</span><span class="s2">, </span><span class="s1">open: </span><span class="s3">'(?:'</span><span class="s2">, </span><span class="s1">close: </span><span class="s3">')*' </span><span class="s1">}</span><span class="s2">,</span>
      <span class="s3">'@'</span><span class="s1">: { type: </span><span class="s3">'at'</span><span class="s2">, </span><span class="s1">open: </span><span class="s3">'(?:'</span><span class="s2">, </span><span class="s1">close: </span><span class="s3">')' </span><span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>

  <span class="s5">/**</span>
   <span class="s5">* Create GLOB_CHARS</span>
   <span class="s5">*/</span>

  <span class="s1">globChars(win32) {</span>
    <span class="s2">return </span><span class="s1">win32 === </span><span class="s2">true </span><span class="s1">? WINDOWS_CHARS : POSIX_CHARS</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">(</span><span class="s2">function </span><span class="s1">(exports) {</span>

	<span class="s2">const </span><span class="s1">path = require$$0$1</span><span class="s2">;</span>
	<span class="s2">const </span><span class="s1">win32 = process.platform === </span><span class="s3">'win32'</span><span class="s2">;</span>
	<span class="s2">const </span><span class="s1">{</span>
	  <span class="s1">REGEX_BACKSLASH</span><span class="s2">,</span>
	  <span class="s1">REGEX_REMOVE_BACKSLASH</span><span class="s2">,</span>
	  <span class="s1">REGEX_SPECIAL_CHARS</span><span class="s2">,</span>
	  <span class="s1">REGEX_SPECIAL_CHARS_GLOBAL</span>
	<span class="s1">} = constants$2</span><span class="s2">;</span>

	<span class="s1">exports.isObject = val =&gt; val !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; !Array.isArray(val)</span><span class="s2">;</span>
	<span class="s1">exports.hasRegexChars = str =&gt; REGEX_SPECIAL_CHARS.test(str)</span><span class="s2">;</span>
	<span class="s1">exports.isRegexChar = str =&gt; str.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; exports.hasRegexChars(str)</span><span class="s2">;</span>
	<span class="s1">exports.escapeRegex = str =&gt; str.replace(REGEX_SPECIAL_CHARS_GLOBAL</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">$1'</span><span class="s1">)</span><span class="s2">;</span>
	<span class="s1">exports.toPosixSlashes = str =&gt; str.replace(REGEX_BACKSLASH</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span><span class="s2">;</span>

	<span class="s1">exports.removeBackslashes = str =&gt; {</span>
	  <span class="s2">return </span><span class="s1">str.replace(REGEX_REMOVE_BACKSLASH</span><span class="s2">, </span><span class="s1">match =&gt; {</span>
	    <span class="s2">return </span><span class="s1">match === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: match</span><span class="s2">;</span>
	  <span class="s1">})</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>

	<span class="s1">exports.supportsLookbehinds = () =&gt; {</span>
	  <span class="s2">const </span><span class="s1">segs = process.version.slice(</span><span class="s4">1</span><span class="s1">).split(</span><span class="s3">'.'</span><span class="s1">).map(Number)</span><span class="s2">;</span>
	  <span class="s2">if </span><span class="s1">(segs.length === </span><span class="s4">3 </span><span class="s1">&amp;&amp; segs[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s4">9 </span><span class="s1">|| (segs[</span><span class="s4">0</span><span class="s1">] === </span><span class="s4">8 </span><span class="s1">&amp;&amp; segs[</span><span class="s4">1</span><span class="s1">] &gt;= </span><span class="s4">10</span><span class="s1">)) {</span>
	    <span class="s2">return true;</span>
	  <span class="s1">}</span>
	  <span class="s2">return false;</span>
	<span class="s1">}</span><span class="s2">;</span>

	<span class="s1">exports.isWindows = options =&gt; {</span>
	  <span class="s2">if </span><span class="s1">(options &amp;&amp; </span><span class="s2">typeof </span><span class="s1">options.windows === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
	    <span class="s2">return </span><span class="s1">options.windows</span><span class="s2">;</span>
	  <span class="s1">}</span>
	  <span class="s2">return </span><span class="s1">win32 === </span><span class="s2">true </span><span class="s1">|| path.sep === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>

	<span class="s1">exports.escapeLast = (input</span><span class="s2">, </span><span class="s1">char</span><span class="s2">, </span><span class="s1">lastIdx) =&gt; {</span>
	  <span class="s2">const </span><span class="s1">idx = input.lastIndexOf(char</span><span class="s2">, </span><span class="s1">lastIdx)</span><span class="s2">;</span>
	  <span class="s2">if </span><span class="s1">(idx === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">input</span><span class="s2">;</span>
	  <span class="s2">if </span><span class="s1">(input[idx - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">exports.escapeLast(input</span><span class="s2">, </span><span class="s1">char</span><span class="s2">, </span><span class="s1">idx - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
	  <span class="s2">return </span><span class="s3">`</span><span class="s1">${input.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">idx)}</span><span class="s2">\\</span><span class="s1">${input.slice(idx)}</span><span class="s3">`</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>

	<span class="s1">exports.removePrefix = (input</span><span class="s2">, </span><span class="s1">state = {}) =&gt; {</span>
	  <span class="s2">let </span><span class="s1">output = input</span><span class="s2">;</span>
	  <span class="s2">if </span><span class="s1">(output.startsWith(</span><span class="s3">'./'</span><span class="s1">)) {</span>
	    <span class="s1">output = output.slice(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
	    <span class="s1">state.prefix = </span><span class="s3">'./'</span><span class="s2">;</span>
	  <span class="s1">}</span>
	  <span class="s2">return </span><span class="s1">output</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>

	<span class="s1">exports.wrapOutput = (input</span><span class="s2">, </span><span class="s1">state = {}</span><span class="s2">, </span><span class="s1">options = {}) =&gt; {</span>
	  <span class="s2">const </span><span class="s1">prepend = options.contains ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'^'</span><span class="s2">;</span>
	  <span class="s2">const </span><span class="s1">append = options.contains ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'$'</span><span class="s2">;</span>

	  <span class="s2">let </span><span class="s1">output = </span><span class="s3">`</span><span class="s1">${prepend}</span><span class="s3">(?:</span><span class="s1">${input}</span><span class="s3">)</span><span class="s1">${append}</span><span class="s3">`</span><span class="s2">;</span>
	  <span class="s2">if </span><span class="s1">(state.negated === </span><span class="s2">true</span><span class="s1">) {</span>
	    <span class="s1">output = </span><span class="s3">`(?:^(?!</span><span class="s1">${output}</span><span class="s3">).*$)`</span><span class="s2">;</span>
	  <span class="s1">}</span>
	  <span class="s2">return </span><span class="s1">output</span><span class="s2">;</span>
	<span class="s1">}</span><span class="s2">;</span>
<span class="s1">} (utils$3))</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">utils$2 = utils$3</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">{</span>
  <span class="s1">CHAR_ASTERISK</span><span class="s2">,             </span><span class="s0">/* * */</span>
  <span class="s1">CHAR_AT</span><span class="s2">,                   </span><span class="s0">/* @ */</span>
  <span class="s1">CHAR_BACKWARD_SLASH</span><span class="s2">,       </span><span class="s0">/* \ */</span>
  <span class="s1">CHAR_COMMA</span><span class="s2">,                </span><span class="s0">/* , */</span>
  <span class="s1">CHAR_DOT</span><span class="s2">,                  </span><span class="s0">/* . */</span>
  <span class="s1">CHAR_EXCLAMATION_MARK</span><span class="s2">,     </span><span class="s0">/* ! */</span>
  <span class="s1">CHAR_FORWARD_SLASH</span><span class="s2">,        </span><span class="s0">/* / */</span>
  <span class="s1">CHAR_LEFT_CURLY_BRACE</span><span class="s2">,     </span><span class="s0">/* { */</span>
  <span class="s1">CHAR_LEFT_PARENTHESES</span><span class="s2">,     </span><span class="s0">/* ( */</span>
  <span class="s1">CHAR_LEFT_SQUARE_BRACKET</span><span class="s2">,  </span><span class="s0">/* [ */</span>
  <span class="s1">CHAR_PLUS</span><span class="s2">,                 </span><span class="s0">/* + */</span>
  <span class="s1">CHAR_QUESTION_MARK</span><span class="s2">,        </span><span class="s0">/* ? */</span>
  <span class="s1">CHAR_RIGHT_CURLY_BRACE</span><span class="s2">,    </span><span class="s0">/* } */</span>
  <span class="s1">CHAR_RIGHT_PARENTHESES</span><span class="s2">,    </span><span class="s0">/* ) */</span>
  <span class="s1">CHAR_RIGHT_SQUARE_BRACKET  </span><span class="s0">/* ] */</span>
<span class="s1">} = constants$2</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isPathSeparator = code =&gt; {</span>
  <span class="s2">return </span><span class="s1">code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">depth = token =&gt; {</span>
  <span class="s2">if </span><span class="s1">(token.isPrefix !== </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">token.depth = token.isGlobstar ? Infinity : </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Quickly scans a glob pattern and returns an object with a handful of</span>
 <span class="s5">* useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),</span>
 <span class="s5">* `glob` (the actual pattern), `negated` (true if the path starts with `!` but not</span>
 <span class="s5">* with `!(`) and `negatedExtglob` (true if the path starts with `!(`).</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const pm = require('picomatch');</span>
 <span class="s5">* console.log(pm.scan('foo/bar/*.js'));</span>
 <span class="s5">* { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `str`</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object} Returns an object with tokens and regex source string.</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">scan$1 = (input</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">const </span><span class="s1">opts = options || {}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">length = input.length - </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">scanToEnd = opts.parts === </span><span class="s2">true </span><span class="s1">|| opts.scanToEnd === </span><span class="s2">true;</span>
  <span class="s2">const </span><span class="s1">slashes = []</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">tokens = []</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">parts = []</span><span class="s2">;</span>

  <span class="s2">let </span><span class="s1">str = input</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">index = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">lastIndex = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">isBrace = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">isBracket = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">isGlob = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">isExtglob = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">isGlobstar = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">braceEscaped = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">backslashes = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">negated = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">negatedExtglob = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">finished = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">braces = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">prev</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">code</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">token = { value: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">depth: </span><span class="s4">0</span><span class="s2">, </span><span class="s1">isGlob: </span><span class="s2">false </span><span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">eos = () =&gt; index &gt;= length</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">peek = () =&gt; str.charCodeAt(index + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">advance = () =&gt; {</span>
    <span class="s1">prev = code</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">str.charCodeAt(++index)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">while </span><span class="s1">(index &lt; length) {</span>
    <span class="s1">code = advance()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(code === CHAR_BACKWARD_SLASH) {</span>
      <span class="s1">backslashes = token.backslashes = </span><span class="s2">true;</span>
      <span class="s1">code = advance()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(code === CHAR_LEFT_CURLY_BRACE) {</span>
        <span class="s1">braceEscaped = </span><span class="s2">true;</span>
      <span class="s1">}</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(braceEscaped === </span><span class="s2">true </span><span class="s1">|| code === CHAR_LEFT_CURLY_BRACE) {</span>
      <span class="s1">braces++</span><span class="s2">;</span>

      <span class="s2">while </span><span class="s1">(eos() !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (code = advance())) {</span>
        <span class="s2">if </span><span class="s1">(code === CHAR_BACKWARD_SLASH) {</span>
          <span class="s1">backslashes = token.backslashes = </span><span class="s2">true;</span>
          <span class="s1">advance()</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(code === CHAR_LEFT_CURLY_BRACE) {</span>
          <span class="s1">braces++</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(braceEscaped !== </span><span class="s2">true </span><span class="s1">&amp;&amp; code === CHAR_DOT &amp;&amp; (code = advance()) === CHAR_DOT) {</span>
          <span class="s1">isBrace = token.isBrace = </span><span class="s2">true;</span>
          <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
          <span class="s1">finished = </span><span class="s2">true;</span>

          <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">continue;</span>
          <span class="s1">}</span>

          <span class="s2">break;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(braceEscaped !== </span><span class="s2">true </span><span class="s1">&amp;&amp; code === CHAR_COMMA) {</span>
          <span class="s1">isBrace = token.isBrace = </span><span class="s2">true;</span>
          <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
          <span class="s1">finished = </span><span class="s2">true;</span>

          <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">continue;</span>
          <span class="s1">}</span>

          <span class="s2">break;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(code === CHAR_RIGHT_CURLY_BRACE) {</span>
          <span class="s1">braces--</span><span class="s2">;</span>

          <span class="s2">if </span><span class="s1">(braces === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">braceEscaped = </span><span class="s2">false;</span>
            <span class="s1">isBrace = token.isBrace = </span><span class="s2">true;</span>
            <span class="s1">finished = </span><span class="s2">true;</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(code === CHAR_FORWARD_SLASH) {</span>
      <span class="s1">slashes.push(index)</span><span class="s2">;</span>
      <span class="s1">tokens.push(token)</span><span class="s2">;</span>
      <span class="s1">token = { value: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">depth: </span><span class="s4">0</span><span class="s2">, </span><span class="s1">isGlob: </span><span class="s2">false </span><span class="s1">}</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(finished === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">continue;</span>
      <span class="s2">if </span><span class="s1">(prev === CHAR_DOT &amp;&amp; index === (start + </span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s1">start += </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">lastIndex = index + </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(opts.noext !== </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">isExtglobChar = code === CHAR_PLUS</span>
        <span class="s1">|| code === CHAR_AT</span>
        <span class="s1">|| code === CHAR_ASTERISK</span>
        <span class="s1">|| code === CHAR_QUESTION_MARK</span>
        <span class="s1">|| code === CHAR_EXCLAMATION_MARK</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(isExtglobChar === </span><span class="s2">true </span><span class="s1">&amp;&amp; peek() === CHAR_LEFT_PARENTHESES) {</span>
        <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
        <span class="s1">isExtglob = token.isExtglob = </span><span class="s2">true;</span>
        <span class="s1">finished = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(code === CHAR_EXCLAMATION_MARK &amp;&amp; index === start) {</span>
          <span class="s1">negatedExtglob = </span><span class="s2">true;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">while </span><span class="s1">(eos() !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (code = advance())) {</span>
            <span class="s2">if </span><span class="s1">(code === CHAR_BACKWARD_SLASH) {</span>
              <span class="s1">backslashes = token.backslashes = </span><span class="s2">true;</span>
              <span class="s1">code = advance()</span><span class="s2">;</span>
              <span class="s2">continue;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(code === CHAR_RIGHT_PARENTHESES) {</span>
              <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
              <span class="s1">finished = </span><span class="s2">true;</span>
              <span class="s2">break;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(code === CHAR_ASTERISK) {</span>
      <span class="s2">if </span><span class="s1">(prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = </span><span class="s2">true;</span>
      <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
      <span class="s1">finished = </span><span class="s2">true;</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(code === CHAR_QUESTION_MARK) {</span>
      <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
      <span class="s1">finished = </span><span class="s2">true;</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(code === CHAR_LEFT_SQUARE_BRACKET) {</span>
      <span class="s2">while </span><span class="s1">(eos() !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (next = advance())) {</span>
        <span class="s2">if </span><span class="s1">(next === CHAR_BACKWARD_SLASH) {</span>
          <span class="s1">backslashes = token.backslashes = </span><span class="s2">true;</span>
          <span class="s1">advance()</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(next === CHAR_RIGHT_SQUARE_BRACKET) {</span>
          <span class="s1">isBracket = token.isBracket = </span><span class="s2">true;</span>
          <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>
          <span class="s1">finished = </span><span class="s2">true;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(opts.nonegate !== </span><span class="s2">true </span><span class="s1">&amp;&amp; code === CHAR_EXCLAMATION_MARK &amp;&amp; index === start) {</span>
      <span class="s1">negated = token.negated = </span><span class="s2">true;</span>
      <span class="s1">start++</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(opts.noparen !== </span><span class="s2">true </span><span class="s1">&amp;&amp; code === CHAR_LEFT_PARENTHESES) {</span>
      <span class="s1">isGlob = token.isGlob = </span><span class="s2">true;</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">while </span><span class="s1">(eos() !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (code = advance())) {</span>
          <span class="s2">if </span><span class="s1">(code === CHAR_LEFT_PARENTHESES) {</span>
            <span class="s1">backslashes = token.backslashes = </span><span class="s2">true;</span>
            <span class="s1">code = advance()</span><span class="s2">;</span>
            <span class="s2">continue;</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(code === CHAR_RIGHT_PARENTHESES) {</span>
            <span class="s1">finished = </span><span class="s2">true;</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s2">break;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isGlob === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">finished = </span><span class="s2">true;</span>

      <span class="s2">if </span><span class="s1">(scanToEnd === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(opts.noext === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">isExtglob = </span><span class="s2">false;</span>
    <span class="s1">isGlob = </span><span class="s2">false;</span>
  <span class="s1">}</span>

  <span class="s2">let </span><span class="s1">base = str</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">prefix = </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">glob = </span><span class="s3">''</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(start &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">prefix = str.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
    <span class="s1">str = str.slice(start)</span><span class="s2">;</span>
    <span class="s1">lastIndex -= start</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(base &amp;&amp; isGlob === </span><span class="s2">true </span><span class="s1">&amp;&amp; lastIndex &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">base = str.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">lastIndex)</span><span class="s2">;</span>
    <span class="s1">glob = str.slice(lastIndex)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isGlob === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">base = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s1">glob = str</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">base = str</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(base &amp;&amp; base !== </span><span class="s3">'' </span><span class="s1">&amp;&amp; base !== </span><span class="s3">'/' </span><span class="s1">&amp;&amp; base !== str) {</span>
    <span class="s2">if </span><span class="s1">(isPathSeparator(base.charCodeAt(base.length - </span><span class="s4">1</span><span class="s1">))) {</span>
      <span class="s1">base = base.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(opts.unescape === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(glob) glob = utils$2.removeBackslashes(glob)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(base &amp;&amp; backslashes === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">base = utils$2.removeBackslashes(base)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">state = {</span>
    <span class="s1">prefix</span><span class="s2">,</span>
    <span class="s1">input</span><span class="s2">,</span>
    <span class="s1">start</span><span class="s2">,</span>
    <span class="s1">base</span><span class="s2">,</span>
    <span class="s1">glob</span><span class="s2">,</span>
    <span class="s1">isBrace</span><span class="s2">,</span>
    <span class="s1">isBracket</span><span class="s2">,</span>
    <span class="s1">isGlob</span><span class="s2">,</span>
    <span class="s1">isExtglob</span><span class="s2">,</span>
    <span class="s1">isGlobstar</span><span class="s2">,</span>
    <span class="s1">negated</span><span class="s2">,</span>
    <span class="s1">negatedExtglob</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(opts.tokens === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">state.maxDepth = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isPathSeparator(code)) {</span>
      <span class="s1">tokens.push(token)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.tokens = tokens</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(opts.parts === </span><span class="s2">true </span><span class="s1">|| opts.tokens === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">prevIndex</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">idx = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">idx &lt; slashes.length</span><span class="s2">; </span><span class="s1">idx++) {</span>
      <span class="s2">const </span><span class="s1">n = prevIndex ? prevIndex + </span><span class="s4">1 </span><span class="s1">: start</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">i = slashes[idx]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">value = input.slice(n</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(opts.tokens) {</span>
        <span class="s2">if </span><span class="s1">(idx === </span><span class="s4">0 </span><span class="s1">&amp;&amp; start !== </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">tokens[idx].isPrefix = </span><span class="s2">true;</span>
          <span class="s1">tokens[idx].value = prefix</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">tokens[idx].value = value</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">depth(tokens[idx])</span><span class="s2">;</span>
        <span class="s1">state.maxDepth += tokens[idx].depth</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(idx !== </span><span class="s4">0 </span><span class="s1">|| value !== </span><span class="s3">''</span><span class="s1">) {</span>
        <span class="s1">parts.push(value)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">prevIndex = i</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(prevIndex &amp;&amp; prevIndex + </span><span class="s4">1 </span><span class="s1">&lt; input.length) {</span>
      <span class="s2">const </span><span class="s1">value = input.slice(prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">parts.push(value)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(opts.tokens) {</span>
        <span class="s1">tokens[tokens.length - </span><span class="s4">1</span><span class="s1">].value = value</span><span class="s2">;</span>
        <span class="s1">depth(tokens[tokens.length - </span><span class="s4">1</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">state.maxDepth += tokens[tokens.length - </span><span class="s4">1</span><span class="s1">].depth</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">state.slashes = slashes</span><span class="s2">;</span>
    <span class="s1">state.parts = parts</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">scan_1 = scan$1</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">constants$1 = constants$2</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">utils$1 = utils$3</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Constants</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">{</span>
  <span class="s1">MAX_LENGTH</span><span class="s2">,</span>
  <span class="s1">POSIX_REGEX_SOURCE</span><span class="s2">,</span>
  <span class="s1">REGEX_NON_SPECIAL_CHARS</span><span class="s2">,</span>
  <span class="s1">REGEX_SPECIAL_CHARS_BACKREF</span><span class="s2">,</span>
  <span class="s1">REPLACEMENTS</span>
<span class="s1">} = constants$1</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Helpers</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">expandRange = (args</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">options.expandRange === </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">options.expandRange(...args</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">args.sort()</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">value = </span><span class="s3">`[</span><span class="s1">${args.join(</span><span class="s3">'-'</span><span class="s1">)}</span><span class="s3">]`</span><span class="s2">;</span>

  <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Create the message for a syntax error</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">syntaxError = (type</span><span class="s2">, </span><span class="s1">char) =&gt; {</span>
  <span class="s2">return </span><span class="s3">`Missing </span><span class="s1">${type}</span><span class="s3">: &quot;</span><span class="s1">${char}</span><span class="s3">&quot; - use &quot;</span><span class="s2">\\\\</span><span class="s1">${char}</span><span class="s3">&quot; to match literal characters`</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Parse the given input string.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} input</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} options</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object}</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">parse$2 = (input</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">input !== </span><span class="s3">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Expected a string'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">input = REPLACEMENTS[input] || input</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">opts = { ...options }</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">max = </span><span class="s2">typeof </span><span class="s1">opts.maxLength === </span><span class="s3">'number' </span><span class="s1">? Math.min(MAX_LENGTH</span><span class="s2">, </span><span class="s1">opts.maxLength) : MAX_LENGTH</span><span class="s2">;</span>

  <span class="s2">let </span><span class="s1">len = input.length</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(len &gt; max) {</span>
    <span class="s2">throw new </span><span class="s1">SyntaxError(</span><span class="s3">`Input length: </span><span class="s1">${len}</span><span class="s3">, exceeds maximum allowed length: </span><span class="s1">${max}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">bos = { type: </span><span class="s3">'bos'</span><span class="s2">, </span><span class="s1">value: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">output: opts.prepend || </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">tokens = [bos]</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">capture = opts.capture ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'?:'</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">win32 = utils$1.isWindows(options)</span><span class="s2">;</span>

  <span class="s0">// create constants based on platform, for windows or posix</span>
  <span class="s2">const </span><span class="s1">PLATFORM_CHARS = constants$1.globChars(win32)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS)</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">{</span>
    <span class="s1">DOT_LITERAL</span><span class="s2">,</span>
    <span class="s1">PLUS_LITERAL</span><span class="s2">,</span>
    <span class="s1">SLASH_LITERAL</span><span class="s2">,</span>
    <span class="s1">ONE_CHAR</span><span class="s2">,</span>
    <span class="s1">DOTS_SLASH</span><span class="s2">,</span>
    <span class="s1">NO_DOT</span><span class="s2">,</span>
    <span class="s1">NO_DOT_SLASH</span><span class="s2">,</span>
    <span class="s1">NO_DOTS_SLASH</span><span class="s2">,</span>
    <span class="s1">QMARK</span><span class="s2">,</span>
    <span class="s1">QMARK_NO_DOT</span><span class="s2">,</span>
    <span class="s1">STAR</span><span class="s2">,</span>
    <span class="s1">START_ANCHOR</span>
  <span class="s1">} = PLATFORM_CHARS</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">globstar = opts =&gt; {</span>
    <span class="s2">return </span><span class="s3">`(</span><span class="s1">${capture}</span><span class="s3">(?:(?!</span><span class="s1">${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}</span><span class="s3">).)*?)`</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">nodot = opts.dot ? </span><span class="s3">'' </span><span class="s1">: NO_DOT</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">star = opts.bash === </span><span class="s2">true </span><span class="s1">? globstar(opts) : STAR</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(opts.capture) {</span>
    <span class="s1">star = </span><span class="s3">`(</span><span class="s1">${star}</span><span class="s3">)`</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// minimatch options support</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.noext === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
    <span class="s1">opts.noextglob = opts.noext</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">state = {</span>
    <span class="s1">input</span><span class="s2">,</span>
    <span class="s1">index: -</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">start: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">dot: opts.dot === </span><span class="s2">true,</span>
    <span class="s1">consumed: </span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">output: </span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">prefix: </span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">backtrack: </span><span class="s2">false,</span>
    <span class="s1">negated: </span><span class="s2">false,</span>
    <span class="s1">brackets: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">braces: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">parens: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">quotes: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">globstar: </span><span class="s2">false,</span>
    <span class="s1">tokens</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s1">input = utils$1.removePrefix(input</span><span class="s2">, </span><span class="s1">state)</span><span class="s2">;</span>
  <span class="s1">len = input.length</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">extglobs = []</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">braces = []</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">stack = []</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">prev = bos</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">value</span><span class="s2">;</span>

  <span class="s5">/**</span>
   <span class="s5">* Tokenizing helpers</span>
   <span class="s5">*/</span>

  <span class="s2">const </span><span class="s1">eos = () =&gt; state.index === len - </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">peek = state.peek = (n = </span><span class="s4">1</span><span class="s1">) =&gt; input[state.index + n]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">advance = state.advance = () =&gt; input[++state.index] || </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">remaining = () =&gt; input.slice(state.index + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">consume = (value = </span><span class="s3">''</span><span class="s2">, </span><span class="s1">num = </span><span class="s4">0</span><span class="s1">) =&gt; {</span>
    <span class="s1">state.consumed += value</span><span class="s2">;</span>
    <span class="s1">state.index += num</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">append = token =&gt; {</span>
    <span class="s1">state.output += token.output != </span><span class="s2">null </span><span class="s1">? token.output : token.value</span><span class="s2">;</span>
    <span class="s1">consume(token.value)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">negate = () =&gt; {</span>
    <span class="s2">let </span><span class="s1">count = </span><span class="s4">1</span><span class="s2">;</span>

    <span class="s2">while </span><span class="s1">(peek() === </span><span class="s3">'!' </span><span class="s1">&amp;&amp; (peek(</span><span class="s4">2</span><span class="s1">) !== </span><span class="s3">'(' </span><span class="s1">|| peek(</span><span class="s4">3</span><span class="s1">) === </span><span class="s3">'?'</span><span class="s1">)) {</span>
      <span class="s1">advance()</span><span class="s2">;</span>
      <span class="s1">state.start++</span><span class="s2">;</span>
      <span class="s1">count++</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(count % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s1">state.negated = </span><span class="s2">true;</span>
    <span class="s1">state.start++</span><span class="s2">;</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">increment = type =&gt; {</span>
    <span class="s1">state[type]++</span><span class="s2">;</span>
    <span class="s1">stack.push(type)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">decrement = type =&gt; {</span>
    <span class="s1">state[type]--</span><span class="s2">;</span>
    <span class="s1">stack.pop()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s5">/**</span>
   <span class="s5">* Push tokens onto the tokens array. This helper speeds up</span>
   <span class="s5">* tokenizing by 1) helping us avoid backtracking as much as possible,</span>
   <span class="s5">* and 2) helping us avoid creating extra tokens when consecutive</span>
   <span class="s5">* characters are plain text. This improves performance and simplifies</span>
   <span class="s5">* lookbehinds.</span>
   <span class="s5">*/</span>

  <span class="s2">const </span><span class="s1">push = tok =&gt; {</span>
    <span class="s2">if </span><span class="s1">(prev.type === </span><span class="s3">'globstar'</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">isBrace = state.braces &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; (tok.type === </span><span class="s3">'comma' </span><span class="s1">|| tok.type === </span><span class="s3">'brace'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">isExtglob = tok.extglob === </span><span class="s2">true </span><span class="s1">|| (extglobs.length &amp;&amp; (tok.type === </span><span class="s3">'pipe' </span><span class="s1">|| tok.type === </span><span class="s3">'paren'</span><span class="s1">))</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(tok.type !== </span><span class="s3">'slash' </span><span class="s1">&amp;&amp; tok.type !== </span><span class="s3">'paren' </span><span class="s1">&amp;&amp; !isBrace &amp;&amp; !isExtglob) {</span>
        <span class="s1">state.output = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-prev.output.length)</span><span class="s2">;</span>
        <span class="s1">prev.type = </span><span class="s3">'star'</span><span class="s2">;</span>
        <span class="s1">prev.value = </span><span class="s3">'*'</span><span class="s2">;</span>
        <span class="s1">prev.output = star</span><span class="s2">;</span>
        <span class="s1">state.output += prev.output</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(extglobs.length &amp;&amp; tok.type !== </span><span class="s3">'paren'</span><span class="s1">) {</span>
      <span class="s1">extglobs[extglobs.length - </span><span class="s4">1</span><span class="s1">].inner += tok.value</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(tok.value || tok.output) append(tok)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prev &amp;&amp; prev.type === </span><span class="s3">'text' </span><span class="s1">&amp;&amp; tok.type === </span><span class="s3">'text'</span><span class="s1">) {</span>
      <span class="s1">prev.value += tok.value</span><span class="s2">;</span>
      <span class="s1">prev.output = (prev.output || </span><span class="s3">''</span><span class="s1">) + tok.value</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>

    <span class="s1">tok.prev = prev</span><span class="s2">;</span>
    <span class="s1">tokens.push(tok)</span><span class="s2">;</span>
    <span class="s1">prev = tok</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">extglobOpen = (type</span><span class="s2">, </span><span class="s1">value) =&gt; {</span>
    <span class="s2">const </span><span class="s1">token = { ...EXTGLOB_CHARS[value]</span><span class="s2">, </span><span class="s1">conditions: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">inner: </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">;</span>

    <span class="s1">token.prev = prev</span><span class="s2">;</span>
    <span class="s1">token.parens = state.parens</span><span class="s2">;</span>
    <span class="s1">token.output = state.output</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">output = (opts.capture ? </span><span class="s3">'(' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + token.open</span><span class="s2">;</span>

    <span class="s1">increment(</span><span class="s3">'parens'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">push({ type</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: state.output ? </span><span class="s3">'' </span><span class="s1">: ONE_CHAR })</span><span class="s2">;</span>
    <span class="s1">push({ type: </span><span class="s3">'paren'</span><span class="s2">, </span><span class="s1">extglob: </span><span class="s2">true, </span><span class="s1">value: advance()</span><span class="s2">, </span><span class="s1">output })</span><span class="s2">;</span>
    <span class="s1">extglobs.push(token)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">extglobClose = token =&gt; {</span>
    <span class="s2">let </span><span class="s1">output = token.close + (opts.capture ? </span><span class="s3">')' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">rest</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(token.type === </span><span class="s3">'negate'</span><span class="s1">) {</span>
      <span class="s2">let </span><span class="s1">extglobStar = star</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(token.inner &amp;&amp; token.inner.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; token.inner.includes(</span><span class="s3">'/'</span><span class="s1">)) {</span>
        <span class="s1">extglobStar = globstar(opts)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(extglobStar !== star || eos() || </span><span class="s4">/^\)+$/</span><span class="s1">.test(remaining())) {</span>
        <span class="s1">output = token.close = </span><span class="s3">`)$))</span><span class="s1">${extglobStar}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(token.inner.includes(</span><span class="s3">'*'</span><span class="s1">) &amp;&amp; (rest = remaining()) &amp;&amp; </span><span class="s4">/^\.[^\\/.]+$/</span><span class="s1">.test(rest)) {</span>
        <span class="s0">// Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.</span>
        <span class="s0">// In this case, we need to parse the string and use it in the output of the original pattern.</span>
        <span class="s0">// Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.</span>
        <span class="s0">//</span>
        <span class="s0">// Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.</span>
        <span class="s2">const </span><span class="s1">expression = parse$2(rest</span><span class="s2">, </span><span class="s1">{ ...options</span><span class="s2">, </span><span class="s1">fastpaths: </span><span class="s2">false </span><span class="s1">}).output</span><span class="s2">;</span>

        <span class="s1">output = token.close = </span><span class="s3">`)</span><span class="s1">${expression}</span><span class="s3">)</span><span class="s1">${extglobStar}</span><span class="s3">)`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(token.prev.type === </span><span class="s3">'bos'</span><span class="s1">) {</span>
        <span class="s1">state.negatedExtglob = </span><span class="s2">true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">push({ type: </span><span class="s3">'paren'</span><span class="s2">, </span><span class="s1">extglob: </span><span class="s2">true, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output })</span><span class="s2">;</span>
    <span class="s1">decrement(</span><span class="s3">'parens'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s5">/**</span>
   <span class="s5">* Fast paths</span>
   <span class="s5">*/</span>

  <span class="s2">if </span><span class="s1">(opts.fastpaths !== </span><span class="s2">false </span><span class="s1">&amp;&amp; !</span><span class="s4">/(^[*!]|[/()[\]{}&quot;])/</span><span class="s1">.test(input)) {</span>
    <span class="s2">let </span><span class="s1">backslashes = </span><span class="s2">false;</span>

    <span class="s2">let </span><span class="s1">output = input.replace(REGEX_SPECIAL_CHARS_BACKREF</span><span class="s2">, </span><span class="s1">(m</span><span class="s2">, </span><span class="s1">esc</span><span class="s2">, </span><span class="s1">chars</span><span class="s2">, </span><span class="s1">first</span><span class="s2">, </span><span class="s1">rest</span><span class="s2">, </span><span class="s1">index) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(first === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) {</span>
        <span class="s1">backslashes = </span><span class="s2">true;</span>
        <span class="s2">return </span><span class="s1">m</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(first === </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(esc) {</span>
          <span class="s2">return </span><span class="s1">esc + first + (rest ? QMARK.repeat(rest.length) : </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(index === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">qmarkNoDot + (rest ? QMARK.repeat(rest.length) : </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">QMARK.repeat(chars.length)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(first === </span><span class="s3">'.'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">DOT_LITERAL.repeat(chars.length)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(first === </span><span class="s3">'*'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(esc) {</span>
          <span class="s2">return </span><span class="s1">esc + first + (rest ? star : </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">star</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">esc ? m : </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${m}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(backslashes === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.unescape === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">output = output.replace(</span><span class="s4">/\\/g</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">output = output.replace(</span><span class="s4">/\\+/g</span><span class="s2">, </span><span class="s1">m =&gt; {</span>
          <span class="s2">return </span><span class="s1">m.length % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'</span><span class="s2">\\\\</span><span class="s3">' </span><span class="s1">: (m ? </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(output === input &amp;&amp; opts.contains === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">state.output = input</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">state.output = utils$1.wrapOutput(output</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Tokenize input until we reach end-of-string</span>
   <span class="s5">*/</span>

  <span class="s2">while </span><span class="s1">(!eos()) {</span>
    <span class="s1">value = advance()</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'</span><span class="s2">\u0000</span><span class="s3">'</span><span class="s1">) {</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Escaped characters</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">next = peek()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(next === </span><span class="s3">'/' </span><span class="s1">&amp;&amp; opts.bash !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(next === </span><span class="s3">'.' </span><span class="s1">|| next === </span><span class="s3">';'</span><span class="s1">) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!next) {</span>
        <span class="s1">value += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">;</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s0">// collapse slashes to reduce potential for exploits</span>
      <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^\\+/</span><span class="s1">.exec(remaining())</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">slashes = </span><span class="s4">0</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(match &amp;&amp; match[</span><span class="s4">0</span><span class="s1">].length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s1">slashes = match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
        <span class="s1">state.index += slashes</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(slashes % </span><span class="s4">2 </span><span class="s1">!== </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">value += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(opts.unescape === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">value = advance()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">value += advance()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(state.brackets === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* If we're inside a regex character class, continue</span>
     <span class="s5">* until we reach the closing bracket.</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(state.brackets &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; (value !== </span><span class="s3">']' </span><span class="s1">|| prev.value === </span><span class="s3">'[' </span><span class="s1">|| prev.value === </span><span class="s3">'[^'</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(opts.posix !== </span><span class="s2">false </span><span class="s1">&amp;&amp; value === </span><span class="s3">':'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">inner = prev.value.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(inner.includes(</span><span class="s3">'['</span><span class="s1">)) {</span>
          <span class="s1">prev.posix = </span><span class="s2">true;</span>

          <span class="s2">if </span><span class="s1">(inner.includes(</span><span class="s3">':'</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">idx = prev.value.lastIndexOf(</span><span class="s3">'['</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">pre = prev.value.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">idx)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">rest = prev.value.slice(idx + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">posix = POSIX_REGEX_SOURCE[rest]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(posix) {</span>
              <span class="s1">prev.value = pre + posix</span><span class="s2">;</span>
              <span class="s1">state.backtrack = </span><span class="s2">true;</span>
              <span class="s1">advance()</span><span class="s2">;</span>

              <span class="s2">if </span><span class="s1">(!bos.output &amp;&amp; tokens.indexOf(prev) === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">bos.output = ONE_CHAR</span><span class="s2">;</span>
              <span class="s1">}</span>
              <span class="s2">continue;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">((value === </span><span class="s3">'[' </span><span class="s1">&amp;&amp; peek() !== </span><span class="s3">':'</span><span class="s1">) || (value === </span><span class="s3">'-' </span><span class="s1">&amp;&amp; peek() === </span><span class="s3">']'</span><span class="s1">)) {</span>
        <span class="s1">value = </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(value === </span><span class="s3">']' </span><span class="s1">&amp;&amp; (prev.value === </span><span class="s3">'[' </span><span class="s1">|| prev.value === </span><span class="s3">'[^'</span><span class="s1">)) {</span>
        <span class="s1">value = </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(opts.posix === </span><span class="s2">true </span><span class="s1">&amp;&amp; value === </span><span class="s3">'!' </span><span class="s1">&amp;&amp; prev.value === </span><span class="s3">'['</span><span class="s1">) {</span>
        <span class="s1">value = </span><span class="s3">'^'</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">prev.value += value</span><span class="s2">;</span>
      <span class="s1">append({ value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* If we're inside a quoted string, continue</span>
     <span class="s5">* until we reach the closing double quote.</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(state.quotes === </span><span class="s4">1 </span><span class="s1">&amp;&amp; value !== </span><span class="s3">'&quot;'</span><span class="s1">) {</span>
      <span class="s1">value = utils$1.escapeRegex(value)</span><span class="s2">;</span>
      <span class="s1">prev.value += value</span><span class="s2">;</span>
      <span class="s1">append({ value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Double quotes</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'&quot;'</span><span class="s1">) {</span>
      <span class="s1">state.quotes = state.quotes === </span><span class="s4">1 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(opts.keepQuotes === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Parentheses</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'('</span><span class="s1">) {</span>
      <span class="s1">increment(</span><span class="s3">'parens'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">push({ type: </span><span class="s3">'paren'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">')'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(state.parens === </span><span class="s4">0 </span><span class="s1">&amp;&amp; opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'opening'</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">const </span><span class="s1">extglob = extglobs[extglobs.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(extglob &amp;&amp; state.parens === extglob.parens + </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">extglobClose(extglobs.pop())</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'paren'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: state.parens ? </span><span class="s3">')' </span><span class="s1">: </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">)' </span><span class="s1">})</span><span class="s2">;</span>
      <span class="s1">decrement(</span><span class="s3">'parens'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Square brackets</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'['</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.nobracket === </span><span class="s2">true </span><span class="s1">|| !remaining().includes(</span><span class="s3">']'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(opts.nobracket !== </span><span class="s2">true </span><span class="s1">&amp;&amp; opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'closing'</span><span class="s2">, </span><span class="s3">']'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">value = </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">increment(</span><span class="s3">'brackets'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'bracket'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">']'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.nobracket === </span><span class="s2">true </span><span class="s1">|| (prev &amp;&amp; prev.type === </span><span class="s3">'bracket' </span><span class="s1">&amp;&amp; prev.value.length === </span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">` </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(state.brackets === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'opening'</span><span class="s2">, </span><span class="s3">'['</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">` </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">decrement(</span><span class="s3">'brackets'</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">const </span><span class="s1">prevValue = prev.value.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(prev.posix !== </span><span class="s2">true </span><span class="s1">&amp;&amp; prevValue[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'^' </span><span class="s1">&amp;&amp; !prevValue.includes(</span><span class="s3">'/'</span><span class="s1">)) {</span>
        <span class="s1">value = </span><span class="s3">`/</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">prev.value += value</span><span class="s2">;</span>
      <span class="s1">append({ value })</span><span class="s2">;</span>

      <span class="s0">// when literal brackets are explicitly disabled</span>
      <span class="s0">// assume we should match with a regex character class</span>
      <span class="s2">if </span><span class="s1">(opts.literalBrackets === </span><span class="s2">false </span><span class="s1">|| utils$1.hasRegexChars(prevValue)) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">const </span><span class="s1">escaped = utils$1.escapeRegex(prev.value)</span><span class="s2">;</span>
      <span class="s1">state.output = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-prev.value.length)</span><span class="s2">;</span>

      <span class="s0">// when literal brackets are explicitly enabled</span>
      <span class="s0">// assume we should escape the brackets to match literal characters</span>
      <span class="s2">if </span><span class="s1">(opts.literalBrackets === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">state.output += escaped</span><span class="s2">;</span>
        <span class="s1">prev.value = escaped</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s0">// when the user specifies nothing, try to match both</span>
      <span class="s1">prev.value = </span><span class="s3">`(</span><span class="s1">${capture}${escaped}</span><span class="s3">|</span><span class="s1">${prev.value}</span><span class="s3">)`</span><span class="s2">;</span>
      <span class="s1">state.output += prev.value</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Braces</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'{' </span><span class="s1">&amp;&amp; opts.nobrace !== </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">increment(</span><span class="s3">'braces'</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">const </span><span class="s1">open = {</span>
        <span class="s1">type: </span><span class="s3">'brace'</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">output: </span><span class="s3">'('</span><span class="s2">,</span>
        <span class="s1">outputIndex: state.output.length</span><span class="s2">,</span>
        <span class="s1">tokensIndex: state.tokens.length</span>
      <span class="s1">}</span><span class="s2">;</span>

      <span class="s1">braces.push(open)</span><span class="s2">;</span>
      <span class="s1">push(open)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'}'</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">brace = braces[braces.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(opts.nobrace === </span><span class="s2">true </span><span class="s1">|| !brace) {</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: value })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">let </span><span class="s1">output = </span><span class="s3">')'</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(brace.dots === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">arr = tokens.slice()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">range = []</span><span class="s2">;</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = arr.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
          <span class="s1">tokens.pop()</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(arr[i].type === </span><span class="s3">'brace'</span><span class="s1">) {</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(arr[i].type !== </span><span class="s3">'dots'</span><span class="s1">) {</span>
            <span class="s1">range.unshift(arr[i].value)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">output = expandRange(range</span><span class="s2">, </span><span class="s1">opts)</span><span class="s2">;</span>
        <span class="s1">state.backtrack = </span><span class="s2">true;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(brace.comma !== </span><span class="s2">true </span><span class="s1">&amp;&amp; brace.dots !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">out = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">brace.outputIndex)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">toks = state.tokens.slice(brace.tokensIndex)</span><span class="s2">;</span>
        <span class="s1">brace.value = brace.output = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">{'</span><span class="s2">;</span>
        <span class="s1">value = output = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">}'</span><span class="s2">;</span>
        <span class="s1">state.output = out</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">t of toks) {</span>
          <span class="s1">state.output += (t.output || t.value)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'brace'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output })</span><span class="s2">;</span>
      <span class="s1">decrement(</span><span class="s3">'braces'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">braces.pop()</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Pipes</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'|'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(extglobs.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">extglobs[extglobs.length - </span><span class="s4">1</span><span class="s1">].conditions++</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Commas</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">','</span><span class="s1">) {</span>
      <span class="s2">let </span><span class="s1">output = value</span><span class="s2">;</span>

      <span class="s2">const </span><span class="s1">brace = braces[braces.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(brace &amp;&amp; stack[stack.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'braces'</span><span class="s1">) {</span>
        <span class="s1">brace.comma = </span><span class="s2">true;</span>
        <span class="s1">output = </span><span class="s3">'|'</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'comma'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Slashes</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'/'</span><span class="s1">) {</span>
      <span class="s0">// if the beginning of the glob is &quot;./&quot;, advance the start</span>
      <span class="s0">// to the current index, and don't add the &quot;./&quot; characters</span>
      <span class="s0">// to the state. This greatly simplifies lookbehinds when</span>
      <span class="s0">// checking for BOS characters like &quot;!&quot; and &quot;.&quot; (not &quot;./&quot;)</span>
      <span class="s2">if </span><span class="s1">(prev.type === </span><span class="s3">'dot' </span><span class="s1">&amp;&amp; state.index === state.start + </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">state.start = state.index + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">state.consumed = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s1">state.output = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s1">tokens.pop()</span><span class="s2">;</span>
        <span class="s1">prev = bos</span><span class="s2">; </span><span class="s0">// reset &quot;prev&quot; to the first token</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'slash'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: SLASH_LITERAL })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Dots</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'.'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(state.braces &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; prev.type === </span><span class="s3">'dot'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(prev.value === </span><span class="s3">'.'</span><span class="s1">) prev.output = DOT_LITERAL</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">brace = braces[braces.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">prev.type = </span><span class="s3">'dots'</span><span class="s2">;</span>
        <span class="s1">prev.output += value</span><span class="s2">;</span>
        <span class="s1">prev.value += value</span><span class="s2">;</span>
        <span class="s1">brace.dots = </span><span class="s2">true;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">((state.braces + state.parens) === </span><span class="s4">0 </span><span class="s1">&amp;&amp; prev.type !== </span><span class="s3">'bos' </span><span class="s1">&amp;&amp; prev.type !== </span><span class="s3">'slash'</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: DOT_LITERAL })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'dot'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: DOT_LITERAL })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Question marks</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'?'</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">isGroup = prev &amp;&amp; prev.value === </span><span class="s3">'('</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!isGroup &amp;&amp; opts.noextglob !== </span><span class="s2">true </span><span class="s1">&amp;&amp; peek() === </span><span class="s3">'(' </span><span class="s1">&amp;&amp; peek(</span><span class="s4">2</span><span class="s1">) !== </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s1">extglobOpen(</span><span class="s3">'qmark'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(prev &amp;&amp; prev.type === </span><span class="s3">'paren'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">next = peek()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">output = value</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(next === </span><span class="s3">'&lt;' </span><span class="s1">&amp;&amp; !utils$1.supportsLookbehinds()) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Node.js v10 or higher is required for regex lookbehinds'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">((prev.value === </span><span class="s3">'(' </span><span class="s1">&amp;&amp; !</span><span class="s4">/[!=&lt;:]/</span><span class="s1">.test(next)) || (next === </span><span class="s3">'&lt;' </span><span class="s1">&amp;&amp; !</span><span class="s4">/&lt;([!=]|\w+&gt;)/</span><span class="s1">.test(remaining()))) {</span>
          <span class="s1">output = </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(opts.dot !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (prev.type === </span><span class="s3">'slash' </span><span class="s1">|| prev.type === </span><span class="s3">'bos'</span><span class="s1">)) {</span>
        <span class="s1">push({ type: </span><span class="s3">'qmark'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: QMARK_NO_DOT })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'qmark'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: QMARK })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Exclamation</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'!'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.noextglob !== </span><span class="s2">true </span><span class="s1">&amp;&amp; peek() === </span><span class="s3">'('</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(peek(</span><span class="s4">2</span><span class="s1">) !== </span><span class="s3">'?' </span><span class="s1">|| !</span><span class="s4">/[!=&lt;:]/</span><span class="s1">.test(peek(</span><span class="s4">3</span><span class="s1">))) {</span>
          <span class="s1">extglobOpen(</span><span class="s3">'negate'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(opts.nonegate !== </span><span class="s2">true </span><span class="s1">&amp;&amp; state.index === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">negate()</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Plus</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'+'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.noextglob !== </span><span class="s2">true </span><span class="s1">&amp;&amp; peek() === </span><span class="s3">'(' </span><span class="s1">&amp;&amp; peek(</span><span class="s4">2</span><span class="s1">) !== </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s1">extglobOpen(</span><span class="s3">'plus'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">((prev &amp;&amp; prev.value === </span><span class="s3">'('</span><span class="s1">) || opts.regex === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'plus'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: PLUS_LITERAL })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">((prev &amp;&amp; (prev.type === </span><span class="s3">'bracket' </span><span class="s1">|| prev.type === </span><span class="s3">'paren' </span><span class="s1">|| prev.type === </span><span class="s3">'brace'</span><span class="s1">)) || state.parens &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'plus'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'plus'</span><span class="s2">, </span><span class="s1">value: PLUS_LITERAL })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Plain text</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'@'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.noextglob !== </span><span class="s2">true </span><span class="s1">&amp;&amp; peek() === </span><span class="s3">'(' </span><span class="s1">&amp;&amp; peek(</span><span class="s4">2</span><span class="s1">) !== </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s1">push({ type: </span><span class="s3">'at'</span><span class="s2">, </span><span class="s1">extglob: </span><span class="s2">true, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Plain text</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(value !== </span><span class="s3">'*'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'$' </span><span class="s1">|| value === </span><span class="s3">'^'</span><span class="s1">) {</span>
        <span class="s1">value = </span><span class="s3">`</span><span class="s2">\\</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">const </span><span class="s1">match = REGEX_NON_SPECIAL_CHARS.exec(remaining())</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(match) {</span>
        <span class="s1">value += match[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">state.index += match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">push({ type: </span><span class="s3">'text'</span><span class="s2">, </span><span class="s1">value })</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s5">/**</span>
     <span class="s5">* Stars</span>
     <span class="s5">*/</span>

    <span class="s2">if </span><span class="s1">(prev &amp;&amp; (prev.type === </span><span class="s3">'globstar' </span><span class="s1">|| prev.star === </span><span class="s2">true</span><span class="s1">)) {</span>
      <span class="s1">prev.type = </span><span class="s3">'star'</span><span class="s2">;</span>
      <span class="s1">prev.star = </span><span class="s2">true;</span>
      <span class="s1">prev.value += value</span><span class="s2">;</span>
      <span class="s1">prev.output = star</span><span class="s2">;</span>
      <span class="s1">state.backtrack = </span><span class="s2">true;</span>
      <span class="s1">state.globstar = </span><span class="s2">true;</span>
      <span class="s1">consume(value)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">let </span><span class="s1">rest = remaining()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(opts.noextglob !== </span><span class="s2">true </span><span class="s1">&amp;&amp; </span><span class="s4">/^\([^?]/</span><span class="s1">.test(rest)) {</span>
      <span class="s1">extglobOpen(</span><span class="s3">'star'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(prev.type === </span><span class="s3">'star'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(opts.noglobstar === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">consume(value)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">const </span><span class="s1">prior = prev.prev</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">before = prior.prev</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">isStart = prior.type === </span><span class="s3">'slash' </span><span class="s1">|| prior.type === </span><span class="s3">'bos'</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">afterStar = before &amp;&amp; (before.type === </span><span class="s3">'star' </span><span class="s1">|| before.type === </span><span class="s3">'globstar'</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(opts.bash === </span><span class="s2">true </span><span class="s1">&amp;&amp; (!isStart || (rest[</span><span class="s4">0</span><span class="s1">] &amp;&amp; rest[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'/'</span><span class="s1">))) {</span>
        <span class="s1">push({ type: </span><span class="s3">'star'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">const </span><span class="s1">isBrace = state.braces &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; (prior.type === </span><span class="s3">'comma' </span><span class="s1">|| prior.type === </span><span class="s3">'brace'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">isExtglob = extglobs.length &amp;&amp; (prior.type === </span><span class="s3">'pipe' </span><span class="s1">|| prior.type === </span><span class="s3">'paren'</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!isStart &amp;&amp; prior.type !== </span><span class="s3">'paren' </span><span class="s1">&amp;&amp; !isBrace &amp;&amp; !isExtglob) {</span>
        <span class="s1">push({ type: </span><span class="s3">'star'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s0">// strip consecutive `/**/`</span>
      <span class="s2">while </span><span class="s1">(rest.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">) === </span><span class="s3">'/**'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">after = input[state.index + </span><span class="s4">4</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(after &amp;&amp; after !== </span><span class="s3">'/'</span><span class="s1">) {</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">rest = rest.slice(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">consume(</span><span class="s3">'/**'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(prior.type === </span><span class="s3">'bos' </span><span class="s1">&amp;&amp; eos()) {</span>
        <span class="s1">prev.type = </span><span class="s3">'globstar'</span><span class="s2">;</span>
        <span class="s1">prev.value += value</span><span class="s2">;</span>
        <span class="s1">prev.output = globstar(opts)</span><span class="s2">;</span>
        <span class="s1">state.output = prev.output</span><span class="s2">;</span>
        <span class="s1">state.globstar = </span><span class="s2">true;</span>
        <span class="s1">consume(value)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(prior.type === </span><span class="s3">'slash' </span><span class="s1">&amp;&amp; prior.prev.type !== </span><span class="s3">'bos' </span><span class="s1">&amp;&amp; !afterStar &amp;&amp; eos()) {</span>
        <span class="s1">state.output = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-(prior.output + prev.output).length)</span><span class="s2">;</span>
        <span class="s1">prior.output = </span><span class="s3">`(?:</span><span class="s1">${prior.output}</span><span class="s3">`</span><span class="s2">;</span>

        <span class="s1">prev.type = </span><span class="s3">'globstar'</span><span class="s2">;</span>
        <span class="s1">prev.output = globstar(opts) + (opts.strictSlashes ? </span><span class="s3">')' </span><span class="s1">: </span><span class="s3">'|$)'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">prev.value += value</span><span class="s2">;</span>
        <span class="s1">state.globstar = </span><span class="s2">true;</span>
        <span class="s1">state.output += prior.output + prev.output</span><span class="s2">;</span>
        <span class="s1">consume(value)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(prior.type === </span><span class="s3">'slash' </span><span class="s1">&amp;&amp; prior.prev.type !== </span><span class="s3">'bos' </span><span class="s1">&amp;&amp; rest[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">end = rest[</span><span class="s4">1</span><span class="s1">] !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'|$' </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>

        <span class="s1">state.output = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-(prior.output + prev.output).length)</span><span class="s2">;</span>
        <span class="s1">prior.output = </span><span class="s3">`(?:</span><span class="s1">${prior.output}</span><span class="s3">`</span><span class="s2">;</span>

        <span class="s1">prev.type = </span><span class="s3">'globstar'</span><span class="s2">;</span>
        <span class="s1">prev.output = </span><span class="s3">`</span><span class="s1">${globstar(opts)}${SLASH_LITERAL}</span><span class="s3">|</span><span class="s1">${SLASH_LITERAL}${end}</span><span class="s3">)`</span><span class="s2">;</span>
        <span class="s1">prev.value += value</span><span class="s2">;</span>

        <span class="s1">state.output += prior.output + prev.output</span><span class="s2">;</span>
        <span class="s1">state.globstar = </span><span class="s2">true;</span>

        <span class="s1">consume(value + advance())</span><span class="s2">;</span>

        <span class="s1">push({ type: </span><span class="s3">'slash'</span><span class="s2">, </span><span class="s1">value: </span><span class="s3">'/'</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(prior.type === </span><span class="s3">'bos' </span><span class="s1">&amp;&amp; rest[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
        <span class="s1">prev.type = </span><span class="s3">'globstar'</span><span class="s2">;</span>
        <span class="s1">prev.value += value</span><span class="s2">;</span>
        <span class="s1">prev.output = </span><span class="s3">`(?:^|</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">|</span><span class="s1">${globstar(opts)}${SLASH_LITERAL}</span><span class="s3">)`</span><span class="s2">;</span>
        <span class="s1">state.output = prev.output</span><span class="s2">;</span>
        <span class="s1">state.globstar = </span><span class="s2">true;</span>
        <span class="s1">consume(value + advance())</span><span class="s2">;</span>
        <span class="s1">push({ type: </span><span class="s3">'slash'</span><span class="s2">, </span><span class="s1">value: </span><span class="s3">'/'</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>

      <span class="s0">// remove single star from output</span>
      <span class="s1">state.output = state.output.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-prev.output.length)</span><span class="s2">;</span>

      <span class="s0">// reset previous token to globstar</span>
      <span class="s1">prev.type = </span><span class="s3">'globstar'</span><span class="s2">;</span>
      <span class="s1">prev.output = globstar(opts)</span><span class="s2">;</span>
      <span class="s1">prev.value += value</span><span class="s2">;</span>

      <span class="s0">// reset output with globstar</span>
      <span class="s1">state.output += prev.output</span><span class="s2">;</span>
      <span class="s1">state.globstar = </span><span class="s2">true;</span>
      <span class="s1">consume(value)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">const </span><span class="s1">token = { type: </span><span class="s3">'star'</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">output: star }</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(opts.bash === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">token.output = </span><span class="s3">'.*?'</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(prev.type === </span><span class="s3">'bos' </span><span class="s1">|| prev.type === </span><span class="s3">'slash'</span><span class="s1">) {</span>
        <span class="s1">token.output = nodot + token.output</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">push(token)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(prev &amp;&amp; (prev.type === </span><span class="s3">'bracket' </span><span class="s1">|| prev.type === </span><span class="s3">'paren'</span><span class="s1">) &amp;&amp; opts.regex === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">token.output = value</span><span class="s2">;</span>
      <span class="s1">push(token)</span><span class="s2">;</span>
      <span class="s2">continue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(state.index === state.start || prev.type === </span><span class="s3">'slash' </span><span class="s1">|| prev.type === </span><span class="s3">'dot'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(prev.type === </span><span class="s3">'dot'</span><span class="s1">) {</span>
        <span class="s1">state.output += NO_DOT_SLASH</span><span class="s2">;</span>
        <span class="s1">prev.output += NO_DOT_SLASH</span><span class="s2">;</span>

      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(opts.dot === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">state.output += NO_DOTS_SLASH</span><span class="s2">;</span>
        <span class="s1">prev.output += NO_DOTS_SLASH</span><span class="s2">;</span>

      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.output += nodot</span><span class="s2">;</span>
        <span class="s1">prev.output += nodot</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(peek() !== </span><span class="s3">'*'</span><span class="s1">) {</span>
        <span class="s1">state.output += ONE_CHAR</span><span class="s2">;</span>
        <span class="s1">prev.output += ONE_CHAR</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">push(token)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">while </span><span class="s1">(state.brackets &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'closing'</span><span class="s2">, </span><span class="s3">']'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">state.output = utils$1.escapeLast(state.output</span><span class="s2">, </span><span class="s3">'['</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">decrement(</span><span class="s3">'brackets'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">while </span><span class="s1">(state.parens &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'closing'</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">state.output = utils$1.escapeLast(state.output</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">decrement(</span><span class="s3">'parens'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">while </span><span class="s1">(state.braces &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(opts.strictBrackets === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">SyntaxError(syntaxError(</span><span class="s3">'closing'</span><span class="s2">, </span><span class="s3">'}'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">state.output = utils$1.escapeLast(state.output</span><span class="s2">, </span><span class="s3">'{'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">decrement(</span><span class="s3">'braces'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(opts.strictSlashes !== </span><span class="s2">true </span><span class="s1">&amp;&amp; (prev.type === </span><span class="s3">'star' </span><span class="s1">|| prev.type === </span><span class="s3">'bracket'</span><span class="s1">)) {</span>
    <span class="s1">push({ type: </span><span class="s3">'maybe_slash'</span><span class="s2">, </span><span class="s1">value: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">output: </span><span class="s3">`</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">?` </span><span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// rebuild the output if we had to backtrack at any point</span>
  <span class="s2">if </span><span class="s1">(state.backtrack === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">state.output = </span><span class="s3">''</span><span class="s2">;</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">token of state.tokens) {</span>
      <span class="s1">state.output += token.output != </span><span class="s2">null </span><span class="s1">? token.output : token.value</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(token.suffix) {</span>
        <span class="s1">state.output += token.suffix</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Fast paths for creating regular expressions for common glob patterns.</span>
 <span class="s5">* This can significantly speed up processing and has very little downside</span>
 <span class="s5">* impact when none of the fast paths match.</span>
 <span class="s5">*/</span>

<span class="s1">parse$2.fastpaths = (input</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">const </span><span class="s1">opts = { ...options }</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">max = </span><span class="s2">typeof </span><span class="s1">opts.maxLength === </span><span class="s3">'number' </span><span class="s1">? Math.min(MAX_LENGTH</span><span class="s2">, </span><span class="s1">opts.maxLength) : MAX_LENGTH</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">len = input.length</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(len &gt; max) {</span>
    <span class="s2">throw new </span><span class="s1">SyntaxError(</span><span class="s3">`Input length: </span><span class="s1">${len}</span><span class="s3">, exceeds maximum allowed length: </span><span class="s1">${max}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">input = REPLACEMENTS[input] || input</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">win32 = utils$1.isWindows(options)</span><span class="s2">;</span>

  <span class="s0">// create constants based on platform, for windows or posix</span>
  <span class="s2">const </span><span class="s1">{</span>
    <span class="s1">DOT_LITERAL</span><span class="s2">,</span>
    <span class="s1">SLASH_LITERAL</span><span class="s2">,</span>
    <span class="s1">ONE_CHAR</span><span class="s2">,</span>
    <span class="s1">DOTS_SLASH</span><span class="s2">,</span>
    <span class="s1">NO_DOT</span><span class="s2">,</span>
    <span class="s1">NO_DOTS</span><span class="s2">,</span>
    <span class="s1">NO_DOTS_SLASH</span><span class="s2">,</span>
    <span class="s1">STAR</span><span class="s2">,</span>
    <span class="s1">START_ANCHOR</span>
  <span class="s1">} = constants$1.globChars(win32)</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">nodot = opts.dot ? NO_DOTS : NO_DOT</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">capture = opts.capture ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'?:'</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">state = { negated: </span><span class="s2">false, </span><span class="s1">prefix: </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">star = opts.bash === </span><span class="s2">true </span><span class="s1">? </span><span class="s3">'.*?' </span><span class="s1">: STAR</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(opts.capture) {</span>
    <span class="s1">star = </span><span class="s3">`(</span><span class="s1">${star}</span><span class="s3">)`</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">globstar = opts =&gt; {</span>
    <span class="s2">if </span><span class="s1">(opts.noglobstar === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">return </span><span class="s1">star</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s3">`(</span><span class="s1">${capture}</span><span class="s3">(?:(?!</span><span class="s1">${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}</span><span class="s3">).)*?)`</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">create = str =&gt; {</span>
    <span class="s2">switch </span><span class="s1">(str) {</span>
      <span class="s2">case </span><span class="s3">'*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${nodot}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'.*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'*.*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'*/*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'**'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">nodot + globstar(opts)</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'**/*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`(?:</span><span class="s1">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s3">)?</span><span class="s1">${slashDot}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'**/*.*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`(?:</span><span class="s1">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s3">)?</span><span class="s1">${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">case </span><span class="s3">'**/.*'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">`(?:</span><span class="s1">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s3">)?</span><span class="s1">${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s3">`</span><span class="s2">;</span>

      <span class="s2">default</span><span class="s1">: {</span>
        <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^(.*?)\.(\w+)$/</span><span class="s1">.exec(str)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!match) </span><span class="s2">return;</span>

        <span class="s2">const </span><span class="s1">source = create(match[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!source) </span><span class="s2">return;</span>

        <span class="s2">return </span><span class="s1">source + DOT_LITERAL + match[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">output = utils$1.removePrefix(input</span><span class="s2">, </span><span class="s1">state)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">source = create(output)</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(source &amp;&amp; opts.strictSlashes !== </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">source += </span><span class="s3">`</span><span class="s1">${SLASH_LITERAL}</span><span class="s3">?`</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">source</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">parse_1 = parse$2</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">path = require$$0$1</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">scan = scan_1</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">parse$1 = parse_1</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">utils = utils$3</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">constants = constants$2</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isObject = val =&gt; val &amp;&amp; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; !Array.isArray(val)</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Creates a matcher function from one or more glob patterns. The</span>
 <span class="s5">* returned function takes a string to match as its first argument,</span>
 <span class="s5">* and returns true if the string is a match. The returned matcher</span>
 <span class="s5">* function also takes a boolean as the second argument that, when true,</span>
 <span class="s5">* returns an object with additional information.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch(glob[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* const isMatch = picomatch('*.!(*a)');</span>
 <span class="s5">* console.log(isMatch('a.a')); //=&gt; false</span>
 <span class="s5">* console.log(isMatch('a.b')); //=&gt; true</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@name </span><span class="s5">picomatch</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String|Array} `globs` One or more glob patterns.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object=} `options`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Function=} Returns a matcher function.</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s2">const </span><span class="s1">picomatch = (glob</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(glob)) {</span>
    <span class="s2">const </span><span class="s1">fns = glob.map(input =&gt; picomatch(input</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">returnState))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">arrayMatcher = str =&gt; {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">isMatch of fns) {</span>
        <span class="s2">const </span><span class="s1">state = isMatch(str)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(state) </span><span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">arrayMatcher</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">isState = isObject(glob) &amp;&amp; glob.tokens &amp;&amp; glob.input</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(glob === </span><span class="s3">'' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">glob !== </span><span class="s3">'string' </span><span class="s1">&amp;&amp; !isState)) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Expected pattern to be a non-empty string'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">posix = utils.isWindows(options)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">regex = isState</span>
    <span class="s1">? picomatch.compileRe(glob</span><span class="s2">, </span><span class="s1">options)</span>
    <span class="s1">: picomatch.makeRe(glob</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s2">const </span><span class="s1">state = regex.state</span><span class="s2">;</span>
  <span class="s2">delete </span><span class="s1">regex.state</span><span class="s2">;</span>

  <span class="s2">let </span><span class="s1">isIgnored = () =&gt; </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(opts.ignore) {</span>
    <span class="s2">const </span><span class="s1">ignoreOpts = { ...options</span><span class="s2">, </span><span class="s1">ignore: </span><span class="s2">null, </span><span class="s1">onMatch: </span><span class="s2">null, </span><span class="s1">onResult: </span><span class="s2">null </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">isIgnored = picomatch(opts.ignore</span><span class="s2">, </span><span class="s1">ignoreOpts</span><span class="s2">, </span><span class="s1">returnState)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">matcher = (input</span><span class="s2">, </span><span class="s1">returnObject = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ isMatch</span><span class="s2">, </span><span class="s1">match</span><span class="s2">, </span><span class="s1">output } = picomatch.test(input</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ glob</span><span class="s2">, </span><span class="s1">posix })</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = { glob</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">posix</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">match</span><span class="s2">, </span><span class="s1">isMatch }</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onResult === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">opts.onResult(result)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isMatch === </span><span class="s2">false</span><span class="s1">) {</span>
      <span class="s1">result.isMatch = </span><span class="s2">false;</span>
      <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">false;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isIgnored(input)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onIgnore === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">opts.onIgnore(result)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">result.isMatch = </span><span class="s2">false;</span>
      <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">false;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onMatch === </span><span class="s3">'function'</span><span class="s1">) {</span>
      <span class="s1">opts.onMatch(result)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">true;</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(returnState) {</span>
    <span class="s1">matcher.state = state</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">matcher</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Test `input` with the given `regex`. This is used by the main</span>
 <span class="s5">* `picomatch()` function to test the input string.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch.test(input, regex[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));</span>
 <span class="s5">* // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `input` String to test.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExp} `regex`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object} Returns an object with matching info.</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.test = (input</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ glob</span><span class="s2">, </span><span class="s1">posix } = {}) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">input !== </span><span class="s3">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Expected input to be a string'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(input === </span><span class="s3">''</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{ isMatch: </span><span class="s2">false, </span><span class="s1">output: </span><span class="s3">'' </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">format = opts.format || (posix ? utils.toPosixSlashes : </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">match = input === glob</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">output = (match &amp;&amp; format) ? format(input) : input</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">output = format ? format(input) : input</span><span class="s2">;</span>
    <span class="s1">match = output === glob</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">false </span><span class="s1">|| opts.capture === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(opts.matchBase === </span><span class="s2">true </span><span class="s1">|| opts.basename === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">match = picomatch.matchBase(input</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">posix)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">match = regex.exec(output)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">{ isMatch: Boolean(match)</span><span class="s2">, </span><span class="s1">match</span><span class="s2">, </span><span class="s1">output }</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Match the basename of a filepath.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch.matchBase(input, glob[, options]);</span>
 <span class="s5">* console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `input` String to test.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Boolean}</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.matchBase = (input</span><span class="s2">, </span><span class="s1">glob</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">posix = utils.isWindows(options)) =&gt; {</span>
  <span class="s2">const </span><span class="s1">regex = glob </span><span class="s2">instanceof </span><span class="s1">RegExp ? glob : picomatch.makeRe(glob</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">regex.test(path.basename(input))</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Returns true if **any** of the given glob `patterns` match the specified `string`.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch.isMatch(string, patterns[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=&gt; true</span>
 <span class="s5">* console.log(picomatch.isMatch('a.a', 'b.*')); //=&gt; false</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String|Array} str The string to test.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String|Array} patterns One or more glob patterns to use for matching.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} [options] See available [options](#options).</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Boolean} Returns true if any patterns match `str`</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.isMatch = (str</span><span class="s2">, </span><span class="s1">patterns</span><span class="s2">, </span><span class="s1">options) =&gt; picomatch(patterns</span><span class="s2">, </span><span class="s1">options)(str)</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Parse a glob pattern to create the source string for a regular</span>
 <span class="s5">* expression.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* const result = picomatch.parse(pattern[, options]);</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `pattern`</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object} Returns an object with useful properties and output to be used as a regex source string.</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.parse = (pattern</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(pattern)) </span><span class="s2">return </span><span class="s1">pattern.map(p =&gt; picomatch.parse(p</span><span class="s2">, </span><span class="s1">options))</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">parse$1(pattern</span><span class="s2">, </span><span class="s1">{ ...options</span><span class="s2">, </span><span class="s1">fastpaths: </span><span class="s2">false </span><span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Scan a glob pattern to separate the pattern into segments.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch.scan(input[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* const result = picomatch.scan('!./foo/*.js');</span>
 <span class="s5">* console.log(result);</span>
 <span class="s5">* { prefix: '!./',</span>
 <span class="s5">*   input: '!./foo/*.js',</span>
 <span class="s5">*   start: 3,</span>
 <span class="s5">*   base: 'foo',</span>
 <span class="s5">*   glob: '*.js',</span>
 <span class="s5">*   isBrace: false,</span>
 <span class="s5">*   isBracket: false,</span>
 <span class="s5">*   isGlob: true,</span>
 <span class="s5">*   isExtglob: false,</span>
 <span class="s5">*   isGlobstar: false,</span>
 <span class="s5">*   negated: true }</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `input` Glob pattern to scan.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object} Returns an object with</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.scan = (input</span><span class="s2">, </span><span class="s1">options) =&gt; scan(input</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Compile a regular expression from the `state` object returned by the</span>
 <span class="s5">* [parse()](#parse) method.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `state`</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{RegExp}</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.compileRe = (state</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">returnOutput = </span><span class="s2">false, </span><span class="s1">returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(returnOutput === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">state.output</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">prepend = opts.contains ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'^'</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">append = opts.contains ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'$'</span><span class="s2">;</span>

  <span class="s2">let </span><span class="s1">source = </span><span class="s3">`</span><span class="s1">${prepend}</span><span class="s3">(?:</span><span class="s1">${state.output}</span><span class="s3">)</span><span class="s1">${append}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state &amp;&amp; state.negated === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">source = </span><span class="s3">`^(?!</span><span class="s1">${source}</span><span class="s3">).*$`</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">regex = picomatch.toRegex(source</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(returnState === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">regex.state = state</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">regex</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Create a regular expression from a parsed glob pattern.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* const state = picomatch.parse('*.js');</span>
 <span class="s5">* // picomatch.compileRe(state[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* console.log(picomatch.compileRe(state));</span>
 <span class="s5">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `state` The object returned from the `.parse` method.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{RegExp} Returns a regex created from the given pattern.</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.makeRe = (input</span><span class="s2">, </span><span class="s1">options = {}</span><span class="s2">, </span><span class="s1">returnOutput = </span><span class="s2">false, </span><span class="s1">returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!input || </span><span class="s2">typeof </span><span class="s1">input !== </span><span class="s3">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Expected a non-empty string'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">let </span><span class="s1">parsed = { negated: </span><span class="s2">false, </span><span class="s1">fastpaths: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(options.fastpaths !== </span><span class="s2">false </span><span class="s1">&amp;&amp; (input[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'.' </span><span class="s1">|| input[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'*'</span><span class="s1">)) {</span>
    <span class="s1">parsed.output = parse$1.fastpaths(input</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!parsed.output) {</span>
    <span class="s1">parsed = parse$1(input</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">picomatch.compileRe(parsed</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">returnOutput</span><span class="s2">, </span><span class="s1">returnState)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Create a regular expression from the given regex source string.</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const picomatch = require('picomatch');</span>
 <span class="s5">* // picomatch.toRegex(source[, options]);</span>
 <span class="s5">*</span>
 <span class="s5">* const { output } = picomatch.parse('*.js');</span>
 <span class="s5">* console.log(picomatch.toRegex(output));</span>
 <span class="s5">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} `source` Regular expression source string.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} `options`</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{RegExp}</span>
 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.toRegex = (source</span><span class="s2">, </span><span class="s1">options) =&gt; {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">opts = options || {}</span><span class="s2">;</span>
    <span class="s2">return new </span><span class="s1">RegExp(source</span><span class="s2">, </span><span class="s1">opts.flags || (opts.nocase ? </span><span class="s3">'i' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">if </span><span class="s1">(options &amp;&amp; options.debug === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">throw </span><span class="s1">err</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s4">/$^/</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Picomatch constants.</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Object}</span>
 <span class="s5">*/</span>

<span class="s1">picomatch.constants = constants</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Expose &quot;picomatch&quot;</span>
 <span class="s5">*/</span>

<span class="s2">var </span><span class="s1">picomatch_1 = picomatch</span><span class="s2">;</span>

<span class="s1">(</span><span class="s2">function </span><span class="s1">(module) {</span>

	<span class="s1">module.exports = picomatch_1</span><span class="s2">;</span>
<span class="s1">} (picomatch$1))</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">pm = </span><span class="s0">/*@__PURE__*/</span><span class="s1">getDefaultExportFromCjs(picomatchExports)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">extractors = {</span>
    <span class="s1">ArrayPattern(names</span><span class="s2">, </span><span class="s1">param) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of param.elements) {</span>
            <span class="s2">if </span><span class="s1">(element)</span>
                <span class="s1">extractors[element.type](names</span><span class="s2">, </span><span class="s1">element)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">AssignmentPattern(names</span><span class="s2">, </span><span class="s1">param) {</span>
        <span class="s1">extractors[param.left.type](names</span><span class="s2">, </span><span class="s1">param.left)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">Identifier(names</span><span class="s2">, </span><span class="s1">param) {</span>
        <span class="s1">names.push(param.name)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">MemberExpression() { }</span><span class="s2">,</span>
    <span class="s1">ObjectPattern(names</span><span class="s2">, </span><span class="s1">param) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">prop of param.properties) {</span>
            <span class="s0">// @ts-ignore Typescript reports that this is not a valid type</span>
            <span class="s2">if </span><span class="s1">(prop.type === </span><span class="s3">'RestElement'</span><span class="s1">) {</span>
                <span class="s1">extractors.RestElement(names</span><span class="s2">, </span><span class="s1">prop)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">extractors[prop.value.type](names</span><span class="s2">, </span><span class="s1">prop.value)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">RestElement(names</span><span class="s2">, </span><span class="s1">param) {</span>
        <span class="s1">extractors[param.argument.type](names</span><span class="s2">, </span><span class="s1">param.argument)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">extractAssignedNames = </span><span class="s2">function </span><span class="s1">extractAssignedNames(param) {</span>
    <span class="s2">const </span><span class="s1">names = []</span><span class="s2">;</span>
    <span class="s1">extractors[param.type](names</span><span class="s2">, </span><span class="s1">param)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">names</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Helper since Typescript can't detect readonly arrays with Array.isArray</span>
<span class="s2">function </span><span class="s1">isArray$1(arg) {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(arg)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ensureArray$1(thing) {</span>
    <span class="s2">if </span><span class="s1">(isArray$1(thing))</span>
        <span class="s2">return </span><span class="s1">thing</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(thing == </span><span class="s2">null</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[thing]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">normalizePath = </span><span class="s2">function </span><span class="s1">normalizePath(filename) {</span>
    <span class="s2">return </span><span class="s1">filename.split(win32.sep).join(posix.sep)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getMatcherString(id</span><span class="s2">, </span><span class="s1">resolutionBase) {</span>
    <span class="s2">if </span><span class="s1">(resolutionBase === </span><span class="s2">false </span><span class="s1">|| isAbsolute$1(id) || id.startsWith(</span><span class="s3">'*'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">normalizePath(id)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// resolve('') is valid and will default to process.cwd()</span>
    <span class="s2">const </span><span class="s1">basePath = normalizePath(resolve$1(resolutionBase || </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s0">// escape all possible (posix + win) path characters that might interfere with regex</span>
        <span class="s1">.replace(</span><span class="s4">/[-^$*+?.()|[\]{}]/g</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">$&amp;'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">// Note that we use posix.join because:</span>
    <span class="s0">// 1. the basePath has been normalized to use /</span>
    <span class="s0">// 2. the incoming glob (id) matcher, also uses /</span>
    <span class="s0">// otherwise Node will force backslash (\) on windows</span>
    <span class="s2">return </span><span class="s1">posix.join(basePath</span><span class="s2">, </span><span class="s1">normalizePath(id))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createFilter = </span><span class="s2">function </span><span class="s1">createFilter(include</span><span class="s2">, </span><span class="s1">exclude</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">const </span><span class="s1">resolutionBase = options &amp;&amp; options.resolve</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getMatcher = (id) =&gt; id </span><span class="s2">instanceof </span><span class="s1">RegExp</span>
        <span class="s1">? id</span>
        <span class="s1">: {</span>
            <span class="s1">test: (what) =&gt; {</span>
                <span class="s0">// this refactor is a tad overly verbose but makes for easy debugging</span>
                <span class="s2">const </span><span class="s1">pattern = getMatcherString(id</span><span class="s2">, </span><span class="s1">resolutionBase)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">fn = pm(pattern</span><span class="s2">, </span><span class="s1">{ dot: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">result = fn(what)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">includeMatchers = ensureArray$1(include).map(getMatcher)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">excludeMatchers = ensureArray$1(exclude).map(getMatcher)</span><span class="s2">;</span>
    <span class="s2">return function </span><span class="s1">result(id) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">id !== </span><span class="s3">'string'</span><span class="s1">)</span>
            <span class="s2">return false;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">/\0/</span><span class="s1">.test(id))</span>
            <span class="s2">return false;</span>
        <span class="s2">const </span><span class="s1">pathId = normalizePath(id)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; excludeMatchers.length</span><span class="s2">; </span><span class="s1">++i) {</span>
            <span class="s2">const </span><span class="s1">matcher = excludeMatchers[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(matcher.test(pathId))</span>
                <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; includeMatchers.length</span><span class="s2">; </span><span class="s1">++i) {</span>
            <span class="s2">const </span><span class="s1">matcher = includeMatchers[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(matcher.test(pathId))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">!includeMatchers.length</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">reservedWords$1 = </span><span class="s3">'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">builtins = </span><span class="s3">'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">forbiddenIdentifiers = </span><span class="s2">new </span><span class="s1">Set(</span><span class="s3">`</span><span class="s1">${reservedWords$1} ${builtins}</span><span class="s3">`</span><span class="s1">.split(</span><span class="s3">' '</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">forbiddenIdentifiers.add(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">createInclusionContext() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">brokenFlow: </span><span class="s2">false,</span>
        <span class="s1">hasBreak: </span><span class="s2">false,</span>
        <span class="s1">hasContinue: </span><span class="s2">false,</span>
        <span class="s1">includedCallArguments: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
        <span class="s1">includedLabels: </span><span class="s2">new </span><span class="s1">Set()</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createHasEffectsContext() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">accessed: </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">,</span>
        <span class="s1">assigned: </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">,</span>
        <span class="s1">brokenFlow: </span><span class="s2">false,</span>
        <span class="s1">called: </span><span class="s2">new </span><span class="s1">DiscriminatedPathTracker()</span><span class="s2">,</span>
        <span class="s1">hasBreak: </span><span class="s2">false,</span>
        <span class="s1">hasContinue: </span><span class="s2">false,</span>
        <span class="s1">ignore: {</span>
            <span class="s1">breaks: </span><span class="s2">false,</span>
            <span class="s1">continues: </span><span class="s2">false,</span>
            <span class="s1">labels: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
            <span class="s1">returnYield: </span><span class="s2">false,</span>
            <span class="s2">this</span><span class="s1">: </span><span class="s2">false</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">includedLabels: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
        <span class="s1">instantiated: </span><span class="s2">new </span><span class="s1">DiscriminatedPathTracker()</span><span class="s2">,</span>
        <span class="s1">replacedVariableInits: </span><span class="s2">new </span><span class="s1">Map()</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">assembleMemberDescriptions(memberDescriptions</span><span class="s2">, </span><span class="s1">inheritedDescriptions = </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">Object.create(inheritedDescriptions</span><span class="s2">, </span><span class="s1">memberDescriptions)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">UNDEFINED_EXPRESSION = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">UndefinedExpression </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">getLiteralValueAtPath() {</span>
        <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">returnsUnknown = {</span>
    <span class="s1">value: {</span>
        <span class="s1">hasEffectsWhenCalled: </span><span class="s2">null,</span>
        <span class="s1">returns: UNKNOWN_EXPRESSION</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_LITERAL_BOOLEAN = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">UnknownBoolean </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">getMemberReturnExpressionWhenCalled(literalBooleanMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ACCESSED) {</span>
            <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">hasMemberEffectWhenCalled(literalBooleanMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">returnsBoolean = {</span>
    <span class="s1">value: {</span>
        <span class="s1">hasEffectsWhenCalled: </span><span class="s2">null,</span>
        <span class="s1">returns: UNKNOWN_LITERAL_BOOLEAN</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_LITERAL_NUMBER = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">UnknownNumber </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">getMemberReturnExpressionWhenCalled(literalNumberMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ACCESSED) {</span>
            <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">hasMemberEffectWhenCalled(literalNumberMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">returnsNumber = {</span>
    <span class="s1">value: {</span>
        <span class="s1">hasEffectsWhenCalled: </span><span class="s2">null,</span>
        <span class="s1">returns: UNKNOWN_LITERAL_NUMBER</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_LITERAL_STRING = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">UnknownString </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">getMemberReturnExpressionWhenCalled(literalStringMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ACCESSED) {</span>
            <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">hasMemberEffectWhenCalled(literalStringMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">returnsString = {</span>
    <span class="s1">value: {</span>
        <span class="s1">hasEffectsWhenCalled: </span><span class="s2">null,</span>
        <span class="s1">returns: UNKNOWN_LITERAL_STRING</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">stringReplace = {</span>
    <span class="s1">value: {</span>
        <span class="s1">hasEffectsWhenCalled({ args }</span><span class="s2">, </span><span class="s1">context) {</span>
            <span class="s2">const </span><span class="s1">argument1 = args[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">(args.length &lt; </span><span class="s4">3 </span><span class="s1">||</span>
                <span class="s1">(</span><span class="s2">typeof </span><span class="s1">argument1.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">deoptimizeCache() { }</span>
                <span class="s1">}) === </span><span class="s3">'symbol' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_CALL</span><span class="s2">, </span><span class="s1">context)))</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">returns: UNKNOWN_LITERAL_STRING</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">objectMembers = assembleMemberDescriptions({</span>
    <span class="s1">hasOwnProperty: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">isPrototypeOf: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">propertyIsEnumerable: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">toLocaleString: returnsString</span><span class="s2">,</span>
    <span class="s1">toString: returnsString</span><span class="s2">,</span>
    <span class="s1">valueOf: returnsUnknown</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">literalBooleanMembers = assembleMemberDescriptions({</span>
    <span class="s1">valueOf: returnsBoolean</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">objectMembers)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">literalNumberMembers = assembleMemberDescriptions({</span>
    <span class="s1">toExponential: returnsString</span><span class="s2">,</span>
    <span class="s1">toFixed: returnsString</span><span class="s2">,</span>
    <span class="s1">toLocaleString: returnsString</span><span class="s2">,</span>
    <span class="s1">toPrecision: returnsString</span><span class="s2">,</span>
    <span class="s1">valueOf: returnsNumber</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">objectMembers)</span><span class="s2">;</span>
<span class="s5">/**</span>
 <span class="s5">* RegExp are stateful when they have the global or sticky flags set.</span>
 <span class="s5">* But if we actually don't use them, the side effect does not matter.</span>
 <span class="s5">* the check logic in `hasEffectsOnInteractionAtPath`.</span>
 <span class="s5">*/</span>
<span class="s2">const </span><span class="s1">literalRegExpMembers = assembleMemberDescriptions({</span>
    <span class="s1">exec: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">test: returnsBoolean</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">objectMembers)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">literalStringMembers = assembleMemberDescriptions({</span>
    <span class="s1">anchor: returnsString</span><span class="s2">,</span>
    <span class="s1">at: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">big: returnsString</span><span class="s2">,</span>
    <span class="s1">blink: returnsString</span><span class="s2">,</span>
    <span class="s1">bold: returnsString</span><span class="s2">,</span>
    <span class="s1">charAt: returnsString</span><span class="s2">,</span>
    <span class="s1">charCodeAt: returnsNumber</span><span class="s2">,</span>
    <span class="s1">codePointAt: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">concat: returnsString</span><span class="s2">,</span>
    <span class="s1">endsWith: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">fixed: returnsString</span><span class="s2">,</span>
    <span class="s1">fontcolor: returnsString</span><span class="s2">,</span>
    <span class="s1">fontsize: returnsString</span><span class="s2">,</span>
    <span class="s1">includes: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">indexOf: returnsNumber</span><span class="s2">,</span>
    <span class="s1">italics: returnsString</span><span class="s2">,</span>
    <span class="s1">lastIndexOf: returnsNumber</span><span class="s2">,</span>
    <span class="s1">link: returnsString</span><span class="s2">,</span>
    <span class="s1">localeCompare: returnsNumber</span><span class="s2">,</span>
    <span class="s1">match: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">matchAll: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">normalize: returnsString</span><span class="s2">,</span>
    <span class="s1">padEnd: returnsString</span><span class="s2">,</span>
    <span class="s1">padStart: returnsString</span><span class="s2">,</span>
    <span class="s1">repeat: returnsString</span><span class="s2">,</span>
    <span class="s1">replace: stringReplace</span><span class="s2">,</span>
    <span class="s1">replaceAll: stringReplace</span><span class="s2">,</span>
    <span class="s1">search: returnsNumber</span><span class="s2">,</span>
    <span class="s1">slice: returnsString</span><span class="s2">,</span>
    <span class="s1">small: returnsString</span><span class="s2">,</span>
    <span class="s1">split: returnsUnknown</span><span class="s2">,</span>
    <span class="s1">startsWith: returnsBoolean</span><span class="s2">,</span>
    <span class="s1">strike: returnsString</span><span class="s2">,</span>
    <span class="s1">sub: returnsString</span><span class="s2">,</span>
    <span class="s1">substr: returnsString</span><span class="s2">,</span>
    <span class="s1">substring: returnsString</span><span class="s2">,</span>
    <span class="s1">sup: returnsString</span><span class="s2">,</span>
    <span class="s1">toLocaleLowerCase: returnsString</span><span class="s2">,</span>
    <span class="s1">toLocaleUpperCase: returnsString</span><span class="s2">,</span>
    <span class="s1">toLowerCase: returnsString</span><span class="s2">,</span>
    <span class="s1">toString: returnsString</span><span class="s2">,</span>
    <span class="s1">toUpperCase: returnsString</span><span class="s2">,</span>
    <span class="s1">trim: returnsString</span><span class="s2">,</span>
    <span class="s1">trimEnd: returnsString</span><span class="s2">,</span>
    <span class="s1">trimLeft: returnsString</span><span class="s2">,</span>
    <span class="s1">trimRight: returnsString</span><span class="s2">,</span>
    <span class="s1">trimStart: returnsString</span><span class="s2">,</span>
    <span class="s1">valueOf: returnsString</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">objectMembers)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getLiteralMembersForValue(value) {</span>
    <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">RegExp) {</span>
        <span class="s2">return </span><span class="s1">literalRegExpMembers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value) {</span>
        <span class="s2">case </span><span class="s3">'boolean'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">literalBooleanMembers</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'number'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">literalNumberMembers</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'string'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">literalStringMembers</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasMemberEffectWhenCalled(members</span><span class="s2">, </span><span class="s1">memberName</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">memberName !== </span><span class="s3">'string' </span><span class="s1">|| !members[memberName]) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">members[memberName].hasEffectsWhenCalled?.(interaction</span><span class="s2">, </span><span class="s1">context) || </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getMemberReturnExpressionWhenCalled(members</span><span class="s2">, </span><span class="s1">memberName) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">memberName !== </span><span class="s3">'string' </span><span class="s1">|| !members[memberName])</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[members[memberName].returns</span><span class="s2">, false</span><span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// AST walker module for Mozilla Parser API compatible trees</span>

<span class="s2">function </span><span class="s1">skipThrough(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { c(node</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s2">function </span><span class="s1">ignore(_node</span><span class="s2">, </span><span class="s1">_st</span><span class="s2">, </span><span class="s1">_c) {}</span>

<span class="s0">// Node walkers.</span>

<span class="s2">var </span><span class="s1">base$1 = {}</span><span class="s2">;</span>

<span class="s1">base$1.Program = base$1.BlockStatement = base$1.StaticBlock = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.body</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">stmt = list[i]</span><span class="s2">;</span>

    <span class="s1">c(stmt</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.Statement = skipThrough</span><span class="s2">;</span>
<span class="s1">base$1.EmptyStatement = ignore</span><span class="s2">;</span>
<span class="s1">base$1.ExpressionStatement = base$1.ParenthesizedExpression = base$1.ChainExpression =</span>
  <span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node.expression</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.IfStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.consequent</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.alternate) { c(node.alternate</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.LabeledStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.BreakStatement = base$1.ContinueStatement = ignore</span><span class="s2">;</span>
<span class="s1">base$1.WithStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.object</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.SwitchStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.discriminant</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i$1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list$1 = node.cases</span><span class="s2">; </span><span class="s1">i$1 &lt; list$1.length</span><span class="s2">; </span><span class="s1">i$1 += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">cs = list$1[i$1]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(cs.test) { c(cs.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = cs.consequent</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">{</span>
      <span class="s2">var </span><span class="s1">cons = list[i]</span><span class="s2">;</span>

      <span class="s1">c(cons</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.SwitchCase = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.test) { c(node.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.consequent</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">cons = list[i]</span><span class="s2">;</span>

    <span class="s1">c(cons</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.argument) { c(node.argument</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ThrowStatement = base$1.SpreadElement =</span>
  <span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node.argument</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.TryStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.block</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.handler) { c(node.handler</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.finalizer) { c(node.finalizer</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.CatchClause = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.param) { c(node.param</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.WhileStatement = base$1.DoWhileStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ForStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.init) { c(node.init</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;ForInit&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.test) { c(node.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.update) { c(node.update</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ForInStatement = base$1.ForOfStatement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.left</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;ForInit&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.right</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ForInit = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.type === </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">) { c(node</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else </span><span class="s1">{ c(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.DebuggerStatement = ignore</span><span class="s2">;</span>

<span class="s1">base$1.FunctionDeclaration = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.VariableDeclaration = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.declarations</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">decl = list[i]</span><span class="s2">;</span>

    <span class="s1">c(decl</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.VariableDeclarator = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.id</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.init) { c(node.init</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">base$1.Function = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.id) { c(node.id</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.params</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">param = list[i]</span><span class="s2">;</span>

    <span class="s1">c(param</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">node.expression ? </span><span class="s3">&quot;Expression&quot; </span><span class="s1">: </span><span class="s3">&quot;Statement&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">base$1.Pattern = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.type === </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span>
    <span class="s1">{ c(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;VariablePattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(node.type === </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">)</span>
    <span class="s1">{ c(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;MemberPattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{ c(node</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.VariablePattern = ignore</span><span class="s2">;</span>
<span class="s1">base$1.MemberPattern = skipThrough</span><span class="s2">;</span>
<span class="s1">base$1.RestElement = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node.argument</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ArrayPattern = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.elements</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">elt = list[i]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(elt) { c(elt</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ObjectPattern = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.properties</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">prop = list[i]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(prop.type === </span><span class="s3">&quot;Property&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(prop.computed) { c(prop.key</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">c(prop.value</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prop.type === </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">) {</span>
      <span class="s1">c(prop.argument</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">base$1.Expression = skipThrough</span><span class="s2">;</span>
<span class="s1">base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore</span><span class="s2">;</span>
<span class="s1">base$1.ArrayExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.elements</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">elt = list[i]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(elt) { c(elt</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ObjectExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.properties</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">prop = list[i]</span><span class="s2">;</span>

    <span class="s1">c(prop</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration</span><span class="s2">;</span>
<span class="s1">base$1.SequenceExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.expressions</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">expr = list[i]</span><span class="s2">;</span>

    <span class="s1">c(expr</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.TemplateLiteral = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.quasis</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">quasi = list[i]</span><span class="s2">;</span>

    <span class="s1">c(quasi</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i$1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list$1 = node.expressions</span><span class="s2">; </span><span class="s1">i$1 &lt; list$1.length</span><span class="s2">; </span><span class="s1">i$1 += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">expr = list$1[i$1]</span><span class="s2">;</span>

    <span class="s1">c(expr</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.TemplateElement = ignore</span><span class="s2">;</span>
<span class="s1">base$1.UnaryExpression = base$1.UpdateExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.argument</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.BinaryExpression = base$1.LogicalExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.left</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.right</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.AssignmentExpression = base$1.AssignmentPattern = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.left</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.right</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ConditionalExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.test</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.consequent</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.alternate</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.NewExpression = base$1.CallExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.callee</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.arguments)</span>
    <span class="s1">{ </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.arguments</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">arg = list[i]</span><span class="s2">;</span>

        <span class="s1">c(arg</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} }</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.MemberExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.object</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.computed) { c(node.property</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.declaration)</span>
    <span class="s1">{ c(node.declaration</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">node.type === </span><span class="s3">&quot;ExportNamedDeclaration&quot; </span><span class="s1">|| node.declaration.id ? </span><span class="s3">&quot;Statement&quot; </span><span class="s1">: </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.source) { c(node.source</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ExportAllDeclaration = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.exported)</span>
    <span class="s1">{ c(node.exported</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">c(node.source</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ImportDeclaration = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.specifiers</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">spec = list[i]</span><span class="s2">;</span>

    <span class="s1">c(spec</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">c(node.source</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ImportExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.source</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.PrivateIdentifier = base$1.Literal = ignore</span><span class="s2">;</span>

<span class="s1">base$1.TaggedTemplateExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s1">c(node.tag</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">c(node.quasi</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ClassDeclaration = base$1.ClassExpression = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) { </span><span class="s2">return </span><span class="s1">c(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Class&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.Class = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.id) { c(node.id</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.superClass) { c(node.superClass</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">c(node.body</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.ClassBody = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.body</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">elt = list[i]</span><span class="s2">;</span>

    <span class="s1">c(elt</span><span class="s2">, </span><span class="s1">st)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">base$1.MethodDefinition = base$1.PropertyDefinition = base$1.Property = </span><span class="s2">function </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s1">c) {</span>
  <span class="s2">if </span><span class="s1">(node.computed) { c(node.key</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(node.value) { c(node.value</span><span class="s2">, </span><span class="s1">st</span><span class="s2">, </span><span class="s3">&quot;Expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">ArrowFunctionExpression$1 = </span><span class="s3">'ArrowFunctionExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">BinaryExpression$1 = </span><span class="s3">'BinaryExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">BlockStatement$1 = </span><span class="s3">'BlockStatement'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CallExpression$1 = </span><span class="s3">'CallExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ChainExpression$1 = </span><span class="s3">'ChainExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ConditionalExpression$1 = </span><span class="s3">'ConditionalExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ExpressionStatement$1 = </span><span class="s3">'ExpressionStatement'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Identifier$1 = </span><span class="s3">'Identifier'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">LogicalExpression$1 = </span><span class="s3">'LogicalExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NewExpression$1 = </span><span class="s3">'NewExpression'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Program$1 = </span><span class="s3">'Program'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Property$1 = </span><span class="s3">'Property'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ReturnStatement$1 = </span><span class="s3">'ReturnStatement'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SequenceExpression$1 = </span><span class="s3">'SequenceExpression'</span><span class="s2">;</span>

<span class="s0">// this looks ridiculous, but it prevents sourcemap tooling from mistaking</span>
<span class="s0">// this for an actual sourceMappingURL</span>
<span class="s2">let </span><span class="s1">SOURCEMAPPING_URL = </span><span class="s3">'sourceMa'</span><span class="s2">;</span>
<span class="s1">SOURCEMAPPING_URL += </span><span class="s3">'ppingURL'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">whiteSpaceNoNewline = </span><span class="s3">'[ </span><span class="s2">\\</span><span class="s3">f</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">t</span><span class="s2">\\</span><span class="s3">v</span><span class="s2">\\</span><span class="s3">u00a0</span><span class="s2">\\</span><span class="s3">u1680</span><span class="s2">\\</span><span class="s3">u2000-</span><span class="s2">\\</span><span class="s3">u200a</span><span class="s2">\\</span><span class="s3">u2028</span><span class="s2">\\</span><span class="s3">u2029</span><span class="s2">\\</span><span class="s3">u202f</span><span class="s2">\\</span><span class="s3">u205f</span><span class="s2">\\</span><span class="s3">u3000</span><span class="s2">\\</span><span class="s3">ufeff]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SOURCEMAPPING_URL_RE = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">`^#</span><span class="s1">${whiteSpaceNoNewline}</span><span class="s3">+</span><span class="s1">${SOURCEMAPPING_URL}</span><span class="s3">=.+`</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">ANNOTATION_KEY = </span><span class="s3">'_rollupAnnotations'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INVALID_COMMENT_KEY = </span><span class="s3">'_rollupRemoved'</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">handlePureAnnotationsOfNode(node</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">type = node.type) {</span>
    <span class="s2">const </span><span class="s1">{ annotations</span><span class="s2">, </span><span class="s1">code } = state</span><span class="s2">;</span>
    <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
    <span class="s2">let </span><span class="s1">comment = annotations[state.annotationIndex]</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(comment &amp;&amp; node.start &gt;= comment.end) {</span>
        <span class="s1">markPureNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">code)</span><span class="s2">;</span>
        <span class="s1">comment = annotations[++state.annotationIndex]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(comment &amp;&amp; comment.end &lt;= node.end) {</span>
        <span class="s1">base$1[type](node</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">handlePureAnnotationsOfNode)</span><span class="s2">;</span>
        <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
        <span class="s2">while </span><span class="s1">((comment = annotations[state.annotationIndex]) &amp;&amp; comment.end &lt;= node.end) {</span>
            <span class="s1">++state.annotationIndex</span><span class="s2">;</span>
            <span class="s1">annotateNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">neitherWithespaceNorBrackets = </span><span class="s4">/[^\s(]/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">noWhitespace = </span><span class="s4">/\S/g</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">markPureNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">code) {</span>
    <span class="s2">const </span><span class="s1">annotatedNodes = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">invalidAnnotation</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">codeInBetween = code.slice(comment.end</span><span class="s2">, </span><span class="s1">node.start)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(doesNotMatchOutsideComment(codeInBetween</span><span class="s2">, </span><span class="s1">neitherWithespaceNorBrackets)) {</span>
        <span class="s2">const </span><span class="s1">parentStart = node.start</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">annotatedNodes.push(node)</span><span class="s2">;</span>
            <span class="s2">switch </span><span class="s1">(node.type) {</span>
                <span class="s2">case </span><span class="s1">ExpressionStatement$1:</span>
                <span class="s2">case </span><span class="s1">ChainExpression$1: {</span>
                    <span class="s1">node = node.expression</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">SequenceExpression$1: {</span>
                    <span class="s0">// if there are parentheses, the annotation would apply to the entire expression</span>
                    <span class="s2">if </span><span class="s1">(doesNotMatchOutsideComment(code.slice(parentStart</span><span class="s2">, </span><span class="s1">node.start)</span><span class="s2">, </span><span class="s1">noWhitespace)) {</span>
                        <span class="s1">node = node.expressions[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                        <span class="s2">continue;</span>
                    <span class="s1">}</span>
                    <span class="s1">invalidAnnotation = </span><span class="s2">true;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">ConditionalExpression$1: {</span>
                    <span class="s0">// if there are parentheses, the annotation would apply to the entire expression</span>
                    <span class="s2">if </span><span class="s1">(doesNotMatchOutsideComment(code.slice(parentStart</span><span class="s2">, </span><span class="s1">node.start)</span><span class="s2">, </span><span class="s1">noWhitespace)) {</span>
                        <span class="s1">node = node.test</span><span class="s2">;</span>
                        <span class="s2">continue;</span>
                    <span class="s1">}</span>
                    <span class="s1">invalidAnnotation = </span><span class="s2">true;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">LogicalExpression$1:</span>
                <span class="s2">case </span><span class="s1">BinaryExpression$1: {</span>
                    <span class="s0">// if there are parentheses, the annotation would apply to the entire expression</span>
                    <span class="s2">if </span><span class="s1">(doesNotMatchOutsideComment(code.slice(parentStart</span><span class="s2">, </span><span class="s1">node.start)</span><span class="s2">, </span><span class="s1">noWhitespace)) {</span>
                        <span class="s1">node = node.left</span><span class="s2">;</span>
                        <span class="s2">continue;</span>
                    <span class="s1">}</span>
                    <span class="s1">invalidAnnotation = </span><span class="s2">true;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
                <span class="s2">case </span><span class="s1">CallExpression$1:</span>
                <span class="s2">case </span><span class="s1">NewExpression$1: {</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
                <span class="s2">default</span><span class="s1">: {</span>
                    <span class="s1">invalidAnnotation = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">invalidAnnotation = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(invalidAnnotation) {</span>
        <span class="s1">annotateNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of annotatedNodes) {</span>
            <span class="s1">annotateNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">doesNotMatchOutsideComment(code</span><span class="s2">, </span><span class="s1">forbiddenChars) {</span>
    <span class="s2">let </span><span class="s1">nextMatch</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">((nextMatch = forbiddenChars.exec(code)) !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(nextMatch[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">charCodeAfterSlash = code.charCodeAt(forbiddenChars.lastIndex)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(charCodeAfterSlash === </span><span class="s4">42 </span><span class="s0">/*&quot;*&quot;*/</span><span class="s1">) {</span>
                <span class="s1">forbiddenChars.lastIndex = code.indexOf(</span><span class="s3">'*/'</span><span class="s2">, </span><span class="s1">forbiddenChars.lastIndex + </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">2</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(charCodeAfterSlash === </span><span class="s4">47 </span><span class="s0">/*&quot;/&quot;*/</span><span class="s1">) {</span>
                <span class="s1">forbiddenChars.lastIndex = code.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">forbiddenChars.lastIndex + </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">forbiddenChars.lastIndex = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">pureCommentRegex = </span><span class="s4">/[#@]__PURE__/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">addAnnotations(comments</span><span class="s2">, </span><span class="s1">esTreeAst</span><span class="s2">, </span><span class="s1">code) {</span>
    <span class="s2">const </span><span class="s1">annotations = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">sourceMappingComments = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">comment of comments) {</span>
        <span class="s2">if </span><span class="s1">(pureCommentRegex.test(comment.value)) {</span>
            <span class="s1">annotations.push(comment)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(SOURCEMAPPING_URL_RE.test(comment.value)) {</span>
            <span class="s1">sourceMappingComments.push(comment)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">comment of sourceMappingComments) {</span>
        <span class="s1">annotateNode(esTreeAst</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">handlePureAnnotationsOfNode(esTreeAst</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">annotationIndex: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">annotations</span><span class="s2">,</span>
        <span class="s1">code</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">annotateNode(node</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">, </span><span class="s1">valid) {</span>
    <span class="s2">const </span><span class="s1">key = valid ? ANNOTATION_KEY : INVALID_COMMENT_KEY</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">property = node[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(property) {</span>
        <span class="s1">property.push(comment)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">node[key] = [comment]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">keys = {</span>
    <span class="s0">// TODO this should be removed once ImportExpression follows official ESTree</span>
    <span class="s0">//  specs with &quot;null&quot; as default</span>
    <span class="s1">ImportExpression: [</span><span class="s3">'arguments'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">Literal: []</span><span class="s2">,</span>
    <span class="s1">Program: [</span><span class="s3">'body'</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getAndCreateKeys(esTreeNode) {</span>
    <span class="s1">keys[esTreeNode.type] = Object.keys(esTreeNode).filter(key =&gt; </span><span class="s2">typeof </span><span class="s1">esTreeNode[key] === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; key.charCodeAt(</span><span class="s4">0</span><span class="s1">) !== </span><span class="s4">95 </span><span class="s0">/* _ */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">keys[esTreeNode.type]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">INCLUDE_PARAMETERS = </span><span class="s3">'variables'</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">NodeBase </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor(esTreeNode</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parentScope</span><span class="s2">, </span><span class="s1">keepEsTreeNode = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Nodes can apply custom deoptimizations once they become part of the</span>
         <span class="s5">* executed code. To do this, they must initialize this as false, implement</span>
         <span class="s5">* applyDeoptimizations and call this from include and hasEffects if they have</span>
         <span class="s5">* custom handlers</span>
         <span class="s5">*/</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">false;</span>
        <span class="s0">// Nodes can opt-in to keep the AST if needed during the build pipeline.</span>
        <span class="s0">// Avoid true when possible as large AST takes up memory.</span>
        <span class="s2">this</span><span class="s1">.esTreeNode = keepEsTreeNode ? esTreeNode : </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.keys = keys[esTreeNode.type] || getAndCreateKeys(esTreeNode)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent = parent</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context = parent.context</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.createScope(parentScope)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.initialise()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.magicString.addSourcemapLocation(</span><span class="s2">this</span><span class="s1">.start)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.magicString.addSourcemapLocation(</span><span class="s2">this</span><span class="s1">.end)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addExportedVariables(_variables</span><span class="s2">, </span><span class="s1">_exportNamesByVariable) { }</span>
    <span class="s5">/**</span>
     <span class="s5">* Override this to bind assignments to variables and do any initialisations</span>
     <span class="s5">* that require the scopes to be populated with variables.</span>
     <span class="s5">*/</span>
    <span class="s1">bind() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of </span><span class="s2">this</span><span class="s1">.keys) {</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s1">child?.bind()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(value) {</span>
                <span class="s1">value.bind()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Override if this node should receive a different scope than the parent</span>
     <span class="s5">* scope.</span>
     <span class="s5">*/</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = parentScope</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of </span><span class="s2">this</span><span class="s1">.keys) {</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s2">if </span><span class="s1">(child?.hasEffects(context))</span>
                        <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(value.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">_checkAccess) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.assignmentInteraction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">_options) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of </span><span class="s2">this</span><span class="s1">.keys) {</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s1">child?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">value.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">_deoptimizeAccess) {</span>
        <span class="s2">this</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Override to perform special initialisation steps after the scope is</span>
     <span class="s5">* initialised</span>
     <span class="s5">*/</span>
    <span class="s1">initialise() { }</span>
    <span class="s1">insertSemicolon(code) {</span>
        <span class="s2">if </span><span class="s1">(code.original[</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">';'</span><span class="s1">) {</span>
            <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode</span><span class="s2">, </span><span class="s1">keepEsTreeNodeKeys) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">value] of Object.entries(esTreeNode)) {</span>
            <span class="s0">// That way, we can override this function to add custom initialisation and then call super.parseNode</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasOwnProperty(key))</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(key.charCodeAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s4">95 </span><span class="s0">/* _ */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(key === ANNOTATION_KEY) {</span>
                    <span class="s2">this</span><span class="s1">.annotations = value</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(key === INVALID_COMMENT_KEY) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ start</span><span class="s2">, </span><span class="s1">end } of value)</span>
                        <span class="s2">this</span><span class="s1">.context.magicString.remove(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value !== </span><span class="s3">'object' </span><span class="s1">|| value === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">[key] = value</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">this</span><span class="s1">[key] = []</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s2">this</span><span class="s1">[key].push(child === </span><span class="s2">null</span>
                        <span class="s1">? </span><span class="s2">null</span>
                        <span class="s1">: </span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(child.type))(child</span><span class="s2">, this, this</span><span class="s1">.scope</span><span class="s2">, </span><span class="s1">keepEsTreeNodeKeys?.includes(key)))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">[key] = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(value.type))(value</span><span class="s2">, this, this</span><span class="s1">.scope</span><span class="s2">, </span><span class="s1">keepEsTreeNodeKeys?.includes(key))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of </span><span class="s2">this</span><span class="s1">.keys) {</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s1">child?.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">value.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setAssignedValue(value) {</span>
        <span class="s2">this</span><span class="s1">.assignmentInteraction = { args: [</span><span class="s2">null, </span><span class="s1">value]</span><span class="s2">, </span><span class="s1">type: INTERACTION_ASSIGNED }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">shouldBeIncluded(context) {</span>
        <span class="s2">return this</span><span class="s1">.included || (!context.brokenFlow &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasEffects(createHasEffectsContext()))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Just deoptimize everything by default so that when e.g. we do not track</span>
     <span class="s5">* something properly, it is deoptimized.</span>
     <span class="s5">* </span><span class="s6">@protected</span>
     <span class="s5">*/</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of </span><span class="s2">this</span><span class="s1">.keys) {</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of value) {</span>
                    <span class="s1">child?.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">value.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">SpreadElement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.argument.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">[UnknownKey</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ propertyReadSideEffects } = </span><span class="s2">this</span><span class="s1">.context.options</span>
            <span class="s1">.treeshake</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument.hasEffects(context) ||</span>
            <span class="s1">(propertyReadSideEffects &amp;&amp;</span>
                <span class="s1">(propertyReadSideEffects === </span><span class="s3">'always' </span><span class="s1">||</span>
                    <span class="s2">this</span><span class="s1">.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ACCESS</span><span class="s2">, </span><span class="s1">context))))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s0">// Only properties of properties of the argument could become subject to reassignment</span>
        <span class="s0">// This will also reassign the return values of iterators</span>
        <span class="s2">this</span><span class="s1">.argument.deoptimizePath([UnknownKey</span><span class="s2">, </span><span class="s1">UnknownKey])</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Method </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor(description) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.description = description</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath({ args</span><span class="s2">, </span><span class="s1">type }</span><span class="s2">, </span><span class="s1">path) {</span>
        <span class="s2">if </span><span class="s1">(type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.description.mutatesSelfAsArray) {</span>
            <span class="s1">args[</span><span class="s4">0</span><span class="s1">]?.deoptimizePath(UNKNOWN_INTEGER_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">{ args }) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s2">this</span><span class="s1">.description.returnsPrimitive ||</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.description.returns === </span><span class="s3">'self'</span>
                    <span class="s1">? args[</span><span class="s4">0</span><span class="s1">] || UNKNOWN_EXPRESSION</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.description.returns())</span><span class="s2">,</span>
            <span class="s2">false</span>
        <span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">{ type } = interaction</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; (type === INTERACTION_ACCESSED ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">{ args } = interaction</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.description.mutatesSelfAsArray === </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
                <span class="s1">args[</span><span class="s4">0</span><span class="s1">]?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ASSIGNMENT</span><span class="s2">, </span><span class="s1">context)) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.description.callsArgs) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argumentIndex of </span><span class="s2">this</span><span class="s1">.description.callsArgs) {</span>
                    <span class="s2">if </span><span class="s1">(args[argumentIndex + </span><span class="s4">1</span><span class="s1">]?.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_CALL</span><span class="s2">, </span><span class="s1">context)) {</span>
                        <span class="s2">return true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">METHOD_RETURNS_BOOLEAN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">false,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_RETURNS_STRING = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">false,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_STRING</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_RETURNS_NUMBER = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">false,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_NUMBER</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_RETURNS_UNKNOWN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">false,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_EXPRESSION</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">INTEGER_REG_EXP = </span><span class="s4">/^\d+$/</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ObjectEntity </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s0">// If a PropertyMap is used, this will be taken as propertiesAndGettersByKey</span>
    <span class="s0">// and we assume there are no setters or getters</span>
    <span class="s1">constructor(properties</span><span class="s2">, </span><span class="s1">prototypeExpression</span><span class="s2">, </span><span class="s1">immutable = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.prototypeExpression = prototypeExpression</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.immutable = immutable</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.additionalExpressionsToBeDeoptimized = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.allProperties = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizedPaths = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.gettersByKey = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hasLostTrack = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedInteger = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.propertiesAndGettersByKey = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.propertiesAndSettersByKey = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.settersByKey = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unknownIntegerProps = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unmatchableGetters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unmatchablePropertiesAndGetters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unmatchableSetters = []</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(properties)) {</span>
            <span class="s2">this</span><span class="s1">.buildPropertyMaps(properties)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.propertiesAndGettersByKey = </span><span class="s2">this</span><span class="s1">.propertiesAndSettersByKey = properties</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">propertiesForKey of Object.values(properties)) {</span>
                <span class="s2">this</span><span class="s1">.allProperties.push(...propertiesForKey)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeAllProperties(noAccessors) {</span>
        <span class="s2">const </span><span class="s1">isDeoptimized = </span><span class="s2">this</span><span class="s1">.hasLostTrack || </span><span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(noAccessors) {</span>
            <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.hasLostTrack = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isDeoptimized) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">properties of [</span>
            <span class="s1">...Object.values(</span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey)</span><span class="s2">,</span>
            <span class="s1">...Object.values(</span><span class="s2">this</span><span class="s1">.settersByKey)</span>
        <span class="s1">]) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of properties) {</span>
                <span class="s1">property.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// While the prototype itself cannot be mutated, each property can</span>
        <span class="s2">this</span><span class="s1">.prototypeExpression?.deoptimizePath([UnknownKey</span><span class="s2">, </span><span class="s1">UnknownKey])</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizeCachedEntities()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">...subPath] = path</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ args</span><span class="s2">, </span><span class="s1">type } = interaction</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasLostTrack ||</span>
            <span class="s0">// single paths that are deoptimized will not become getters or setters</span>
            <span class="s1">((type === INTERACTION_CALLED || path.length &gt; </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty ||</span>
                    <span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.deoptimizedPaths[key])))) {</span>
            <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[propertiesForExactMatchByKey</span><span class="s2">, </span><span class="s1">relevantPropertiesByKey</span><span class="s2">, </span><span class="s1">relevantUnmatchableProperties] = type === INTERACTION_CALLED || path.length &gt; </span><span class="s4">1</span>
            <span class="s1">? [</span>
                <span class="s2">this</span><span class="s1">.propertiesAndGettersByKey</span><span class="s2">,</span>
                <span class="s2">this</span><span class="s1">.propertiesAndGettersByKey</span><span class="s2">,</span>
                <span class="s2">this</span><span class="s1">.unmatchablePropertiesAndGetters</span>
            <span class="s1">]</span>
            <span class="s1">: type === INTERACTION_ACCESSED</span>
                <span class="s1">? [</span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey</span><span class="s2">, this</span><span class="s1">.gettersByKey</span><span class="s2">, this</span><span class="s1">.unmatchableGetters]</span>
                <span class="s1">: [</span><span class="s2">this</span><span class="s1">.propertiesAndSettersByKey</span><span class="s2">, this</span><span class="s1">.settersByKey</span><span class="s2">, this</span><span class="s1">.unmatchableSetters]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(propertiesForExactMatchByKey[key]) {</span>
                <span class="s2">const </span><span class="s1">properties = relevantPropertiesByKey[key]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(properties) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of properties) {</span>
                        <span class="s1">property.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">subPath</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.immutable) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of args) {</span>
                        <span class="s2">if </span><span class="s1">(argument) {</span>
                            <span class="s2">this</span><span class="s1">.additionalExpressionsToBeDeoptimized.add(argument)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of relevantUnmatchableProperties) {</span>
                <span class="s1">property.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">subPath</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(INTEGER_REG_EXP.test(key)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.unknownIntegerProps) {</span>
                    <span class="s1">property.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">subPath</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">properties of [</span>
                <span class="s1">...Object.values(relevantPropertiesByKey)</span><span class="s2">,</span>
                <span class="s1">relevantUnmatchableProperties</span>
            <span class="s1">]) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of properties) {</span>
                    <span class="s1">property.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">subPath</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.unknownIntegerProps) {</span>
                <span class="s1">property.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">subPath</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.immutable) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of args) {</span>
                <span class="s2">if </span><span class="s1">(argument) {</span>
                    <span class="s2">this</span><span class="s1">.additionalExpressionsToBeDeoptimized.add(argument)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.prototypeExpression?.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeIntegerProperties() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasLostTrack ||</span>
            <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty ||</span>
            <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedInteger) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedInteger = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">propertiesAndGetters] of Object.entries(</span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey)) {</span>
            <span class="s2">if </span><span class="s1">(INTEGER_REG_EXP.test(key)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of propertiesAndGetters) {</span>
                    <span class="s1">property.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.deoptimizeCachedIntegerEntities()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Assumption: If only a specific path is deoptimized, no accessors are created</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasLostTrack || </span><span class="s2">this</span><span class="s1">.immutable) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key !== </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(key === UnknownInteger) {</span>
                    <span class="s2">return this</span><span class="s1">.deoptimizeIntegerProperties()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.deoptimizeAllProperties(key === UnknownNonAccessorKey)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimizedPaths[key]) {</span>
                <span class="s2">this</span><span class="s1">.deoptimizedPaths[key] = </span><span class="s2">true;</span>
                <span class="s0">// we only deoptimizeCache exact matches as in all other cases,</span>
                <span class="s0">// we do not return a literal value or return expression</span>
                <span class="s2">const </span><span class="s1">expressionsToBeDeoptimized = </span><span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey[key]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(expressionsToBeDeoptimized) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                        <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">subPath = path.length === </span><span class="s4">1 </span><span class="s1">? UNKNOWN_PATH : path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span>
            <span class="s1">? [</span>
                <span class="s1">...(</span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey[key] || </span><span class="s2">this</span><span class="s1">.unmatchablePropertiesAndGetters)</span><span class="s2">,</span>
                <span class="s1">...(</span><span class="s2">this</span><span class="s1">.settersByKey[key] || </span><span class="s2">this</span><span class="s1">.unmatchableSetters)</span>
            <span class="s1">]</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.allProperties) {</span>
            <span class="s1">property.deoptimizePath(subPath)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.prototypeExpression?.deoptimizePath(path.length === </span><span class="s4">1 </span><span class="s1">? [...path</span><span class="s2">, </span><span class="s1">UnknownKey] : path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UnknownTruthyValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">expressionAtPath = </span><span class="s2">this</span><span class="s1">.getMemberExpressionAndTrackDeopt(key</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(expressionAtPath) {</span>
            <span class="s2">return </span><span class="s1">expressionAtPath.getLiteralValueAtPath(path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prototypeExpression) {</span>
            <span class="s2">return this</span><span class="s1">.prototypeExpression.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">...subPath] = path</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">expressionAtPath = </span><span class="s2">this</span><span class="s1">.getMemberExpressionAndTrackDeopt(key</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(expressionAtPath) {</span>
            <span class="s2">return </span><span class="s1">expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prototypeExpression) {</span>
            <span class="s2">return this</span><span class="s1">.prototypeExpression.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">...subPath] = path</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(subPath.length &gt; </span><span class="s4">0 </span><span class="s1">|| interaction.type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">expressionAtPath = </span><span class="s2">this</span><span class="s1">.getMemberExpression(key)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(expressionAtPath) {</span>
                <span class="s2">return </span><span class="s1">expressionAtPath.hasEffectsOnInteractionAtPath(subPath</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prototypeExpression) {</span>
                <span class="s2">return this</span><span class="s1">.prototypeExpression.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(key === UnknownNonAccessorKey)</span>
            <span class="s2">return false;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasLostTrack)</span>
            <span class="s2">return true;</span>
        <span class="s2">const </span><span class="s1">[propertiesAndAccessorsByKey</span><span class="s2">, </span><span class="s1">accessorsByKey</span><span class="s2">, </span><span class="s1">unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED</span>
            <span class="s1">? [</span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey</span><span class="s2">, this</span><span class="s1">.gettersByKey</span><span class="s2">, this</span><span class="s1">.unmatchableGetters]</span>
            <span class="s1">: [</span><span class="s2">this</span><span class="s1">.propertiesAndSettersByKey</span><span class="s2">, this</span><span class="s1">.settersByKey</span><span class="s2">, this</span><span class="s1">.unmatchableSetters]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(propertiesAndAccessorsByKey[key]) {</span>
                <span class="s2">const </span><span class="s1">accessors = accessorsByKey[key]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(accessors) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessor of accessors) {</span>
                        <span class="s2">if </span><span class="s1">(accessor.hasEffectsOnInteractionAtPath(subPath</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
                            <span class="s2">return true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessor of unmatchableAccessors) {</span>
                <span class="s2">if </span><span class="s1">(accessor.hasEffectsOnInteractionAtPath(subPath</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessors of [...Object.values(accessorsByKey)</span><span class="s2">, </span><span class="s1">unmatchableAccessors]) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessor of accessors) {</span>
                    <span class="s2">if </span><span class="s1">(accessor.hasEffectsOnInteractionAtPath(subPath</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
                        <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prototypeExpression) {</span>
            <span class="s2">return this</span><span class="s1">.prototypeExpression.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">buildPropertyMaps(properties) {</span>
        <span class="s2">const </span><span class="s1">{ allProperties</span><span class="s2">, </span><span class="s1">propertiesAndGettersByKey</span><span class="s2">, </span><span class="s1">propertiesAndSettersByKey</span><span class="s2">, </span><span class="s1">settersByKey</span><span class="s2">, </span><span class="s1">gettersByKey</span><span class="s2">, </span><span class="s1">unknownIntegerProps</span><span class="s2">, </span><span class="s1">unmatchablePropertiesAndGetters</span><span class="s2">, </span><span class="s1">unmatchableGetters</span><span class="s2">, </span><span class="s1">unmatchableSetters } = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">unmatchablePropertiesAndSetters = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = properties.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">index &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index--) {</span>
            <span class="s2">const </span><span class="s1">{ key</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">property } = properties[index]</span><span class="s2">;</span>
            <span class="s1">allProperties.push(property)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(kind === </span><span class="s3">'set'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!propertiesAndSettersByKey[key]) {</span>
                        <span class="s1">propertiesAndSettersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchablePropertiesAndSetters]</span><span class="s2">;</span>
                        <span class="s1">settersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchableSetters]</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(kind === </span><span class="s3">'get'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!propertiesAndGettersByKey[key]) {</span>
                        <span class="s1">propertiesAndGettersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchablePropertiesAndGetters]</span><span class="s2">;</span>
                        <span class="s1">gettersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchableGetters]</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(!propertiesAndSettersByKey[key]) {</span>
                        <span class="s1">propertiesAndSettersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchablePropertiesAndSetters]</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!propertiesAndGettersByKey[key]) {</span>
                        <span class="s1">propertiesAndGettersByKey[key] = [property</span><span class="s2">, </span><span class="s1">...unmatchablePropertiesAndGetters]</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(key === UnknownInteger) {</span>
                    <span class="s1">unknownIntegerProps.push(property)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(kind === </span><span class="s3">'set'</span><span class="s1">)</span>
                    <span class="s1">unmatchableSetters.push(property)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(kind === </span><span class="s3">'get'</span><span class="s1">)</span>
                    <span class="s1">unmatchableGetters.push(property)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(kind !== </span><span class="s3">'get'</span><span class="s1">)</span>
                    <span class="s1">unmatchablePropertiesAndSetters.push(property)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(kind !== </span><span class="s3">'set'</span><span class="s1">)</span>
                    <span class="s1">unmatchablePropertiesAndGetters.push(property)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCachedEntities() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expressionsToBeDeoptimized of Object.values(</span><span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.additionalExpressionsToBeDeoptimized) {</span>
            <span class="s1">expression.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCachedIntegerEntities() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">expressionsToBeDeoptimized] of Object.entries(</span><span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey)) {</span>
            <span class="s2">if </span><span class="s1">(INTEGER_REG_EXP.test(key)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                    <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.additionalExpressionsToBeDeoptimized) {</span>
            <span class="s1">expression.deoptimizePath(UNKNOWN_INTEGER_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getMemberExpression(key) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasLostTrack ||</span>
            <span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedProperty ||</span>
            <span class="s2">typeof </span><span class="s1">key !== </span><span class="s3">'string' </span><span class="s1">||</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.hasUnknownDeoptimizedInteger &amp;&amp; INTEGER_REG_EXP.test(key)) ||</span>
            <span class="s2">this</span><span class="s1">.deoptimizedPaths[key]) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">properties = </span><span class="s2">this</span><span class="s1">.propertiesAndGettersByKey[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(properties?.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">properties[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(properties ||</span>
            <span class="s2">this</span><span class="s1">.unmatchablePropertiesAndGetters.length &gt; </span><span class="s4">0 </span><span class="s1">||</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.unknownIntegerProps.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; INTEGER_REG_EXP.test(key))) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s1">getMemberExpressionAndTrackDeopt(key</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key !== </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">expression = </span><span class="s2">this</span><span class="s1">.getMemberExpression(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!(expression === UNKNOWN_EXPRESSION || </span><span class="s2">this</span><span class="s1">.immutable)) {</span>
            <span class="s2">const </span><span class="s1">expressionsToBeDeoptimized = (</span><span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey[key] =</span>
                <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimizedByKey[key] || [])</span><span class="s2">;</span>
            <span class="s1">expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">expression</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isInteger = (property) =&gt; </span><span class="s2">typeof </span><span class="s1">property === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s4">/^\d+$/</span><span class="s1">.test(property)</span><span class="s2">;</span>
<span class="s0">// This makes sure unknown properties are not handled as &quot;undefined&quot; but as</span>
<span class="s0">// &quot;unknown&quot; but without access side effects. An exception is done for numeric</span>
<span class="s0">// properties as we do not expect new builtin properties to be numbers, this</span>
<span class="s0">// will improve tree-shaking for out-of-bounds array properties</span>
<span class="s2">const </span><span class="s1">OBJECT_PROTOTYPE_FALLBACK = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">class </span><span class="s1">ObjectPrototypeFallbackExpression </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; !isInteger(path[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path) {</span>
        <span class="s0">// We ignore number properties as we do not expect new properties to be</span>
        <span class="s0">// numbers and also want to keep handling out-of-bound array elements as</span>
        <span class="s0">// &quot;undefined&quot;</span>
        <span class="s2">return </span><span class="s1">path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; isInteger(path[</span><span class="s4">0</span><span class="s1">]) ? undefined : UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1 </span><span class="s1">|| type === INTERACTION_CALLED</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">})()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">OBJECT_PROTOTYPE = </span><span class="s2">new </span><span class="s1">ObjectEntity({</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">hasOwnProperty: METHOD_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">isPrototypeOf: METHOD_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">propertyIsEnumerable: METHOD_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">toLocaleString: METHOD_RETURNS_STRING</span><span class="s2">,</span>
    <span class="s1">toString: METHOD_RETURNS_STRING</span><span class="s2">,</span>
    <span class="s1">valueOf: METHOD_RETURNS_UNKNOWN</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE_FALLBACK</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">NEW_ARRAY_PROPERTIES = [</span>
    <span class="s1">{ key: UnknownInteger</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: UNKNOWN_EXPRESSION }</span><span class="s2">,</span>
    <span class="s1">{ key: </span><span class="s3">'length'</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: UNKNOWN_LITERAL_NUMBER }</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_NUMBER</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">true,</span>
        <span class="s1">returns: () =&gt; </span><span class="s2">new </span><span class="s1">ObjectEntity(NEW_ARRAY_PROPERTIES</span><span class="s2">, </span><span class="s1">ARRAY_PROTOTYPE)</span><span class="s2">,</span>
        <span class="s1">returnsPrimitive: </span><span class="s2">null</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: () =&gt; </span><span class="s2">new </span><span class="s1">ObjectEntity(NEW_ARRAY_PROPERTIES</span><span class="s2">, </span><span class="s1">ARRAY_PROTOTYPE)</span><span class="s2">,</span>
        <span class="s1">returnsPrimitive: </span><span class="s2">null</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: () =&gt; </span><span class="s2">new </span><span class="s1">ObjectEntity(NEW_ARRAY_PROPERTIES</span><span class="s2">, </span><span class="s1">ARRAY_PROTOTYPE)</span><span class="s2">,</span>
        <span class="s1">returnsPrimitive: </span><span class="s2">null</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_MUTATES_SELF_RETURNS_NUMBER = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">true,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_LITERAL_NUMBER</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">true,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_EXPRESSION</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_EXPRESSION</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s3">'deopt-only'</span><span class="s2">,</span>
        <span class="s1">returns: </span><span class="s2">null,</span>
        <span class="s1">returnsPrimitive: UNKNOWN_EXPRESSION</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_MUTATES_SELF_RETURNS_SELF = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: </span><span class="s2">null,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">true,</span>
        <span class="s1">returns: </span><span class="s3">'self'</span><span class="s2">,</span>
        <span class="s1">returnsPrimitive: </span><span class="s2">null</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [</span>
    <span class="s2">new </span><span class="s1">Method({</span>
        <span class="s1">callsArgs: [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mutatesSelfAsArray: </span><span class="s2">true,</span>
        <span class="s1">returns: </span><span class="s3">'self'</span><span class="s2">,</span>
        <span class="s1">returnsPrimitive: </span><span class="s2">null</span>
    <span class="s1">})</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ARRAY_PROTOTYPE = </span><span class="s2">new </span><span class="s1">ObjectEntity({</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s0">// We assume that accessors have effects as we do not track the accessed value afterwards</span>
    <span class="s1">at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF</span><span class="s2">,</span>
    <span class="s1">entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">fill: METHOD_MUTATES_SELF_RETURNS_SELF</span><span class="s2">,</span>
    <span class="s1">filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">includes: METHOD_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">indexOf: METHOD_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">join: METHOD_RETURNS_STRING</span><span class="s2">,</span>
    <span class="s1">keys: METHOD_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">lastIndexOf: METHOD_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">push: METHOD_MUTATES_SELF_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">reverse: METHOD_MUTATES_SELF_RETURNS_SELF</span><span class="s2">,</span>
    <span class="s1">shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN</span><span class="s2">,</span>
    <span class="s1">slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN</span><span class="s2">,</span>
    <span class="s1">sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF</span><span class="s2">,</span>
    <span class="s1">splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY</span><span class="s2">,</span>
    <span class="s1">toLocaleString: METHOD_RETURNS_STRING</span><span class="s2">,</span>
    <span class="s1">toString: METHOD_RETURNS_STRING</span><span class="s2">,</span>
    <span class="s1">unshift: METHOD_MUTATES_SELF_RETURNS_NUMBER</span><span class="s2">,</span>
    <span class="s1">values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">ArrayExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">let </span><span class="s1">hasSpread = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index &lt; </span><span class="s2">this</span><span class="s1">.elements.length</span><span class="s2">; </span><span class="s1">index++) {</span>
            <span class="s2">const </span><span class="s1">element = </span><span class="s2">this</span><span class="s1">.elements[index]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(element &amp;&amp; (hasSpread || element </span><span class="s2">instanceof </span><span class="s1">SpreadElement)) {</span>
                <span class="s1">hasSpread = </span><span class="s2">true;</span>
                <span class="s1">element.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getObjectEntity() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.objectEntity</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">properties = [</span>
            <span class="s1">{ key: </span><span class="s3">'length'</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: UNKNOWN_LITERAL_NUMBER }</span>
        <span class="s1">]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hasSpread = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index &lt; </span><span class="s2">this</span><span class="s1">.elements.length</span><span class="s2">; </span><span class="s1">index++) {</span>
            <span class="s2">const </span><span class="s1">element = </span><span class="s2">this</span><span class="s1">.elements[index]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(hasSpread || element </span><span class="s2">instanceof </span><span class="s1">SpreadElement) {</span>
                <span class="s2">if </span><span class="s1">(element) {</span>
                    <span class="s1">hasSpread = </span><span class="s2">true;</span>
                    <span class="s1">properties.unshift({ key: UnknownInteger</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: element })</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(element) {</span>
                <span class="s1">properties.push({ key: String(index)</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: element })</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">properties.push({ key: String(index)</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property: UNDEFINED_EXPRESSION })</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity(properties</span><span class="s2">, </span><span class="s1">ARRAY_PROTOTYPE))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ArrayPattern </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of </span><span class="s2">this</span><span class="s1">.elements) {</span>
            <span class="s1">element?.addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind) {</span>
        <span class="s2">const </span><span class="s1">variables = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of </span><span class="s2">this</span><span class="s1">.elements) {</span>
            <span class="s2">if </span><span class="s1">(element !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">variables.push(...element.declare(kind</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">variables</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Patterns can only be deoptimized at the empty path at the moment</span>
    <span class="s1">deoptimizePath() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of </span><span class="s2">this</span><span class="s1">.elements) {</span>
            <span class="s1">element?.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// Patterns are only checked at the emtpy path at the moment</span>
    <span class="s1">hasEffectsOnInteractionAtPath(_path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of </span><span class="s2">this</span><span class="s1">.elements) {</span>
            <span class="s2">if </span><span class="s1">(element?.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of </span><span class="s2">this</span><span class="s1">.elements) {</span>
            <span class="s1">element?.markDeclarationReached()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">LocalVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor(name</span><span class="s2">, </span><span class="s1">declarator</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(name)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.init = init</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.calledFromTryStatement = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.additionalInitializers = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.declarations = declarator ? [declarator] : []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizationTracker = context.deoptimizationTracker</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.module = context.module</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addDeclaration(identifier</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">this</span><span class="s1">.declarations.push(identifier)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.markInitializersForDeoptimization().push(init)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">consolidateInitializers() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.additionalInitializers) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">initializer of </span><span class="s2">this</span><span class="s1">.additionalInitializers) {</span>
                <span class="s1">initializer.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.additionalInitializers = </span><span class="s2">null;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned) {</span>
            <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, this</span><span class="s1">.init</span><span class="s2">, </span><span class="s1">() =&gt; </span><span class="s2">this</span><span class="s1">.init.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">, </span><span class="s1">undefined)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned ||</span>
            <span class="s2">this</span><span class="s1">.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, this</span><span class="s1">)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isReassigned) {</span>
                <span class="s2">this</span><span class="s1">.isReassigned = </span><span class="s2">true;</span>
                <span class="s2">const </span><span class="s1">expressionsToBeDeoptimized = </span><span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = EMPTY_ARRAY</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                    <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.init.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.init.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned) {</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, this</span><span class="s1">.init</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
            <span class="s2">return this</span><span class="s1">.init.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">UnknownValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, this</span><span class="s1">.init</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
            <span class="s2">return this</span><span class="s1">.init.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">UNKNOWN_RETURN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">switch </span><span class="s1">(interaction.type) {</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ACCESSED: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned)</span>
                    <span class="s2">return true;</span>
                <span class="s2">return </span><span class="s1">(!context.accessed.trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, this</span><span class="s1">) &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.init.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ASSIGNED: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.included)</span>
                    <span class="s2">return true;</span>
                <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s2">return false;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned)</span>
                    <span class="s2">return true;</span>
                <span class="s2">return </span><span class="s1">(!context.assigned.trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, this</span><span class="s1">) &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.init.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_CALLED: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned)</span>
                    <span class="s2">return true;</span>
                <span class="s2">return </span><span class="s1">(!(interaction.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, </span><span class="s1">interaction.args</span><span class="s2">, this</span><span class="s1">) &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.init.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declaration of </span><span class="s2">this</span><span class="s1">.declarations) {</span>
                <span class="s0">// If node is a default export, it can save a tree-shaking run to include the full declaration now</span>
                <span class="s2">if </span><span class="s1">(!declaration.included)</span>
                    <span class="s1">declaration.include(createInclusionContext()</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">node = declaration.parent</span><span class="s2">;</span>
                <span class="s2">while </span><span class="s1">(!node.included) {</span>
                    <span class="s0">// We do not want to properly include parents in case they are part of a dead branch</span>
                    <span class="s0">// in which case .include() might pull in more dead code</span>
                    <span class="s1">node.included = </span><span class="s2">true;</span>
                    <span class="s2">if </span><span class="s1">(node.type === Program$1)</span>
                        <span class="s2">break;</span>
                    <span class="s1">node = node.parent</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isReassigned || context.includedCallArguments.has(</span><span class="s2">this</span><span class="s1">.init)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of parameters) {</span>
                <span class="s1">argument.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">context.includedCallArguments.add(</span><span class="s2">this</span><span class="s1">.init)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.init.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
            <span class="s1">context.includedCallArguments.delete(</span><span class="s2">this</span><span class="s1">.init)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">markCalledFromTryStatement() {</span>
        <span class="s2">this</span><span class="s1">.calledFromTryStatement = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">markInitializersForDeoptimization() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.additionalInitializers === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.additionalInitializers = [</span><span class="s2">this</span><span class="s1">.init]</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.init = UNKNOWN_EXPRESSION</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.isReassigned = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.additionalInitializers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mergeDeclarations(variable) {</span>
        <span class="s2">const </span><span class="s1">{ declarations } = </span><span class="s2">this;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declaration of variable.declarations) {</span>
            <span class="s1">declarations.push(declaration)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">additionalInitializers = </span><span class="s2">this</span><span class="s1">.markInitializersForDeoptimization()</span><span class="s2">;</span>
        <span class="s1">additionalInitializers.push(variable.init)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variable.additionalInitializers) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">initializer of variable.additionalInitializers) {</span>
                <span class="s1">additionalInitializers.push(initializer)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">MAX_TRACKED_INTERACTIONS = </span><span class="s4">20</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NO_INTERACTIONS = EMPTY_ARRAY</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_DEOPTIMIZED_FIELD = </span><span class="s2">new </span><span class="s1">Set([UnknownKey])</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_PATH_TRACKER = </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNKNOWN_DEOPTIMIZED_ENTITY = </span><span class="s2">new </span><span class="s1">Set([UNKNOWN_EXPRESSION])</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ParameterVariable </span><span class="s2">extends </span><span class="s1">LocalVariable {</span>
    <span class="s1">constructor(name</span><span class="s2">, </span><span class="s1">declarator</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(name</span><span class="s2">, </span><span class="s1">declarator</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizationInteractions = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizations = </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizedFields = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addEntityToBeDeoptimized(entity) {</span>
        <span class="s2">if </span><span class="s1">(entity === UNKNOWN_EXPRESSION) {</span>
            <span class="s0">// As unknown expressions fully deoptimize all interactions, we can clear</span>
            <span class="s0">// the interaction cache at this point provided we keep this optimization</span>
            <span class="s0">// in mind when adding new interactions</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {</span>
                <span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.add(UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ interaction } of </span><span class="s2">this</span><span class="s1">.deoptimizationInteractions) {</span>
                    <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.deoptimizationInteractions = NO_INTERACTIONS</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(UnknownKey)) {</span>
            <span class="s0">// This means that we already deoptimized all interactions and no longer</span>
            <span class="s0">// track them</span>
            <span class="s1">entity.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.has(entity)) {</span>
            <span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.add(entity)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">field of </span><span class="s2">this</span><span class="s1">.deoptimizedFields) {</span>
                <span class="s1">entity.deoptimizePath([field])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ interaction</span><span class="s2">, </span><span class="s1">path } of </span><span class="s2">this</span><span class="s1">.deoptimizationInteractions) {</span>
                <span class="s1">entity.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path) {</span>
        <span class="s0">// For performance reasons, we fully deoptimize all deeper interactions</span>
        <span class="s2">if </span><span class="s1">(path.length &gt;= </span><span class="s4">2 </span><span class="s1">||</span>
            <span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION) ||</span>
            <span class="s2">this</span><span class="s1">.deoptimizationInteractions.length &gt;= MAX_TRACKED_INTERACTIONS ||</span>
            <span class="s1">(path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(UnknownKey) ||</span>
                    <span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; </span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(path[</span><span class="s4">0</span><span class="s1">]))))) {</span>
            <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimizations.trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, </span><span class="s1">interaction.args)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entity of </span><span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized) {</span>
                <span class="s1">entity.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {</span>
                <span class="s2">this</span><span class="s1">.deoptimizationInteractions.push({</span>
                    <span class="s1">interaction</span><span class="s2">,</span>
                    <span class="s1">path</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(UnknownKey)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(key)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.deoptimizedFields.add(key)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entity of </span><span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized) {</span>
            <span class="s0">// We do not need a recursion tracker here as we already track whether</span>
            <span class="s0">// this field is deoptimized</span>
            <span class="s1">entity.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(key === UnknownKey) {</span>
            <span class="s0">// save some memory</span>
            <span class="s2">this</span><span class="s1">.deoptimizationInteractions = NO_INTERACTIONS</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.deoptimizations = EMPTY_PATH_TRACKER</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.deoptimizedFields = UNKNOWN_DEOPTIMIZED_FIELD</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.entitiesToBeDeoptimized = UNKNOWN_DEOPTIMIZED_ENTITY</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s0">// We deoptimize everything that is called as that will trivially deoptimize</span>
        <span class="s0">// the corresponding return expressions as well and avoid badly performing</span>
        <span class="s0">// and complicated alternatives</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimizedFields.has(path[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s2">this</span><span class="s1">.deoptimizePath([path[</span><span class="s4">0</span><span class="s1">]])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">chars = </span><span class="s3">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">base = </span><span class="s4">64</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">toBase64(value) {</span>
    <span class="s2">let </span><span class="s1">outString = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">currentDigit = value % base</span><span class="s2">;</span>
        <span class="s1">value = (value / base) | </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">outString = chars[currentDigit] + outString</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(value !== </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">outString</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getSafeName(baseName</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">forbiddenNames) {</span>
    <span class="s2">let </span><span class="s1">safeName = baseName</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">count = </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(usedNames.has(safeName) || RESERVED_NAMES$1.has(safeName) || forbiddenNames?.has(safeName)) {</span>
        <span class="s1">safeName = </span><span class="s3">`</span><span class="s1">${baseName}</span><span class="s3">$</span><span class="s1">${toBase64(count++)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">usedNames.add(safeName)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">safeName</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">Scope$1 = </span><span class="s2">class </span><span class="s1">Scope {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.children = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">_isHoisted) {</span>
        <span class="s2">const </span><span class="s1">name = identifier.name</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.variables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variable) {</span>
            <span class="s1">variable.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">init)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">variable = </span><span class="s2">new </span><span class="s1">LocalVariable(identifier.name</span><span class="s2">, </span><span class="s1">identifier</span><span class="s2">, </span><span class="s1">init || UNDEFINED_EXPRESSION</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.variables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">contains(name) {</span>
        <span class="s2">return this</span><span class="s1">.variables.has(name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findVariable(_name) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Internal Error: findVariable needs to be implemented by a subclass'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">ChildScope </span><span class="s2">extends </span><span class="s1">Scope$1 {</span>
    <span class="s1">constructor(parent) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.accessedOutsideVariables = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent = parent</span><span class="s2">;</span>
        <span class="s1">parent.children.push(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addAccessedDynamicImport(importExpression) {</span>
        <span class="s1">(</span><span class="s2">this</span><span class="s1">.accessedDynamicImports || (</span><span class="s2">this</span><span class="s1">.accessedDynamicImports = </span><span class="s2">new </span><span class="s1">Set())).add(importExpression)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.parent </span><span class="s2">instanceof </span><span class="s1">ChildScope) {</span>
            <span class="s2">this</span><span class="s1">.parent.addAccessedDynamicImport(importExpression)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addAccessedGlobals(globals</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope) {</span>
        <span class="s2">const </span><span class="s1">accessedGlobals = accessedGlobalsByScope.get(</span><span class="s2">this</span><span class="s1">) || </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of globals) {</span>
            <span class="s1">accessedGlobals.add(name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">accessedGlobalsByScope.set(</span><span class="s2">this, </span><span class="s1">accessedGlobals)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.parent </span><span class="s2">instanceof </span><span class="s1">ChildScope) {</span>
            <span class="s2">this</span><span class="s1">.parent.addAccessedGlobals(globals</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addNamespaceMemberAccess(name</span><span class="s2">, </span><span class="s1">variable) {</span>
        <span class="s2">this</span><span class="s1">.accessedOutsideVariables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent.addNamespaceMemberAccess(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addReturnExpression(expression) {</span>
        <span class="s2">this</span><span class="s1">.parent </span><span class="s2">instanceof </span><span class="s1">ChildScope &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent.addReturnExpression(expression)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addUsedOutsideNames(usedNames</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of </span><span class="s2">this</span><span class="s1">.accessedOutsideVariables.values()) {</span>
            <span class="s2">if </span><span class="s1">(variable.included) {</span>
                <span class="s1">usedNames.add(variable.getBaseVariableName())</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'system' </span><span class="s1">&amp;&amp; exportNamesByVariable.has(variable)) {</span>
                    <span class="s1">usedNames.add(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">accessedGlobals = accessedGlobalsByScope.get(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(accessedGlobals) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of accessedGlobals) {</span>
                <span class="s1">usedNames.add(name)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">contains(name) {</span>
        <span class="s2">return this</span><span class="s1">.variables.has(name) || </span><span class="s2">this</span><span class="s1">.parent.contains(name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deconflict(format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope) {</span>
        <span class="s2">const </span><span class="s1">usedNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.addUsedOutsideNames(usedNames</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.accessedDynamicImports) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importExpression of </span><span class="s2">this</span><span class="s1">.accessedDynamicImports) {</span>
                <span class="s2">if </span><span class="s1">(importExpression.inlineNamespace) {</span>
                    <span class="s1">usedNames.add(importExpression.inlineNamespace.getBaseVariableName())</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">variable] of </span><span class="s2">this</span><span class="s1">.variables) {</span>
            <span class="s2">if </span><span class="s1">(variable.included || variable.alwaysRendered) {</span>
                <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName(name</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">variable.forbiddenNames))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">scope of </span><span class="s2">this</span><span class="s1">.children) {</span>
            <span class="s1">scope.deconflict(format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">findLexicalBoundary() {</span>
        <span class="s2">return this</span><span class="s1">.parent.findLexicalBoundary()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findVariable(name) {</span>
        <span class="s2">const </span><span class="s1">knownVariable = </span><span class="s2">this</span><span class="s1">.variables.get(name) || </span><span class="s2">this</span><span class="s1">.accessedOutsideVariables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(knownVariable) {</span>
            <span class="s2">return </span><span class="s1">knownVariable</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.parent.findVariable(name)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.accessedOutsideVariables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ParameterScope </span><span class="s2">extends </span><span class="s1">ChildScope {</span>
    <span class="s1">constructor(parent</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(parent)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parameters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hasRest = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.context = context</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hoistedBodyVarScope = </span><span class="s2">new </span><span class="s1">ChildScope(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Adds a parameter to this scope. Parameters must be added in the correct</span>
     <span class="s5">* order, i.e. from left to right.</span>
     <span class="s5">*/</span>
    <span class="s1">addParameterDeclaration(identifier) {</span>
        <span class="s2">const </span><span class="s1">{ name } = identifier</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">variable = </span><span class="s2">new </span><span class="s1">ParameterVariable(name</span><span class="s2">, </span><span class="s1">identifier</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">localVariable = </span><span class="s2">this</span><span class="s1">.hoistedBodyVarScope.variables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(localVariable) {</span>
            <span class="s2">this</span><span class="s1">.hoistedBodyVarScope.variables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
            <span class="s1">variable.mergeDeclarations(localVariable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.variables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addParameterVariables(parameters</span><span class="s2">, </span><span class="s1">hasRest) {</span>
        <span class="s2">this</span><span class="s1">.parameters = parameters</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parameterList of parameters) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parameter of parameterList) {</span>
                <span class="s1">parameter.alwaysRendered = </span><span class="s2">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.hasRest = hasRest</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">let </span><span class="s1">calledFromTryStatement = </span><span class="s2">false;</span>
        <span class="s2">let </span><span class="s1">argumentIncluded = </span><span class="s2">false;</span>
        <span class="s2">const </span><span class="s1">restParameter = </span><span class="s2">this</span><span class="s1">.hasRest &amp;&amp; </span><span class="s2">this</span><span class="s1">.parameters[</span><span class="s2">this</span><span class="s1">.parameters.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">checkedArgument of parameters) {</span>
            <span class="s2">if </span><span class="s1">(checkedArgument </span><span class="s2">instanceof </span><span class="s1">SpreadElement) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of parameters) {</span>
                    <span class="s1">argument.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = parameters.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">index &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index--) {</span>
            <span class="s2">const </span><span class="s1">parameterVariables = </span><span class="s2">this</span><span class="s1">.parameters[index] || restParameter</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">argument = parameters[index]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(parameterVariables) {</span>
                <span class="s1">calledFromTryStatement = </span><span class="s2">false;</span>
                <span class="s2">if </span><span class="s1">(parameterVariables.length === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">// handle empty destructuring</span>
                    <span class="s1">argumentIncluded = </span><span class="s2">true;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of parameterVariables) {</span>
                        <span class="s2">if </span><span class="s1">(variable.included) {</span>
                            <span class="s1">argumentIncluded = </span><span class="s2">true;</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(variable.calledFromTryStatement) {</span>
                            <span class="s1">calledFromTryStatement = </span><span class="s2">true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!argumentIncluded &amp;&amp; argument.shouldBeIncluded(context)) {</span>
                <span class="s1">argumentIncluded = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(argumentIncluded) {</span>
                <span class="s1">argument.include(context</span><span class="s2">, </span><span class="s1">calledFromTryStatement)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ReturnValueScope </span><span class="s2">extends </span><span class="s1">ParameterScope {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.returnExpression = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.returnExpressions = []</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addReturnExpression(expression) {</span>
        <span class="s2">this</span><span class="s1">.returnExpressions.push(expression)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpression() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression === </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">this</span><span class="s1">.updateReturnExpression()</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.returnExpression</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">updateReturnExpression() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpressions.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.returnExpression = </span><span class="s2">this</span><span class="s1">.returnExpressions[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.returnExpression = UNKNOWN_EXPRESSION</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.returnExpressions) {</span>
                <span class="s1">expression.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{ import('estree').Node} Node */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{Node | {</span>
 <span class="s5">*   type: 'PropertyDefinition';</span>
 <span class="s5">*   computed: boolean;</span>
 <span class="s5">*   value: Node</span>
 <span class="s5">* }} NodeWithPropertyDefinition */</span>

<span class="s5">/**</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{NodeWithPropertyDefinition} node</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{NodeWithPropertyDefinition} parent</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean}</span>
 <span class="s5">*/</span>
<span class="s2">function </span><span class="s1">is_reference (node</span><span class="s2">, </span><span class="s1">parent) {</span>
	<span class="s2">if </span><span class="s1">(node.type === </span><span class="s3">'MemberExpression'</span><span class="s1">) {</span>
		<span class="s2">return </span><span class="s1">!node.computed &amp;&amp; is_reference(node.object</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s2">if </span><span class="s1">(node.type === </span><span class="s3">'Identifier'</span><span class="s1">) {</span>
		<span class="s2">if </span><span class="s1">(!parent) </span><span class="s2">return true;</span>

		<span class="s2">switch </span><span class="s1">(parent.type) {</span>
			<span class="s0">// disregard `bar` in `foo.bar`</span>
			<span class="s2">case </span><span class="s3">'MemberExpression'</span><span class="s1">: </span><span class="s2">return </span><span class="s1">parent.computed || node === parent.object</span><span class="s2">;</span>

			<span class="s0">// disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`</span>
			<span class="s2">case </span><span class="s3">'MethodDefinition'</span><span class="s1">: </span><span class="s2">return </span><span class="s1">parent.computed</span><span class="s2">;</span>

			<span class="s0">// disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`</span>
			<span class="s2">case </span><span class="s3">'PropertyDefinition'</span><span class="s1">: </span><span class="s2">return </span><span class="s1">parent.computed || node === parent.value</span><span class="s2">;</span>

			<span class="s0">// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`</span>
			<span class="s2">case </span><span class="s3">'Property'</span><span class="s1">: </span><span class="s2">return </span><span class="s1">parent.computed || node === parent.value</span><span class="s2">;</span>

			<span class="s0">// disregard the `bar` in `export { foo as bar }` or</span>
			<span class="s0">// the foo in `import { foo as bar }`</span>
			<span class="s2">case </span><span class="s3">'ExportSpecifier'</span><span class="s1">:</span>
			<span class="s2">case </span><span class="s3">'ImportSpecifier'</span><span class="s1">: </span><span class="s2">return </span><span class="s1">node === parent.local</span><span class="s2">;</span>

			<span class="s0">// disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`</span>
			<span class="s2">case </span><span class="s3">'LabeledStatement'</span><span class="s1">:</span>
			<span class="s2">case </span><span class="s3">'BreakStatement'</span><span class="s1">:</span>
			<span class="s2">case </span><span class="s3">'ContinueStatement'</span><span class="s1">: </span><span class="s2">return false;</span>
			<span class="s2">default</span><span class="s1">: </span><span class="s2">return true;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">return false;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">PureFunctionKey = Symbol(</span><span class="s3">'PureFunction'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getPureFunctions = ({ treeshake }) =&gt; {</span>
    <span class="s2">const </span><span class="s1">pureFunctions = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">functionName of treeshake ? treeshake.manualPureFunctions : []) {</span>
        <span class="s2">let </span><span class="s1">currentFunctions = pureFunctions</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathSegment of functionName.split(</span><span class="s3">'.'</span><span class="s1">)) {</span>
            <span class="s1">currentFunctions = currentFunctions[pathSegment] || (currentFunctions[pathSegment] = Object.create(</span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">currentFunctions[PureFunctionKey] = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pureFunctions</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">doNothing = () =&gt; { }</span><span class="s2">;</span>

<span class="s0">/* eslint sort-keys: &quot;off&quot; */</span>
<span class="s2">const </span><span class="s1">ValueProperties = Symbol(</span><span class="s3">'Value Properties'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getTruthyLiteralValue = () =&gt; UnknownTruthyValue</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">returnFalse = () =&gt; </span><span class="s2">false;</span>
<span class="s2">const </span><span class="s1">returnTrue = () =&gt; </span><span class="s2">true;</span>
<span class="s2">const </span><span class="s1">PURE = {</span>
    <span class="s1">deoptimizeArgumentsOnCall: doNothing</span><span class="s2">,</span>
    <span class="s1">getLiteralValue: getTruthyLiteralValue</span><span class="s2">,</span>
    <span class="s1">hasEffectsWhenCalled: returnFalse</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">IMPURE = {</span>
    <span class="s1">deoptimizeArgumentsOnCall: doNothing</span><span class="s2">,</span>
    <span class="s1">getLiteralValue: getTruthyLiteralValue</span><span class="s2">,</span>
    <span class="s1">hasEffectsWhenCalled: returnTrue</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">// We use shortened variables to reduce file size here</span>
<span class="s0">/* OBJECT */</span>
<span class="s2">const </span><span class="s1">O = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: IMPURE</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/* PURE FUNCTION */</span>
<span class="s2">const </span><span class="s1">PF = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: PURE</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/* FUNCTION THAT MUTATES FIRST ARG WITHOUT TRIGGERING ACCESSORS */</span>
<span class="s2">const </span><span class="s1">MUTATES_ARG_WITHOUT_ACCESSOR = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: {</span>
        <span class="s1">deoptimizeArgumentsOnCall({ args: [</span><span class="s2">, </span><span class="s1">firstArgument] }) {</span>
            <span class="s1">firstArgument?.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">getLiteralValue: getTruthyLiteralValue</span><span class="s2">,</span>
        <span class="s1">hasEffectsWhenCalled({ args }</span><span class="s2">, </span><span class="s1">context) {</span>
            <span class="s2">return </span><span class="s1">(args.length &lt;= </span><span class="s4">1 </span><span class="s1">||</span>
                <span class="s1">args[</span><span class="s4">1</span><span class="s1">].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ASSIGNMENT</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/* CONSTRUCTOR */</span>
<span class="s2">const </span><span class="s1">C = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
    <span class="s1">prototype: O</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/* PURE CONSTRUCTOR */</span>
<span class="s2">const </span><span class="s1">PC = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
    <span class="s1">prototype: O</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ARRAY_TYPE = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
    <span class="s1">from: PF</span><span class="s2">,</span>
    <span class="s1">of: PF</span><span class="s2">,</span>
    <span class="s1">prototype: O</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTL_MEMBER = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
    <span class="s1">supportedLocalesOf: PC</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">knownGlobals = {</span>
    <span class="s0">// Placeholders for global objects to avoid shape mutations</span>
    <span class="s1">global: O</span><span class="s2">,</span>
    <span class="s1">globalThis: O</span><span class="s2">,</span>
    <span class="s1">self: O</span><span class="s2">,</span>
    <span class="s1">window: O</span><span class="s2">,</span>
    <span class="s0">// Common globals</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
    <span class="s1">Array: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
        <span class="s1">from: O</span><span class="s2">,</span>
        <span class="s1">isArray: PF</span><span class="s2">,</span>
        <span class="s1">of: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">ArrayBuffer: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s1">isView: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">Atomics: O</span><span class="s2">,</span>
    <span class="s1">BigInt: C</span><span class="s2">,</span>
    <span class="s1">BigInt64Array: C</span><span class="s2">,</span>
    <span class="s1">BigUint64Array: C</span><span class="s2">,</span>
    <span class="s1">Boolean: PC</span><span class="s2">,</span>
    <span class="s1">constructor: C</span><span class="s2">,</span>
    <span class="s1">DataView: PC</span><span class="s2">,</span>
    <span class="s1">Date: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s1">now: PF</span><span class="s2">,</span>
        <span class="s1">parse: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span><span class="s2">,</span>
        <span class="s1">UTC: PF</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">decodeURI: PF</span><span class="s2">,</span>
    <span class="s1">decodeURIComponent: PF</span><span class="s2">,</span>
    <span class="s1">encodeURI: PF</span><span class="s2">,</span>
    <span class="s1">encodeURIComponent: PF</span><span class="s2">,</span>
    <span class="s1">Error: PC</span><span class="s2">,</span>
    <span class="s1">escape: PF</span><span class="s2">,</span>
    <span class="s1">eval: O</span><span class="s2">,</span>
    <span class="s1">EvalError: PC</span><span class="s2">,</span>
    <span class="s1">Float32Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Float64Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Function: C</span><span class="s2">,</span>
    <span class="s1">hasOwnProperty: O</span><span class="s2">,</span>
    <span class="s1">Infinity: O</span><span class="s2">,</span>
    <span class="s1">Int16Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Int32Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Int8Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">isFinite: PF</span><span class="s2">,</span>
    <span class="s1">isNaN: PF</span><span class="s2">,</span>
    <span class="s1">isPrototypeOf: O</span><span class="s2">,</span>
    <span class="s1">JSON: O</span><span class="s2">,</span>
    <span class="s1">Map: PC</span><span class="s2">,</span>
    <span class="s1">Math: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
        <span class="s1">abs: PF</span><span class="s2">,</span>
        <span class="s1">acos: PF</span><span class="s2">,</span>
        <span class="s1">acosh: PF</span><span class="s2">,</span>
        <span class="s1">asin: PF</span><span class="s2">,</span>
        <span class="s1">asinh: PF</span><span class="s2">,</span>
        <span class="s1">atan: PF</span><span class="s2">,</span>
        <span class="s1">atan2: PF</span><span class="s2">,</span>
        <span class="s1">atanh: PF</span><span class="s2">,</span>
        <span class="s1">cbrt: PF</span><span class="s2">,</span>
        <span class="s1">ceil: PF</span><span class="s2">,</span>
        <span class="s1">clz32: PF</span><span class="s2">,</span>
        <span class="s1">cos: PF</span><span class="s2">,</span>
        <span class="s1">cosh: PF</span><span class="s2">,</span>
        <span class="s1">exp: PF</span><span class="s2">,</span>
        <span class="s1">expm1: PF</span><span class="s2">,</span>
        <span class="s1">floor: PF</span><span class="s2">,</span>
        <span class="s1">fround: PF</span><span class="s2">,</span>
        <span class="s1">hypot: PF</span><span class="s2">,</span>
        <span class="s1">imul: PF</span><span class="s2">,</span>
        <span class="s1">log: PF</span><span class="s2">,</span>
        <span class="s1">log10: PF</span><span class="s2">,</span>
        <span class="s1">log1p: PF</span><span class="s2">,</span>
        <span class="s1">log2: PF</span><span class="s2">,</span>
        <span class="s1">max: PF</span><span class="s2">,</span>
        <span class="s1">min: PF</span><span class="s2">,</span>
        <span class="s1">pow: PF</span><span class="s2">,</span>
        <span class="s1">random: PF</span><span class="s2">,</span>
        <span class="s1">round: PF</span><span class="s2">,</span>
        <span class="s1">sign: PF</span><span class="s2">,</span>
        <span class="s1">sin: PF</span><span class="s2">,</span>
        <span class="s1">sinh: PF</span><span class="s2">,</span>
        <span class="s1">sqrt: PF</span><span class="s2">,</span>
        <span class="s1">tan: PF</span><span class="s2">,</span>
        <span class="s1">tanh: PF</span><span class="s2">,</span>
        <span class="s1">trunc: PF</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">NaN: O</span><span class="s2">,</span>
    <span class="s1">Number: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s1">isFinite: PF</span><span class="s2">,</span>
        <span class="s1">isInteger: PF</span><span class="s2">,</span>
        <span class="s1">isNaN: PF</span><span class="s2">,</span>
        <span class="s1">isSafeInteger: PF</span><span class="s2">,</span>
        <span class="s1">parseFloat: PF</span><span class="s2">,</span>
        <span class="s1">parseInt: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">Object: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s1">create: PF</span><span class="s2">,</span>
        <span class="s0">// Technically those can throw in certain situations, but we ignore this as</span>
        <span class="s0">// code that relies on this will hopefully wrap this in a try-catch, which</span>
        <span class="s0">// deoptimizes everything anyway</span>
        <span class="s1">defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR</span><span class="s2">,</span>
        <span class="s1">defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR</span><span class="s2">,</span>
        <span class="s1">freeze: MUTATES_ARG_WITHOUT_ACCESSOR</span><span class="s2">,</span>
        <span class="s1">getOwnPropertyDescriptor: PF</span><span class="s2">,</span>
        <span class="s1">getOwnPropertyDescriptors: PF</span><span class="s2">,</span>
        <span class="s1">getOwnPropertyNames: PF</span><span class="s2">,</span>
        <span class="s1">getOwnPropertySymbols: PF</span><span class="s2">,</span>
        <span class="s1">getPrototypeOf: PF</span><span class="s2">,</span>
        <span class="s1">hasOwn: PF</span><span class="s2">,</span>
        <span class="s1">is: PF</span><span class="s2">,</span>
        <span class="s1">isExtensible: PF</span><span class="s2">,</span>
        <span class="s1">isFrozen: PF</span><span class="s2">,</span>
        <span class="s1">isSealed: PF</span><span class="s2">,</span>
        <span class="s1">keys: PF</span><span class="s2">,</span>
        <span class="s1">fromEntries: PF</span><span class="s2">,</span>
        <span class="s1">entries: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">parseFloat: PF</span><span class="s2">,</span>
    <span class="s1">parseInt: PF</span><span class="s2">,</span>
    <span class="s1">Promise: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
        <span class="s1">all: O</span><span class="s2">,</span>
        <span class="s1">allSettled: O</span><span class="s2">,</span>
        <span class="s1">any: O</span><span class="s2">,</span>
        <span class="s1">prototype: O</span><span class="s2">,</span>
        <span class="s1">race: O</span><span class="s2">,</span>
        <span class="s1">reject: O</span><span class="s2">,</span>
        <span class="s1">resolve: O</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">propertyIsEnumerable: O</span><span class="s2">,</span>
    <span class="s1">Proxy: O</span><span class="s2">,</span>
    <span class="s1">RangeError: PC</span><span class="s2">,</span>
    <span class="s1">ReferenceError: PC</span><span class="s2">,</span>
    <span class="s1">Reflect: O</span><span class="s2">,</span>
    <span class="s1">RegExp: PC</span><span class="s2">,</span>
    <span class="s1">Set: PC</span><span class="s2">,</span>
    <span class="s1">SharedArrayBuffer: C</span><span class="s2">,</span>
    <span class="s1">String: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s1">fromCharCode: PF</span><span class="s2">,</span>
        <span class="s1">fromCodePoint: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span><span class="s2">,</span>
        <span class="s1">raw: PF</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">Symbol: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: PURE</span><span class="s2">,</span>
        <span class="s2">for</span><span class="s1">: PF</span><span class="s2">,</span>
        <span class="s1">keyFor: PF</span><span class="s2">,</span>
        <span class="s1">prototype: O</span><span class="s2">,</span>
        <span class="s1">toStringTag: {</span>
            <span class="s1">__proto__: </span><span class="s2">null,</span>
            <span class="s1">[ValueProperties]: {</span>
                <span class="s1">deoptimizeArgumentsOnCall: doNothing</span><span class="s2">,</span>
                <span class="s1">getLiteralValue() {</span>
                    <span class="s2">return </span><span class="s1">SymbolToStringTag</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">hasEffectsWhenCalled: returnTrue</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">SyntaxError: PC</span><span class="s2">,</span>
    <span class="s1">toLocaleString: O</span><span class="s2">,</span>
    <span class="s1">toString: O</span><span class="s2">,</span>
    <span class="s1">TypeError: PC</span><span class="s2">,</span>
    <span class="s1">Uint16Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Uint32Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Uint8Array: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s1">Uint8ClampedArray: ARRAY_TYPE</span><span class="s2">,</span>
    <span class="s0">// Technically, this is a global, but it needs special handling</span>
    <span class="s0">// undefined: ?,</span>
    <span class="s1">unescape: PF</span><span class="s2">,</span>
    <span class="s1">URIError: PC</span><span class="s2">,</span>
    <span class="s1">valueOf: O</span><span class="s2">,</span>
    <span class="s1">WeakMap: PC</span><span class="s2">,</span>
    <span class="s1">WeakSet: PC</span><span class="s2">,</span>
    <span class="s0">// Additional globals shared by Node and Browser that are not strictly part of the language</span>
    <span class="s1">clearInterval: C</span><span class="s2">,</span>
    <span class="s1">clearTimeout: C</span><span class="s2">,</span>
    <span class="s1">console: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
        <span class="s1">assert: C</span><span class="s2">,</span>
        <span class="s1">clear: C</span><span class="s2">,</span>
        <span class="s1">count: C</span><span class="s2">,</span>
        <span class="s1">countReset: C</span><span class="s2">,</span>
        <span class="s1">debug: C</span><span class="s2">,</span>
        <span class="s1">dir: C</span><span class="s2">,</span>
        <span class="s1">dirxml: C</span><span class="s2">,</span>
        <span class="s1">error: C</span><span class="s2">,</span>
        <span class="s1">exception: C</span><span class="s2">,</span>
        <span class="s1">group: C</span><span class="s2">,</span>
        <span class="s1">groupCollapsed: C</span><span class="s2">,</span>
        <span class="s1">groupEnd: C</span><span class="s2">,</span>
        <span class="s1">info: C</span><span class="s2">,</span>
        <span class="s1">log: C</span><span class="s2">,</span>
        <span class="s1">table: C</span><span class="s2">,</span>
        <span class="s1">time: C</span><span class="s2">,</span>
        <span class="s1">timeEnd: C</span><span class="s2">,</span>
        <span class="s1">timeLog: C</span><span class="s2">,</span>
        <span class="s1">trace: C</span><span class="s2">,</span>
        <span class="s1">warn: C</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">Intl: {</span>
        <span class="s1">__proto__: </span><span class="s2">null,</span>
        <span class="s1">[ValueProperties]: IMPURE</span><span class="s2">,</span>
        <span class="s1">Collator: INTL_MEMBER</span><span class="s2">,</span>
        <span class="s1">DateTimeFormat: INTL_MEMBER</span><span class="s2">,</span>
        <span class="s1">ListFormat: INTL_MEMBER</span><span class="s2">,</span>
        <span class="s1">NumberFormat: INTL_MEMBER</span><span class="s2">,</span>
        <span class="s1">PluralRules: INTL_MEMBER</span><span class="s2">,</span>
        <span class="s1">RelativeTimeFormat: INTL_MEMBER</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">setInterval: C</span><span class="s2">,</span>
    <span class="s1">setTimeout: C</span><span class="s2">,</span>
    <span class="s1">TextDecoder: C</span><span class="s2">,</span>
    <span class="s1">TextEncoder: C</span><span class="s2">,</span>
    <span class="s1">URL: C</span><span class="s2">,</span>
    <span class="s1">URLSearchParams: C</span><span class="s2">,</span>
    <span class="s0">// Browser specific globals</span>
    <span class="s1">AbortController: C</span><span class="s2">,</span>
    <span class="s1">AbortSignal: C</span><span class="s2">,</span>
    <span class="s1">addEventListener: O</span><span class="s2">,</span>
    <span class="s1">alert: O</span><span class="s2">,</span>
    <span class="s1">AnalyserNode: C</span><span class="s2">,</span>
    <span class="s1">Animation: C</span><span class="s2">,</span>
    <span class="s1">AnimationEvent: C</span><span class="s2">,</span>
    <span class="s1">applicationCache: O</span><span class="s2">,</span>
    <span class="s1">ApplicationCache: C</span><span class="s2">,</span>
    <span class="s1">ApplicationCacheErrorEvent: C</span><span class="s2">,</span>
    <span class="s1">atob: O</span><span class="s2">,</span>
    <span class="s1">Attr: C</span><span class="s2">,</span>
    <span class="s1">Audio: C</span><span class="s2">,</span>
    <span class="s1">AudioBuffer: C</span><span class="s2">,</span>
    <span class="s1">AudioBufferSourceNode: C</span><span class="s2">,</span>
    <span class="s1">AudioContext: C</span><span class="s2">,</span>
    <span class="s1">AudioDestinationNode: C</span><span class="s2">,</span>
    <span class="s1">AudioListener: C</span><span class="s2">,</span>
    <span class="s1">AudioNode: C</span><span class="s2">,</span>
    <span class="s1">AudioParam: C</span><span class="s2">,</span>
    <span class="s1">AudioProcessingEvent: C</span><span class="s2">,</span>
    <span class="s1">AudioScheduledSourceNode: C</span><span class="s2">,</span>
    <span class="s1">AudioWorkletNode: C</span><span class="s2">,</span>
    <span class="s1">BarProp: C</span><span class="s2">,</span>
    <span class="s1">BaseAudioContext: C</span><span class="s2">,</span>
    <span class="s1">BatteryManager: C</span><span class="s2">,</span>
    <span class="s1">BeforeUnloadEvent: C</span><span class="s2">,</span>
    <span class="s1">BiquadFilterNode: C</span><span class="s2">,</span>
    <span class="s1">Blob: C</span><span class="s2">,</span>
    <span class="s1">BlobEvent: C</span><span class="s2">,</span>
    <span class="s1">blur: O</span><span class="s2">,</span>
    <span class="s1">BroadcastChannel: C</span><span class="s2">,</span>
    <span class="s1">btoa: O</span><span class="s2">,</span>
    <span class="s1">ByteLengthQueuingStrategy: C</span><span class="s2">,</span>
    <span class="s1">Cache: C</span><span class="s2">,</span>
    <span class="s1">caches: O</span><span class="s2">,</span>
    <span class="s1">CacheStorage: C</span><span class="s2">,</span>
    <span class="s1">cancelAnimationFrame: O</span><span class="s2">,</span>
    <span class="s1">cancelIdleCallback: O</span><span class="s2">,</span>
    <span class="s1">CanvasCaptureMediaStreamTrack: C</span><span class="s2">,</span>
    <span class="s1">CanvasGradient: C</span><span class="s2">,</span>
    <span class="s1">CanvasPattern: C</span><span class="s2">,</span>
    <span class="s1">CanvasRenderingContext2D: C</span><span class="s2">,</span>
    <span class="s1">ChannelMergerNode: C</span><span class="s2">,</span>
    <span class="s1">ChannelSplitterNode: C</span><span class="s2">,</span>
    <span class="s1">CharacterData: C</span><span class="s2">,</span>
    <span class="s1">clientInformation: O</span><span class="s2">,</span>
    <span class="s1">ClipboardEvent: C</span><span class="s2">,</span>
    <span class="s1">close: O</span><span class="s2">,</span>
    <span class="s1">closed: O</span><span class="s2">,</span>
    <span class="s1">CloseEvent: C</span><span class="s2">,</span>
    <span class="s1">Comment: C</span><span class="s2">,</span>
    <span class="s1">CompositionEvent: C</span><span class="s2">,</span>
    <span class="s1">confirm: O</span><span class="s2">,</span>
    <span class="s1">ConstantSourceNode: C</span><span class="s2">,</span>
    <span class="s1">ConvolverNode: C</span><span class="s2">,</span>
    <span class="s1">CountQueuingStrategy: C</span><span class="s2">,</span>
    <span class="s1">createImageBitmap: O</span><span class="s2">,</span>
    <span class="s1">Credential: C</span><span class="s2">,</span>
    <span class="s1">CredentialsContainer: C</span><span class="s2">,</span>
    <span class="s1">crypto: O</span><span class="s2">,</span>
    <span class="s1">Crypto: C</span><span class="s2">,</span>
    <span class="s1">CryptoKey: C</span><span class="s2">,</span>
    <span class="s1">CSS: C</span><span class="s2">,</span>
    <span class="s1">CSSConditionRule: C</span><span class="s2">,</span>
    <span class="s1">CSSFontFaceRule: C</span><span class="s2">,</span>
    <span class="s1">CSSGroupingRule: C</span><span class="s2">,</span>
    <span class="s1">CSSImportRule: C</span><span class="s2">,</span>
    <span class="s1">CSSKeyframeRule: C</span><span class="s2">,</span>
    <span class="s1">CSSKeyframesRule: C</span><span class="s2">,</span>
    <span class="s1">CSSMediaRule: C</span><span class="s2">,</span>
    <span class="s1">CSSNamespaceRule: C</span><span class="s2">,</span>
    <span class="s1">CSSPageRule: C</span><span class="s2">,</span>
    <span class="s1">CSSRule: C</span><span class="s2">,</span>
    <span class="s1">CSSRuleList: C</span><span class="s2">,</span>
    <span class="s1">CSSStyleDeclaration: C</span><span class="s2">,</span>
    <span class="s1">CSSStyleRule: C</span><span class="s2">,</span>
    <span class="s1">CSSStyleSheet: C</span><span class="s2">,</span>
    <span class="s1">CSSSupportsRule: C</span><span class="s2">,</span>
    <span class="s1">CustomElementRegistry: C</span><span class="s2">,</span>
    <span class="s1">customElements: O</span><span class="s2">,</span>
    <span class="s1">CustomEvent: C</span><span class="s2">,</span>
    <span class="s1">DataTransfer: C</span><span class="s2">,</span>
    <span class="s1">DataTransferItem: C</span><span class="s2">,</span>
    <span class="s1">DataTransferItemList: C</span><span class="s2">,</span>
    <span class="s1">defaultstatus: O</span><span class="s2">,</span>
    <span class="s1">defaultStatus: O</span><span class="s2">,</span>
    <span class="s1">DelayNode: C</span><span class="s2">,</span>
    <span class="s1">DeviceMotionEvent: C</span><span class="s2">,</span>
    <span class="s1">DeviceOrientationEvent: C</span><span class="s2">,</span>
    <span class="s1">devicePixelRatio: O</span><span class="s2">,</span>
    <span class="s1">dispatchEvent: O</span><span class="s2">,</span>
    <span class="s1">document: O</span><span class="s2">,</span>
    <span class="s1">Document: C</span><span class="s2">,</span>
    <span class="s1">DocumentFragment: C</span><span class="s2">,</span>
    <span class="s1">DocumentType: C</span><span class="s2">,</span>
    <span class="s1">DOMError: C</span><span class="s2">,</span>
    <span class="s1">DOMException: C</span><span class="s2">,</span>
    <span class="s1">DOMImplementation: C</span><span class="s2">,</span>
    <span class="s1">DOMMatrix: C</span><span class="s2">,</span>
    <span class="s1">DOMMatrixReadOnly: C</span><span class="s2">,</span>
    <span class="s1">DOMParser: C</span><span class="s2">,</span>
    <span class="s1">DOMPoint: C</span><span class="s2">,</span>
    <span class="s1">DOMPointReadOnly: C</span><span class="s2">,</span>
    <span class="s1">DOMQuad: C</span><span class="s2">,</span>
    <span class="s1">DOMRect: C</span><span class="s2">,</span>
    <span class="s1">DOMRectReadOnly: C</span><span class="s2">,</span>
    <span class="s1">DOMStringList: C</span><span class="s2">,</span>
    <span class="s1">DOMStringMap: C</span><span class="s2">,</span>
    <span class="s1">DOMTokenList: C</span><span class="s2">,</span>
    <span class="s1">DragEvent: C</span><span class="s2">,</span>
    <span class="s1">DynamicsCompressorNode: C</span><span class="s2">,</span>
    <span class="s1">Element: C</span><span class="s2">,</span>
    <span class="s1">ErrorEvent: C</span><span class="s2">,</span>
    <span class="s1">Event: C</span><span class="s2">,</span>
    <span class="s1">EventSource: C</span><span class="s2">,</span>
    <span class="s1">EventTarget: C</span><span class="s2">,</span>
    <span class="s1">external: O</span><span class="s2">,</span>
    <span class="s1">fetch: O</span><span class="s2">,</span>
    <span class="s1">File: C</span><span class="s2">,</span>
    <span class="s1">FileList: C</span><span class="s2">,</span>
    <span class="s1">FileReader: C</span><span class="s2">,</span>
    <span class="s1">find: O</span><span class="s2">,</span>
    <span class="s1">focus: O</span><span class="s2">,</span>
    <span class="s1">FocusEvent: C</span><span class="s2">,</span>
    <span class="s1">FontFace: C</span><span class="s2">,</span>
    <span class="s1">FontFaceSetLoadEvent: C</span><span class="s2">,</span>
    <span class="s1">FormData: C</span><span class="s2">,</span>
    <span class="s1">frames: O</span><span class="s2">,</span>
    <span class="s1">GainNode: C</span><span class="s2">,</span>
    <span class="s1">Gamepad: C</span><span class="s2">,</span>
    <span class="s1">GamepadButton: C</span><span class="s2">,</span>
    <span class="s1">GamepadEvent: C</span><span class="s2">,</span>
    <span class="s1">getComputedStyle: O</span><span class="s2">,</span>
    <span class="s1">getSelection: O</span><span class="s2">,</span>
    <span class="s1">HashChangeEvent: C</span><span class="s2">,</span>
    <span class="s1">Headers: C</span><span class="s2">,</span>
    <span class="s1">history: O</span><span class="s2">,</span>
    <span class="s1">History: C</span><span class="s2">,</span>
    <span class="s1">HTMLAllCollection: C</span><span class="s2">,</span>
    <span class="s1">HTMLAnchorElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLAreaElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLAudioElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLBaseElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLBodyElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLBRElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLButtonElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLCanvasElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLCollection: C</span><span class="s2">,</span>
    <span class="s1">HTMLContentElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDataElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDataListElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDetailsElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDialogElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDirectoryElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDivElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDListElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLDocument: C</span><span class="s2">,</span>
    <span class="s1">HTMLElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLEmbedElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLFieldSetElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLFontElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLFormControlsCollection: C</span><span class="s2">,</span>
    <span class="s1">HTMLFormElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLFrameElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLFrameSetElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLHeadElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLHeadingElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLHRElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLHtmlElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLIFrameElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLImageElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLInputElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLLabelElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLLegendElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLLIElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLLinkElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMapElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMarqueeElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMediaElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMenuElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMetaElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLMeterElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLModElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLObjectElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLOListElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLOptGroupElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLOptionElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLOptionsCollection: C</span><span class="s2">,</span>
    <span class="s1">HTMLOutputElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLParagraphElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLParamElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLPictureElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLPreElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLProgressElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLQuoteElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLScriptElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLSelectElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLShadowElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLSlotElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLSourceElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLSpanElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLStyleElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableCaptionElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableCellElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableColElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableRowElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTableSectionElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTemplateElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTextAreaElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTimeElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTitleElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLTrackElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLUListElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLUnknownElement: C</span><span class="s2">,</span>
    <span class="s1">HTMLVideoElement: C</span><span class="s2">,</span>
    <span class="s1">IDBCursor: C</span><span class="s2">,</span>
    <span class="s1">IDBCursorWithValue: C</span><span class="s2">,</span>
    <span class="s1">IDBDatabase: C</span><span class="s2">,</span>
    <span class="s1">IDBFactory: C</span><span class="s2">,</span>
    <span class="s1">IDBIndex: C</span><span class="s2">,</span>
    <span class="s1">IDBKeyRange: C</span><span class="s2">,</span>
    <span class="s1">IDBObjectStore: C</span><span class="s2">,</span>
    <span class="s1">IDBOpenDBRequest: C</span><span class="s2">,</span>
    <span class="s1">IDBRequest: C</span><span class="s2">,</span>
    <span class="s1">IDBTransaction: C</span><span class="s2">,</span>
    <span class="s1">IDBVersionChangeEvent: C</span><span class="s2">,</span>
    <span class="s1">IdleDeadline: C</span><span class="s2">,</span>
    <span class="s1">IIRFilterNode: C</span><span class="s2">,</span>
    <span class="s1">Image: C</span><span class="s2">,</span>
    <span class="s1">ImageBitmap: C</span><span class="s2">,</span>
    <span class="s1">ImageBitmapRenderingContext: C</span><span class="s2">,</span>
    <span class="s1">ImageCapture: C</span><span class="s2">,</span>
    <span class="s1">ImageData: C</span><span class="s2">,</span>
    <span class="s1">indexedDB: O</span><span class="s2">,</span>
    <span class="s1">innerHeight: O</span><span class="s2">,</span>
    <span class="s1">innerWidth: O</span><span class="s2">,</span>
    <span class="s1">InputEvent: C</span><span class="s2">,</span>
    <span class="s1">IntersectionObserver: C</span><span class="s2">,</span>
    <span class="s1">IntersectionObserverEntry: C</span><span class="s2">,</span>
    <span class="s1">isSecureContext: O</span><span class="s2">,</span>
    <span class="s1">KeyboardEvent: C</span><span class="s2">,</span>
    <span class="s1">KeyframeEffect: C</span><span class="s2">,</span>
    <span class="s1">length: O</span><span class="s2">,</span>
    <span class="s1">localStorage: O</span><span class="s2">,</span>
    <span class="s1">location: O</span><span class="s2">,</span>
    <span class="s1">Location: C</span><span class="s2">,</span>
    <span class="s1">locationbar: O</span><span class="s2">,</span>
    <span class="s1">matchMedia: O</span><span class="s2">,</span>
    <span class="s1">MediaDeviceInfo: C</span><span class="s2">,</span>
    <span class="s1">MediaDevices: C</span><span class="s2">,</span>
    <span class="s1">MediaElementAudioSourceNode: C</span><span class="s2">,</span>
    <span class="s1">MediaEncryptedEvent: C</span><span class="s2">,</span>
    <span class="s1">MediaError: C</span><span class="s2">,</span>
    <span class="s1">MediaKeyMessageEvent: C</span><span class="s2">,</span>
    <span class="s1">MediaKeySession: C</span><span class="s2">,</span>
    <span class="s1">MediaKeyStatusMap: C</span><span class="s2">,</span>
    <span class="s1">MediaKeySystemAccess: C</span><span class="s2">,</span>
    <span class="s1">MediaList: C</span><span class="s2">,</span>
    <span class="s1">MediaQueryList: C</span><span class="s2">,</span>
    <span class="s1">MediaQueryListEvent: C</span><span class="s2">,</span>
    <span class="s1">MediaRecorder: C</span><span class="s2">,</span>
    <span class="s1">MediaSettingsRange: C</span><span class="s2">,</span>
    <span class="s1">MediaSource: C</span><span class="s2">,</span>
    <span class="s1">MediaStream: C</span><span class="s2">,</span>
    <span class="s1">MediaStreamAudioDestinationNode: C</span><span class="s2">,</span>
    <span class="s1">MediaStreamAudioSourceNode: C</span><span class="s2">,</span>
    <span class="s1">MediaStreamEvent: C</span><span class="s2">,</span>
    <span class="s1">MediaStreamTrack: C</span><span class="s2">,</span>
    <span class="s1">MediaStreamTrackEvent: C</span><span class="s2">,</span>
    <span class="s1">menubar: O</span><span class="s2">,</span>
    <span class="s1">MessageChannel: C</span><span class="s2">,</span>
    <span class="s1">MessageEvent: C</span><span class="s2">,</span>
    <span class="s1">MessagePort: C</span><span class="s2">,</span>
    <span class="s1">MIDIAccess: C</span><span class="s2">,</span>
    <span class="s1">MIDIConnectionEvent: C</span><span class="s2">,</span>
    <span class="s1">MIDIInput: C</span><span class="s2">,</span>
    <span class="s1">MIDIInputMap: C</span><span class="s2">,</span>
    <span class="s1">MIDIMessageEvent: C</span><span class="s2">,</span>
    <span class="s1">MIDIOutput: C</span><span class="s2">,</span>
    <span class="s1">MIDIOutputMap: C</span><span class="s2">,</span>
    <span class="s1">MIDIPort: C</span><span class="s2">,</span>
    <span class="s1">MimeType: C</span><span class="s2">,</span>
    <span class="s1">MimeTypeArray: C</span><span class="s2">,</span>
    <span class="s1">MouseEvent: C</span><span class="s2">,</span>
    <span class="s1">moveBy: O</span><span class="s2">,</span>
    <span class="s1">moveTo: O</span><span class="s2">,</span>
    <span class="s1">MutationEvent: C</span><span class="s2">,</span>
    <span class="s1">MutationObserver: C</span><span class="s2">,</span>
    <span class="s1">MutationRecord: C</span><span class="s2">,</span>
    <span class="s1">name: O</span><span class="s2">,</span>
    <span class="s1">NamedNodeMap: C</span><span class="s2">,</span>
    <span class="s1">NavigationPreloadManager: C</span><span class="s2">,</span>
    <span class="s1">navigator: O</span><span class="s2">,</span>
    <span class="s1">Navigator: C</span><span class="s2">,</span>
    <span class="s1">NetworkInformation: C</span><span class="s2">,</span>
    <span class="s1">Node: C</span><span class="s2">,</span>
    <span class="s1">NodeFilter: O</span><span class="s2">,</span>
    <span class="s1">NodeIterator: C</span><span class="s2">,</span>
    <span class="s1">NodeList: C</span><span class="s2">,</span>
    <span class="s1">Notification: C</span><span class="s2">,</span>
    <span class="s1">OfflineAudioCompletionEvent: C</span><span class="s2">,</span>
    <span class="s1">OfflineAudioContext: C</span><span class="s2">,</span>
    <span class="s1">offscreenBuffering: O</span><span class="s2">,</span>
    <span class="s1">OffscreenCanvas: C</span><span class="s2">,</span>
    <span class="s1">open: O</span><span class="s2">,</span>
    <span class="s1">openDatabase: O</span><span class="s2">,</span>
    <span class="s1">Option: C</span><span class="s2">,</span>
    <span class="s1">origin: O</span><span class="s2">,</span>
    <span class="s1">OscillatorNode: C</span><span class="s2">,</span>
    <span class="s1">outerHeight: O</span><span class="s2">,</span>
    <span class="s1">outerWidth: O</span><span class="s2">,</span>
    <span class="s1">PageTransitionEvent: C</span><span class="s2">,</span>
    <span class="s1">pageXOffset: O</span><span class="s2">,</span>
    <span class="s1">pageYOffset: O</span><span class="s2">,</span>
    <span class="s1">PannerNode: C</span><span class="s2">,</span>
    <span class="s1">parent: O</span><span class="s2">,</span>
    <span class="s1">Path2D: C</span><span class="s2">,</span>
    <span class="s1">PaymentAddress: C</span><span class="s2">,</span>
    <span class="s1">PaymentRequest: C</span><span class="s2">,</span>
    <span class="s1">PaymentRequestUpdateEvent: C</span><span class="s2">,</span>
    <span class="s1">PaymentResponse: C</span><span class="s2">,</span>
    <span class="s1">performance: O</span><span class="s2">,</span>
    <span class="s1">Performance: C</span><span class="s2">,</span>
    <span class="s1">PerformanceEntry: C</span><span class="s2">,</span>
    <span class="s1">PerformanceLongTaskTiming: C</span><span class="s2">,</span>
    <span class="s1">PerformanceMark: C</span><span class="s2">,</span>
    <span class="s1">PerformanceMeasure: C</span><span class="s2">,</span>
    <span class="s1">PerformanceNavigation: C</span><span class="s2">,</span>
    <span class="s1">PerformanceNavigationTiming: C</span><span class="s2">,</span>
    <span class="s1">PerformanceObserver: C</span><span class="s2">,</span>
    <span class="s1">PerformanceObserverEntryList: C</span><span class="s2">,</span>
    <span class="s1">PerformancePaintTiming: C</span><span class="s2">,</span>
    <span class="s1">PerformanceResourceTiming: C</span><span class="s2">,</span>
    <span class="s1">PerformanceTiming: C</span><span class="s2">,</span>
    <span class="s1">PeriodicWave: C</span><span class="s2">,</span>
    <span class="s1">Permissions: C</span><span class="s2">,</span>
    <span class="s1">PermissionStatus: C</span><span class="s2">,</span>
    <span class="s1">personalbar: O</span><span class="s2">,</span>
    <span class="s1">PhotoCapabilities: C</span><span class="s2">,</span>
    <span class="s1">Plugin: C</span><span class="s2">,</span>
    <span class="s1">PluginArray: C</span><span class="s2">,</span>
    <span class="s1">PointerEvent: C</span><span class="s2">,</span>
    <span class="s1">PopStateEvent: C</span><span class="s2">,</span>
    <span class="s1">postMessage: O</span><span class="s2">,</span>
    <span class="s1">Presentation: C</span><span class="s2">,</span>
    <span class="s1">PresentationAvailability: C</span><span class="s2">,</span>
    <span class="s1">PresentationConnection: C</span><span class="s2">,</span>
    <span class="s1">PresentationConnectionAvailableEvent: C</span><span class="s2">,</span>
    <span class="s1">PresentationConnectionCloseEvent: C</span><span class="s2">,</span>
    <span class="s1">PresentationConnectionList: C</span><span class="s2">,</span>
    <span class="s1">PresentationReceiver: C</span><span class="s2">,</span>
    <span class="s1">PresentationRequest: C</span><span class="s2">,</span>
    <span class="s1">print: O</span><span class="s2">,</span>
    <span class="s1">ProcessingInstruction: C</span><span class="s2">,</span>
    <span class="s1">ProgressEvent: C</span><span class="s2">,</span>
    <span class="s1">PromiseRejectionEvent: C</span><span class="s2">,</span>
    <span class="s1">prompt: O</span><span class="s2">,</span>
    <span class="s1">PushManager: C</span><span class="s2">,</span>
    <span class="s1">PushSubscription: C</span><span class="s2">,</span>
    <span class="s1">PushSubscriptionOptions: C</span><span class="s2">,</span>
    <span class="s1">queueMicrotask: O</span><span class="s2">,</span>
    <span class="s1">RadioNodeList: C</span><span class="s2">,</span>
    <span class="s1">Range: C</span><span class="s2">,</span>
    <span class="s1">ReadableStream: C</span><span class="s2">,</span>
    <span class="s1">RemotePlayback: C</span><span class="s2">,</span>
    <span class="s1">removeEventListener: O</span><span class="s2">,</span>
    <span class="s1">Request: C</span><span class="s2">,</span>
    <span class="s1">requestAnimationFrame: O</span><span class="s2">,</span>
    <span class="s1">requestIdleCallback: O</span><span class="s2">,</span>
    <span class="s1">resizeBy: O</span><span class="s2">,</span>
    <span class="s1">ResizeObserver: C</span><span class="s2">,</span>
    <span class="s1">ResizeObserverEntry: C</span><span class="s2">,</span>
    <span class="s1">resizeTo: O</span><span class="s2">,</span>
    <span class="s1">Response: C</span><span class="s2">,</span>
    <span class="s1">RTCCertificate: C</span><span class="s2">,</span>
    <span class="s1">RTCDataChannel: C</span><span class="s2">,</span>
    <span class="s1">RTCDataChannelEvent: C</span><span class="s2">,</span>
    <span class="s1">RTCDtlsTransport: C</span><span class="s2">,</span>
    <span class="s1">RTCIceCandidate: C</span><span class="s2">,</span>
    <span class="s1">RTCIceTransport: C</span><span class="s2">,</span>
    <span class="s1">RTCPeerConnection: C</span><span class="s2">,</span>
    <span class="s1">RTCPeerConnectionIceEvent: C</span><span class="s2">,</span>
    <span class="s1">RTCRtpReceiver: C</span><span class="s2">,</span>
    <span class="s1">RTCRtpSender: C</span><span class="s2">,</span>
    <span class="s1">RTCSctpTransport: C</span><span class="s2">,</span>
    <span class="s1">RTCSessionDescription: C</span><span class="s2">,</span>
    <span class="s1">RTCStatsReport: C</span><span class="s2">,</span>
    <span class="s1">RTCTrackEvent: C</span><span class="s2">,</span>
    <span class="s1">screen: O</span><span class="s2">,</span>
    <span class="s1">Screen: C</span><span class="s2">,</span>
    <span class="s1">screenLeft: O</span><span class="s2">,</span>
    <span class="s1">ScreenOrientation: C</span><span class="s2">,</span>
    <span class="s1">screenTop: O</span><span class="s2">,</span>
    <span class="s1">screenX: O</span><span class="s2">,</span>
    <span class="s1">screenY: O</span><span class="s2">,</span>
    <span class="s1">ScriptProcessorNode: C</span><span class="s2">,</span>
    <span class="s1">scroll: O</span><span class="s2">,</span>
    <span class="s1">scrollbars: O</span><span class="s2">,</span>
    <span class="s1">scrollBy: O</span><span class="s2">,</span>
    <span class="s1">scrollTo: O</span><span class="s2">,</span>
    <span class="s1">scrollX: O</span><span class="s2">,</span>
    <span class="s1">scrollY: O</span><span class="s2">,</span>
    <span class="s1">SecurityPolicyViolationEvent: C</span><span class="s2">,</span>
    <span class="s1">Selection: C</span><span class="s2">,</span>
    <span class="s1">ServiceWorker: C</span><span class="s2">,</span>
    <span class="s1">ServiceWorkerContainer: C</span><span class="s2">,</span>
    <span class="s1">ServiceWorkerRegistration: C</span><span class="s2">,</span>
    <span class="s1">sessionStorage: O</span><span class="s2">,</span>
    <span class="s1">ShadowRoot: C</span><span class="s2">,</span>
    <span class="s1">SharedWorker: C</span><span class="s2">,</span>
    <span class="s1">SourceBuffer: C</span><span class="s2">,</span>
    <span class="s1">SourceBufferList: C</span><span class="s2">,</span>
    <span class="s1">speechSynthesis: O</span><span class="s2">,</span>
    <span class="s1">SpeechSynthesisEvent: C</span><span class="s2">,</span>
    <span class="s1">SpeechSynthesisUtterance: C</span><span class="s2">,</span>
    <span class="s1">StaticRange: C</span><span class="s2">,</span>
    <span class="s1">status: O</span><span class="s2">,</span>
    <span class="s1">statusbar: O</span><span class="s2">,</span>
    <span class="s1">StereoPannerNode: C</span><span class="s2">,</span>
    <span class="s1">stop: O</span><span class="s2">,</span>
    <span class="s1">Storage: C</span><span class="s2">,</span>
    <span class="s1">StorageEvent: C</span><span class="s2">,</span>
    <span class="s1">StorageManager: C</span><span class="s2">,</span>
    <span class="s1">styleMedia: O</span><span class="s2">,</span>
    <span class="s1">StyleSheet: C</span><span class="s2">,</span>
    <span class="s1">StyleSheetList: C</span><span class="s2">,</span>
    <span class="s1">SubtleCrypto: C</span><span class="s2">,</span>
    <span class="s1">SVGAElement: C</span><span class="s2">,</span>
    <span class="s1">SVGAngle: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedAngle: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedBoolean: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedEnumeration: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedInteger: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedLength: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedLengthList: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedNumber: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedNumberList: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedPreserveAspectRatio: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedRect: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedString: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimatedTransformList: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimateElement: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimateMotionElement: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimateTransformElement: C</span><span class="s2">,</span>
    <span class="s1">SVGAnimationElement: C</span><span class="s2">,</span>
    <span class="s1">SVGCircleElement: C</span><span class="s2">,</span>
    <span class="s1">SVGClipPathElement: C</span><span class="s2">,</span>
    <span class="s1">SVGComponentTransferFunctionElement: C</span><span class="s2">,</span>
    <span class="s1">SVGDefsElement: C</span><span class="s2">,</span>
    <span class="s1">SVGDescElement: C</span><span class="s2">,</span>
    <span class="s1">SVGDiscardElement: C</span><span class="s2">,</span>
    <span class="s1">SVGElement: C</span><span class="s2">,</span>
    <span class="s1">SVGEllipseElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEBlendElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEColorMatrixElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEComponentTransferElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFECompositeElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEConvolveMatrixElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEDiffuseLightingElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEDisplacementMapElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEDistantLightElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEDropShadowElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEFloodElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEFuncAElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEFuncBElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEFuncGElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEFuncRElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEGaussianBlurElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEImageElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEMergeElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEMergeNodeElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEMorphologyElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEOffsetElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFEPointLightElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFESpecularLightingElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFESpotLightElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFETileElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFETurbulenceElement: C</span><span class="s2">,</span>
    <span class="s1">SVGFilterElement: C</span><span class="s2">,</span>
    <span class="s1">SVGForeignObjectElement: C</span><span class="s2">,</span>
    <span class="s1">SVGGElement: C</span><span class="s2">,</span>
    <span class="s1">SVGGeometryElement: C</span><span class="s2">,</span>
    <span class="s1">SVGGradientElement: C</span><span class="s2">,</span>
    <span class="s1">SVGGraphicsElement: C</span><span class="s2">,</span>
    <span class="s1">SVGImageElement: C</span><span class="s2">,</span>
    <span class="s1">SVGLength: C</span><span class="s2">,</span>
    <span class="s1">SVGLengthList: C</span><span class="s2">,</span>
    <span class="s1">SVGLinearGradientElement: C</span><span class="s2">,</span>
    <span class="s1">SVGLineElement: C</span><span class="s2">,</span>
    <span class="s1">SVGMarkerElement: C</span><span class="s2">,</span>
    <span class="s1">SVGMaskElement: C</span><span class="s2">,</span>
    <span class="s1">SVGMatrix: C</span><span class="s2">,</span>
    <span class="s1">SVGMetadataElement: C</span><span class="s2">,</span>
    <span class="s1">SVGMPathElement: C</span><span class="s2">,</span>
    <span class="s1">SVGNumber: C</span><span class="s2">,</span>
    <span class="s1">SVGNumberList: C</span><span class="s2">,</span>
    <span class="s1">SVGPathElement: C</span><span class="s2">,</span>
    <span class="s1">SVGPatternElement: C</span><span class="s2">,</span>
    <span class="s1">SVGPoint: C</span><span class="s2">,</span>
    <span class="s1">SVGPointList: C</span><span class="s2">,</span>
    <span class="s1">SVGPolygonElement: C</span><span class="s2">,</span>
    <span class="s1">SVGPolylineElement: C</span><span class="s2">,</span>
    <span class="s1">SVGPreserveAspectRatio: C</span><span class="s2">,</span>
    <span class="s1">SVGRadialGradientElement: C</span><span class="s2">,</span>
    <span class="s1">SVGRect: C</span><span class="s2">,</span>
    <span class="s1">SVGRectElement: C</span><span class="s2">,</span>
    <span class="s1">SVGScriptElement: C</span><span class="s2">,</span>
    <span class="s1">SVGSetElement: C</span><span class="s2">,</span>
    <span class="s1">SVGStopElement: C</span><span class="s2">,</span>
    <span class="s1">SVGStringList: C</span><span class="s2">,</span>
    <span class="s1">SVGStyleElement: C</span><span class="s2">,</span>
    <span class="s1">SVGSVGElement: C</span><span class="s2">,</span>
    <span class="s1">SVGSwitchElement: C</span><span class="s2">,</span>
    <span class="s1">SVGSymbolElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTextContentElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTextElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTextPathElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTextPositioningElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTitleElement: C</span><span class="s2">,</span>
    <span class="s1">SVGTransform: C</span><span class="s2">,</span>
    <span class="s1">SVGTransformList: C</span><span class="s2">,</span>
    <span class="s1">SVGTSpanElement: C</span><span class="s2">,</span>
    <span class="s1">SVGUnitTypes: C</span><span class="s2">,</span>
    <span class="s1">SVGUseElement: C</span><span class="s2">,</span>
    <span class="s1">SVGViewElement: C</span><span class="s2">,</span>
    <span class="s1">TaskAttributionTiming: C</span><span class="s2">,</span>
    <span class="s1">Text: C</span><span class="s2">,</span>
    <span class="s1">TextEvent: C</span><span class="s2">,</span>
    <span class="s1">TextMetrics: C</span><span class="s2">,</span>
    <span class="s1">TextTrack: C</span><span class="s2">,</span>
    <span class="s1">TextTrackCue: C</span><span class="s2">,</span>
    <span class="s1">TextTrackCueList: C</span><span class="s2">,</span>
    <span class="s1">TextTrackList: C</span><span class="s2">,</span>
    <span class="s1">TimeRanges: C</span><span class="s2">,</span>
    <span class="s1">toolbar: O</span><span class="s2">,</span>
    <span class="s1">top: O</span><span class="s2">,</span>
    <span class="s1">Touch: C</span><span class="s2">,</span>
    <span class="s1">TouchEvent: C</span><span class="s2">,</span>
    <span class="s1">TouchList: C</span><span class="s2">,</span>
    <span class="s1">TrackEvent: C</span><span class="s2">,</span>
    <span class="s1">TransitionEvent: C</span><span class="s2">,</span>
    <span class="s1">TreeWalker: C</span><span class="s2">,</span>
    <span class="s1">UIEvent: C</span><span class="s2">,</span>
    <span class="s1">ValidityState: C</span><span class="s2">,</span>
    <span class="s1">visualViewport: O</span><span class="s2">,</span>
    <span class="s1">VisualViewport: C</span><span class="s2">,</span>
    <span class="s1">VTTCue: C</span><span class="s2">,</span>
    <span class="s1">WaveShaperNode: C</span><span class="s2">,</span>
    <span class="s1">WebAssembly: O</span><span class="s2">,</span>
    <span class="s1">WebGL2RenderingContext: C</span><span class="s2">,</span>
    <span class="s1">WebGLActiveInfo: C</span><span class="s2">,</span>
    <span class="s1">WebGLBuffer: C</span><span class="s2">,</span>
    <span class="s1">WebGLContextEvent: C</span><span class="s2">,</span>
    <span class="s1">WebGLFramebuffer: C</span><span class="s2">,</span>
    <span class="s1">WebGLProgram: C</span><span class="s2">,</span>
    <span class="s1">WebGLQuery: C</span><span class="s2">,</span>
    <span class="s1">WebGLRenderbuffer: C</span><span class="s2">,</span>
    <span class="s1">WebGLRenderingContext: C</span><span class="s2">,</span>
    <span class="s1">WebGLSampler: C</span><span class="s2">,</span>
    <span class="s1">WebGLShader: C</span><span class="s2">,</span>
    <span class="s1">WebGLShaderPrecisionFormat: C</span><span class="s2">,</span>
    <span class="s1">WebGLSync: C</span><span class="s2">,</span>
    <span class="s1">WebGLTexture: C</span><span class="s2">,</span>
    <span class="s1">WebGLTransformFeedback: C</span><span class="s2">,</span>
    <span class="s1">WebGLUniformLocation: C</span><span class="s2">,</span>
    <span class="s1">WebGLVertexArrayObject: C</span><span class="s2">,</span>
    <span class="s1">WebSocket: C</span><span class="s2">,</span>
    <span class="s1">WheelEvent: C</span><span class="s2">,</span>
    <span class="s1">Window: C</span><span class="s2">,</span>
    <span class="s1">Worker: C</span><span class="s2">,</span>
    <span class="s1">WritableStream: C</span><span class="s2">,</span>
    <span class="s1">XMLDocument: C</span><span class="s2">,</span>
    <span class="s1">XMLHttpRequest: C</span><span class="s2">,</span>
    <span class="s1">XMLHttpRequestEventTarget: C</span><span class="s2">,</span>
    <span class="s1">XMLHttpRequestUpload: C</span><span class="s2">,</span>
    <span class="s1">XMLSerializer: C</span><span class="s2">,</span>
    <span class="s1">XPathEvaluator: C</span><span class="s2">,</span>
    <span class="s1">XPathExpression: C</span><span class="s2">,</span>
    <span class="s1">XPathResult: C</span><span class="s2">,</span>
    <span class="s1">XSLTProcessor: C</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">global of [</span><span class="s3">'window'</span><span class="s2">, </span><span class="s3">'global'</span><span class="s2">, </span><span class="s3">'self'</span><span class="s2">, </span><span class="s3">'globalThis'</span><span class="s1">]) {</span>
    <span class="s1">knownGlobals[global] = knownGlobals</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getGlobalAtPath(path) {</span>
    <span class="s2">let </span><span class="s1">currentGlobal = knownGlobals</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathSegment of path) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pathSegment !== </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s1">currentGlobal = currentGlobal[pathSegment]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!currentGlobal) {</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">currentGlobal[ValueProperties]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">GlobalVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s0">// Ensure we use live-bindings for globals as we do not know if they have</span>
        <span class="s0">// been reassigned</span>
        <span class="s2">this</span><span class="s1">.isReassigned = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">switch </span><span class="s1">(interaction.type) {</span>
            <span class="s0">// While there is no point in testing these cases as at the moment, they</span>
            <span class="s0">// are also covered via other means, we keep them for completeness</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ACCESSED:</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ASSIGNED: {</span>
                <span class="s2">if </span><span class="s1">(!getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, </span><span class="s1">...path].slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))) {</span>
                    <span class="s2">super</span><span class="s1">.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_CALLED: {</span>
                <span class="s2">const </span><span class="s1">globalAtPath = getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, </span><span class="s1">...path])</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(globalAtPath) {</span>
                    <span class="s1">globalAtPath.deoptimizeArgumentsOnCall(interaction)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">super</span><span class="s1">.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">_recursionTracker</span><span class="s2">, </span><span class="s1">_origin) {</span>
        <span class="s2">const </span><span class="s1">globalAtPath = getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, </span><span class="s1">...path])</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">switch </span><span class="s1">(interaction.type) {</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ACCESSED: {</span>
                <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">// Technically, &quot;undefined&quot; is a global variable of sorts</span>
                    <span class="s2">return this</span><span class="s1">.name !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; !getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">!getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, </span><span class="s1">...path].slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ASSIGNED: {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_CALLED: {</span>
                <span class="s2">const </span><span class="s1">globalAtPath = getGlobalAtPath([</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, </span><span class="s1">...path])</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">!globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">tdzVariableKinds = {</span>
    <span class="s1">__proto__: </span><span class="s2">null,</span>
    <span class="s2">class</span><span class="s1">: </span><span class="s2">true,</span>
    <span class="s2">const</span><span class="s1">: </span><span class="s2">true,</span>
    <span class="s2">let</span><span class="s1">: </span><span class="s2">true,</span>
    <span class="s2">var</span><span class="s1">: </span><span class="s2">true</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">Identifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.isTDZAccess = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
        <span class="s2">if </span><span class="s1">(exportNamesByVariable.has(</span><span class="s2">this</span><span class="s1">.variable)) {</span>
            <span class="s1">variables.push(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">bind() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.variable &amp;&amp; is_reference(</span><span class="s2">this, this</span><span class="s1">.parent)) {</span>
            <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s2">this</span><span class="s1">.name)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.variable.addReference(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">let </span><span class="s1">variable</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ treeshake } = </span><span class="s2">this</span><span class="s1">.context.options</span><span class="s2">;</span>
        <span class="s2">switch </span><span class="s1">(kind) {</span>
            <span class="s2">case </span><span class="s3">'var'</span><span class="s1">: {</span>
                <span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.addDeclaration(</span><span class="s2">this, this</span><span class="s1">.context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(treeshake &amp;&amp; treeshake.correctVarValueBeforeDeclaration) {</span>
                    <span class="s0">// Necessary to make sure the init is deoptimized. We cannot call deoptimizePath here.</span>
                    <span class="s1">variable.markInitializersForDeoptimization()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'function'</span><span class="s1">: {</span>
                <span class="s0">// in strict mode, functions are only hoisted within a scope but not across block scopes</span>
                <span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.addDeclaration(</span><span class="s2">this, this</span><span class="s1">.context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'let'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s3">'const'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s3">'class'</span><span class="s1">: {</span>
                <span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.addDeclaration(</span><span class="s2">this, this</span><span class="s1">.context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'parameter'</span><span class="s1">: {</span>
                <span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.addParameterDeclaration(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s0">/* istanbul ignore next */</span>
            <span class="s2">default</span><span class="s1">: {</span>
                <span class="s0">/* istanbul ignore next */</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Internal Error: Unexpected identifier kind </span><span class="s1">${kind}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">variable.kind = kind</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s2">this</span><span class="s1">.variable = variable)]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.variable.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.scope.contains(</span><span class="s2">this</span><span class="s1">.name)) {</span>
            <span class="s2">this</span><span class="s1">.disallowImportReassignment()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// We keep conditional chaining because an unknown Node could have an</span>
        <span class="s0">// Identifier as property that might be deoptimized by default</span>
        <span class="s2">this</span><span class="s1">.variable?.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getVariableRespectingTDZ().getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">[expression</span><span class="s2">, </span><span class="s1">isPure] = </span><span class="s2">this</span><span class="s1">.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">[expression</span><span class="s2">, </span><span class="s1">isPure || </span><span class="s2">this</span><span class="s1">.isPureFunction(path)]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isPossibleTDZ() &amp;&amp; </span><span class="s2">this</span><span class="s1">.variable.kind !== </span><span class="s3">'var'</span><span class="s1">) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.options.treeshake.unknownGlobalSideEffects &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.variable </span><span class="s2">instanceof </span><span class="s1">GlobalVariable &amp;&amp;</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.isPureFunction(EMPTY_PATH) &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ACCESS</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">switch </span><span class="s1">(interaction.type) {</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ACCESSED: {</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable !== </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!</span><span class="s2">this</span><span class="s1">.isPureFunction(path) &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ASSIGNED: {</span>
                <span class="s2">return </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.getVariableRespectingTDZ() : </span><span class="s2">this</span><span class="s1">.variable).hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_CALLED: {</span>
                <span class="s2">return </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isPureFunction(path) &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">this</span><span class="s1">.variable.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">isPossibleTDZ() {</span>
        <span class="s0">// return cached value to avoid issues with the next tree-shaking pass</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTDZAccess !== </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">return this</span><span class="s1">.isTDZAccess</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.variable </span><span class="s2">instanceof </span><span class="s1">LocalVariable &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.variable.kind &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.variable.kind </span><span class="s2">in </span><span class="s1">tdzVariableKinds &amp;&amp;</span>
            <span class="s0">// we ignore possible TDZs due to circular module dependencies as</span>
            <span class="s0">// otherwise we get many false positives</span>
            <span class="s2">this</span><span class="s1">.variable.module === </span><span class="s2">this</span><span class="s1">.context.module)) {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTDZAccess = </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">decl_id</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable.declarations &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.variable.declarations.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(decl_id = </span><span class="s2">this</span><span class="s1">.variable.declarations[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.start &lt; decl_id.start &amp;&amp;</span>
            <span class="s1">closestParentFunctionOrProgram(</span><span class="s2">this</span><span class="s1">) === closestParentFunctionOrProgram(decl_id)) {</span>
            <span class="s0">// a variable accessed before its declaration</span>
            <span class="s0">// in the same function or at top level of module</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTDZAccess = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.variable.initReached) {</span>
            <span class="s0">// Either a const/let TDZ violation or</span>
            <span class="s0">// var use before declaration was encountered.</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTDZAccess = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTDZAccess = </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">this</span><span class="s1">.variable.initReached = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">{ snippets: { getPropertyAccess }</span><span class="s2">, </span><span class="s1">useOriginalName }</span><span class="s2">, </span><span class="s1">{ renderedParentType</span><span class="s2">, </span><span class="s1">isCalleeOfRenderedParent</span><span class="s2">, </span><span class="s1">isShorthandProperty } = BLANK) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">const </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.variable.getName(getPropertyAccess</span><span class="s2">, </span><span class="s1">useOriginalName)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(name !== </span><span class="s2">this</span><span class="s1">.name) {</span>
                <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">contentOnly: </span><span class="s2">true,</span>
                    <span class="s1">storeName: </span><span class="s2">true</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isShorthandProperty) {</span>
                    <span class="s1">code.prependRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.name}</span><span class="s3">: `</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">// In strict mode, any variable named &quot;eval&quot; must be the actual &quot;eval&quot; function</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'eval' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">renderedParentType === CallExpression$1 &amp;&amp;</span>
                <span class="s1">isCalleeOfRenderedParent) {</span>
                <span class="s1">code.appendRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">'0, '</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable </span><span class="s2">instanceof </span><span class="s1">LocalVariable) {</span>
            <span class="s2">this</span><span class="s1">.variable.consolidateInitializers()</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">disallowImportReassignment() {</span>
        <span class="s2">return this</span><span class="s1">.context.error(errorIllegalImportReassignment(</span><span class="s2">this</span><span class="s1">.name</span><span class="s2">, this</span><span class="s1">.context.module.id)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getVariableRespectingTDZ() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isPossibleTDZ()) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.variable</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">isPureFunction(path) {</span>
        <span class="s2">let </span><span class="s1">currentPureFunction = </span><span class="s2">this</span><span class="s1">.context.manualPureFunctions[</span><span class="s2">this</span><span class="s1">.name]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of path) {</span>
            <span class="s2">if </span><span class="s1">(currentPureFunction) {</span>
                <span class="s2">if </span><span class="s1">(currentPureFunction[PureFunctionKey]) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
                <span class="s1">currentPureFunction = currentPureFunction[segment]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">currentPureFunction?.[PureFunctionKey]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">closestParentFunctionOrProgram(node) {</span>
    <span class="s2">while </span><span class="s1">(node &amp;&amp; !</span><span class="s4">/^Program|Function/</span><span class="s1">.test(node.type)) {</span>
        <span class="s1">node = node.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program</span>
    <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">treeshakeNode(node</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
    <span class="s1">code.remove(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.annotations) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">annotation of node.annotations) {</span>
            <span class="s2">if </span><span class="s1">(annotation.start &lt; start) {</span>
                <span class="s1">code.remove(annotation.start</span><span class="s2">, </span><span class="s1">annotation.end)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeAnnotations(node</span><span class="s2">, </span><span class="s1">code) {</span>
    <span class="s2">if </span><span class="s1">(!node.annotations &amp;&amp; node.parent.type === ExpressionStatement$1) {</span>
        <span class="s1">node = node.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.annotations) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">annotation of node.annotations) {</span>
            <span class="s1">code.remove(annotation.start</span><span class="s2">, </span><span class="s1">annotation.end)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">NO_SEMICOLON = { isNoStatement: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
<span class="s0">// This assumes there are only white-space and comments between start and the string we are looking for</span>
<span class="s2">function </span><span class="s1">findFirstOccurrenceOutsideComment(code</span><span class="s2">, </span><span class="s1">searchString</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">searchPos</span><span class="s2">, </span><span class="s1">charCodeAfterSlash</span><span class="s2">;</span>
    <span class="s1">searchPos = code.indexOf(searchString</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">start = code.indexOf(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(start === -</span><span class="s4">1 </span><span class="s1">|| start &gt;= searchPos)</span>
            <span class="s2">return </span><span class="s1">searchPos</span><span class="s2">;</span>
        <span class="s1">charCodeAfterSlash = code.charCodeAt(++start)</span><span class="s2">;</span>
        <span class="s1">++start</span><span class="s2">;</span>
        <span class="s0">// With our assumption, '/' always starts a comment. Determine comment type:</span>
        <span class="s1">start =</span>
            <span class="s1">charCodeAfterSlash === </span><span class="s4">47 </span><span class="s0">/*&quot;/&quot;*/</span>
                <span class="s1">? code.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">start) + </span><span class="s4">1</span>
                <span class="s1">: code.indexOf(</span><span class="s3">'*/'</span><span class="s2">, </span><span class="s1">start) + </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(start &gt; searchPos) {</span>
            <span class="s1">searchPos = code.indexOf(searchString</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">NON_WHITESPACE = </span><span class="s4">/\S/g</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">findNonWhiteSpace(code</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s1">NON_WHITESPACE.lastIndex = index</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = NON_WHITESPACE.exec(code)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">result.index</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">// This assumes &quot;code&quot; only contains white-space and comments</span>
<span class="s0">// Returns position of line-comment if applicable</span>
<span class="s2">function </span><span class="s1">findFirstLineBreakOutsideComment(code) {</span>
    <span class="s2">let </span><span class="s1">lineBreakPos</span><span class="s2">, </span><span class="s1">charCodeAfterSlash</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">lineBreakPos = code.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">start = code.indexOf(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(start === -</span><span class="s4">1 </span><span class="s1">|| start &gt; lineBreakPos)</span>
            <span class="s2">return </span><span class="s1">[lineBreakPos</span><span class="s2">, </span><span class="s1">lineBreakPos + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s0">// With our assumption, '/' always starts a comment. Determine comment type:</span>
        <span class="s1">charCodeAfterSlash = code.charCodeAt(start + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(charCodeAfterSlash === </span><span class="s4">47 </span><span class="s0">/*&quot;/&quot;*/</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[start</span><span class="s2">, </span><span class="s1">lineBreakPos + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">start = code.indexOf(</span><span class="s3">'*/'</span><span class="s2">, </span><span class="s1">start + </span><span class="s4">3</span><span class="s1">) + </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(start &gt; lineBreakPos) {</span>
            <span class="s1">lineBreakPos = code.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderStatementList(statements</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">let </span><span class="s1">currentNode</span><span class="s2">, </span><span class="s1">currentNodeStart</span><span class="s2">, </span><span class="s1">currentNodeNeedsBoundaries</span><span class="s2">, </span><span class="s1">nextNodeStart</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">nextNode = statements[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextNodeNeedsBoundaries) {</span>
        <span class="s1">nextNodeStart =</span>
            <span class="s1">start + findFirstLineBreakOutsideComment(code.original.slice(start</span><span class="s2">, </span><span class="s1">nextNode.start))[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">nextIndex = </span><span class="s4">1</span><span class="s2">; </span><span class="s1">nextIndex &lt;= statements.length</span><span class="s2">; </span><span class="s1">nextIndex++) {</span>
        <span class="s1">currentNode = nextNode</span><span class="s2">;</span>
        <span class="s1">currentNodeStart = nextNodeStart</span><span class="s2">;</span>
        <span class="s1">currentNodeNeedsBoundaries = nextNodeNeedsBoundaries</span><span class="s2">;</span>
        <span class="s1">nextNode = statements[nextIndex]</span><span class="s2">;</span>
        <span class="s1">nextNodeNeedsBoundaries =</span>
            <span class="s1">nextNode === undefined ? </span><span class="s2">false </span><span class="s1">: !nextNode.included || nextNode.needsBoundaries</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {</span>
            <span class="s1">nextNodeStart =</span>
                <span class="s1">currentNode.end +</span>
                    <span class="s1">findFirstLineBreakOutsideComment(code.original.slice(currentNode.end</span><span class="s2">, </span><span class="s1">nextNode === undefined ? end : nextNode.start))[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(currentNode.included) {</span>
                <span class="s1">currentNodeNeedsBoundaries</span>
                    <span class="s1">? currentNode.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">end: nextNodeStart</span><span class="s2">,</span>
                        <span class="s1">start: currentNodeStart</span>
                    <span class="s1">})</span>
                    <span class="s1">: currentNode.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">treeshakeNode(currentNode</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">currentNodeStart</span><span class="s2">, </span><span class="s1">nextNodeStart)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">currentNode.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// This assumes that the first character is not part of the first node</span>
<span class="s2">function </span><span class="s1">getCommaSeparatedNodesWithBoundaries(nodes</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
    <span class="s2">const </span><span class="s1">splitUpNodes = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">node</span><span class="s2">, </span><span class="s1">nextNodeStart</span><span class="s2">, </span><span class="s1">contentEnd</span><span class="s2">, </span><span class="s1">char</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">separator = start - </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">nextNode of nodes) {</span>
        <span class="s2">if </span><span class="s1">(node !== undefined) {</span>
            <span class="s1">separator =</span>
                <span class="s1">node.end +</span>
                    <span class="s1">findFirstOccurrenceOutsideComment(code.original.slice(node.end</span><span class="s2">, </span><span class="s1">nextNode.start)</span><span class="s2">, </span><span class="s3">','</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">nextNodeStart = contentEnd =</span>
            <span class="s1">separator +</span>
                <span class="s4">1 </span><span class="s1">+</span>
                <span class="s1">findFirstLineBreakOutsideComment(code.original.slice(separator + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">nextNode.start))[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(((char = code.original.charCodeAt(nextNodeStart))</span><span class="s2">,</span>
            <span class="s1">char === </span><span class="s4">32 </span><span class="s0">/*&quot; &quot;*/ </span><span class="s1">|| char === </span><span class="s4">9 </span><span class="s0">/*&quot;\t&quot;*/ </span><span class="s1">|| char === </span><span class="s4">10 </span><span class="s0">/*&quot;\n&quot;*/ </span><span class="s1">|| char === </span><span class="s4">13</span><span class="s1">) </span><span class="s0">/*&quot;\r&quot;*/</span><span class="s1">)</span>
            <span class="s1">nextNodeStart++</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(node !== undefined) {</span>
            <span class="s1">splitUpNodes.push({</span>
                <span class="s1">contentEnd</span><span class="s2">,</span>
                <span class="s1">end: nextNodeStart</span><span class="s2">,</span>
                <span class="s1">node</span><span class="s2">,</span>
                <span class="s1">separator</span><span class="s2">,</span>
                <span class="s1">start</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">node = nextNode</span><span class="s2">;</span>
        <span class="s1">start = nextNodeStart</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">splitUpNodes.push({</span>
        <span class="s1">contentEnd: end</span><span class="s2">,</span>
        <span class="s1">end</span><span class="s2">,</span>
        <span class="s1">node: node</span><span class="s2">,</span>
        <span class="s1">separator: </span><span class="s2">null,</span>
        <span class="s1">start</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">splitUpNodes</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">// This assumes there are only white-space and comments between start and end</span>
<span class="s2">function </span><span class="s1">removeLineBreaks(code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[removeStart</span><span class="s2">, </span><span class="s1">removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start</span><span class="s2">, </span><span class="s1">end))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(removeStart === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">code.remove(start + removeStart</span><span class="s2">, </span><span class="s1">(start += removeEnd))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">BlockScope </span><span class="s2">extends </span><span class="s1">ChildScope {</span>
    <span class="s1">addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted) {</span>
        <span class="s2">if </span><span class="s1">(isHoisted) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.parent.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted)</span><span class="s2">;</span>
            <span class="s0">// Necessary to make sure the init is deoptimized for conditional declarations.</span>
            <span class="s0">// We cannot call deoptimizePath here.</span>
            <span class="s1">variable.markInitializersForDeoptimization()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return super</span><span class="s1">.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExpressionStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">initialise() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.directive &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.directive !== </span><span class="s3">'use strict' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.parent.type === Program$1) {</span>
            <span class="s2">this</span><span class="s1">.context.warn(</span>
            <span class="s0">// This is necessary, because either way (deleting or not) can lead to errors.</span>
            <span class="s1">errorModuleLevelDirective(</span><span class="s2">this</span><span class="s1">.directive</span><span class="s2">, this</span><span class="s1">.context.module.id)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.included)</span>
            <span class="s2">this</span><span class="s1">.insertSemicolon(code)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">shouldBeIncluded(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.directive &amp;&amp; </span><span class="s2">this</span><span class="s1">.directive !== </span><span class="s3">'use strict'</span><span class="s1">)</span>
            <span class="s2">return this</span><span class="s1">.parent.type !== Program$1</span><span class="s2">;</span>
        <span class="s2">return super</span><span class="s1">.shouldBeIncluded(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">BlockStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.directlyIncluded = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">addImplicitReturnExpressionToScope() {</span>
        <span class="s2">const </span><span class="s1">lastStatement = </span><span class="s2">this</span><span class="s1">.body[</span><span class="s2">this</span><span class="s1">.body.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!lastStatement || lastStatement.type !== ReturnStatement$1) {</span>
            <span class="s2">this</span><span class="s1">.scope.addReturnExpression(UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">this</span><span class="s1">.parent.preventChildBlockScope</span>
            <span class="s1">? parentScope</span>
            <span class="s1">: </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deoptimizeBody)</span>
            <span class="s2">return true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s2">if </span><span class="s1">(context.brokenFlow)</span>
                <span class="s2">break;</span>
            <span class="s2">if </span><span class="s1">(node.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.deoptimizeBody &amp;&amp; </span><span class="s2">this</span><span class="s1">.directlyIncluded)) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.directlyIncluded = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deoptimizeBody)</span>
                <span class="s1">includeChildrenRecursively = </span><span class="s2">true;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
                <span class="s2">if </span><span class="s1">(includeChildrenRecursively || node.shouldBeIncluded(context))</span>
                    <span class="s1">node.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">const </span><span class="s1">firstBodyStatement = </span><span class="s2">this</span><span class="s1">.body[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizeBody =</span>
            <span class="s1">firstBodyStatement </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement &amp;&amp;</span>
                <span class="s1">firstBodyStatement.directive === </span><span class="s3">'use asm'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">renderStatementList(</span><span class="s2">this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.start + </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">RestElement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.declarationInit = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
        <span class="s2">this</span><span class="s1">.argument.addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">this</span><span class="s1">.declarationInit = init</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.argument.declare(kind</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s1">path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.argument.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">||</span>
            <span class="s2">this</span><span class="s1">.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">this</span><span class="s1">.argument.markDeclarationReached()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.declarationInit !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.declarationInit.deoptimizePath([UnknownKey</span><span class="s2">, </span><span class="s1">UnknownKey])</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">FunctionBase </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.deoptimizedReturn = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">{ parameters } = </span><span class="s2">this</span><span class="s1">.scope</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ args } = interaction</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hasRest = </span><span class="s2">false;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">position = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">position &lt; args.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">position++) {</span>
                <span class="s2">const </span><span class="s1">parameter = </span><span class="s2">this</span><span class="s1">.params[position]</span><span class="s2">;</span>
                <span class="s0">// Only the &quot;this&quot; argument arg[0] can be null</span>
                <span class="s2">const </span><span class="s1">argument = args[position + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hasRest || parameter </span><span class="s2">instanceof </span><span class="s1">RestElement) {</span>
                    <span class="s1">hasRest = </span><span class="s2">true;</span>
                    <span class="s1">argument.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(parameter </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
                    <span class="s1">parameters[position][</span><span class="s4">0</span><span class="s1">].addEntityToBeDeoptimized(argument)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(parameter) {</span>
                    <span class="s1">argument.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; path[</span><span class="s4">0</span><span class="s1">] === UnknownKey) {</span>
            <span class="s0">// A reassignment of UNKNOWN_PATH is considered equivalent to having lost track</span>
            <span class="s0">// which means the return expression needs to be reassigned</span>
            <span class="s2">this</span><span class="s1">.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.getObjectEntity().getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.async) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimizedReturn) {</span>
                <span class="s2">this</span><span class="s1">.deoptimizedReturn = </span><span class="s2">true;</span>
                <span class="s2">this</span><span class="s1">.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.scope.getReturnExpression()</span><span class="s2">, false</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">|| interaction.type !== INTERACTION_CALLED) {</span>
            <span class="s2">return this</span><span class="s1">.getObjectEntity().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.async) {</span>
            <span class="s2">const </span><span class="s1">{ propertyReadSideEffects } = </span><span class="s2">this</span><span class="s1">.context.options</span>
                <span class="s1">.treeshake</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">returnExpression = </span><span class="s2">this</span><span class="s1">.scope.getReturnExpression()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(returnExpression.hasEffectsOnInteractionAtPath([</span><span class="s3">'then'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_CALL</span><span class="s2">, </span><span class="s1">context) ||</span>
                <span class="s1">(propertyReadSideEffects &amp;&amp;</span>
                    <span class="s1">(propertyReadSideEffects === </span><span class="s3">'always' </span><span class="s1">||</span>
                        <span class="s1">returnExpression.hasEffectsOnInteractionAtPath([</span><span class="s3">'then'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ACCESS</span><span class="s2">, </span><span class="s1">context)))) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parameter of </span><span class="s2">this</span><span class="s1">.params) {</span>
            <span class="s2">if </span><span class="s1">(parameter.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ brokenFlow } = context</span><span class="s2">;</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.body.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">this</span><span class="s1">.scope.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.scope.addParameterVariables(</span><span class="s2">this</span><span class="s1">.params.map(parameter =&gt; parameter.declare(</span><span class="s3">'parameter'</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION))</span><span class="s2">, this</span><span class="s1">.params[</span><span class="s2">this</span><span class="s1">.params.length - </span><span class="s4">1</span><span class="s1">] </span><span class="s2">instanceof </span><span class="s1">RestElement)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body </span><span class="s2">instanceof </span><span class="s1">BlockStatement) {</span>
            <span class="s2">this</span><span class="s1">.body.addImplicitReturnExpressionToScope()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.scope.addReturnExpression(</span><span class="s2">this</span><span class="s1">.body)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">if </span><span class="s1">(esTreeNode.body.type === BlockStatement$1) {</span>
            <span class="s2">this</span><span class="s1">.body = </span><span class="s2">new </span><span class="s1">BlockStatement(esTreeNode.body</span><span class="s2">, this, this</span><span class="s1">.scope.hoistedBodyVarScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>
<span class="s1">FunctionBase.prototype.preventChildBlockScope = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">ArrowFunctionExpression </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">ReturnValueScope(parentScope</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">super</span><span class="s1">.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
            <span class="s2">return true;</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">{ ignore</span><span class="s2">, </span><span class="s1">brokenFlow } = context</span><span class="s2">;</span>
            <span class="s1">context.ignore = {</span>
                <span class="s1">breaks: </span><span class="s2">false,</span>
                <span class="s1">continues: </span><span class="s2">false,</span>
                <span class="s1">labels: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
                <span class="s1">returnYield: </span><span class="s2">true,</span>
                <span class="s2">this</span><span class="s1">: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.hasEffects(context))</span>
                <span class="s2">return true;</span>
            <span class="s1">context.ignore = ignore</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parameter of </span><span class="s2">this</span><span class="s1">.params) {</span>
            <span class="s2">if </span><span class="s1">(!(parameter </span><span class="s2">instanceof </span><span class="s1">Identifier)) {</span>
                <span class="s1">parameter.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getObjectEntity() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.objectEntity</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity([]</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getSystemExportStatement(exportedVariables</span><span class="s2">, </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">snippets: { _</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">getPropertyAccess } }</span><span class="s2">, </span><span class="s1">modifier = </span><span class="s3">''</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(exportedVariables.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">exportNamesByVariable.get(exportedVariables[</span><span class="s4">0</span><span class="s1">]).length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">variable = exportedVariables[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s3">`exports('</span><span class="s1">${exportNamesByVariable.get(variable)}</span><span class="s3">',</span><span class="s1">${_}${variable.getName(getPropertyAccess)}${modifier}</span><span class="s3">)`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">fields = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of exportedVariables) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of exportNamesByVariable.get(variable)) {</span>
                <span class="s1">fields.push([exportName</span><span class="s2">, </span><span class="s1">variable.getName(getPropertyAccess) + modifier])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s3">`exports(</span><span class="s1">${getObject(fields</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: </span><span class="s2">null </span><span class="s1">})}</span><span class="s3">)`</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderSystemExportExpression(exportedVariable</span><span class="s2">, </span><span class="s1">expressionStart</span><span class="s2">, </span><span class="s1">expressionEnd</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">snippets: { _ } }) {</span>
    <span class="s1">code.prependRight(expressionStart</span><span class="s2">, </span><span class="s3">`exports('</span><span class="s1">${exportNamesByVariable.get(exportedVariable)}</span><span class="s3">',</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">code.appendLeft(expressionEnd</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderSystemExportFunction(exportedVariables</span><span class="s2">, </span><span class="s1">expressionStart</span><span class="s2">, </span><span class="s1">expressionEnd</span><span class="s2">, </span><span class="s1">needsParens</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnIifeLeft } = options.snippets</span><span class="s2">;</span>
    <span class="s1">code.prependRight(expressionStart</span><span class="s2">, </span><span class="s1">getDirectReturnIifeLeft([</span><span class="s3">'v'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${getSystemExportStatement(exportedVariables</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">v`</span><span class="s2">, </span><span class="s1">{ needsArrowReturnParens: </span><span class="s2">true, </span><span class="s1">needsWrappedFunction: needsParens }))</span><span class="s2">;</span>
    <span class="s1">code.appendLeft(expressionEnd</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderSystemExportSequenceAfterExpression(exportedVariable</span><span class="s2">, </span><span class="s1">expressionStart</span><span class="s2">, </span><span class="s1">expressionEnd</span><span class="s2">, </span><span class="s1">needsParens</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getPropertyAccess } = options.snippets</span><span class="s2">;</span>
    <span class="s1">code.appendLeft(expressionEnd</span><span class="s2">, </span><span class="s3">`,</span><span class="s1">${_}${getSystemExportStatement([exportedVariable]</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">,</span><span class="s1">${_}${exportedVariable.getName(getPropertyAccess)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needsParens) {</span>
        <span class="s1">code.prependRight(expressionStart</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">code.appendLeft(expressionEnd</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderSystemExportSequenceBeforeExpression(exportedVariable</span><span class="s2">, </span><span class="s1">expressionStart</span><span class="s2">, </span><span class="s1">expressionEnd</span><span class="s2">, </span><span class="s1">needsParens</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">modifier) {</span>
    <span class="s2">const </span><span class="s1">{ _ } = options.snippets</span><span class="s2">;</span>
    <span class="s1">code.prependRight(expressionStart</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${getSystemExportStatement([exportedVariable]</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">modifier)}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needsParens) {</span>
        <span class="s1">code.prependRight(expressionStart</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">code.appendLeft(expressionEnd</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ObjectPattern </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
            <span class="s2">if </span><span class="s1">(property.type === Property$1) {</span>
                <span class="s1">property.value.addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">property.argument.addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">const </span><span class="s1">variables = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
            <span class="s1">variables.push(...property.declare(kind</span><span class="s2">, </span><span class="s1">init))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">variables</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
                <span class="s1">property.deoptimizePath(path)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(</span>
    <span class="s0">// At the moment, this is only triggered for assignment left-hand sides,</span>
    <span class="s0">// where the path is empty</span>
    <span class="s1">_path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
            <span class="s2">if </span><span class="s1">(property.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
            <span class="s1">property.markDeclarationReached()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">AssignmentExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">const </span><span class="s1">{ deoptimized</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">, </span><span class="s1">right } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s0">// MemberExpressions do not access the property before assignments if the</span>
        <span class="s0">// operator is '='.</span>
        <span class="s2">return </span><span class="s1">(right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">operator !== </span><span class="s3">'='</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return this</span><span class="s1">.right.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">const </span><span class="s1">{ deoptimized</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">operator } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively ||</span>
            <span class="s1">operator !== </span><span class="s3">'=' </span><span class="s1">||</span>
            <span class="s1">left.included ||</span>
            <span class="s1">left.hasEffectsAsAssignmentTarget(createHasEffectsContext()</span><span class="s2">, false</span><span class="s1">)) {</span>
            <span class="s1">left.includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">operator !== </span><span class="s3">'='</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">right.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.left.setAssignedValue(</span><span class="s2">this</span><span class="s1">.right)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ preventASI</span><span class="s2">, </span><span class="s1">renderedParentType</span><span class="s2">, </span><span class="s1">renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">const </span><span class="s1">{ left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">parent } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(left.included) {</span>
            <span class="s1">left.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">right.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">inclusionStart = findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'='</span><span class="s2">, </span><span class="s1">left.end) + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.remove(start</span><span class="s2">, </span><span class="s1">inclusionStart)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(preventASI) {</span>
                <span class="s1">removeLineBreaks(code</span><span class="s2">, </span><span class="s1">inclusionStart</span><span class="s2">, </span><span class="s1">right.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">right.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">renderedParentType: renderedParentType || parent.type</span><span class="s2">,</span>
                <span class="s1">renderedSurroundingElement: renderedSurroundingElement || parent.type</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(options.format === </span><span class="s3">'system'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(left </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
                <span class="s2">const </span><span class="s1">variable = left.variable</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">exportNames = options.exportNamesByVariable.get(variable)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(exportNames) {</span>
                    <span class="s2">if </span><span class="s1">(exportNames.length === </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">renderSystemExportExpression(variable</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">renderSystemExportSequenceAfterExpression(variable</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">parent.type !== ExpressionStatement$1</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">systemPatternExports = []</span><span class="s2">;</span>
                <span class="s1">left.addExportedVariables(systemPatternExports</span><span class="s2">, </span><span class="s1">options.exportNamesByVariable)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(systemPatternExports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">renderSystemExportFunction(systemPatternExports</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">renderedSurroundingElement === ExpressionStatement$1</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(left.included &amp;&amp;</span>
            <span class="s1">left </span><span class="s2">instanceof </span><span class="s1">ObjectPattern &amp;&amp;</span>
            <span class="s1">(renderedSurroundingElement === ExpressionStatement$1 ||</span>
                <span class="s1">renderedSurroundingElement === ArrowFunctionExpression$1)) {</span>
            <span class="s1">code.appendRight(start</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.prependLeft(end</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.left.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">AssignmentPattern </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
        <span class="s2">this</span><span class="s1">.left.addExportedVariables(variables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">return this</span><span class="s1">.left.declare(kind</span><span class="s2">, </span><span class="s1">init)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s1">path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.left.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.left.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">this</span><span class="s1">.left.markDeclarationReached()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isShorthandProperty } = BLANK) {</span>
        <span class="s2">this</span><span class="s1">.left.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isShorthandProperty })</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.left.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ArgumentsVariable </span><span class="s2">extends </span><span class="s1">LocalVariable {</span>
    <span class="s1">constructor(context) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s3">'arguments'</span><span class="s2">, null, </span><span class="s1">UNKNOWN_EXPRESSION</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">type !== INTERACTION_ACCESSED || path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ThisVariable </span><span class="s2">extends </span><span class="s1">ParameterVariable {</span>
    <span class="s1">constructor(context) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s3">'this'</span><span class="s2">, null, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return </span><span class="s1">(context.replacedVariableInits.get(</span><span class="s2">this</span><span class="s1">) || UNKNOWN_EXPRESSION).hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">FunctionScope </span><span class="s2">extends </span><span class="s1">ReturnValueScope {</span>
    <span class="s1">constructor(parent</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(parent</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'arguments'</span><span class="s2">, </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argumentsVariable = </span><span class="s2">new </span><span class="s1">ArgumentsVariable(context)))</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'this'</span><span class="s2">, </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.thisVariable = </span><span class="s2">new </span><span class="s1">ThisVariable(context)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findLexicalBoundary() {</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">super</span><span class="s1">.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argumentsVariable.included) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of parameters) {</span>
                <span class="s2">if </span><span class="s1">(!argument.included) {</span>
                    <span class="s1">argument.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">FunctionNode </span><span class="s2">extends </span><span class="s1">FunctionBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">FunctionScope(parentScope</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.constructedEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity(Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE)</span><span class="s2">;</span>
        <span class="s0">// This makes sure that all deoptimizations of &quot;this&quot; are applied to the</span>
        <span class="s0">// constructed entity.</span>
        <span class="s2">this</span><span class="s1">.scope.thisVariable.addEntityToBeDeoptimized(</span><span class="s2">this</span><span class="s1">.constructedEntity)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">super</span><span class="s1">.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; interaction.args[</span><span class="s4">0</span><span class="s1">]) {</span>
            <span class="s0">// args[0] is the &quot;this&quot; argument</span>
            <span class="s2">this</span><span class="s1">.scope.thisVariable.addEntityToBeDeoptimized(interaction.args[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">!!</span><span class="s2">this</span><span class="s1">.id?.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">super</span><span class="s1">.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
            <span class="s2">return true;</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">thisInit = context.replacedVariableInits.get(</span><span class="s2">this</span><span class="s1">.scope.thisVariable)</span><span class="s2">;</span>
            <span class="s1">context.replacedVariableInits.set(</span><span class="s2">this</span><span class="s1">.scope.thisVariable</span><span class="s2">, </span><span class="s1">interaction.withNew ? </span><span class="s2">this</span><span class="s1">.constructedEntity : UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">ignore</span><span class="s2">, </span><span class="s1">replacedVariableInits } = context</span><span class="s2">;</span>
            <span class="s1">context.ignore = {</span>
                <span class="s1">breaks: </span><span class="s2">false,</span>
                <span class="s1">continues: </span><span class="s2">false,</span>
                <span class="s1">labels: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
                <span class="s1">returnYield: </span><span class="s2">true,</span>
                <span class="s2">this</span><span class="s1">: interaction.withNew</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.hasEffects(context))</span>
                <span class="s2">return true;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(thisInit) {</span>
                <span class="s1">replacedVariableInits.set(</span><span class="s2">this</span><span class="s1">.scope.thisVariable</span><span class="s2">, </span><span class="s1">thisInit)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">replacedVariableInits.delete(</span><span class="s2">this</span><span class="s1">.scope.thisVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">context.ignore = ignore</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id?.include()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">hasArguments = </span><span class="s2">this</span><span class="s1">.scope.argumentsVariable.included</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">parameter of </span><span class="s2">this</span><span class="s1">.params) {</span>
            <span class="s2">if </span><span class="s1">(!(parameter </span><span class="s2">instanceof </span><span class="s1">Identifier) || hasArguments) {</span>
                <span class="s1">parameter.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">super</span><span class="s1">.initialise()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id?.declare(</span><span class="s3">'function'</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getObjectEntity() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.objectEntity</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity([</span>
            <span class="s1">{</span>
                <span class="s1">key: </span><span class="s3">'prototype'</span><span class="s2">,</span>
                <span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">,</span>
                <span class="s1">property: </span><span class="s2">new </span><span class="s1">ObjectEntity([]</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE)</span>
            <span class="s1">}</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">OBJECT_PROTOTYPE))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">AwaitExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s1">checkTopLevelAwait: </span><span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.context.usesTopLevelAwait) {</span>
                <span class="s2">let </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
                <span class="s2">do </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">FunctionNode || parent </span><span class="s2">instanceof </span><span class="s1">ArrowFunctionExpression)</span>
                        <span class="s2">break </span><span class="s1">checkTopLevelAwait</span><span class="s2">;</span>
                <span class="s1">} </span><span class="s2">while </span><span class="s1">((parent = parent.parent))</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.context.usesTopLevelAwait = </span><span class="s2">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.argument.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">binaryOperators = {</span>
    <span class="s3">'!='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left != right</span><span class="s2">,</span>
    <span class="s3">'!=='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left !== right</span><span class="s2">,</span>
    <span class="s3">'%'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left % right</span><span class="s2">,</span>
    <span class="s3">'&amp;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &amp; right</span><span class="s2">,</span>
    <span class="s3">'*'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left * right</span><span class="s2">,</span>
    <span class="s0">// At the moment, &quot;**&quot; will be transpiled to Math.pow</span>
    <span class="s3">'**'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left ** right</span><span class="s2">,</span>
    <span class="s3">'+'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left + right</span><span class="s2">,</span>
    <span class="s3">'-'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left - right</span><span class="s2">,</span>
    <span class="s3">'/'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left / right</span><span class="s2">,</span>
    <span class="s3">'&lt;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &lt; right</span><span class="s2">,</span>
    <span class="s3">'&lt;&lt;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &lt;&lt; right</span><span class="s2">,</span>
    <span class="s3">'&lt;='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &lt;= right</span><span class="s2">,</span>
    <span class="s3">'=='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left == right</span><span class="s2">,</span>
    <span class="s3">'==='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left === right</span><span class="s2">,</span>
    <span class="s3">'&gt;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &gt; right</span><span class="s2">,</span>
    <span class="s3">'&gt;='</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &gt;= right</span><span class="s2">,</span>
    <span class="s3">'&gt;&gt;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &gt;&gt; right</span><span class="s2">,</span>
    <span class="s3">'&gt;&gt;&gt;'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left &gt;&gt;&gt; right</span><span class="s2">,</span>
    <span class="s3">'^'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left ^ right</span><span class="s2">,</span>
    <span class="s3">'|'</span><span class="s1">: (left</span><span class="s2">, </span><span class="s1">right) =&gt; left | right</span>
    <span class="s0">// We use the fallback for cases where we return something unknown</span>
    <span class="s0">// in: () =&gt; UnknownValue,</span>
    <span class="s0">// instanceof: () =&gt; UnknownValue,</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">BinaryExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeCache() { }</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">leftValue = </span><span class="s2">this</span><span class="s1">.left.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">leftValue === </span><span class="s3">'symbol'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">rightValue = </span><span class="s2">this</span><span class="s1">.right.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">rightValue === </span><span class="s3">'symbol'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">operatorFunction = binaryOperators[</span><span class="s2">this</span><span class="s1">.operator]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!operatorFunction)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">operatorFunction(leftValue</span><span class="s2">, </span><span class="s1">rightValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s0">// support some implicit type coercion runtime errors</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'+' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.parent </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.left.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">) === </span><span class="s3">''</span><span class="s1">) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return super</span><span class="s1">.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">type !== INTERACTION_ACCESSED || path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">this</span><span class="s1">.left.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement })</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">BreakStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.label) {</span>
            <span class="s2">if </span><span class="s1">(!context.ignore.labels.has(</span><span class="s2">this</span><span class="s1">.label.name))</span>
                <span class="s2">return true;</span>
            <span class="s1">context.includedLabels.add(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!context.ignore.breaks)</span>
                <span class="s2">return true;</span>
            <span class="s1">context.hasBreak = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.label) {</span>
            <span class="s2">this</span><span class="s1">.label.include()</span><span class="s2">;</span>
            <span class="s1">context.includedLabels.add(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">context.hasBreak = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">renderCallArguments(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">node) {</span>
    <span class="s2">if </span><span class="s1">(node.arguments.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.arguments[node.arguments.length - </span><span class="s4">1</span><span class="s1">].included) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of node.arguments) {</span>
                <span class="s1">argument.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">let </span><span class="s1">lastIncludedIndex = node.arguments.length - </span><span class="s4">2</span><span class="s2">;</span>
            <span class="s2">while </span><span class="s1">(lastIncludedIndex &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; !node.arguments[lastIncludedIndex].included) {</span>
                <span class="s1">lastIncludedIndex--</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(lastIncludedIndex &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index &lt;= lastIncludedIndex</span><span class="s2">; </span><span class="s1">index++) {</span>
                    <span class="s1">node.arguments[index].render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">code.remove(findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">','</span><span class="s2">, </span><span class="s1">node.arguments[lastIncludedIndex].end)</span><span class="s2">, </span><span class="s1">node.end - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">code.remove(findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'('</span><span class="s2">, </span><span class="s1">node.callee.end) + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">node.end - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Literal </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath() { }</span>
    <span class="s1">getLiteralValueAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">||</span>
            <span class="s0">// unknown literals can also be null but do not start with an &quot;n&quot;</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.value === </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.context.code.charCodeAt(</span><span class="s2">this</span><span class="s1">.start) !== </span><span class="s4">110</span><span class="s1">) ||</span>
            <span class="s2">typeof this</span><span class="s1">.value === </span><span class="s3">'bigint' </span><span class="s1">||</span>
            <span class="s0">// to support shims for regular expressions</span>
            <span class="s2">this</span><span class="s1">.context.code.charCodeAt(</span><span class="s2">this</span><span class="s1">.start) === </span><span class="s4">47</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length !== </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">getMemberReturnExpressionWhenCalled(</span><span class="s2">this</span><span class="s1">.members</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">switch </span><span class="s1">(interaction.type) {</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ACCESSED: {</span>
                <span class="s2">return </span><span class="s1">path.length &gt; (</span><span class="s2">this</span><span class="s1">.value === </span><span class="s2">null </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_ASSIGNED: {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">INTERACTION_CALLED: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.included &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.value </span><span class="s2">instanceof </span><span class="s1">RegExp &amp;&amp;</span>
                    <span class="s1">(</span><span class="s2">this</span><span class="s1">.value.global || </span><span class="s2">this</span><span class="s1">.value.sticky)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">(path.length !== </span><span class="s4">1 </span><span class="s1">||</span>
                    <span class="s1">hasMemberEffectWhenCalled(</span><span class="s2">this</span><span class="s1">.members</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.members = getLiteralMembersForValue(</span><span class="s2">this</span><span class="s1">.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">this</span><span class="s1">.value = esTreeNode.value</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.regex = esTreeNode.regex</span><span class="s2">;</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">.value === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s1">code.indentExclusionRanges.push([</span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// To avoid infinite recursions</span>
<span class="s2">const </span><span class="s1">MAX_PATH_DEPTH = </span><span class="s4">7</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getResolvablePropertyKey(memberExpression) {</span>
    <span class="s2">return </span><span class="s1">memberExpression.computed</span>
        <span class="s1">? getResolvableComputedPropertyKey(memberExpression.property)</span>
        <span class="s1">: memberExpression.property.name</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getResolvableComputedPropertyKey(propertyKey) {</span>
    <span class="s2">if </span><span class="s1">(propertyKey </span><span class="s2">instanceof </span><span class="s1">Literal) {</span>
        <span class="s2">return </span><span class="s1">String(propertyKey.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPathIfNotComputed(memberExpression) {</span>
    <span class="s2">const </span><span class="s1">nextPathKey = memberExpression.propertyKey</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">object = memberExpression.object</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">nextPathKey === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(object </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">{ key: object.name</span><span class="s2">, </span><span class="s1">pos: object.start }</span><span class="s2">,</span>
                <span class="s1">{ key: nextPathKey</span><span class="s2">, </span><span class="s1">pos: memberExpression.property.start }</span>
            <span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(object </span><span class="s2">instanceof </span><span class="s1">MemberExpression) {</span>
            <span class="s2">const </span><span class="s1">parentPath = getPathIfNotComputed(object)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">(parentPath &amp;&amp; [...parentPath</span><span class="s2">, </span><span class="s1">{ key: nextPathKey</span><span class="s2">, </span><span class="s1">pos: memberExpression.property.start }])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getStringFromPath(path) {</span>
    <span class="s2">let </span><span class="s1">pathString = path[</span><span class="s4">0</span><span class="s1">].key</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">1</span><span class="s2">; </span><span class="s1">index &lt; path.length</span><span class="s2">; </span><span class="s1">index++) {</span>
        <span class="s1">pathString += </span><span class="s3">'.' </span><span class="s1">+ path[index].key</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pathString</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">MemberExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.assignmentDeoptimized = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.bound = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.isUndefined = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">bind() {</span>
        <span class="s2">this</span><span class="s1">.bound = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">path = getPathIfNotComputed(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">baseVariable = path &amp;&amp; </span><span class="s2">this</span><span class="s1">.scope.findVariable(path[</span><span class="s4">0</span><span class="s1">].key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(baseVariable?.isNamespace) {</span>
            <span class="s2">const </span><span class="s1">resolvedVariable = resolveNamespaceVariables(baseVariable</span><span class="s2">, </span><span class="s1">path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!resolvedVariable) {</span>
                <span class="s2">super</span><span class="s1">.bind()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(resolvedVariable === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.isUndefined = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.variable = resolvedVariable</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.scope.addNamespaceMemberAccess(getStringFromPath(path)</span><span class="s2">, </span><span class="s1">resolvedVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.bind()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">this</span><span class="s1">.variable.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isUndefined) {</span>
            <span class="s2">if </span><span class="s1">(path.length &lt; MAX_PATH_DEPTH) {</span>
                <span class="s2">this</span><span class="s1">.object.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">const </span><span class="s1">{ expressionsToBeDeoptimized</span><span class="s2">, </span><span class="s1">object } = </span><span class="s2">this;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = EMPTY_ARRAY</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.propertyKey = UnknownKey</span><span class="s2">;</span>
        <span class="s1">object.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
            <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">this</span><span class="s1">.disallowNamespaceReassignment()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">this</span><span class="s1">.variable.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isUndefined &amp;&amp; path.length &lt; MAX_PATH_DEPTH) {</span>
            <span class="s2">const </span><span class="s1">propertyKey = </span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.object.deoptimizePath([</span>
                <span class="s1">propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey</span><span class="s2">,</span>
                <span class="s1">...path</span>
            <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">return this</span><span class="s1">.variable.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUndefined) {</span>
            <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.propertyKey !== UnknownKey &amp;&amp; path.length &lt; MAX_PATH_DEPTH) {</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
            <span class="s2">return this</span><span class="s1">.object.getLiteralValueAtPath([</span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">return this</span><span class="s1">.variable.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUndefined) {</span>
            <span class="s2">return </span><span class="s1">[UNDEFINED_EXPRESSION</span><span class="s2">, false</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.propertyKey !== UnknownKey &amp;&amp; path.length &lt; MAX_PATH_DEPTH) {</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
            <span class="s2">return this</span><span class="s1">.object.getReturnExpressionWhenCalledAtPath([</span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.property.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.object.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.hasAccessEffect(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">checkAccess) {</span>
        <span class="s2">if </span><span class="s1">(checkAccess &amp;&amp; !</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.assignmentDeoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyAssignmentDeoptimization()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.property.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.object.hasEffects(context) ||</span>
            <span class="s1">(checkAccess &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasAccessEffect(context)) ||</span>
            <span class="s2">this</span><span class="s1">.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.assignmentInteraction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">return this</span><span class="s1">.variable.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUndefined) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.length &lt; MAX_PATH_DEPTH) {</span>
            <span class="s2">return this</span><span class="s1">.object.hasEffectsOnInteractionAtPath([</span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includeProperties(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">deoptimizeAccess) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.assignmentDeoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyAssignmentDeoptimization()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(deoptimizeAccess) {</span>
            <span class="s2">this</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.includeProperties(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s2">this</span><span class="s1">.variable.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.propertyKey = getResolvablePropertyKey(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.accessInteraction = { args: [</span><span class="s2">this</span><span class="s1">.object]</span><span class="s2">, </span><span class="s1">type: INTERACTION_ACCESSED }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">isSkippedAsOptional(origin) {</span>
        <span class="s2">return </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.variable &amp;&amp;</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.isUndefined &amp;&amp;</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.object.isSkippedAsOptional?.(origin) ||</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.optional &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.object.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, </span><span class="s1">origin) == </span><span class="s2">null</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedParentType</span><span class="s2">, </span><span class="s1">isCalleeOfRenderedParent</span><span class="s2">, </span><span class="s1">renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable || </span><span class="s2">this</span><span class="s1">.isUndefined) {</span>
            <span class="s2">const </span><span class="s1">{ snippets: { getPropertyAccess } } = options</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">replacement = </span><span class="s2">this</span><span class="s1">.variable ? </span><span class="s2">this</span><span class="s1">.variable.getName(getPropertyAccess) : </span><span class="s3">'undefined'</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(renderedParentType &amp;&amp; isCalleeOfRenderedParent)</span>
                <span class="s1">replacement = </span><span class="s3">'0, ' </span><span class="s1">+ replacement</span><span class="s2">;</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s1">replacement</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">contentOnly: </span><span class="s2">true,</span>
                <span class="s1">storeName: </span><span class="s2">true</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(renderedParentType &amp;&amp; isCalleeOfRenderedParent) {</span>
                <span class="s1">code.appendRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">'0, '</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.object.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement })</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.property.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setAssignedValue(value) {</span>
        <span class="s2">this</span><span class="s1">.assignmentInteraction = {</span>
            <span class="s1">args: [</span><span class="s2">this</span><span class="s1">.object</span><span class="s2">, </span><span class="s1">value]</span><span class="s2">,</span>
            <span class="s1">type: INTERACTION_ASSIGNED</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ propertyReadSideEffects } = </span><span class="s2">this</span><span class="s1">.context.options</span>
            <span class="s1">.treeshake</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span>
        <span class="s0">// Namespaces are not bound and should not be deoptimized</span>
        <span class="s2">this</span><span class="s1">.bound &amp;&amp;</span>
            <span class="s1">propertyReadSideEffects &amp;&amp;</span>
            <span class="s1">!(</span><span class="s2">this</span><span class="s1">.variable || </span><span class="s2">this</span><span class="s1">.isUndefined)) {</span>
            <span class="s2">const </span><span class="s1">propertyKey = </span><span class="s2">this</span><span class="s1">.getPropertyKey()</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.object.deoptimizeArgumentsOnInteractionAtPath(</span><span class="s2">this</span><span class="s1">.accessInteraction</span><span class="s2">, </span><span class="s1">[propertyKey]</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyAssignmentDeoptimization() {</span>
        <span class="s2">this</span><span class="s1">.assignmentDeoptimized = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ propertyReadSideEffects } = </span><span class="s2">this</span><span class="s1">.context.options</span>
            <span class="s1">.treeshake</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span>
        <span class="s0">// Namespaces are not bound and should not be deoptimized</span>
        <span class="s2">this</span><span class="s1">.bound &amp;&amp;</span>
            <span class="s1">propertyReadSideEffects &amp;&amp;</span>
            <span class="s1">!(</span><span class="s2">this</span><span class="s1">.variable || </span><span class="s2">this</span><span class="s1">.isUndefined)) {</span>
            <span class="s2">this</span><span class="s1">.object.deoptimizeArgumentsOnInteractionAtPath(</span><span class="s2">this</span><span class="s1">.assignmentInteraction</span><span class="s2">, </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.getPropertyKey()]</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">disallowNamespaceReassignment() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.object </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s2">this</span><span class="s1">.object.name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable.isNamespace) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
                    <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.context.warn(errorIllegalImportReassignment(</span><span class="s2">this</span><span class="s1">.object.name</span><span class="s2">, this</span><span class="s1">.context.module.id)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getPropertyKey() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.propertyKey === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.propertyKey = UnknownKey</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.property.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.propertyKey =</span>
                <span class="s1">value === SymbolToStringTag</span>
                    <span class="s1">? value</span>
                    <span class="s1">: </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'symbol'</span>
                        <span class="s1">? UnknownKey</span>
                        <span class="s1">: String(value))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.propertyKey</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasAccessEffect(context) {</span>
        <span class="s2">const </span><span class="s1">{ propertyReadSideEffects } = </span><span class="s2">this</span><span class="s1">.context.options</span>
            <span class="s1">.treeshake</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.variable || </span><span class="s2">this</span><span class="s1">.isUndefined) &amp;&amp;</span>
            <span class="s1">propertyReadSideEffects &amp;&amp;</span>
            <span class="s1">(propertyReadSideEffects === </span><span class="s3">'always' </span><span class="s1">||</span>
                <span class="s2">this</span><span class="s1">.object.hasEffectsOnInteractionAtPath([</span><span class="s2">this</span><span class="s1">.getPropertyKey()]</span><span class="s2">, this</span><span class="s1">.accessInteraction</span><span class="s2">, </span><span class="s1">context)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeProperties(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable) {</span>
                <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.object.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.property.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveNamespaceVariables(baseVariable</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">astContext) {</span>
    <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">baseVariable</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!baseVariable.isNamespace || baseVariable </span><span class="s2">instanceof </span><span class="s1">ExternalVariable)</span>
        <span class="s2">return null;</span>
    <span class="s2">const </span><span class="s1">exportName = path[</span><span class="s4">0</span><span class="s1">].key</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">variable = baseVariable.context.traceExport(exportName)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!variable) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">fileName = baseVariable.context.fileName</span><span class="s2">;</span>
            <span class="s1">astContext.warn(errorMissingExport(exportName</span><span class="s2">, </span><span class="s1">astContext.module.id</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">].pos)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">'undefined'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolveNamespaceVariables(variable</span><span class="s2">, </span><span class="s1">path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">astContext)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">CallExpressionBase </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.returnExpression = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.deoptimizableDependentExpressions = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">const </span><span class="s1">{ args } = interaction</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">[returnExpression</span><span class="s2">, </span><span class="s1">isPure] = </span><span class="s2">this</span><span class="s1">.getReturnExpression(recursionTracker)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPure)</span>
            <span class="s2">return;</span>
        <span class="s2">const </span><span class="s1">deoptimizedExpressions = args.filter(expression =&gt; !!expression &amp;&amp; expression !== UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(deoptimizedExpressions.length === </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return;</span>
        <span class="s2">if </span><span class="s1">(returnExpression === UNKNOWN_EXPRESSION) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of deoptimizedExpressions) {</span>
                <span class="s1">expression.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, </span><span class="s1">returnExpression</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of deoptimizedExpressions) {</span>
                    <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.add(expression)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">returnExpression.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression?.[</span><span class="s4">0</span><span class="s1">] !== UNKNOWN_EXPRESSION) {</span>
            <span class="s2">this</span><span class="s1">.returnExpression = UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ deoptimizableDependentExpressions</span><span class="s2">, </span><span class="s1">expressionsToBeDeoptimized } = </span><span class="s2">this;</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = EMPTY_SET</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.deoptimizableDependentExpressions = EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of deoptimizableDependentExpressions) {</span>
                <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                <span class="s1">expression.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0 </span><span class="s1">||</span>
            <span class="s2">this</span><span class="s1">.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, this</span><span class="s1">)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[returnExpression] = </span><span class="s2">this</span><span class="s1">.getReturnExpression()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(returnExpression !== UNKNOWN_EXPRESSION) {</span>
            <span class="s1">returnExpression.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">[returnExpression] = </span><span class="s2">this</span><span class="s1">.getReturnExpression(recursionTracker)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(returnExpression === UNKNOWN_EXPRESSION) {</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, </span><span class="s1">returnExpression</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">this</span><span class="s1">.deoptimizableDependentExpressions.push(origin)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">returnExpression.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">UnknownValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">returnExpression = </span><span class="s2">this</span><span class="s1">.getReturnExpression(recursionTracker)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(returnExpression[</span><span class="s4">0</span><span class="s1">] === UNKNOWN_EXPRESSION) {</span>
            <span class="s2">return </span><span class="s1">returnExpression</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">recursionTracker.withTrackedEntityAtPath(path</span><span class="s2">, </span><span class="s1">returnExpression</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">this</span><span class="s1">.deoptimizableDependentExpressions.push(origin)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">[expression</span><span class="s2">, </span><span class="s1">isPure] = returnExpression[</span><span class="s4">0</span><span class="s1">].getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">[expression</span><span class="s2">, </span><span class="s1">isPure || returnExpression[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">UNKNOWN_RETURN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">{ type } = interaction</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type === INTERACTION_CALLED) {</span>
            <span class="s2">const </span><span class="s1">{ args</span><span class="s2">, </span><span class="s1">withNew } = interaction</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">((withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, this</span><span class="s1">)) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">((type === INTERACTION_ASSIGNED</span>
            <span class="s1">? context.assigned</span>
            <span class="s1">: context.accessed).trackEntityAtPathAndGetIfTracked(path</span><span class="s2">, this</span><span class="s1">)) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">[returnExpression</span><span class="s2">, </span><span class="s1">isPure] = </span><span class="s2">this</span><span class="s1">.getReturnExpression()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">((type === INTERACTION_ASSIGNED || !isPure) &amp;&amp;</span>
            <span class="s1">returnExpression.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">CallExpression </span><span class="s2">extends </span><span class="s1">CallExpressionBase {</span>
    <span class="s1">bind() {</span>
        <span class="s2">super</span><span class="s1">.bind()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.callee </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s2">this</span><span class="s1">.callee.name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable.isNamespace) {</span>
                <span class="s2">this</span><span class="s1">.context.warn(errorCannotCallNamespace(</span><span class="s2">this</span><span class="s1">.callee.name)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.callee.name === </span><span class="s3">'eval'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.context.warn(errorEval(</span><span class="s2">this</span><span class="s1">.context.module.id)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.interaction = {</span>
            <span class="s1">args: [</span>
                <span class="s2">this</span><span class="s1">.callee </span><span class="s2">instanceof </span><span class="s1">MemberExpression &amp;&amp; !</span><span class="s2">this</span><span class="s1">.callee.variable</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.callee.object</span>
                    <span class="s1">: </span><span class="s2">null,</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.arguments</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
            <span class="s1">withNew: </span><span class="s2">false</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of </span><span class="s2">this</span><span class="s1">.arguments) {</span>
                <span class="s2">if </span><span class="s1">(argument.hasEffects(context))</span>
                    <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.options.treeshake.annotations &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.annotations)</span>
                <span class="s2">return false;</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.callee.hasEffects(context) ||</span>
                <span class="s2">this</span><span class="s1">.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
                <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively) {</span>
            <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively === INCLUDE_PARAMETERS &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.callee </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.callee.variable) {</span>
                <span class="s2">this</span><span class="s1">.callee.variable.markCalledFromTryStatement()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.callee.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.callee.includeCallArguments(context</span><span class="s2">, this</span><span class="s1">.arguments)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">isSkippedAsOptional(origin) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.callee.isSkippedAsOptional?.(origin) ||</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.optional &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.callee.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, </span><span class="s1">origin) == </span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">this</span><span class="s1">.callee.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">isCalleeOfRenderedParent: </span><span class="s2">true,</span>
            <span class="s1">renderedSurroundingElement</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">renderCallArguments(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.callee.deoptimizeArgumentsOnInteractionAtPath(</span><span class="s2">this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.returnExpression = UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression = </span><span class="s2">this</span><span class="s1">.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, this</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.returnExpression</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">CatchScope </span><span class="s2">extends </span><span class="s1">ParameterScope {</span>
    <span class="s1">addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted) {</span>
        <span class="s2">const </span><span class="s1">existingParameter = </span><span class="s2">this</span><span class="s1">.variables.get(identifier.name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(existingParameter) {</span>
            <span class="s0">// While we still create a hoisted declaration, the initializer goes to</span>
            <span class="s0">// the parameter. Note that technically, the declaration now belongs to</span>
            <span class="s0">// two variables, which is not correct but should not cause issues.</span>
            <span class="s2">this</span><span class="s1">.parent.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">UNDEFINED_EXPRESSION</span><span class="s2">, </span><span class="s1">isHoisted)</span><span class="s2">;</span>
            <span class="s1">existingParameter.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">init)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">existingParameter</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parent.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">CatchClause </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">CatchScope(parentScope</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s0">// Parameters need to be declared first as the logic is that initializers</span>
        <span class="s0">// of hoisted body variables are associated with parameters of the same</span>
        <span class="s0">// name instead of the variable</span>
        <span class="s2">const </span><span class="s1">{ param } = esTreeNode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(param) {</span>
            <span class="s2">this</span><span class="s1">.param = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(param.type))(param</span><span class="s2">, this, this</span><span class="s1">.scope)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.param.declare(</span><span class="s3">'parameter'</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ChainExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s0">// deoptimizations are not relevant as we are not caching values</span>
    <span class="s1">deoptimizeCache() { }</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.expression.isSkippedAsOptional(origin))</span>
            <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.expression.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.expression.isSkippedAsOptional(</span><span class="s2">this</span><span class="s1">))</span>
            <span class="s2">return false;</span>
        <span class="s2">return this</span><span class="s1">.expression.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ClassBodyScope </span><span class="s2">extends </span><span class="s1">ChildScope {</span>
    <span class="s1">constructor(parent</span><span class="s2">, </span><span class="s1">classNode</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(parent)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'this'</span><span class="s2">, </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.thisVariable = </span><span class="s2">new </span><span class="s1">LocalVariable(</span><span class="s3">'this'</span><span class="s2">, null, </span><span class="s1">classNode</span><span class="s2">, </span><span class="s1">context)))</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.instanceScope = </span><span class="s2">new </span><span class="s1">ChildScope(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.instanceScope.variables.set(</span><span class="s3">'this'</span><span class="s2">, new </span><span class="s1">ThisVariable(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findLexicalBoundary() {</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ClassBody </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">ClassBodyScope(parentScope</span><span class="s2">, this</span><span class="s1">.parent</span><span class="s2">, this</span><span class="s1">.context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.scope.thisVariable)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">definition of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s1">definition.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">const </span><span class="s1">body = (</span><span class="s2">this</span><span class="s1">.body = [])</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">definition of esTreeNode.body) {</span>
            <span class="s1">body.push(</span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(definition.type))(definition</span><span class="s2">, this, </span><span class="s1">definition.static ? </span><span class="s2">this</span><span class="s1">.scope : </span><span class="s2">this</span><span class="s1">.scope.instanceScope))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">MethodBase </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.accessedValue = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ACCESSED &amp;&amp; </span><span class="s2">this</span><span class="s1">.kind === </span><span class="s3">'get' </span><span class="s1">&amp;&amp; path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.value.deoptimizeArgumentsOnInteractionAtPath({</span>
                <span class="s1">args: interaction.args</span><span class="s2">,</span>
                <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
                <span class="s1">withNew: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">EMPTY_PATH</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ASSIGNED &amp;&amp; </span><span class="s2">this</span><span class="s1">.kind === </span><span class="s3">'set' </span><span class="s1">&amp;&amp; path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.value.deoptimizeArgumentsOnInteractionAtPath({</span>
                <span class="s1">args: interaction.args</span><span class="s2">,</span>
                <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
                <span class="s1">withNew: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">EMPTY_PATH</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.getAccessedValue()[</span><span class="s4">0</span><span class="s1">].deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// As getter properties directly receive their values from fixed function</span>
    <span class="s0">// expressions, there is no known situation where a getter is deoptimized.</span>
    <span class="s1">deoptimizeCache() { }</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.getAccessedValue()[</span><span class="s4">0</span><span class="s1">].deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getAccessedValue()[</span><span class="s4">0</span><span class="s1">].getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getAccessedValue()[</span><span class="s4">0</span><span class="s1">].getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">return this</span><span class="s1">.key.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.kind === </span><span class="s3">'get' </span><span class="s1">&amp;&amp; interaction.type === INTERACTION_ACCESSED &amp;&amp; path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.value.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">args: interaction.args</span><span class="s2">,</span>
                <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
                <span class="s1">withNew: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// setters are only called for empty paths</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.kind === </span><span class="s3">'set' </span><span class="s1">&amp;&amp; interaction.type === INTERACTION_ASSIGNED) {</span>
            <span class="s2">return this</span><span class="s1">.value.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">args: interaction.args</span><span class="s2">,</span>
                <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
                <span class="s1">withNew: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.getAccessedValue()[</span><span class="s4">0</span><span class="s1">].hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">getAccessedValue() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.accessedValue === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.kind === </span><span class="s3">'get'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.accessedValue = UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.accessedValue = </span><span class="s2">this</span><span class="s1">.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_CALL</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.accessedValue = [</span><span class="s2">this</span><span class="s1">.value</span><span class="s2">, false</span><span class="s1">])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.accessedValue</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">MethodDefinition </span><span class="s2">extends </span><span class="s1">MethodBase {</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ObjectMember </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor(object</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.object = object</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.key = key</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.object.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.object.deoptimizePath([</span><span class="s2">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">...path])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.object.getLiteralValueAtPath([</span><span class="s2">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.object.getReturnExpressionWhenCalledAtPath([</span><span class="s2">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return this</span><span class="s1">.object.hasEffectsOnInteractionAtPath([</span><span class="s2">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">...path]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ClassNode </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">ChildScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeAllProperties()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">initEffect = </span><span class="s2">this</span><span class="s1">.superClass?.hasEffects(context) || </span><span class="s2">this</span><span class="s1">.body.hasEffects(context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id?.markDeclarationReached()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">initEffect || </span><span class="s2">super</span><span class="s1">.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return </span><span class="s1">interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">0</span>
            <span class="s1">? !interaction.withNew ||</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.classConstructor === </span><span class="s2">null</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.superClass?.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.classConstructor.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)) ||</span>
                <span class="s2">false</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.getObjectEntity().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.superClass?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.body.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.id) {</span>
            <span class="s2">this</span><span class="s1">.id.markDeclarationReached()</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.id.include()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.id?.declare(</span><span class="s3">'class'</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">method of </span><span class="s2">this</span><span class="s1">.body.body) {</span>
            <span class="s2">if </span><span class="s1">(method </span><span class="s2">instanceof </span><span class="s1">MethodDefinition &amp;&amp; method.kind === </span><span class="s3">'constructor'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.classConstructor = method</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.classConstructor = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">definition of </span><span class="s2">this</span><span class="s1">.body.body) {</span>
            <span class="s2">if </span><span class="s1">(!(definition.static ||</span>
                <span class="s1">(definition </span><span class="s2">instanceof </span><span class="s1">MethodDefinition &amp;&amp; definition.kind === </span><span class="s3">'constructor'</span><span class="s1">))) {</span>
                <span class="s0">// Calls to methods are not tracked, ensure that the return value is deoptimized</span>
                <span class="s1">definition.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getObjectEntity() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.objectEntity</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">staticProperties = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">dynamicMethods = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">definition of </span><span class="s2">this</span><span class="s1">.body.body) {</span>
            <span class="s2">const </span><span class="s1">properties = definition.static ? staticProperties : dynamicMethods</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">definitionKind = definition.kind</span><span class="s2">;</span>
            <span class="s0">// Note that class fields do not end up on the prototype</span>
            <span class="s2">if </span><span class="s1">(properties === dynamicMethods &amp;&amp; !definitionKind)</span>
                <span class="s2">continue;</span>
            <span class="s2">const </span><span class="s1">kind = definitionKind === </span><span class="s3">'set' </span><span class="s1">|| definitionKind === </span><span class="s3">'get' </span><span class="s1">? definitionKind : </span><span class="s3">'init'</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">key</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(definition.computed) {</span>
                <span class="s2">const </span><span class="s1">keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keyValue === </span><span class="s3">'symbol'</span><span class="s1">) {</span>
                    <span class="s1">properties.push({ key: UnknownKey</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">property: definition })</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">key = String(keyValue)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">key =</span>
                    <span class="s1">definition.key </span><span class="s2">instanceof </span><span class="s1">Identifier</span>
                        <span class="s1">? definition.key.name</span>
                        <span class="s1">: String(definition.key.value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">properties.push({ key</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">, </span><span class="s1">property: definition })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">staticProperties.unshift({</span>
            <span class="s1">key: </span><span class="s3">'prototype'</span><span class="s2">,</span>
            <span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">,</span>
            <span class="s1">property: </span><span class="s2">new </span><span class="s1">ObjectEntity(dynamicMethods</span><span class="s2">, this</span><span class="s1">.superClass ? </span><span class="s2">new </span><span class="s1">ObjectMember(</span><span class="s2">this</span><span class="s1">.superClass</span><span class="s2">, </span><span class="s3">'prototype'</span><span class="s1">) : OBJECT_PROTOTYPE)</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity(staticProperties</span><span class="s2">, this</span><span class="s1">.superClass || OBJECT_PROTOTYPE))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ClassDeclaration </span><span class="s2">extends </span><span class="s1">ClassNode {</span>
    <span class="s1">initialise() {</span>
        <span class="s2">super</span><span class="s1">.initialise()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.id !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.id.variable.isId = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">if </span><span class="s1">(esTreeNode.id !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.id = </span><span class="s2">new </span><span class="s1">Identifier(esTreeNode.id</span><span class="s2">, this, this</span><span class="s1">.scope.parent)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">snippets: { _</span><span class="s2">, </span><span class="s1">getPropertyAccess } } = options</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.id) {</span>
            <span class="s2">const </span><span class="s1">{ variable</span><span class="s2">, </span><span class="s1">name } = </span><span class="s2">this</span><span class="s1">.id</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'system' </span><span class="s1">&amp;&amp; exportNamesByVariable.has(variable)) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${_}${getSystemExportStatement([variable]</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">;`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">renderedVariable = variable.getName(getPropertyAccess)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(renderedVariable !== name) {</span>
                <span class="s2">this</span><span class="s1">.superClass?.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.body.render(code</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">...options</span><span class="s2">,</span>
                    <span class="s1">useOriginalName: (_variable) =&gt; _variable === variable</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">code.prependRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">`let </span><span class="s1">${renderedVariable}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">super</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ id</span><span class="s2">, </span><span class="s1">scope } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(id) {</span>
            <span class="s2">const </span><span class="s1">{ name</span><span class="s2">, </span><span class="s1">variable } = id</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessedVariable of scope.accessedOutsideVariables.values()) {</span>
                <span class="s2">if </span><span class="s1">(accessedVariable !== variable) {</span>
                    <span class="s1">accessedVariable.forbidName(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ClassExpression </span><span class="s2">extends </span><span class="s1">ClassNode {</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(renderedSurroundingElement === ExpressionStatement$1) {</span>
            <span class="s1">code.appendRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">MultiExpression </span><span class="s2">extends </span><span class="s1">ExpressionEntity {</span>
    <span class="s1">constructor(expressions) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressions = expressions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.expressions) {</span>
            <span class="s1">expression.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s2">new </span><span class="s1">MultiExpression(</span><span class="s2">this</span><span class="s1">.expressions.map(expression =&gt; expression.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s2">false</span>
        <span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.expressions) {</span>
            <span class="s2">if </span><span class="s1">(expression.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ConditionalExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.usedBranch = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.consequent.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.alternate.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.usedBranch !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">unusedBranch = </span><span class="s2">this</span><span class="s1">.usedBranch === </span><span class="s2">this</span><span class="s1">.consequent ? </span><span class="s2">this</span><span class="s1">.alternate : </span><span class="s2">this</span><span class="s1">.consequent</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.usedBranch = </span><span class="s2">null;</span>
            <span class="s1">unusedBranch.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ expressionsToBeDeoptimized } = </span><span class="s2">this;</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usedBranch) {</span>
            <span class="s1">usedBranch.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.consequent.deoptimizePath(path)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.alternate.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">usedBranch.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch)</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s2">new </span><span class="s1">MultiExpression([</span>
                    <span class="s2">this</span><span class="s1">.consequent.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s2">this</span><span class="s1">.alternate.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">])</span><span class="s2">,</span>
                <span class="s2">false</span>
            <span class="s1">]</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">usedBranch.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch) {</span>
            <span class="s2">return this</span><span class="s1">.consequent.hasEffects(context) || </span><span class="s2">this</span><span class="s1">.alternate.hasEffects(context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">usedBranch.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch) {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) ||</span>
                <span class="s2">this</span><span class="s1">.alternate.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">usedBranch.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively || </span><span class="s2">this</span><span class="s1">.test.shouldBeIncluded(context) || usedBranch === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.consequent.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.alternate.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">usedBranch.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usedBranch) {</span>
            <span class="s1">usedBranch.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.consequent.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.alternate.includeCallArguments(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isCalleeOfRenderedParent</span><span class="s2">, </span><span class="s1">preventASI</span><span class="s2">, </span><span class="s1">renderedParentType</span><span class="s2">, </span><span class="s1">renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.included) {</span>
            <span class="s2">this</span><span class="s1">.test.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement })</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.consequent.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.alternate.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">colonPos = findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">':'</span><span class="s2">, this</span><span class="s1">.consequent.end)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">inclusionStart = findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.included</span>
                <span class="s1">? findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'?'</span><span class="s2">, this</span><span class="s1">.test.end)</span>
                <span class="s1">: colonPos) + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(preventASI) {</span>
                <span class="s1">removeLineBreaks(code</span><span class="s2">, </span><span class="s1">inclusionStart</span><span class="s2">, </span><span class="s1">usedBranch.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">inclusionStart)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.included) {</span>
                <span class="s1">code.remove(colonPos</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">removeAnnotations(</span><span class="s2">this, </span><span class="s1">code)</span><span class="s2">;</span>
            <span class="s1">usedBranch.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">isCalleeOfRenderedParent</span><span class="s2">,</span>
                <span class="s1">preventASI: </span><span class="s2">true,</span>
                <span class="s1">renderedParentType: renderedParentType || </span><span class="s2">this</span><span class="s1">.parent.type</span><span class="s2">,</span>
                <span class="s1">renderedSurroundingElement: renderedSurroundingElement || </span><span class="s2">this</span><span class="s1">.parent.type</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getUsedBranch() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed) {</span>
            <span class="s2">return this</span><span class="s1">.usedBranch</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">testValue = </span><span class="s2">this</span><span class="s1">.test.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return typeof </span><span class="s1">testValue === </span><span class="s3">'symbol'</span>
            <span class="s1">? </span><span class="s2">null</span>
            <span class="s1">: (</span><span class="s2">this</span><span class="s1">.usedBranch = testValue ? </span><span class="s2">this</span><span class="s1">.consequent : </span><span class="s2">this</span><span class="s1">.alternate)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ContinueStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.label) {</span>
            <span class="s2">if </span><span class="s1">(!context.ignore.labels.has(</span><span class="s2">this</span><span class="s1">.label.name))</span>
                <span class="s2">return true;</span>
            <span class="s1">context.includedLabels.add(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!context.ignore.continues)</span>
                <span class="s2">return true;</span>
            <span class="s1">context.hasContinue = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.label) {</span>
            <span class="s2">this</span><span class="s1">.label.include()</span><span class="s2">;</span>
            <span class="s1">context.includedLabels.add(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">context.hasContinue = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">hasLoopBodyEffects(context</span><span class="s2">, </span><span class="s1">body) {</span>
    <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">hasBreak</span><span class="s2">, </span><span class="s1">hasContinue</span><span class="s2">, </span><span class="s1">ignore } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ breaks</span><span class="s2">, </span><span class="s1">continues } = ignore</span><span class="s2">;</span>
    <span class="s1">ignore.breaks = </span><span class="s2">true;</span>
    <span class="s1">ignore.continues = </span><span class="s2">true;</span>
    <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
    <span class="s1">context.hasContinue = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(body.hasEffects(context))</span>
        <span class="s2">return true;</span>
    <span class="s1">ignore.breaks = breaks</span><span class="s2">;</span>
    <span class="s1">ignore.continues = continues</span><span class="s2">;</span>
    <span class="s1">context.hasBreak = hasBreak</span><span class="s2">;</span>
    <span class="s1">context.hasContinue = hasContinue</span><span class="s2">;</span>
    <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">includeLoopBody(context</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
    <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">hasBreak</span><span class="s2">, </span><span class="s1">hasContinue } = context</span><span class="s2">;</span>
    <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
    <span class="s1">context.hasContinue = </span><span class="s2">false;</span>
    <span class="s1">body.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">context.hasBreak = hasBreak</span><span class="s2">;</span>
    <span class="s1">context.hasContinue = hasContinue</span><span class="s2">;</span>
    <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">DoWhileStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">return </span><span class="s1">hasLoopBodyEffects(context</span><span class="s2">, this</span><span class="s1">.body)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">includeLoopBody(context</span><span class="s2">, this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">EmptyStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExportAllDeclaration </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.context.addExport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">_options</span><span class="s2">, </span><span class="s1">nodeRenderOptions) {</span>
        <span class="s1">code.remove(nodeRenderOptions.start</span><span class="s2">, </span><span class="s1">nodeRenderOptions.end)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>
<span class="s1">ExportAllDeclaration.prototype.needsBoundaries = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">FunctionDeclaration </span><span class="s2">extends </span><span class="s1">FunctionNode {</span>
    <span class="s1">initialise() {</span>
        <span class="s2">super</span><span class="s1">.initialise()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.id !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.id.variable.isId = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">if </span><span class="s1">(esTreeNode.id !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.id = </span><span class="s2">new </span><span class="s1">Identifier(esTreeNode.id</span><span class="s2">, this, this</span><span class="s1">.scope.parent)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// The header ends at the first non-white-space after &quot;default&quot;</span>
<span class="s2">function </span><span class="s1">getDeclarationStart(code</span><span class="s2">, </span><span class="s1">start) {</span>
    <span class="s2">return </span><span class="s1">findNonWhiteSpace(code</span><span class="s2">, </span><span class="s1">findFirstOccurrenceOutsideComment(code</span><span class="s2">, </span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">start) + </span><span class="s4">7</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getFunctionIdInsertPosition(code</span><span class="s2">, </span><span class="s1">start) {</span>
    <span class="s2">const </span><span class="s1">declarationEnd = findFirstOccurrenceOutsideComment(code</span><span class="s2">, </span><span class="s3">'function'</span><span class="s2">, </span><span class="s1">start) + </span><span class="s3">'function'</span><span class="s1">.length</span><span class="s2">;</span>
    <span class="s1">code = code.slice(declarationEnd</span><span class="s2">, </span><span class="s1">findFirstOccurrenceOutsideComment(code</span><span class="s2">, </span><span class="s3">'('</span><span class="s2">, </span><span class="s1">declarationEnd))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">generatorStarPos = findFirstOccurrenceOutsideComment(code</span><span class="s2">, </span><span class="s3">'*'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(generatorStarPos === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">declarationEnd</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">declarationEnd + generatorStarPos + </span><span class="s4">1</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">ExportDefaultDeclaration </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively) {</span>
            <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">const </span><span class="s1">declaration = </span><span class="s2">this</span><span class="s1">.declaration</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.declarationName =</span>
            <span class="s1">(declaration.id &amp;&amp; declaration.id.name) || </span><span class="s2">this</span><span class="s1">.declaration.name</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">this</span><span class="s1">.scope.addExportDefaultDeclaration(</span><span class="s2">this</span><span class="s1">.declarationName || </span><span class="s2">this</span><span class="s1">.context.getModuleName()</span><span class="s2">, this, this</span><span class="s1">.context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.addExport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">nodeRenderOptions) {</span>
        <span class="s2">const </span><span class="s1">{ start</span><span class="s2">, </span><span class="s1">end } = nodeRenderOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">declarationStart = getDeclarationStart(code.original</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.declaration </span><span class="s2">instanceof </span><span class="s1">FunctionDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.renderNamedDeclaration(code</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, this</span><span class="s1">.declaration.id === </span><span class="s2">null</span>
                <span class="s1">? getFunctionIdInsertPosition(code.original</span><span class="s2">, </span><span class="s1">declarationStart)</span>
                <span class="s1">: </span><span class="s2">null, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.declaration </span><span class="s2">instanceof </span><span class="s1">ClassDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.renderNamedDeclaration(code</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, this</span><span class="s1">.declaration.id === </span><span class="s2">null</span>
                <span class="s1">? findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'class'</span><span class="s2">, </span><span class="s1">start) + </span><span class="s3">'class'</span><span class="s1">.length</span>
                <span class="s1">: </span><span class="s2">null, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable.getOriginalVariable() !== </span><span class="s2">this</span><span class="s1">.variable) {</span>
            <span class="s0">// Remove altogether to prevent re-declaring the same variable</span>
            <span class="s1">treeshakeNode(</span><span class="s2">this, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.variable.included) {</span>
            <span class="s2">this</span><span class="s1">.renderVariableDeclaration(code</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">declarationStart)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.declaration.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">renderedSurroundingElement: ExpressionStatement$1</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(code.original[</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">';'</span><span class="s1">) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.declaration.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">renderNamedDeclaration(code</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, </span><span class="s1">idInsertPosition</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">snippets: { getPropertyAccess } } = options</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.variable.getName(getPropertyAccess)</span><span class="s2">;</span>
        <span class="s0">// Remove `export default`</span>
        <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">declarationStart)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(idInsertPosition !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">code.appendLeft(idInsertPosition</span><span class="s2">, </span><span class="s3">` </span><span class="s1">${name}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'system' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.declaration </span><span class="s2">instanceof </span><span class="s1">ClassDeclaration &amp;&amp;</span>
            <span class="s1">exportNamesByVariable.has(</span><span class="s2">this</span><span class="s1">.variable)) {</span>
            <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">` </span><span class="s1">${getSystemExportStatement([</span><span class="s2">this</span><span class="s1">.variable]</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">;`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">renderVariableDeclaration(code</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, </span><span class="s1">{ format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">snippets: { cnst</span><span class="s2">, </span><span class="s1">getPropertyAccess } }) {</span>
        <span class="s2">const </span><span class="s1">hasTrailingSemicolon = code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">59</span><span class="s2">; </span><span class="s0">/*&quot;;&quot;*/</span>
        <span class="s2">const </span><span class="s1">systemExportNames = format === </span><span class="s3">'system' </span><span class="s1">&amp;&amp; exportNamesByVariable.get(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(systemExportNames) {</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${cnst} ${</span><span class="s2">this</span><span class="s1">.variable.getName(getPropertyAccess)} </span><span class="s3">= exports('</span><span class="s1">${systemExportNames[</span><span class="s4">0</span><span class="s1">]}</span><span class="s3">', `</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.appendRight(hasTrailingSemicolon ? </span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1 </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">')' </span><span class="s1">+ (hasTrailingSemicolon ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">';'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">declarationStart</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${cnst} ${</span><span class="s2">this</span><span class="s1">.variable.getName(getPropertyAccess)} </span><span class="s3">= `</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!hasTrailingSemicolon) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">ExportDefaultDeclaration.prototype.needsBoundaries = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">ExportNamedDeclaration </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">bind() {</span>
        <span class="s0">// Do not bind specifiers</span>
        <span class="s2">this</span><span class="s1">.declaration?.bind()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">return </span><span class="s1">!!</span><span class="s2">this</span><span class="s1">.declaration?.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.context.addExport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">nodeRenderOptions) {</span>
        <span class="s2">const </span><span class="s1">{ start</span><span class="s2">, </span><span class="s1">end } = nodeRenderOptions</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.declaration === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">code.remove(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.declaration.start)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.declaration.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ end</span><span class="s2">, </span><span class="s1">start })</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>
<span class="s1">ExportNamedDeclaration.prototype.needsBoundaries = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">ExportSpecifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ForInStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">const </span><span class="s1">{ body</span><span class="s2">, </span><span class="s1">deoptimized</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(left.hasEffectsAsAssignmentTarget(context</span><span class="s2">, false</span><span class="s1">) || right.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">return </span><span class="s1">hasLoopBodyEffects(context</span><span class="s2">, </span><span class="s1">body)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">const </span><span class="s1">{ body</span><span class="s2">, </span><span class="s1">deoptimized</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s1">left.includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively || </span><span class="s2">true, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">right.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">includeLoopBody(context</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.left.setAssignedValue(UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.left.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s0">// handle no space between &quot;in&quot; and the right side</span>
        <span class="s2">if </span><span class="s1">(code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.right.start - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">110 </span><span class="s0">/* n */</span><span class="s1">) {</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.right.start</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.body.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.left.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ForOfStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s0">// Placeholder until proper Symbol.Iterator support</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">const </span><span class="s1">{ body</span><span class="s2">, </span><span class="s1">deoptimized</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s1">left.includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively || </span><span class="s2">true, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">right.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">includeLoopBody(context</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.left.setAssignedValue(UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.left.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s0">// handle no space between &quot;of&quot; and the right side</span>
        <span class="s2">if </span><span class="s1">(code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.right.start - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">102 </span><span class="s0">/* f */</span><span class="s1">) {</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.right.start</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.body.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.left.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ForStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.init?.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.test?.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.update?.hasEffects(context)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">hasLoopBodyEffects(context</span><span class="s2">, this</span><span class="s1">.body)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.init?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.test?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.update?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">includeLoopBody(context</span><span class="s2">, this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.init?.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.test?.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.update?.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">NO_SEMICOLON)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.body.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">FunctionExpression </span><span class="s2">extends </span><span class="s1">FunctionNode {</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(renderedSurroundingElement === ExpressionStatement$1) {</span>
            <span class="s1">code.appendRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TrackingScope </span><span class="s2">extends </span><span class="s1">BlockScope {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hoistedDeclarations = []</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted) {</span>
        <span class="s2">this</span><span class="s1">.hoistedDeclarations.push(identifier)</span><span class="s2">;</span>
        <span class="s2">return super</span><span class="s1">.addDeclaration(identifier</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">isHoisted)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">unset = Symbol(</span><span class="s3">'unset'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">IfStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.testValue = unset</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">this</span><span class="s1">.testValue = UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.hasEffects(context)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">testValue = </span><span class="s2">this</span><span class="s1">.getTestValue()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">testValue === </span><span class="s3">'symbol'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ brokenFlow } = context</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.hasEffects(context))</span>
                <span class="s2">return true;</span>
            <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
            <span class="s2">const </span><span class="s1">consequentBrokenFlow = context.brokenFlow</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alternate === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">return false;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alternate.hasEffects(context))</span>
                <span class="s2">return true;</span>
            <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
            <span class="s1">context.brokenFlow = context.brokenFlow &amp;&amp; consequentBrokenFlow</span><span class="s2">;</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">testValue ? </span><span class="s2">this</span><span class="s1">.consequent.hasEffects(context) : !!</span><span class="s2">this</span><span class="s1">.alternate?.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively) {</span>
            <span class="s2">this</span><span class="s1">.includeRecursively(includeChildrenRecursively</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">testValue = </span><span class="s2">this</span><span class="s1">.getTestValue()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">testValue === </span><span class="s3">'symbol'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.includeUnknownTest(context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.includeKnownTest(context</span><span class="s2">, </span><span class="s1">testValue)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">this</span><span class="s1">.consequentScope = </span><span class="s2">new </span><span class="s1">TrackingScope(</span><span class="s2">this</span><span class="s1">.scope)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.consequent = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(esTreeNode.consequent.type))(esTreeNode.consequent</span><span class="s2">, this, this</span><span class="s1">.consequentScope)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(esTreeNode.alternate) {</span>
            <span class="s2">this</span><span class="s1">.alternateScope = </span><span class="s2">new </span><span class="s1">TrackingScope(</span><span class="s2">this</span><span class="s1">.scope)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.alternate = </span><span class="s2">new </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.getNodeConstructor(esTreeNode.alternate.type))(esTreeNode.alternate</span><span class="s2">, this, this</span><span class="s1">.alternateScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ snippets: { getPropertyAccess } } = options</span><span class="s2">;</span>
        <span class="s0">// Note that unknown test values are always included</span>
        <span class="s2">const </span><span class="s1">testValue = </span><span class="s2">this</span><span class="s1">.getTestValue()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">hoistedDeclarations = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">includesIfElse = </span><span class="s2">this</span><span class="s1">.test.included</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">noTreeshake = !</span><span class="s2">this</span><span class="s1">.context.options.treeshake</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includesIfElse) {</span>
            <span class="s2">this</span><span class="s1">.test.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.consequent.start)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.included &amp;&amp; (noTreeshake || </span><span class="s2">typeof </span><span class="s1">testValue === </span><span class="s3">'symbol' </span><span class="s1">|| testValue)) {</span>
            <span class="s2">this</span><span class="s1">.consequent.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.consequent.start</span><span class="s2">, this</span><span class="s1">.consequent.end</span><span class="s2">, </span><span class="s1">includesIfElse ? </span><span class="s3">';' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">hoistedDeclarations.push(...</span><span class="s2">this</span><span class="s1">.consequentScope.hoistedDeclarations)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alternate) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alternate.included &amp;&amp; (noTreeshake || </span><span class="s2">typeof </span><span class="s1">testValue === </span><span class="s3">'symbol' </span><span class="s1">|| !testValue)) {</span>
                <span class="s2">if </span><span class="s1">(includesIfElse) {</span>
                    <span class="s2">if </span><span class="s1">(code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.alternate.start - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">101</span><span class="s1">) {</span>
                        <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.alternate.start</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.consequent.end</span><span class="s2">, this</span><span class="s1">.alternate.start)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.alternate.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(includesIfElse &amp;&amp; </span><span class="s2">this</span><span class="s1">.shouldKeepAlternateBranch()) {</span>
                    <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.alternate.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.consequent.end</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">hoistedDeclarations.push(...</span><span class="s2">this</span><span class="s1">.alternateScope.hoistedDeclarations)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.renderHoistedDeclarations(hoistedDeclarations</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">getPropertyAccess)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">getTestValue() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.testValue === unset) {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.testValue = </span><span class="s2">this</span><span class="s1">.test.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.testValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeKnownTest(context</span><span class="s2">, </span><span class="s1">testValue) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.shouldBeIncluded(context)) {</span>
            <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(testValue &amp;&amp; </span><span class="s2">this</span><span class="s1">.consequent.shouldBeIncluded(context)) {</span>
            <span class="s2">this</span><span class="s1">.consequent.include(context</span><span class="s2">, false, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!testValue &amp;&amp; </span><span class="s2">this</span><span class="s1">.alternate?.shouldBeIncluded(context)) {</span>
            <span class="s2">this</span><span class="s1">.alternate.include(context</span><span class="s2">, false, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeRecursively(includeChildrenRecursively</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.consequent.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.alternate?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeUnknownTest(context) {</span>
        <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ brokenFlow } = context</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">consequentBrokenFlow = </span><span class="s2">false;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.shouldBeIncluded(context)) {</span>
            <span class="s2">this</span><span class="s1">.consequent.include(context</span><span class="s2">, false, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
            <span class="s1">consequentBrokenFlow = context.brokenFlow</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alternate?.shouldBeIncluded(context)) {</span>
            <span class="s2">this</span><span class="s1">.alternate.include(context</span><span class="s2">, false, </span><span class="s1">{ asSingleStatement: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
            <span class="s1">context.brokenFlow = context.brokenFlow &amp;&amp; consequentBrokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">renderHoistedDeclarations(hoistedDeclarations</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">getPropertyAccess) {</span>
        <span class="s2">const </span><span class="s1">hoistedVariables = [</span>
            <span class="s1">...</span><span class="s2">new </span><span class="s1">Set(hoistedDeclarations.map(identifier =&gt; {</span>
                <span class="s2">const </span><span class="s1">variable = identifier.variable</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">variable.included ? variable.getName(getPropertyAccess) : </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s1">}))</span>
        <span class="s1">]</span>
            <span class="s1">.filter(Boolean)</span>
            <span class="s1">.join(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hoistedVariables) {</span>
            <span class="s2">const </span><span class="s1">parentType = </span><span class="s2">this</span><span class="s1">.parent.type</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">needsBraces = parentType !== Program$1 &amp;&amp; parentType !== BlockStatement$1</span><span class="s2">;</span>
            <span class="s1">code.prependRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${needsBraces ? </span><span class="s3">'{ ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">var </span><span class="s1">${hoistedVariables}</span><span class="s3">; `</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(needsBraces) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">` }`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">shouldKeepAlternateBranch() {</span>
        <span class="s2">let </span><span class="s1">currentParent = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
        <span class="s2">do </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(currentParent </span><span class="s2">instanceof </span><span class="s1">IfStatement &amp;&amp; currentParent.alternate) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(currentParent </span><span class="s2">instanceof </span><span class="s1">BlockStatement) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
            <span class="s1">currentParent = currentParent.parent</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(currentParent)</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ImportAttribute </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ImportDeclaration </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s0">// Do not bind specifiers or assertions</span>
    <span class="s1">bind() { }</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.context.addImport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">_options</span><span class="s2">, </span><span class="s1">nodeRenderOptions) {</span>
        <span class="s1">code.remove(nodeRenderOptions.start</span><span class="s2">, </span><span class="s1">nodeRenderOptions.end)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>
<span class="s1">ImportDeclaration.prototype.needsBoundaries = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">ImportDefaultSpecifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">INTEROP_DEFAULT_VARIABLE = </span><span class="s3">'_interopDefault'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTEROP_DEFAULT_COMPAT_VARIABLE = </span><span class="s3">'_interopDefaultCompat'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTEROP_NAMESPACE_VARIABLE = </span><span class="s3">'_interopNamespace'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTEROP_NAMESPACE_COMPAT_VARIABLE = </span><span class="s3">'_interopNamespaceCompat'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTEROP_NAMESPACE_DEFAULT_VARIABLE = </span><span class="s3">'_interopNamespaceDefault'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = </span><span class="s3">'_interopNamespaceDefaultOnly'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">MERGE_NAMESPACES_VARIABLE = </span><span class="s3">'_mergeNamespaces'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">defaultInteropHelpersByInteropType = {</span>
    <span class="s1">auto: INTEROP_DEFAULT_VARIABLE</span><span class="s2">,</span>
    <span class="s1">compat: INTEROP_DEFAULT_COMPAT_VARIABLE</span><span class="s2">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">null,</span>
    <span class="s1">defaultOnly: </span><span class="s2">null,</span>
    <span class="s1">esModule: </span><span class="s2">null</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isDefaultAProperty = (interopType</span><span class="s2">, </span><span class="s1">externalLiveBindings) =&gt; interopType === </span><span class="s3">'esModule' </span><span class="s1">||</span>
    <span class="s1">(externalLiveBindings &amp;&amp; (interopType === </span><span class="s3">'auto' </span><span class="s1">|| interopType === </span><span class="s3">'compat'</span><span class="s1">))</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">namespaceInteropHelpersByInteropType = {</span>
    <span class="s1">auto: INTEROP_NAMESPACE_VARIABLE</span><span class="s2">,</span>
    <span class="s1">compat: INTEROP_NAMESPACE_COMPAT_VARIABLE</span><span class="s2">,</span>
    <span class="s2">default</span><span class="s1">: INTEROP_NAMESPACE_DEFAULT_VARIABLE</span><span class="s2">,</span>
    <span class="s1">defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE</span><span class="s2">,</span>
    <span class="s1">esModule: </span><span class="s2">null</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">canDefaultBeTakenFromNamespace = (interopType</span><span class="s2">, </span><span class="s1">externalLiveBindings) =&gt; interopType !== </span><span class="s3">'esModule' </span><span class="s1">&amp;&amp; isDefaultAProperty(interopType</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getHelpersBlock = (additionalHelpers</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) =&gt; {</span>
    <span class="s2">const </span><span class="s1">usedHelpers = </span><span class="s2">new </span><span class="s1">Set(additionalHelpers)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of HELPER_NAMES) {</span>
        <span class="s2">if </span><span class="s1">(accessedGlobals.has(variable)) {</span>
            <span class="s1">usedHelpers.add(variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">HELPER_NAMES.map(variable =&gt; usedHelpers.has(variable)</span>
        <span class="s1">? HELPER_GENERATORS[variable](indent</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">usedHelpers)</span>
        <span class="s1">: </span><span class="s3">''</span><span class="s1">).join(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">HELPER_GENERATORS = {</span>
    <span class="s1">[INTEROP_DEFAULT_COMPAT_VARIABLE](_t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">functionReturn: </span><span class="s2">true,</span>
            <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
            <span class="s1">name: INTEROP_DEFAULT_COMPAT_VARIABLE</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${left}${getIsCompatNamespace(snippets)}${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[INTEROP_DEFAULT_VARIABLE](_t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">functionReturn: </span><span class="s2">true,</span>
            <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
            <span class="s1">name: INTEROP_DEFAULT_VARIABLE</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${left}</span><span class="s3">e</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">e.__esModule</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[INTEROP_NAMESPACE_COMPAT_VARIABLE](t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">usedHelpers) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {</span>
            <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">functionReturn: </span><span class="s2">true,</span>
                <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                <span class="s1">name: INTEROP_NAMESPACE_COMPAT_VARIABLE</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${left}${getIsCompatNamespace(snippets)}${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">e</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}</span><span class="s3">(e)</span><span class="s1">${right}${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`function </span><span class="s1">${INTEROP_NAMESPACE_COMPAT_VARIABLE}</span><span class="s3">(e)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${getIsCompatNamespace(snippets)}</span><span class="s3">)</span><span class="s1">${_}</span><span class="s3">return e;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s1">createNamespaceObject(t</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) +</span>
            <span class="s3">`}</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">_liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) {</span>
        <span class="s2">const </span><span class="s1">{ getDirectReturnFunction</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">functionReturn: </span><span class="s2">true,</span>
            <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
            <span class="s1">name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${left}${getFrozen(freeze</span><span class="s2">, </span><span class="s1">getWithToStringTag(namespaceToStringTag</span><span class="s2">, </span><span class="s1">getObject([</span>
            <span class="s1">[</span><span class="s3">'__proto__'</span><span class="s2">, </span><span class="s3">'null'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'e'</span><span class="s1">]</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: </span><span class="s2">null </span><span class="s1">})</span><span class="s2">, </span><span class="s1">snippets))}${right}${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[INTEROP_NAMESPACE_DEFAULT_VARIABLE](t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`function </span><span class="s1">${INTEROP_NAMESPACE_DEFAULT_VARIABLE}</span><span class="s3">(e)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s1">createNamespaceObject(t</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) +</span>
            <span class="s3">`}</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[INTEROP_NAMESPACE_VARIABLE](t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">usedHelpers) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {</span>
            <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">functionReturn: </span><span class="s2">true,</span>
                <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                <span class="s1">name: INTEROP_NAMESPACE_VARIABLE</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${left}</span><span class="s3">e</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">e.__esModule</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">e</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}</span><span class="s3">(e)</span><span class="s1">${right}${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`function </span><span class="s1">${INTEROP_NAMESPACE_VARIABLE}</span><span class="s3">(e)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(e</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">e.__esModule)</span><span class="s1">${_}</span><span class="s3">return e;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s1">createNamespaceObject(t</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) +</span>
            <span class="s3">`}</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[MERGE_NAMESPACES_VARIABLE](t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) {</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">useForEach = cnst === </span><span class="s3">'var' </span><span class="s1">&amp;&amp; liveBindings</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`function </span><span class="s1">${MERGE_NAMESPACES_VARIABLE}</span><span class="s3">(n, m)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}${loopOverNamespaces(</span><span class="s3">`{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}${t}${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(k</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'default'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">!(k in n))</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s1">(liveBindings</span>
                    <span class="s1">? useForEach</span>
                        <span class="s1">? copyOwnPropertyLiveBinding</span>
                        <span class="s1">: copyPropertyLiveBinding</span>
                    <span class="s1">: copyPropertyStatic)(t</span><span class="s2">, </span><span class="s1">t + t + t + t</span><span class="s2">, </span><span class="s1">snippets) +</span>
                <span class="s3">`</span><span class="s1">${t}${t}${t}</span><span class="s3">}</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">}`</span><span class="s2">, </span><span class="s1">useForEach</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)}${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}</span><span class="s3">return </span><span class="s1">${getFrozen(freeze</span><span class="s2">, </span><span class="s1">getWithToStringTag(namespaceToStringTag</span><span class="s2">, </span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">snippets))}</span><span class="s3">;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`}</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getDefaultLiveBinding = ({ _</span><span class="s2">, </span><span class="s1">getObject }) =&gt; </span><span class="s3">`e</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}${getObject([[</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'e'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: </span><span class="s2">null </span><span class="s1">})}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getDefaultStatic = ({ _</span><span class="s2">, </span><span class="s1">getPropertyAccess }) =&gt; </span><span class="s3">`e</span><span class="s1">${getPropertyAccess(</span><span class="s3">'default'</span><span class="s1">)}${_}</span><span class="s3">:</span><span class="s1">${_}</span><span class="s3">e`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getIsCompatNamespace = ({ _ }) =&gt; </span><span class="s3">`e</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">typeof e</span><span class="s1">${_}</span><span class="s3">===</span><span class="s1">${_}</span><span class="s3">'object'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">'default'</span><span class="s1">${_}</span><span class="s3">in e`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">createNamespaceObject = (t</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">liveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">copyProperty = </span><span class="s3">`{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">(liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t</span><span class="s2">, </span><span class="s1">index + t + t</span><span class="s2">, </span><span class="s1">snippets) +</span>
        <span class="s3">`</span><span class="s1">${index}${t}</span><span class="s3">}`</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${index}${cnst} </span><span class="s3">n</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">Object.create(null</span><span class="s1">${namespaceToStringTag</span>
        <span class="s1">? </span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}</span><span class="s3">[Symbol.toStringTag]:</span><span class="s1">${_}${getToStringTagValue(getObject)}${_}</span><span class="s3">}`</span>
        <span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">);</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(e)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}${loopOverKeys(copyProperty</span><span class="s2">, </span><span class="s1">!liveBindings</span><span class="s2">, </span><span class="s1">snippets)}${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">}</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">n</span><span class="s1">${getPropertyAccess(</span><span class="s3">'default'</span><span class="s1">)}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">e;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">return </span><span class="s1">${getFrozen(freeze</span><span class="s2">, </span><span class="s3">'n'</span><span class="s1">)}${s}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">loopOverKeys = (body</span><span class="s2">, </span><span class="s1">allowVariableLoopVariable</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getFunctionIntro</span><span class="s2">, </span><span class="s1">s }) =&gt; cnst !== </span><span class="s3">'var' </span><span class="s1">|| allowVariableLoopVariable</span>
    <span class="s1">? </span><span class="s3">`for</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${cnst} </span><span class="s3">k in e)</span><span class="s1">${_}${body}</span><span class="s3">`</span>
    <span class="s1">: </span><span class="s3">`Object.keys(e).forEach(</span><span class="s1">${getFunctionIntro([</span><span class="s3">'k'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">isAsync: </span><span class="s2">false,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})}${body}</span><span class="s3">)</span><span class="s1">${s}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">loopOverNamespaces = (body</span><span class="s2">, </span><span class="s1">useForEach</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">getFunctionIntro</span><span class="s2">, </span><span class="s1">n }) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(useForEach) {</span>
        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'e'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">functionReturn: </span><span class="s2">false,</span>
            <span class="s1">lineBreakIndent: { base: t</span><span class="s2">, </span><span class="s1">t }</span><span class="s2">,</span>
            <span class="s1">name: </span><span class="s2">null</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`m.forEach(</span><span class="s1">${left}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`e</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">typeof e</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'string'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">!Array.isArray(e)</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">Object.keys(e).forEach(</span><span class="s1">${getFunctionIntro([</span><span class="s3">'k'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">isAsync: </span><span class="s2">false,</span>
                <span class="s1">name: </span><span class="s2">null</span>
            <span class="s1">})}${body}</span><span class="s3">)</span><span class="s1">${right}</span><span class="s3">);`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`for</span><span class="s1">${_}</span><span class="s3">(var i</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">0;</span><span class="s1">${_}</span><span class="s3">i</span><span class="s1">${_}</span><span class="s3">&lt;</span><span class="s1">${_}</span><span class="s3">m.length;</span><span class="s1">${_}</span><span class="s3">i++)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${t}${t}${cnst} </span><span class="s3">e</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">m[i];</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(typeof e</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'string'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">!Array.isArray(e))</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}</span><span class="s3">for</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${cnst} </span><span class="s3">k in e)</span><span class="s1">${_}${body}${_}</span><span class="s3">}</span><span class="s1">${n}${t}</span><span class="s3">}`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">copyNonDefaultOwnPropertyLiveBinding = (t</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">snippets) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${index}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(k</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'default')</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">copyOwnPropertyLiveBinding(t</span><span class="s2">, </span><span class="s1">index + t</span><span class="s2">, </span><span class="s1">snippets) +</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">}</span><span class="s1">${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">copyOwnPropertyLiveBinding = (t</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n }) =&gt; {</span>
    <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">functionReturn: </span><span class="s2">true,</span>
        <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${index}${cnst} </span><span class="s3">d</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">Object.getOwnPropertyDescriptor(e,</span><span class="s1">${_}</span><span class="s3">k);</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">Object.defineProperty(n,</span><span class="s1">${_}</span><span class="s3">k,</span><span class="s1">${_}</span><span class="s3">d.get</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">d</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}</span><span class="s3">enumerable:</span><span class="s1">${_}</span><span class="s3">true,</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}</span><span class="s3">get:</span><span class="s1">${_}${left}</span><span class="s3">e[k]</span><span class="s1">${right}${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">});</span><span class="s1">${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">copyPropertyLiveBinding = (t</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n }) =&gt; {</span>
    <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">functionReturn: </span><span class="s2">true,</span>
        <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`</span><span class="s1">${index}${cnst} </span><span class="s3">d</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">Object.getOwnPropertyDescriptor(e,</span><span class="s1">${_}</span><span class="s3">k);</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(d)</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}</span><span class="s3">Object.defineProperty(n,</span><span class="s1">${_}</span><span class="s3">k,</span><span class="s1">${_}</span><span class="s3">d.get</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">d</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}${t}</span><span class="s3">enumerable:</span><span class="s1">${_}</span><span class="s3">true,</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}${t}</span><span class="s3">get:</span><span class="s1">${_}${left}</span><span class="s3">e[k]</span><span class="s1">${right}${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}${t}</span><span class="s3">});</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${index}</span><span class="s3">}</span><span class="s1">${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">copyPropertyStatic = (_t</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n }) =&gt; </span><span class="s3">`</span><span class="s1">${index}</span><span class="s3">n[k]</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">e[k];</span><span class="s1">${n}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getFrozen = (freeze</span><span class="s2">, </span><span class="s1">fragment) =&gt; freeze ? </span><span class="s3">`Object.freeze(</span><span class="s1">${fragment}</span><span class="s3">)` </span><span class="s1">: fragment</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getWithToStringTag = (namespaceToStringTag</span><span class="s2">, </span><span class="s1">fragment</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getObject }) =&gt; namespaceToStringTag</span>
    <span class="s1">? </span><span class="s3">`Object.defineProperty(</span><span class="s1">${fragment}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">Symbol.toStringTag,</span><span class="s1">${_}${getToStringTagValue(getObject)}</span><span class="s3">)`</span>
    <span class="s1">: fragment</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">HELPER_NAMES = Object.keys(HELPER_GENERATORS)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getToStringTagValue(getObject) {</span>
    <span class="s2">return </span><span class="s1">getObject([[</span><span class="s3">'value'</span><span class="s2">, </span><span class="s3">&quot;'Module'&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">lineBreakIndent: </span><span class="s2">null</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isReassignedExportsMember(variable</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
    <span class="s2">return </span><span class="s1">(variable.renderBaseName !== </span><span class="s2">null </span><span class="s1">&amp;&amp; exportNamesByVariable.has(variable) &amp;&amp; variable.isReassigned)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">VariableDeclarator </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">declareDeclarator(kind) {</span>
        <span class="s2">this</span><span class="s1">.id.declare(kind</span><span class="s2">, this</span><span class="s1">.init || UNDEFINED_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.id.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">initEffect = </span><span class="s2">this</span><span class="s1">.init?.hasEffects(context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id.markDeclarationReached()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">initEffect || </span><span class="s2">this</span><span class="s1">.id.hasEffects(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">const </span><span class="s1">{ deoptimized</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">init } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(!deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s1">init?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">id.markDeclarationReached()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively || id.shouldBeIncluded(context)) {</span>
            <span class="s1">id.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">snippets: { _</span><span class="s2">, </span><span class="s1">getPropertyAccess } } = options</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ end</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">init</span><span class="s2">, </span><span class="s1">start } = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">renderId = id.included</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(renderId) {</span>
            <span class="s1">id.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">operatorPos = findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'='</span><span class="s2">, </span><span class="s1">id.end)</span><span class="s2">;</span>
            <span class="s1">code.remove(start</span><span class="s2">, </span><span class="s1">findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">operatorPos + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(init) {</span>
            <span class="s2">if </span><span class="s1">(id </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp; init </span><span class="s2">instanceof </span><span class="s1">ClassExpression &amp;&amp; !init.id) {</span>
                <span class="s2">const </span><span class="s1">renderedVariable = id.variable.getName(getPropertyAccess)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(renderedVariable !== id.name) {</span>
                    <span class="s1">code.appendLeft(init.start + </span><span class="s4">5</span><span class="s2">, </span><span class="s3">` </span><span class="s1">${id.name}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">init.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">renderId ? BLANK : { renderedSurroundingElement: ExpressionStatement$1 })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(id </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp;</span>
            <span class="s1">isReassignedExportsMember(id.variable</span><span class="s2">, </span><span class="s1">exportNamesByVariable)) {</span>
            <span class="s1">code.appendLeft(end</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">void 0`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ id</span><span class="s2">, </span><span class="s1">init } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(init &amp;&amp; id </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp; init </span><span class="s2">instanceof </span><span class="s1">ClassExpression &amp;&amp; !init.id) {</span>
            <span class="s2">const </span><span class="s1">{ name</span><span class="s2">, </span><span class="s1">variable } = id</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">accessedVariable of init.scope.accessedOutsideVariables.values()) {</span>
                <span class="s2">if </span><span class="s1">(accessedVariable !== variable) {</span>
                    <span class="s1">accessedVariable.forbidName(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// TODO once ImportExpression follows official ESTree specs with &quot;null&quot; as</span>
<span class="s0">//  default, keys.ts should be updated</span>
<span class="s2">class </span><span class="s1">ImportExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inlineNamespace = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.assertions = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.mechanism = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.namespaceExportName = undefined</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.resolution = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.resolutionString = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s0">// Do not bind assertions</span>
    <span class="s1">bind() {</span>
        <span class="s2">this</span><span class="s1">.source.bind()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Get imported variables for deterministic usage, valid cases are:</span>
     <span class="s5">*</span>
     <span class="s5">* - `const { foo } = await import('bar')`.</span>
     <span class="s5">* - `(await import('bar')).foo`</span>
     <span class="s5">* - `import('bar').then(({ foo }) =&gt; {})`</span>
     <span class="s5">*</span>
     <span class="s5">* Returns empty array if it's side-effect only import.</span>
     <span class="s5">* Returns undefined if it's not fully deterministic.</span>
     <span class="s5">*/</span>
    <span class="s1">getDeterministicImportedNames() {</span>
        <span class="s2">const </span><span class="s1">parent1 = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
        <span class="s0">// Side-effect only: import('bar')</span>
        <span class="s2">if </span><span class="s1">(parent1 </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement) {</span>
            <span class="s2">return </span><span class="s1">EMPTY_ARRAY</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parent1 </span><span class="s2">instanceof </span><span class="s1">AwaitExpression) {</span>
            <span class="s2">const </span><span class="s1">parent2 = parent1.parent</span><span class="s2">;</span>
            <span class="s0">// Side-effect only: await import('bar')</span>
            <span class="s2">if </span><span class="s1">(parent2 </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement) {</span>
                <span class="s2">return </span><span class="s1">EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// Case 1: const { foo } = await import('bar')</span>
            <span class="s2">if </span><span class="s1">(parent2 </span><span class="s2">instanceof </span><span class="s1">VariableDeclarator) {</span>
                <span class="s2">const </span><span class="s1">declaration = parent2.id</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">declaration </span><span class="s2">instanceof </span><span class="s1">ObjectPattern</span>
                    <span class="s1">? getDeterministicObjectDestructure(declaration)</span>
                    <span class="s1">: undefined</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// Case 2: (await import('bar')).foo</span>
            <span class="s2">if </span><span class="s1">(parent2 </span><span class="s2">instanceof </span><span class="s1">MemberExpression) {</span>
                <span class="s2">const </span><span class="s1">id = parent2.property</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!parent2.computed &amp;&amp; id </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
                    <span class="s2">return </span><span class="s1">[id.name]</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s0">// Case 3: import('bar').then(({ foo }) =&gt; {})</span>
        <span class="s2">if </span><span class="s1">(parent1 </span><span class="s2">instanceof </span><span class="s1">MemberExpression) {</span>
            <span class="s2">const </span><span class="s1">callExpression = parent1.parent</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">property = parent1.property</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!(callExpression </span><span class="s2">instanceof </span><span class="s1">CallExpression) || !(property </span><span class="s2">instanceof </span><span class="s1">Identifier)) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">memberName = property.name</span><span class="s2">;</span>
            <span class="s0">// side-effect only, when only chaining .catch or .finally</span>
            <span class="s2">if </span><span class="s1">(callExpression.parent </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement &amp;&amp;</span>
                <span class="s1">[</span><span class="s3">'catch'</span><span class="s2">, </span><span class="s3">'finally'</span><span class="s1">].includes(memberName)) {</span>
                <span class="s2">return </span><span class="s1">EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(memberName !== </span><span class="s3">'then'</span><span class="s1">)</span>
                <span class="s2">return;</span>
            <span class="s0">// Side-effect only: import('bar').then()</span>
            <span class="s2">if </span><span class="s1">(callExpression.arguments.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">argument = callExpression.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(callExpression.arguments.length !== </span><span class="s4">1 </span><span class="s1">||</span>
                <span class="s1">!(argument </span><span class="s2">instanceof </span><span class="s1">ArrowFunctionExpression || argument </span><span class="s2">instanceof </span><span class="s1">FunctionExpression)) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s0">// Side-effect only: import('bar').then(() =&gt; {})</span>
            <span class="s2">if </span><span class="s1">(argument.params.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">declaration = argument.params[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(argument.params.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; declaration </span><span class="s2">instanceof </span><span class="s1">ObjectPattern) {</span>
                <span class="s2">return </span><span class="s1">getDeterministicObjectDestructure(declaration)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.context.includeDynamicImport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.scope.addAccessedDynamicImport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.source.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.context.addDynamicImport(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s0">// Keep the source AST to be used by renderDynamicImport</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'source'</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ snippets: { _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">getPropertyAccess } } = options</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inlineNamespace) {</span>
            <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">functionReturn: </span><span class="s2">true,</span>
                <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                <span class="s1">name: </span><span class="s2">null</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">`Promise.resolve().then(</span><span class="s1">${left}${</span><span class="s2">this</span><span class="s1">.inlineNamespace.getName(getPropertyAccess)}${right}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.mechanism) {</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'('</span><span class="s2">, this</span><span class="s1">.start + </span><span class="s4">6</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.mechanism.left)</span><span class="s2">;</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, this</span><span class="s1">.mechanism.right)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resolutionString) {</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.source.start</span><span class="s2">, this</span><span class="s1">.source.end</span><span class="s2">, this</span><span class="s1">.resolutionString)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.namespaceExportName) {</span>
                <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([</span><span class="s3">'n'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">functionReturn: </span><span class="s2">true,</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">`.then(</span><span class="s1">${left}</span><span class="s3">n.</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.namespaceExportName}${right}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.source.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.assertions !== </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.arguments) {</span>
                <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.source.end</span><span class="s2">, this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">{ contentOnly: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.assertions) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, </span><span class="s3">`,</span><span class="s1">${_}${getObject([[</span><span class="s3">'assert'</span><span class="s2">, this</span><span class="s1">.assertions]]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null</span>
                <span class="s1">})}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setExternalResolution(exportMode</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">resolutionString</span><span class="s2">, </span><span class="s1">namespaceExportName</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">const </span><span class="s1">{ format } = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inlineNamespace = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.resolution = resolution</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.resolutionString = resolutionString</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.namespaceExportName = namespaceExportName</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.assertions = assertions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">accessedGlobals = [...(accessedImportGlobals[format] || [])]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">helper</span><span class="s2">;</span>
        <span class="s1">({ helper</span><span class="s2">, </span><span class="s1">mechanism: </span><span class="s2">this</span><span class="s1">.mechanism } = </span><span class="s2">this</span><span class="s1">.getDynamicImportMechanismAndHelper(resolution</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">pluginDriver))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(helper) {</span>
            <span class="s1">accessedGlobals.push(helper)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(accessedGlobals.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scope.addAccessedGlobals(accessedGlobals</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setInternalResolution(inlineNamespace) {</span>
        <span class="s2">this</span><span class="s1">.inlineNamespace = inlineNamespace</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">getDynamicImportMechanismAndHelper(resolution</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">{ compact</span><span class="s2">, </span><span class="s1">dynamicImportFunction</span><span class="s2">, </span><span class="s1">dynamicImportInCjs</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">generatedCode: { arrowFunctions }</span><span class="s2">, </span><span class="s1">interop }</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">getDirectReturnIifeLeft }</span><span class="s2">, </span><span class="s1">pluginDriver) {</span>
        <span class="s2">const </span><span class="s1">mechanism = pluginDriver.hookFirstSync(</span><span class="s3">'renderDynamicImport'</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">{</span>
                <span class="s1">customResolution: </span><span class="s2">typeof this</span><span class="s1">.resolution === </span><span class="s3">'string' </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.resolution : </span><span class="s2">null,</span>
                <span class="s1">format</span><span class="s2">,</span>
                <span class="s1">moduleId: </span><span class="s2">this</span><span class="s1">.context.module.id</span><span class="s2">,</span>
                <span class="s1">targetModuleId: </span><span class="s2">this</span><span class="s1">.resolution &amp;&amp; </span><span class="s2">typeof this</span><span class="s1">.resolution !== </span><span class="s3">'string' </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.resolution.id : </span><span class="s2">null</span>
            <span class="s1">}</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mechanism) {</span>
            <span class="s2">return </span><span class="s1">{ helper: </span><span class="s2">null, </span><span class="s1">mechanism }</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">hasDynamicTarget = !</span><span class="s2">this</span><span class="s1">.resolution || </span><span class="s2">typeof this</span><span class="s1">.resolution === </span><span class="s3">'string'</span><span class="s2">;</span>
        <span class="s2">switch </span><span class="s1">(format) {</span>
            <span class="s2">case </span><span class="s3">'cjs'</span><span class="s1">: {</span>
                <span class="s2">if </span><span class="s1">(dynamicImportInCjs &amp;&amp;</span>
                    <span class="s1">(!resolution || </span><span class="s2">typeof </span><span class="s1">resolution === </span><span class="s3">'string' </span><span class="s1">|| resolution </span><span class="s2">instanceof </span><span class="s1">ExternalModule)) {</span>
                    <span class="s2">return </span><span class="s1">{ helper: </span><span class="s2">null, </span><span class="s1">mechanism: </span><span class="s2">null </span><span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">helper = getInteropHelper(resolution</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">interop)</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">left = </span><span class="s3">`require(`</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">right = </span><span class="s3">`)`</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(helper) {</span>
                    <span class="s1">left = </span><span class="s3">`/*#__PURE__*/</span><span class="s1">${helper}</span><span class="s3">(</span><span class="s1">${left}</span><span class="s3">`</span><span class="s2">;</span>
                    <span class="s1">right += </span><span class="s3">')'</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">[functionLeft</span><span class="s2">, </span><span class="s1">functionRight] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">functionReturn: </span><span class="s2">true,</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">left = </span><span class="s3">`Promise.resolve().then(</span><span class="s1">${functionLeft}${left}</span><span class="s3">`</span><span class="s2">;</span>
                <span class="s1">right += </span><span class="s3">`</span><span class="s1">${functionRight}</span><span class="s3">)`</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!arrowFunctions &amp;&amp; hasDynamicTarget) {</span>
                    <span class="s1">left = getDirectReturnIifeLeft([</span><span class="s3">'t'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${left}</span><span class="s3">t</span><span class="s1">${right}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">needsArrowReturnParens: </span><span class="s2">false,</span>
                        <span class="s1">needsWrappedFunction: </span><span class="s2">true</span>
                    <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">right = </span><span class="s3">')'</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">helper</span><span class="s2">,</span>
                    <span class="s1">mechanism: { left</span><span class="s2">, </span><span class="s1">right }</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'amd'</span><span class="s1">: {</span>
                <span class="s2">const </span><span class="s1">resolve = compact ? </span><span class="s3">'c' </span><span class="s1">: </span><span class="s3">'resolve'</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">reject = compact ? </span><span class="s3">'e' </span><span class="s1">: </span><span class="s3">'reject'</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">helper = getInteropHelper(resolution</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">interop)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">[resolveLeft</span><span class="s2">, </span><span class="s1">resolveRight] = getDirectReturnFunction([</span><span class="s3">'m'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">functionReturn: </span><span class="s2">false,</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">resolveNamespace = helper</span>
                    <span class="s1">? </span><span class="s3">`</span><span class="s1">${resolveLeft}${resolve}</span><span class="s3">(/*#__PURE__*/</span><span class="s1">${helper}</span><span class="s3">(m))</span><span class="s1">${resolveRight}</span><span class="s3">`</span>
                    <span class="s1">: resolve</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">[handlerLeft</span><span class="s2">, </span><span class="s1">handlerRight] = getDirectReturnFunction([resolve</span><span class="s2">, </span><span class="s1">reject]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">functionReturn: </span><span class="s2">false,</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">left = </span><span class="s3">`new Promise(</span><span class="s1">${handlerLeft}</span><span class="s3">require([`</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">right = </span><span class="s3">`],</span><span class="s1">${_}${resolveNamespace}</span><span class="s3">,</span><span class="s1">${_}${reject}</span><span class="s3">)</span><span class="s1">${handlerRight}</span><span class="s3">)`</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!arrowFunctions &amp;&amp; hasDynamicTarget) {</span>
                    <span class="s1">left = getDirectReturnIifeLeft([</span><span class="s3">'t'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${left}</span><span class="s3">t</span><span class="s1">${right}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">needsArrowReturnParens: </span><span class="s2">false,</span>
                        <span class="s1">needsWrappedFunction: </span><span class="s2">true</span>
                    <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">right = </span><span class="s3">')'</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">helper</span><span class="s2">,</span>
                    <span class="s1">mechanism: { left</span><span class="s2">, </span><span class="s1">right }</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'system'</span><span class="s1">: {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">helper: </span><span class="s2">null,</span>
                    <span class="s1">mechanism: {</span>
                        <span class="s1">left: </span><span class="s3">'module.import('</span><span class="s2">,</span>
                        <span class="s1">right: </span><span class="s3">')'</span>
                    <span class="s1">}</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'es'</span><span class="s1">: {</span>
                <span class="s2">if </span><span class="s1">(dynamicImportFunction) {</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">helper: </span><span class="s2">null,</span>
                        <span class="s1">mechanism: {</span>
                            <span class="s1">left: </span><span class="s3">`</span><span class="s1">${dynamicImportFunction}</span><span class="s3">(`</span><span class="s2">,</span>
                            <span class="s1">right: </span><span class="s3">')'</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ helper: </span><span class="s2">null, </span><span class="s1">mechanism: </span><span class="s2">null </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getInteropHelper(resolution</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">interop) {</span>
    <span class="s2">return </span><span class="s1">exportMode === </span><span class="s3">'external'</span>
        <span class="s1">? namespaceInteropHelpersByInteropType[interop(resolution </span><span class="s2">instanceof </span><span class="s1">ExternalModule ? resolution.id : </span><span class="s2">null</span><span class="s1">)]</span>
        <span class="s1">: exportMode === </span><span class="s3">'default'</span>
            <span class="s1">? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE</span>
            <span class="s1">: </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">accessedImportGlobals = {</span>
    <span class="s1">amd: [</span><span class="s3">'require'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">cjs: [</span><span class="s3">'require'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">system: [</span><span class="s3">'module'</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getDeterministicObjectDestructure(objectPattern) {</span>
    <span class="s2">const </span><span class="s1">variables = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of objectPattern.properties) {</span>
        <span class="s2">if </span><span class="s1">(property.type === </span><span class="s3">'RestElement' </span><span class="s1">|| property.computed || property.key.type !== </span><span class="s3">'Identifier'</span><span class="s1">)</span>
            <span class="s2">return;</span>
        <span class="s1">variables.push(property.key.name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">variables</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ImportNamespaceSpecifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ImportSpecifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">LabeledStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">const </span><span class="s1">brokenFlow = context.brokenFlow</span><span class="s2">;</span>
        <span class="s1">context.ignore.labels.add(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s1">context.ignore.labels.delete(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(context.includedLabels.has(</span><span class="s2">this</span><span class="s1">.label.name)) {</span>
            <span class="s1">context.includedLabels.delete(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">brokenFlow = context.brokenFlow</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.body.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively || context.includedLabels.has(</span><span class="s2">this</span><span class="s1">.label.name)) {</span>
            <span class="s2">this</span><span class="s1">.label.include()</span><span class="s2">;</span>
            <span class="s1">context.includedLabels.delete(</span><span class="s2">this</span><span class="s1">.label.name)</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.label.included) {</span>
            <span class="s2">this</span><span class="s1">.label.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">':'</span><span class="s2">, this</span><span class="s1">.label.end) + </span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.body.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">LogicalExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s0">// We collect deoptimization information if usedBranch !== null</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.usedBranch = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.left.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.right.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.usedBranch) {</span>
            <span class="s2">const </span><span class="s1">unusedBranch = </span><span class="s2">this</span><span class="s1">.usedBranch === </span><span class="s2">this</span><span class="s1">.left ? </span><span class="s2">this</span><span class="s1">.right : </span><span class="s2">this</span><span class="s1">.left</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.usedBranch = </span><span class="s2">null;</span>
            <span class="s1">unusedBranch.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ context</span><span class="s2">, </span><span class="s1">expressionsToBeDeoptimized } = </span><span class="s2">this;</span>
            <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized = EMPTY_ARRAY</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of expressionsToBeDeoptimized) {</span>
                <span class="s1">expression.deoptimizeCache()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// Request another pass because we need to ensure &quot;include&quot; runs again if</span>
            <span class="s0">// it is rendered</span>
            <span class="s1">context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usedBranch) {</span>
            <span class="s1">usedBranch.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.left.deoptimizePath(path)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.right.deoptimizePath(path)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">usedBranch.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch)</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s2">new </span><span class="s1">MultiExpression([</span>
                    <span class="s2">this</span><span class="s1">.left.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s2">this</span><span class="s1">.right.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">])</span><span class="s2">,</span>
                <span class="s2">false</span>
            <span class="s1">]</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expressionsToBeDeoptimized.push(origin)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">usedBranch.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.left.hasEffects(context)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.getUsedBranch() !== </span><span class="s2">this</span><span class="s1">.left) {</span>
            <span class="s2">return this</span><span class="s1">.right.hasEffects(context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!usedBranch) {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.left.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) ||</span>
                <span class="s2">this</span><span class="s1">.right.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">usedBranch.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">usedBranch = </span><span class="s2">this</span><span class="s1">.getUsedBranch()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively ||</span>
            <span class="s1">(usedBranch === </span><span class="s2">this</span><span class="s1">.right &amp;&amp; </span><span class="s2">this</span><span class="s1">.left.shouldBeIncluded(context)) ||</span>
            <span class="s1">!usedBranch) {</span>
            <span class="s2">this</span><span class="s1">.left.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.right.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">usedBranch.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isCalleeOfRenderedParent</span><span class="s2">, </span><span class="s1">preventASI</span><span class="s2">, </span><span class="s1">renderedParentType</span><span class="s2">, </span><span class="s1">renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.left.included || !</span><span class="s2">this</span><span class="s1">.right.included) {</span>
            <span class="s2">const </span><span class="s1">operatorPos = findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, this</span><span class="s1">.operator</span><span class="s2">, this</span><span class="s1">.left.end)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.right.included) {</span>
                <span class="s2">const </span><span class="s1">removePos = findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">operatorPos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">removePos)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(preventASI) {</span>
                    <span class="s1">removeLineBreaks(code</span><span class="s2">, </span><span class="s1">removePos</span><span class="s2">, this</span><span class="s1">.right.start)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">code.remove(operatorPos</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">removeAnnotations(</span><span class="s2">this, </span><span class="s1">code)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.getUsedBranch().render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">isCalleeOfRenderedParent</span><span class="s2">,</span>
                <span class="s1">preventASI</span><span class="s2">,</span>
                <span class="s1">renderedParentType: renderedParentType || </span><span class="s2">this</span><span class="s1">.parent.type</span><span class="s2">,</span>
                <span class="s1">renderedSurroundingElement: renderedSurroundingElement || </span><span class="s2">this</span><span class="s1">.parent.type</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.left.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">preventASI</span><span class="s2">,</span>
                <span class="s1">renderedSurroundingElement</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.right.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getUsedBranch() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed) {</span>
            <span class="s2">this</span><span class="s1">.isBranchResolutionAnalysed = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">leftValue = </span><span class="s2">this</span><span class="s1">.left.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">leftValue === </span><span class="s3">'symbol'</span><span class="s1">) {</span>
                <span class="s2">return null;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.usedBranch =</span>
                    <span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'||' </span><span class="s1">&amp;&amp; leftValue) ||</span>
                        <span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'&amp;&amp;' </span><span class="s1">&amp;&amp; !leftValue) ||</span>
                        <span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'??' </span><span class="s1">&amp;&amp; leftValue != </span><span class="s2">null</span><span class="s1">)</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.left</span>
                        <span class="s1">: </span><span class="s2">this</span><span class="s1">.right</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.usedBranch</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">FILE_PREFIX = </span><span class="s3">'ROLLUP_FILE_URL_'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">IMPORT = </span><span class="s3">'import'</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">MetaProperty </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.metaProperty = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.preliminaryChunkId = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.referenceId = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">getReferencedFileName(outputPluginDriver) {</span>
        <span class="s2">const </span><span class="s1">{ meta: { name }</span><span class="s2">, </span><span class="s1">metaProperty } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(name === IMPORT &amp;&amp; metaProperty?.startsWith(FILE_PREFIX)) {</span>
            <span class="s2">return </span><span class="s1">outputPluginDriver.getFileName(metaProperty.slice(FILE_PREFIX.length))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1 </span><span class="s1">|| type !== INTERACTION_ACCESSED</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.meta.name === IMPORT) {</span>
                <span class="s2">this</span><span class="s1">.context.addImportMeta(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">metaProperty = (</span><span class="s2">this</span><span class="s1">.metaProperty =</span>
                    <span class="s1">parent </span><span class="s2">instanceof </span><span class="s1">MemberExpression &amp;&amp; </span><span class="s2">typeof </span><span class="s1">parent.propertyKey === </span><span class="s3">'string'</span>
                        <span class="s1">? parent.propertyKey</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(metaProperty?.startsWith(FILE_PREFIX)) {</span>
                    <span class="s2">this</span><span class="s1">.referenceId = metaProperty.slice(FILE_PREFIX.length)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">{ format</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">snippets }) {</span>
        <span class="s2">const </span><span class="s1">{ context: { module: { id: moduleId } }</span><span class="s2">, </span><span class="s1">meta: { name }</span><span class="s2">, </span><span class="s1">metaProperty</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">preliminaryChunkId</span><span class="s2">, </span><span class="s1">referenceId</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end } = </span><span class="s2">this;</span>
        <span class="s2">if </span><span class="s1">(name !== IMPORT)</span>
            <span class="s2">return;</span>
        <span class="s2">const </span><span class="s1">chunkId = preliminaryChunkId</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(referenceId) {</span>
            <span class="s2">const </span><span class="s1">fileName = pluginDriver.getFileName(referenceId)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">relativePath = normalize(relative$1(dirname(chunkId)</span><span class="s2">, </span><span class="s1">fileName))</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">replacement = pluginDriver.hookFirstSync(</span><span class="s3">'resolveFileUrl'</span><span class="s2">, </span><span class="s1">[</span>
                <span class="s1">{ chunkId</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">moduleId</span><span class="s2">, </span><span class="s1">referenceId</span><span class="s2">, </span><span class="s1">relativePath }</span>
            <span class="s1">]) || relativeUrlMechanisms[format](relativePath)</span><span class="s2">;</span>
            <span class="s1">code.overwrite(parent.start</span><span class="s2">, </span><span class="s1">parent.end</span><span class="s2">, </span><span class="s1">replacement</span><span class="s2">, </span><span class="s1">{ contentOnly: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">replacement = pluginDriver.hookFirstSync(</span><span class="s3">'resolveImportMeta'</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">metaProperty</span><span class="s2">,</span>
            <span class="s1">{ chunkId</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">moduleId }</span>
        <span class="s1">]) || importMetaMechanisms[format]?.(metaProperty</span><span class="s2">, </span><span class="s1">{ chunkId</span><span class="s2">, </span><span class="s1">snippets })</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">replacement === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">MemberExpression) {</span>
                <span class="s1">code.overwrite(parent.start</span><span class="s2">, </span><span class="s1">parent.end</span><span class="s2">, </span><span class="s1">replacement</span><span class="s2">, </span><span class="s1">{ contentOnly: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">code.overwrite(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">replacement</span><span class="s2">, </span><span class="s1">{ contentOnly: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setResolution(format</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">preliminaryChunkId) {</span>
        <span class="s2">this</span><span class="s1">.preliminaryChunkId = preliminaryChunkId</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">accessedGlobals = (</span><span class="s2">this</span><span class="s1">.metaProperty?.startsWith(FILE_PREFIX) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(accessedGlobals.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scope.addAccessedGlobals(accessedGlobals</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">accessedMetaUrlGlobals = {</span>
    <span class="s1">amd: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'module'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">cjs: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'require'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">es: []</span><span class="s2">,</span>
    <span class="s1">iife: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">system: [</span><span class="s3">'module'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">umd: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'require'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">accessedFileUrlGlobals = {</span>
    <span class="s1">amd: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'require'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">cjs: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'require'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">es: []</span><span class="s2">,</span>
    <span class="s1">iife: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">system: [</span><span class="s3">'module'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">umd: [</span><span class="s3">'document'</span><span class="s2">, </span><span class="s3">'require'</span><span class="s2">, </span><span class="s3">'URL'</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getResolveUrl = (path</span><span class="s2">, </span><span class="s1">URL = </span><span class="s3">'URL'</span><span class="s1">) =&gt; </span><span class="s3">`new </span><span class="s1">${URL}</span><span class="s3">(</span><span class="s1">${path}</span><span class="s3">).href`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getRelativeUrlFromDocument = (relativePath</span><span class="s2">, </span><span class="s1">umd = </span><span class="s2">false</span><span class="s1">) =&gt; getResolveUrl(</span><span class="s3">`'</span><span class="s1">${escapeId(relativePath)}</span><span class="s3">', </span><span class="s1">${umd ? </span><span class="s3">`typeof document === 'undefined' ? location.href : ` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">document.currentScript &amp;&amp; document.currentScript.src || document.baseURI`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getGenericImportMetaMechanism = (getUrl) =&gt; (property</span><span class="s2">, </span><span class="s1">{ chunkId }) =&gt; {</span>
    <span class="s2">const </span><span class="s1">urlMechanism = getUrl(chunkId)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">property === </span><span class="s2">null</span>
        <span class="s1">? </span><span class="s3">`({ url: </span><span class="s1">${urlMechanism} </span><span class="s3">})`</span>
        <span class="s1">: property === </span><span class="s3">'url'</span>
            <span class="s1">? urlMechanism</span>
            <span class="s1">: </span><span class="s3">'undefined'</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getFileUrlFromFullPath = (path) =&gt; </span><span class="s3">`require('u' + 'rl').pathToFileURL(</span><span class="s1">${path}</span><span class="s3">).href`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getFileUrlFromRelativePath = (path) =&gt; getFileUrlFromFullPath(</span><span class="s3">`__dirname + '/</span><span class="s1">${path}</span><span class="s3">'`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getUrlFromDocument = (chunkId</span><span class="s2">, </span><span class="s1">umd = </span><span class="s2">false</span><span class="s1">) =&gt; </span><span class="s3">`</span><span class="s1">${umd ? </span><span class="s3">`typeof document === 'undefined' ? location.href : ` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">(document.currentScript &amp;&amp; document.currentScript.src || new URL('</span><span class="s1">${escapeId(chunkId)}</span><span class="s3">', document.baseURI).href)`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">relativeUrlMechanisms = {</span>
    <span class="s1">amd: relativePath =&gt; {</span>
        <span class="s2">if </span><span class="s1">(relativePath[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'.'</span><span class="s1">)</span>
            <span class="s1">relativePath = </span><span class="s3">'./' </span><span class="s1">+ relativePath</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">getResolveUrl(</span><span class="s3">`require.toUrl('</span><span class="s1">${relativePath}</span><span class="s3">'), document.baseURI`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">cjs: relativePath =&gt; </span><span class="s3">`(typeof document === 'undefined' ? </span><span class="s1">${getFileUrlFromRelativePath(relativePath)} </span><span class="s3">: </span><span class="s1">${getRelativeUrlFromDocument(relativePath)}</span><span class="s3">)`</span><span class="s2">,</span>
    <span class="s1">es: relativePath =&gt; getResolveUrl(</span><span class="s3">`'</span><span class="s1">${relativePath}</span><span class="s3">', import.meta.url`</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">iife: relativePath =&gt; getRelativeUrlFromDocument(relativePath)</span><span class="s2">,</span>
    <span class="s1">system: relativePath =&gt; getResolveUrl(</span><span class="s3">`'</span><span class="s1">${relativePath}</span><span class="s3">', module.meta.url`</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">umd: relativePath =&gt; </span><span class="s3">`(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? </span><span class="s1">${getFileUrlFromRelativePath(relativePath)} </span><span class="s3">: </span><span class="s1">${getRelativeUrlFromDocument(relativePath</span><span class="s2">, true</span><span class="s1">)}</span><span class="s3">)`</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">importMetaMechanisms = {</span>
    <span class="s1">amd: getGenericImportMetaMechanism(() =&gt; getResolveUrl(</span><span class="s3">`module.uri, document.baseURI`</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">cjs: getGenericImportMetaMechanism(chunkId =&gt; </span><span class="s3">`(typeof document === 'undefined' ? </span><span class="s1">${getFileUrlFromFullPath(</span><span class="s3">'__filename'</span><span class="s1">)} </span><span class="s3">: </span><span class="s1">${getUrlFromDocument(chunkId)}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">iife: getGenericImportMetaMechanism(chunkId =&gt; getUrlFromDocument(chunkId))</span><span class="s2">,</span>
    <span class="s1">system: (property</span><span class="s2">, </span><span class="s1">{ snippets: { getPropertyAccess } }) =&gt; property === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">`module.meta` </span><span class="s1">: </span><span class="s3">`module.meta</span><span class="s1">${getPropertyAccess(property)}</span><span class="s3">`</span><span class="s2">,</span>
    <span class="s1">umd: getGenericImportMetaMechanism(chunkId =&gt; </span><span class="s3">`(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? </span><span class="s1">${getFileUrlFromFullPath(</span><span class="s3">'__filename'</span><span class="s1">)} </span><span class="s3">: </span><span class="s1">${getUrlFromDocument(chunkId</span><span class="s2">, true</span><span class="s1">)}</span><span class="s3">)`</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">NewExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of </span><span class="s2">this</span><span class="s1">.arguments) {</span>
                <span class="s2">if </span><span class="s1">(argument.hasEffects(context))</span>
                    <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.options.treeshake.annotations &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.annotations) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.callee.hasEffects(context) ||</span>
                <span class="s2">this</span><span class="s1">.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
                <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">0 </span><span class="s1">|| type !== INTERACTION_ACCESSED</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively) {</span>
            <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.callee.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.callee.includeCallArguments(context</span><span class="s2">, this</span><span class="s1">.arguments)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.interaction = {</span>
            <span class="s1">args: [</span><span class="s2">null, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.arguments]</span><span class="s2">,</span>
            <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
            <span class="s1">withNew: </span><span class="s2">true</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.callee.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">renderCallArguments(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.callee.deoptimizeArgumentsOnInteractionAtPath(</span><span class="s2">this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ObjectExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeCache() {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizeAllProperties()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.getObjectEntity().deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return this</span><span class="s1">.getObjectEntity().hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedSurroundingElement } = BLANK) {</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(renderedSurroundingElement === ExpressionStatement$1 ||</span>
            <span class="s1">renderedSurroundingElement === ArrowFunctionExpression$1) {</span>
            <span class="s1">code.appendRight(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">'('</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">')'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">getObjectEntity() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return this</span><span class="s1">.objectEntity</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">prototype = OBJECT_PROTOTYPE</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">properties = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of </span><span class="s2">this</span><span class="s1">.properties) {</span>
            <span class="s2">if </span><span class="s1">(property </span><span class="s2">instanceof </span><span class="s1">SpreadElement) {</span>
                <span class="s1">properties.push({ key: UnknownKey</span><span class="s2">, </span><span class="s1">kind: </span><span class="s3">'init'</span><span class="s2">, </span><span class="s1">property })</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">key</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(property.computed) {</span>
                <span class="s2">const </span><span class="s1">keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keyValue === </span><span class="s3">'symbol'</span><span class="s1">) {</span>
                    <span class="s1">properties.push({ key: UnknownKey</span><span class="s2">, </span><span class="s1">kind: property.kind</span><span class="s2">, </span><span class="s1">property })</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">key = String(keyValue)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">key =</span>
                    <span class="s1">property.key </span><span class="s2">instanceof </span><span class="s1">Identifier</span>
                        <span class="s1">? property.key.name</span>
                        <span class="s1">: String(property.key.value)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'__proto__' </span><span class="s1">&amp;&amp; property.kind === </span><span class="s3">'init'</span><span class="s1">) {</span>
                    <span class="s1">prototype =</span>
                        <span class="s1">property.value </span><span class="s2">instanceof </span><span class="s1">Literal &amp;&amp; property.value.value === </span><span class="s2">null</span>
                            <span class="s1">? </span><span class="s2">null</span>
                            <span class="s1">: property.value</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">properties.push({ key</span><span class="s2">, </span><span class="s1">kind: property.kind</span><span class="s2">, </span><span class="s1">property })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.objectEntity = </span><span class="s2">new </span><span class="s1">ObjectEntity(properties</span><span class="s2">, </span><span class="s1">prototype))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">PrivateIdentifier </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getOriginalLocation(sourcemapChain</span><span class="s2">, </span><span class="s1">location) {</span>
    <span class="s2">const </span><span class="s1">filteredSourcemapChain = sourcemapChain.filter((sourcemap) =&gt; !!sourcemap.mappings)</span><span class="s2">;</span>
    <span class="s1">traceSourcemap: </span><span class="s2">while </span><span class="s1">(filteredSourcemapChain.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">sourcemap = filteredSourcemapChain.pop()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">line = sourcemap.mappings[location.line - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(line) {</span>
            <span class="s2">const </span><span class="s1">filteredLine = line.filter((segment) =&gt; segment.length &gt; </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">lastSegment = filteredLine[filteredLine.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of filteredLine) {</span>
                <span class="s2">if </span><span class="s1">(segment[</span><span class="s4">0</span><span class="s1">] &gt;= location.column || segment === lastSegment) {</span>
                    <span class="s1">location = {</span>
                        <span class="s1">column: segment[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">line: segment[</span><span class="s4">2</span><span class="s1">] + </span><span class="s4">1</span>
                    <span class="s1">}</span><span class="s2">;</span>
                    <span class="s2">continue </span><span class="s1">traceSourcemap</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Can't resolve original location of error.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">location</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Program </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hasCachedEffect = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.hasLoggedEffect = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">hasCachedEffects() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.hasCachedEffect === </span><span class="s2">null</span>
            <span class="s1">? (</span><span class="s2">this</span><span class="s1">.hasCachedEffect = </span><span class="s2">this</span><span class="s1">.hasEffects(createHasEffectsContext()))</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.hasCachedEffect</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s2">if </span><span class="s1">(node.hasEffects(context)) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.options.experimentalLogSideEffects &amp;&amp; !</span><span class="s2">this</span><span class="s1">.hasLoggedEffect) {</span>
                    <span class="s2">this</span><span class="s1">.hasLoggedEffect = </span><span class="s2">true;</span>
                    <span class="s2">const </span><span class="s1">{ code</span><span class="s2">, </span><span class="s1">module } = </span><span class="s2">this</span><span class="s1">.context</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">{ line</span><span class="s2">, </span><span class="s1">column } = locate(code</span><span class="s2">, </span><span class="s1">node.start</span><span class="s2">, </span><span class="s1">{ offsetLine: </span><span class="s4">1 </span><span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">console.log(</span><span class="s3">`First side effect in </span><span class="s1">${relativeId(module.id)} </span><span class="s3">is at (</span><span class="s1">${line}</span><span class="s3">:</span><span class="s1">${column}</span><span class="s3">)</span><span class="s2">\n</span><span class="s1">${getCodeFrame(code</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">{ column: originalColumn</span><span class="s2">, </span><span class="s1">line: originalLine } = getOriginalLocation(module.sourcemapChain</span><span class="s2">, </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line })</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(originalLine !== line) {</span>
                            <span class="s1">console.log(</span><span class="s3">`Original location is at (</span><span class="s1">${originalLine}</span><span class="s3">:</span><span class="s1">${originalColumn}</span><span class="s3">)</span><span class="s2">\n</span><span class="s1">${getCodeFrame(module.originalCode</span><span class="s2">, </span><span class="s1">originalLine</span><span class="s2">, </span><span class="s1">originalColumn)}</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">catch </span><span class="s1">{</span>
                        <span class="s0">/* ignored */</span>
                    <span class="s1">}</span>
                    <span class="s1">console.log()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasCachedEffect = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively || node.shouldBeIncluded(context)) {</span>
                <span class="s1">node.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">let </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(code.original.startsWith(</span><span class="s3">'#!'</span><span class="s1">)) {</span>
            <span class="s1">start = Math.min(code.original.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
            <span class="s1">code.remove(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">renderStatementList(</span><span class="s2">this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Property </span><span class="s2">extends </span><span class="s1">MethodBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.declarationInit = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">declare(kind</span><span class="s2">, </span><span class="s1">init) {</span>
        <span class="s2">this</span><span class="s1">.declarationInit = init</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.value.declare(kind</span><span class="s2">, </span><span class="s1">UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">propertyReadSideEffects = </span><span class="s2">this</span><span class="s1">.context.options.treeshake</span>
            <span class="s1">.propertyReadSideEffects</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s2">this</span><span class="s1">.parent.type === </span><span class="s3">'ObjectPattern' </span><span class="s1">&amp;&amp; propertyReadSideEffects === </span><span class="s3">'always'</span><span class="s1">) ||</span>
            <span class="s2">this</span><span class="s1">.key.hasEffects(context) ||</span>
            <span class="s2">this</span><span class="s1">.value.hasEffects(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">markDeclarationReached() {</span>
        <span class="s2">this</span><span class="s1">.value.markDeclarationReached()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.shorthand) {</span>
            <span class="s2">this</span><span class="s1">.key.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.value.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isShorthandProperty: </span><span class="s2">this</span><span class="s1">.shorthand })</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.declarationInit !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.declarationInit.deoptimizePath([UnknownKey</span><span class="s2">, </span><span class="s1">UnknownKey])</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">PropertyDefinition </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.value?.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.value?.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.value</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.value.getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span>
            <span class="s1">: UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.value</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.value.getReturnExpressionWhenCalledAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span>
            <span class="s1">: UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">return this</span><span class="s1">.key.hasEffects(context) || (</span><span class="s2">this</span><span class="s1">.static &amp;&amp; !!</span><span class="s2">this</span><span class="s1">.value?.hasEffects(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.value || </span><span class="s2">this</span><span class="s1">.value.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ReturnStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!context.ignore.returnYield || </span><span class="s2">this</span><span class="s1">.argument?.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.argument?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.scope.addReturnExpression(</span><span class="s2">this</span><span class="s1">.argument || UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument) {</span>
            <span class="s2">this</span><span class="s1">.argument.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ preventASI: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument.start === </span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">6 </span><span class="s0">/* 'return'.length */</span><span class="s1">) {</span>
                <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">6</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">SequenceExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">].deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">].deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">return this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">].getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.expressions) {</span>
            <span class="s2">if </span><span class="s1">(expression.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">return this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">].hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">lastExpression = </span><span class="s2">this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">expression of </span><span class="s2">this</span><span class="s1">.expressions) {</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively ||</span>
                <span class="s1">(expression === lastExpression &amp;&amp; !(</span><span class="s2">this</span><span class="s1">.parent </span><span class="s2">instanceof </span><span class="s1">ExpressionStatement)) ||</span>
                <span class="s1">expression.shouldBeIncluded(context))</span>
                <span class="s1">expression.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ renderedParentType</span><span class="s2">, </span><span class="s1">isCalleeOfRenderedParent</span><span class="s2">, </span><span class="s1">preventASI } = BLANK) {</span>
        <span class="s2">let </span><span class="s1">includedNodes = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">lastSeparatorPos = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">lastNode = </span><span class="s2">this</span><span class="s1">.expressions[</span><span class="s2">this</span><span class="s1">.expressions.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ node</span><span class="s2">, </span><span class="s1">separator</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end } of getCommaSeparatedNodesWithBoundaries(</span><span class="s2">this</span><span class="s1">.expressions</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end)) {</span>
            <span class="s2">if </span><span class="s1">(!node.included) {</span>
                <span class="s1">treeshakeNode(node</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">includedNodes++</span><span class="s2">;</span>
            <span class="s1">lastSeparatorPos = separator</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(includedNodes === </span><span class="s4">1 </span><span class="s1">&amp;&amp; preventASI) {</span>
                <span class="s1">removeLineBreaks(code</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">node.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includedNodes === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">parentType = renderedParentType || </span><span class="s2">this</span><span class="s1">.parent.type</span><span class="s2">;</span>
                <span class="s1">node.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">isCalleeOfRenderedParent: isCalleeOfRenderedParent &amp;&amp; node === lastNode</span><span class="s2">,</span>
                    <span class="s1">renderedParentType: parentType</span><span class="s2">,</span>
                    <span class="s1">renderedSurroundingElement: parentType</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">node.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(lastSeparatorPos) {</span>
            <span class="s1">code.remove(lastSeparatorPos</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">StaticBlock </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s2">if </span><span class="s1">(node.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.body) {</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively || node.shouldBeIncluded(context))</span>
                <span class="s1">node.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.body.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">bodyStartPos = findFirstOccurrenceOutsideComment(code.original.slice(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">, </span><span class="s3">'{'</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">renderStatementList(</span><span class="s2">this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.start + bodyStartPos</span><span class="s2">, this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Super </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">bind() {</span>
        <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s3">'this'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.variable.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.variable.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">SwitchCase </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test?.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.consequent) {</span>
            <span class="s2">if </span><span class="s1">(context.brokenFlow)</span>
                <span class="s2">break;</span>
            <span class="s2">if </span><span class="s1">(node.hasEffects(context))</span>
                <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.test?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">node of </span><span class="s2">this</span><span class="s1">.consequent) {</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively || node.shouldBeIncluded(context))</span>
                <span class="s1">node.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">nodeRenderOptions) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.consequent.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.test &amp;&amp; </span><span class="s2">this</span><span class="s1">.test.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">testEnd = </span><span class="s2">this</span><span class="s1">.test</span>
                <span class="s1">? </span><span class="s2">this</span><span class="s1">.test.end</span>
                <span class="s1">: findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'default'</span><span class="s2">, this</span><span class="s1">.start) + </span><span class="s4">7</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">consequentStart = findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">':'</span><span class="s2">, </span><span class="s1">testEnd) + </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">renderStatementList(</span><span class="s2">this</span><span class="s1">.consequent</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">consequentStart</span><span class="s2">, </span><span class="s1">nodeRenderOptions.end</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">SwitchCase.prototype.needsBoundaries = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">SwitchStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">createScope(parentScope) {</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">BlockScope(parentScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.discriminant.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">hasBreak</span><span class="s2">, </span><span class="s1">ignore } = context</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ breaks } = ignore</span><span class="s2">;</span>
        <span class="s1">ignore.breaks = </span><span class="s2">true;</span>
        <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
        <span class="s2">let </span><span class="s1">onlyHasBrokenFlow = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">switchCase of </span><span class="s2">this</span><span class="s1">.cases) {</span>
            <span class="s2">if </span><span class="s1">(switchCase.hasEffects(context))</span>
                <span class="s2">return true;</span>
            <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
            <span class="s1">onlyHasBrokenFlow &amp;&amp; (onlyHasBrokenFlow = context.brokenFlow &amp;&amp; !context.hasBreak)</span><span class="s2">;</span>
            <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.defaultCase !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">context.brokenFlow = onlyHasBrokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">ignore.breaks = breaks</span><span class="s2">;</span>
        <span class="s1">context.hasBreak = hasBreak</span><span class="s2">;</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.discriminant.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">hasBreak } = context</span><span class="s2">;</span>
        <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
        <span class="s2">let </span><span class="s1">onlyHasBrokenFlow = </span><span class="s2">true;</span>
        <span class="s2">let </span><span class="s1">isCaseIncluded = includeChildrenRecursively ||</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.defaultCase !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.defaultCase &lt; </span><span class="s2">this</span><span class="s1">.cases.length - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">caseIndex = </span><span class="s2">this</span><span class="s1">.cases.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">caseIndex &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">caseIndex--) {</span>
            <span class="s2">const </span><span class="s1">switchCase = </span><span class="s2">this</span><span class="s1">.cases[caseIndex]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(switchCase.included) {</span>
                <span class="s1">isCaseIncluded = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!isCaseIncluded) {</span>
                <span class="s2">const </span><span class="s1">hasEffectsContext = createHasEffectsContext()</span><span class="s2">;</span>
                <span class="s1">hasEffectsContext.ignore.breaks = </span><span class="s2">true;</span>
                <span class="s1">isCaseIncluded = switchCase.hasEffects(hasEffectsContext)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isCaseIncluded) {</span>
                <span class="s1">switchCase.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
                <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
                <span class="s1">onlyHasBrokenFlow &amp;&amp; (onlyHasBrokenFlow = context.brokenFlow &amp;&amp; !context.hasBreak)</span><span class="s2">;</span>
                <span class="s1">context.hasBreak = </span><span class="s2">false;</span>
                <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">onlyHasBrokenFlow = brokenFlow</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isCaseIncluded &amp;&amp; </span><span class="s2">this</span><span class="s1">.defaultCase !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">context.brokenFlow = onlyHasBrokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">context.hasBreak = hasBreak</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">caseIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">caseIndex &lt; </span><span class="s2">this</span><span class="s1">.cases.length</span><span class="s2">; </span><span class="s1">caseIndex++) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.cases[caseIndex].test === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.defaultCase = caseIndex</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.defaultCase = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.discriminant.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.cases.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">renderStatementList(</span><span class="s2">this</span><span class="s1">.cases</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.cases[</span><span class="s4">0</span><span class="s1">].start</span><span class="s2">, this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TaggedTemplateExpression </span><span class="s2">extends </span><span class="s1">CallExpressionBase {</span>
    <span class="s1">bind() {</span>
        <span class="s2">super</span><span class="s1">.bind()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.tag.type === Identifier$1) {</span>
            <span class="s2">const </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.tag.name</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable.isNamespace) {</span>
                <span class="s2">this</span><span class="s1">.context.warn(errorCannotCallNamespace(name)</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">argument of </span><span class="s2">this</span><span class="s1">.quasi.expressions) {</span>
                <span class="s2">if </span><span class="s1">(argument.hasEffects(context))</span>
                    <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.tag.hasEffects(context) ||</span>
                <span class="s2">this</span><span class="s1">.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
                <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(includeChildrenRecursively) {</span>
            <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.tag.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.quasi.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.tag.includeCallArguments(context</span><span class="s2">, this</span><span class="s1">.args)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">[returnExpression] = </span><span class="s2">this</span><span class="s1">.getReturnExpression()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!returnExpression.included) {</span>
            <span class="s1">returnExpression.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.args = [UNKNOWN_EXPRESSION</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.quasi.expressions]</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.interaction = {</span>
            <span class="s1">args: [</span>
                <span class="s2">this</span><span class="s1">.tag </span><span class="s2">instanceof </span><span class="s1">MemberExpression &amp;&amp; !</span><span class="s2">this</span><span class="s1">.tag.variable ? </span><span class="s2">this</span><span class="s1">.tag.object : </span><span class="s2">null,</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.args</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">type: INTERACTION_CALLED</span><span class="s2">,</span>
            <span class="s1">withNew: </span><span class="s2">false</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.tag.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ isCalleeOfRenderedParent: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.quasi.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.tag.deoptimizeArgumentsOnInteractionAtPath(</span><span class="s2">this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">EMPTY_PATH</span><span class="s2">, </span><span class="s1">SHARED_RECURSION_TRACKER)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.returnExpression = UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.returnExpression = </span><span class="s2">this</span><span class="s1">.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH</span><span class="s2">, this</span><span class="s1">.interaction</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, this</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.returnExpression</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TemplateElement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s0">// Do not try to bind value</span>
    <span class="s1">bind() { }</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">parseNode(esTreeNode) {</span>
        <span class="s2">this</span><span class="s1">.value = esTreeNode.value</span><span class="s2">;</span>
        <span class="s2">super</span><span class="s1">.parseNode(esTreeNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TemplateLiteral </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath() { }</span>
    <span class="s1">getLiteralValueAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.quasis.length !== </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.quasis[</span><span class="s4">0</span><span class="s1">].value.cooked</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReturnExpressionWhenCalledAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length !== </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">UNKNOWN_RETURN_EXPRESSION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">getMemberReturnExpressionWhenCalled(literalStringMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_ACCESSED) {</span>
            <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(interaction.type === INTERACTION_CALLED &amp;&amp; path.length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">hasMemberEffectWhenCalled(literalStringMembers</span><span class="s2">, </span><span class="s1">path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s1">code.indentExclusionRanges.push([</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end])</span><span class="s2">;</span>
        <span class="s2">super</span><span class="s1">.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">UndefinedVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s3">'undefined'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath() {</span>
        <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ExportDefaultVariable </span><span class="s2">extends </span><span class="s1">LocalVariable {</span>
    <span class="s1">constructor(name</span><span class="s2">, </span><span class="s1">exportDefaultDeclaration</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(name</span><span class="s2">, </span><span class="s1">exportDefaultDeclaration</span><span class="s2">, </span><span class="s1">exportDefaultDeclaration.declaration</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hasId = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.originalId = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.originalVariable = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">declaration = exportDefaultDeclaration.declaration</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((declaration </span><span class="s2">instanceof </span><span class="s1">FunctionDeclaration || declaration </span><span class="s2">instanceof </span><span class="s1">ClassDeclaration) &amp;&amp;</span>
            <span class="s1">declaration.id) {</span>
            <span class="s2">this</span><span class="s1">.hasId = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.originalId = declaration.id</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(declaration </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
            <span class="s2">this</span><span class="s1">.originalId = declaration</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addReference(identifier) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasId) {</span>
            <span class="s2">this</span><span class="s1">.name = identifier.name</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">forbidName(name) {</span>
        <span class="s2">const </span><span class="s1">original = </span><span class="s2">this</span><span class="s1">.getOriginalVariable()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(original === </span><span class="s2">this</span><span class="s1">) {</span>
            <span class="s2">super</span><span class="s1">.forbidName(name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">original.forbidName(name)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getAssignedVariableName() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.originalId &amp;&amp; </span><span class="s2">this</span><span class="s1">.originalId.name) || </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseVariableName() {</span>
        <span class="s2">const </span><span class="s1">original = </span><span class="s2">this</span><span class="s1">.getOriginalVariable()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">original === </span><span class="s2">this </span><span class="s1">? </span><span class="s2">super</span><span class="s1">.getBaseVariableName() : original.getBaseVariableName()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getDirectOriginalVariable() {</span>
        <span class="s2">return this</span><span class="s1">.originalId &amp;&amp;</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.hasId ||</span>
                <span class="s1">!(</span><span class="s2">this</span><span class="s1">.originalId.isPossibleTDZ() ||</span>
                    <span class="s2">this</span><span class="s1">.originalId.variable.isReassigned ||</span>
                    <span class="s2">this</span><span class="s1">.originalId.variable </span><span class="s2">instanceof </span><span class="s1">UndefinedVariable ||</span>
                    <span class="s0">// this avoids a circular dependency</span>
                    <span class="s3">'syntheticNamespace' </span><span class="s2">in this</span><span class="s1">.originalId.variable))</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.originalId.variable</span>
            <span class="s1">: </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">getName(getPropertyAccess) {</span>
        <span class="s2">const </span><span class="s1">original = </span><span class="s2">this</span><span class="s1">.getOriginalVariable()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">original === </span><span class="s2">this</span>
            <span class="s1">? </span><span class="s2">super</span><span class="s1">.getName(getPropertyAccess)</span>
            <span class="s1">: original.getName(getPropertyAccess)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getOriginalVariable() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.originalVariable)</span>
            <span class="s2">return this</span><span class="s1">.originalVariable</span><span class="s2">;</span>
        <span class="s0">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s2">let </span><span class="s1">original = </span><span class="s2">this;</span>
        <span class="s2">let </span><span class="s1">currentVariable</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">checkedVariables = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">do </span><span class="s1">{</span>
            <span class="s1">checkedVariables.add(original)</span><span class="s2">;</span>
            <span class="s1">currentVariable = original</span><span class="s2">;</span>
            <span class="s1">original = currentVariable.getDirectOriginalVariable()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(original </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable &amp;&amp; !checkedVariables.has(original))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.originalVariable = original || currentVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ModuleScope </span><span class="s2">extends </span><span class="s1">ChildScope {</span>
    <span class="s1">constructor(parent</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">super</span><span class="s1">(parent)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context = context</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'this'</span><span class="s2">, new </span><span class="s1">LocalVariable(</span><span class="s3">'this'</span><span class="s2">, null, </span><span class="s1">UNDEFINED_EXPRESSION</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addExportDefaultDeclaration(name</span><span class="s2">, </span><span class="s1">exportDefaultDeclaration</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">variable = </span><span class="s2">new </span><span class="s1">ExportDefaultVariable(name</span><span class="s2">, </span><span class="s1">exportDefaultDeclaration</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addNamespaceMemberAccess() { }</span>
    <span class="s1">deconflict(format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope) {</span>
        <span class="s0">// all module level variables are already deconflicted when deconflicting the chunk</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">scope of </span><span class="s2">this</span><span class="s1">.children)</span>
            <span class="s1">scope.deconflict(format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findLexicalBoundary() {</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">findVariable(name) {</span>
        <span class="s2">const </span><span class="s1">knownVariable = </span><span class="s2">this</span><span class="s1">.variables.get(name) || </span><span class="s2">this</span><span class="s1">.accessedOutsideVariables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(knownVariable) {</span>
            <span class="s2">return </span><span class="s1">knownVariable</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.context.traceVariable(name) || </span><span class="s2">this</span><span class="s1">.parent.findVariable(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">GlobalVariable) {</span>
            <span class="s2">this</span><span class="s1">.accessedOutsideVariables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ThisExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">bind() {</span>
        <span class="s2">this</span><span class="s1">.variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s3">'this'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">this</span><span class="s1">.variable.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">this</span><span class="s1">.variable.deoptimizePath(path)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">interaction.type !== INTERACTION_ACCESSED</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.variable.hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.included) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.alias =</span>
            <span class="s2">this</span><span class="s1">.scope.findLexicalBoundary() </span><span class="s2">instanceof </span><span class="s1">ModuleScope ? </span><span class="s2">this</span><span class="s1">.context.moduleContext : </span><span class="s2">null;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alias === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.context.warn(errorThisIsUndefined()</span><span class="s2">, this</span><span class="s1">.start)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.alias !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">code.overwrite(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, this</span><span class="s1">.alias</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">contentOnly: </span><span class="s2">false,</span>
                <span class="s1">storeName: </span><span class="s2">true</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">ThrowStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.argument.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">context.brokenFlow = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">this</span><span class="s1">.argument.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ preventASI: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument.start === </span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">5 </span><span class="s0">/* 'throw'.length */</span><span class="s1">) {</span>
            <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">5</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">TryStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.directlyIncluded = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.includedLabelsAfterBlock = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s2">this</span><span class="s1">.context.options.treeshake.tryCatchDeoptimization</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.block.body.length &gt; </span><span class="s4">0</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.block.hasEffects(context)) || !!</span><span class="s2">this</span><span class="s1">.finalizer?.hasEffects(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">const </span><span class="s1">tryCatchDeoptimization = </span><span class="s2">this</span><span class="s1">.context.options.treeshake</span>
            <span class="s1">?.tryCatchDeoptimization</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ brokenFlow</span><span class="s2">, </span><span class="s1">includedLabels } = context</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.directlyIncluded || !tryCatchDeoptimization) {</span>
            <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.directlyIncluded = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.block.include(context</span><span class="s2">, </span><span class="s1">tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(includedLabels.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.includedLabelsAfterBlock = [...includedLabels]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.includedLabelsAfterBlock) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">label of </span><span class="s2">this</span><span class="s1">.includedLabelsAfterBlock) {</span>
                <span class="s1">includedLabels.add(label)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.handler !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.handler.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">context.brokenFlow = brokenFlow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.finalizer?.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">unaryOperators = {</span>
    <span class="s3">'!'</span><span class="s1">: value =&gt; !value</span><span class="s2">,</span>
    <span class="s3">'+'</span><span class="s1">: value =&gt; +value</span><span class="s2">,</span>
    <span class="s3">'-'</span><span class="s1">: value =&gt; -value</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: () =&gt; UnknownValue</span><span class="s2">,</span>
    <span class="s2">typeof</span><span class="s1">: value =&gt; </span><span class="s2">typeof </span><span class="s1">value</span><span class="s2">,</span>
    <span class="s2">void</span><span class="s1">: () =&gt; undefined</span><span class="s2">,</span>
    <span class="s3">'~'</span><span class="s1">: value =&gt; ~value</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">UnaryExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">getLiteralValueAtPath(path</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">argumentValue = </span><span class="s2">this</span><span class="s1">.argument.getLiteralValueAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">recursionTracker</span><span class="s2">, </span><span class="s1">origin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">argumentValue === </span><span class="s3">'symbol'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">unaryOperators[</span><span class="s2">this</span><span class="s1">.operator](argumentValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'typeof' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.argument </span><span class="s2">instanceof </span><span class="s1">Identifier)</span>
            <span class="s2">return false;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument.hasEffects(context) ||</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'delete' </span><span class="s1">&amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH</span><span class="s2">, </span><span class="s1">NODE_INTERACTION_UNKNOWN_ASSIGNMENT</span><span class="s2">, </span><span class="s1">context)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">type !== INTERACTION_ACCESSED || path.length &gt; (</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'void' </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.operator === </span><span class="s3">'delete'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.argument.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">UnknownNode </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">include(context) {</span>
        <span class="s2">super</span><span class="s1">.include(context</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">UpdateExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.argument.hasEffectsAsAssignmentTarget(context</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">{ type }) {</span>
        <span class="s2">return </span><span class="s1">path.length &gt; </span><span class="s4">1 </span><span class="s1">|| type !== INTERACTION_ACCESSED</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.argument.includeAsAssignmentTarget(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">this</span><span class="s1">.argument.setAssignedValue(UNKNOWN_EXPRESSION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">snippets: { _ } } = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.argument.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'system'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.argument.variable</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">exportNames = exportNamesByVariable.get(variable)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(exportNames) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prefix) {</span>
                    <span class="s2">if </span><span class="s1">(exportNames.length === </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">renderSystemExportExpression(variable</span><span class="s2">, this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">renderSystemExportSequenceAfterExpression(variable</span><span class="s2">, this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, this</span><span class="s1">.parent.type !== ExpressionStatement$1</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">operator = </span><span class="s2">this</span><span class="s1">.operator[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                    <span class="s1">renderSystemExportSequenceBeforeExpression(variable</span><span class="s2">, this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end</span><span class="s2">, this</span><span class="s1">.parent.type !== ExpressionStatement$1</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${_}${operator}${_}</span><span class="s3">1`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() {</span>
        <span class="s2">this</span><span class="s1">.deoptimized = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.argument.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument </span><span class="s2">instanceof </span><span class="s1">Identifier) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.scope.findVariable(</span><span class="s2">this</span><span class="s1">.argument.name)</span><span class="s2">;</span>
            <span class="s1">variable.isReassigned = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.context.requestTreeshakingPass()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">areAllDeclarationsIncludedAndNotExported(declarations</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of declarations) {</span>
        <span class="s2">if </span><span class="s1">(!declarator.id.included)</span>
            <span class="s2">return false;</span>
        <span class="s2">if </span><span class="s1">(declarator.id.type === Identifier$1) {</span>
            <span class="s2">if </span><span class="s1">(exportNamesByVariable.has(declarator.id.variable))</span>
                <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">exportedVariables = []</span><span class="s2">;</span>
            <span class="s1">declarator.id.addExportedVariables(exportedVariables</span><span class="s2">, </span><span class="s1">exportNamesByVariable)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(exportedVariables.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s2">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">VariableDeclaration </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">deoptimizePath() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of </span><span class="s2">this</span><span class="s1">.declarations) {</span>
            <span class="s1">declarator.deoptimizePath(EMPTY_PATH)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively</span><span class="s2">, </span><span class="s1">{ asSingleStatement } = BLANK) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of </span><span class="s2">this</span><span class="s1">.declarations) {</span>
            <span class="s2">if </span><span class="s1">(includeChildrenRecursively || declarator.shouldBeIncluded(context))</span>
                <span class="s1">declarator.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ id</span><span class="s2">, </span><span class="s1">init } = declarator</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(asSingleStatement) {</span>
                <span class="s1">id.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(init &amp;&amp;</span>
                <span class="s1">id.included &amp;&amp;</span>
                <span class="s1">!init.included &amp;&amp;</span>
                <span class="s1">(id </span><span class="s2">instanceof </span><span class="s1">ObjectPattern || id </span><span class="s2">instanceof </span><span class="s1">ArrayPattern)) {</span>
                <span class="s1">init.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initialise() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of </span><span class="s2">this</span><span class="s1">.declarations) {</span>
            <span class="s1">declarator.declareDeclarator(</span><span class="s2">this</span><span class="s1">.kind)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">nodeRenderOptions = BLANK) {</span>
        <span class="s2">if </span><span class="s1">(areAllDeclarationsIncludedAndNotExported(</span><span class="s2">this</span><span class="s1">.declarations</span><span class="s2">, </span><span class="s1">options.exportNamesByVariable)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of </span><span class="s2">this</span><span class="s1">.declarations) {</span>
                <span class="s1">declarator.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!nodeRenderOptions.isNoStatement &amp;&amp;</span>
                <span class="s1">code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">59 </span><span class="s0">/*&quot;;&quot;*/</span><span class="s1">) {</span>
                <span class="s1">code.appendLeft(</span><span class="s2">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s3">';'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.renderReplacedDeclarations(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">applyDeoptimizations() { }</span>
    <span class="s1">renderDeclarationEnd(code</span><span class="s2">, </span><span class="s1">separatorString</span><span class="s2">, </span><span class="s1">lastSeparatorPos</span><span class="s2">, </span><span class="s1">actualContentEnd</span><span class="s2">, </span><span class="s1">renderedContentEnd</span><span class="s2">, </span><span class="s1">systemPatternExports</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">59 </span><span class="s0">/*&quot;;&quot;*/</span><span class="s1">) {</span>
            <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">separatorString += </span><span class="s3">';'</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(lastSeparatorPos === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">code.appendLeft(renderedContentEnd</span><span class="s2">, </span><span class="s1">separatorString)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(code.original.charCodeAt(actualContentEnd - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">10 </span><span class="s0">/*&quot;\n&quot;*/ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end) === </span><span class="s4">10 </span><span class="s0">/*&quot;\n&quot;*/ </span><span class="s1">||</span>
                    <span class="s1">code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end) === </span><span class="s4">13</span><span class="s1">) </span><span class="s0">/*&quot;\r&quot;*/</span><span class="s1">) {</span>
                <span class="s1">actualContentEnd--</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(code.original.charCodeAt(actualContentEnd) === </span><span class="s4">13 </span><span class="s0">/*&quot;\r&quot;*/</span><span class="s1">) {</span>
                    <span class="s1">actualContentEnd--</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(actualContentEnd === lastSeparatorPos + </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">code.overwrite(lastSeparatorPos</span><span class="s2">, </span><span class="s1">renderedContentEnd</span><span class="s2">, </span><span class="s1">separatorString)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">code.overwrite(lastSeparatorPos</span><span class="s2">, </span><span class="s1">lastSeparatorPos + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">separatorString)</span><span class="s2">;</span>
                <span class="s1">code.remove(actualContentEnd</span><span class="s2">, </span><span class="s1">renderedContentEnd)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(systemPatternExports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">code.appendLeft(renderedContentEnd</span><span class="s2">, </span><span class="s3">` </span><span class="s1">${getSystemExportStatement(systemPatternExports</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">;`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">renderReplacedDeclarations(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">const </span><span class="s1">separatedNodes = getCommaSeparatedNodesWithBoundaries(</span><span class="s2">this</span><span class="s1">.declarations</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.start + </span><span class="s2">this</span><span class="s1">.kind.length</span><span class="s2">, this</span><span class="s1">.end - (code.original.charCodeAt(</span><span class="s2">this</span><span class="s1">.end - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">59 </span><span class="s0">/*&quot;;&quot;*/ </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">actualContentEnd</span><span class="s2">, </span><span class="s1">renderedContentEnd</span><span class="s2">;</span>
        <span class="s1">renderedContentEnd = findNonWhiteSpace(code.original</span><span class="s2">, this</span><span class="s1">.start + </span><span class="s2">this</span><span class="s1">.kind.length)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">lastSeparatorPos = renderedContentEnd - </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">code.remove(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">lastSeparatorPos)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">isInDeclaration = </span><span class="s2">false;</span>
        <span class="s2">let </span><span class="s1">hasRenderedContent = </span><span class="s2">false;</span>
        <span class="s2">let </span><span class="s1">separatorString = </span><span class="s3">''</span><span class="s2">, </span><span class="s1">leadingString</span><span class="s2">, </span><span class="s1">nextSeparatorString</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">aggregatedSystemExports = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">aggregatedSystemExports)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ node</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">separator</span><span class="s2">, </span><span class="s1">contentEnd</span><span class="s2">, </span><span class="s1">end } of separatedNodes) {</span>
            <span class="s2">if </span><span class="s1">(!node.included) {</span>
                <span class="s1">code.remove(start</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">node.render(code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">leadingString = </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s1">nextSeparatorString = </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!node.id.included ||</span>
                <span class="s1">(node.id </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp;</span>
                    <span class="s1">isReassignedExportsMember(node.id.variable</span><span class="s2">, </span><span class="s1">options.exportNamesByVariable))) {</span>
                <span class="s2">if </span><span class="s1">(hasRenderedContent) {</span>
                    <span class="s1">separatorString += </span><span class="s3">';'</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">isInDeclaration = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(singleSystemExport &amp;&amp; singleSystemExport === node.id.variable) {</span>
                    <span class="s2">const </span><span class="s1">operatorPos = findFirstOccurrenceOutsideComment(code.original</span><span class="s2">, </span><span class="s3">'='</span><span class="s2">, </span><span class="s1">node.id.end)</span><span class="s2">;</span>
                    <span class="s1">renderSystemExportExpression(singleSystemExport</span><span class="s2">, </span><span class="s1">findNonWhiteSpace(code.original</span><span class="s2">, </span><span class="s1">operatorPos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">separator === </span><span class="s2">null </span><span class="s1">? contentEnd : separator</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isInDeclaration) {</span>
                    <span class="s1">separatorString += </span><span class="s3">','</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(hasRenderedContent) {</span>
                        <span class="s1">separatorString += </span><span class="s3">';'</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">leadingString += </span><span class="s3">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.kind} </span><span class="s3">`</span><span class="s2">;</span>
                    <span class="s1">isInDeclaration = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(renderedContentEnd === lastSeparatorPos + </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">code.overwrite(lastSeparatorPos</span><span class="s2">, </span><span class="s1">renderedContentEnd</span><span class="s2">, </span><span class="s1">separatorString + leadingString)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">code.overwrite(lastSeparatorPos</span><span class="s2">, </span><span class="s1">lastSeparatorPos + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">separatorString)</span><span class="s2">;</span>
                <span class="s1">code.appendLeft(renderedContentEnd</span><span class="s2">, </span><span class="s1">leadingString)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">actualContentEnd = contentEnd</span><span class="s2">;</span>
            <span class="s1">renderedContentEnd = end</span><span class="s2">;</span>
            <span class="s1">hasRenderedContent = </span><span class="s2">true;</span>
            <span class="s1">lastSeparatorPos = separator</span><span class="s2">;</span>
            <span class="s1">separatorString = nextSeparatorString</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.renderDeclarationEnd(code</span><span class="s2">, </span><span class="s1">separatorString</span><span class="s2">, </span><span class="s1">lastSeparatorPos</span><span class="s2">, </span><span class="s1">actualContentEnd</span><span class="s2">, </span><span class="s1">renderedContentEnd</span><span class="s2">, </span><span class="s1">aggregatedSystemExports</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">gatherSystemExportsAndGetSingleExport(separatedNodes</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">aggregatedSystemExports) {</span>
    <span class="s2">let </span><span class="s1">singleSystemExport = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(options.format === </span><span class="s3">'system'</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ node } of separatedNodes) {</span>
            <span class="s2">if </span><span class="s1">(node.id </span><span class="s2">instanceof </span><span class="s1">Identifier &amp;&amp;</span>
                <span class="s1">node.init &amp;&amp;</span>
                <span class="s1">aggregatedSystemExports.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">options.exportNamesByVariable.get(node.id.variable)?.length === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">singleSystemExport = node.id.variable</span><span class="s2">;</span>
                <span class="s1">aggregatedSystemExports.push(singleSystemExport)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">node.id.addExportedVariables(aggregatedSystemExports</span><span class="s2">, </span><span class="s1">options.exportNamesByVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(aggregatedSystemExports.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">singleSystemExport = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(singleSystemExport) {</span>
            <span class="s1">aggregatedSystemExports.length = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">singleSystemExport</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">WhileStatement </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.test.hasEffects(context))</span>
            <span class="s2">return true;</span>
        <span class="s2">return </span><span class="s1">hasLoopBodyEffects(context</span><span class="s2">, this</span><span class="s1">.body)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively) {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.test.include(context</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
        <span class="s1">includeLoopBody(context</span><span class="s2">, this</span><span class="s1">.body</span><span class="s2">, </span><span class="s1">includeChildrenRecursively)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">YieldExpression </span><span class="s2">extends </span><span class="s1">NodeBase {</span>
    <span class="s1">hasEffects(context) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.deoptimized)</span>
            <span class="s2">this</span><span class="s1">.applyDeoptimizations()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">!(context.ignore.returnYield &amp;&amp; !</span><span class="s2">this</span><span class="s1">.argument?.hasEffects(context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(code</span><span class="s2">, </span><span class="s1">options) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument) {</span>
            <span class="s2">this</span><span class="s1">.argument.render(code</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ preventASI: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.argument.start === </span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">5 </span><span class="s0">/* 'yield'.length */</span><span class="s1">) {</span>
                <span class="s1">code.prependLeft(</span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">5</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">nodeConstructors = {</span>
    <span class="s1">ArrayExpression</span><span class="s2">,</span>
    <span class="s1">ArrayPattern</span><span class="s2">,</span>
    <span class="s1">ArrowFunctionExpression</span><span class="s2">,</span>
    <span class="s1">AssignmentExpression</span><span class="s2">,</span>
    <span class="s1">AssignmentPattern</span><span class="s2">,</span>
    <span class="s1">AwaitExpression</span><span class="s2">,</span>
    <span class="s1">BinaryExpression</span><span class="s2">,</span>
    <span class="s1">BlockStatement</span><span class="s2">,</span>
    <span class="s1">BreakStatement</span><span class="s2">,</span>
    <span class="s1">CallExpression</span><span class="s2">,</span>
    <span class="s1">CatchClause</span><span class="s2">,</span>
    <span class="s1">ChainExpression</span><span class="s2">,</span>
    <span class="s1">ClassBody</span><span class="s2">,</span>
    <span class="s1">ClassDeclaration</span><span class="s2">,</span>
    <span class="s1">ClassExpression</span><span class="s2">,</span>
    <span class="s1">ConditionalExpression</span><span class="s2">,</span>
    <span class="s1">ContinueStatement</span><span class="s2">,</span>
    <span class="s1">DoWhileStatement</span><span class="s2">,</span>
    <span class="s1">EmptyStatement</span><span class="s2">,</span>
    <span class="s1">ExportAllDeclaration</span><span class="s2">,</span>
    <span class="s1">ExportDefaultDeclaration</span><span class="s2">,</span>
    <span class="s1">ExportNamedDeclaration</span><span class="s2">,</span>
    <span class="s1">ExportSpecifier</span><span class="s2">,</span>
    <span class="s1">ExpressionStatement</span><span class="s2">,</span>
    <span class="s1">ForInStatement</span><span class="s2">,</span>
    <span class="s1">ForOfStatement</span><span class="s2">,</span>
    <span class="s1">ForStatement</span><span class="s2">,</span>
    <span class="s1">FunctionDeclaration</span><span class="s2">,</span>
    <span class="s1">FunctionExpression</span><span class="s2">,</span>
    <span class="s1">Identifier</span><span class="s2">,</span>
    <span class="s1">IfStatement</span><span class="s2">,</span>
    <span class="s1">ImportAttribute</span><span class="s2">,</span>
    <span class="s1">ImportDeclaration</span><span class="s2">,</span>
    <span class="s1">ImportDefaultSpecifier</span><span class="s2">,</span>
    <span class="s1">ImportExpression</span><span class="s2">,</span>
    <span class="s1">ImportNamespaceSpecifier</span><span class="s2">,</span>
    <span class="s1">ImportSpecifier</span><span class="s2">,</span>
    <span class="s1">LabeledStatement</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">LogicalExpression</span><span class="s2">,</span>
    <span class="s1">MemberExpression</span><span class="s2">,</span>
    <span class="s1">MetaProperty</span><span class="s2">,</span>
    <span class="s1">MethodDefinition</span><span class="s2">,</span>
    <span class="s1">NewExpression</span><span class="s2">,</span>
    <span class="s1">ObjectExpression</span><span class="s2">,</span>
    <span class="s1">ObjectPattern</span><span class="s2">,</span>
    <span class="s1">PrivateIdentifier</span><span class="s2">,</span>
    <span class="s1">Program</span><span class="s2">,</span>
    <span class="s1">Property</span><span class="s2">,</span>
    <span class="s1">PropertyDefinition</span><span class="s2">,</span>
    <span class="s1">RestElement</span><span class="s2">,</span>
    <span class="s1">ReturnStatement</span><span class="s2">,</span>
    <span class="s1">SequenceExpression</span><span class="s2">,</span>
    <span class="s1">SpreadElement</span><span class="s2">,</span>
    <span class="s1">StaticBlock</span><span class="s2">,</span>
    <span class="s1">Super</span><span class="s2">,</span>
    <span class="s1">SwitchCase</span><span class="s2">,</span>
    <span class="s1">SwitchStatement</span><span class="s2">,</span>
    <span class="s1">TaggedTemplateExpression</span><span class="s2">,</span>
    <span class="s1">TemplateElement</span><span class="s2">,</span>
    <span class="s1">TemplateLiteral</span><span class="s2">,</span>
    <span class="s1">ThisExpression</span><span class="s2">,</span>
    <span class="s1">ThrowStatement</span><span class="s2">,</span>
    <span class="s1">TryStatement</span><span class="s2">,</span>
    <span class="s1">UnaryExpression</span><span class="s2">,</span>
    <span class="s1">UnknownNode</span><span class="s2">,</span>
    <span class="s1">UpdateExpression</span><span class="s2">,</span>
    <span class="s1">VariableDeclaration</span><span class="s2">,</span>
    <span class="s1">VariableDeclarator</span><span class="s2">,</span>
    <span class="s1">WhileStatement</span><span class="s2">,</span>
    <span class="s1">YieldExpression</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">MISSING_EXPORT_SHIM_VARIABLE = </span><span class="s3">'_missingExportShim'</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">ExportShimVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor(module) {</span>
        <span class="s2">super</span><span class="s1">(MISSING_EXPORT_SHIM_VARIABLE)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.module = module</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">super</span><span class="s1">.include()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.module.needsExportShim = </span><span class="s2">true;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">NamespaceVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor(context) {</span>
        <span class="s2">super</span><span class="s1">(context.getModuleName())</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.memberVariables = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.mergedNamespaces = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.referencedEarly = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.references = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context = context</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.module = context.module</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addReference(identifier) {</span>
        <span class="s2">this</span><span class="s1">.references.push(identifier)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.name = identifier.name</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">recursionTracker) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">1 </span><span class="s1">|| (path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; interaction.type === INTERACTION_CALLED)) {</span>
            <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.getMemberVariables()[key]?.deoptimizeArgumentsOnInteractionAtPath(interaction</span><span class="s2">, </span><span class="s1">path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">recursionTracker)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">deoptimizeInteraction(interaction)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">deoptimizePath(path) {</span>
        <span class="s2">if </span><span class="s1">(path.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.getMemberVariables()[key]?.deoptimizePath(path.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getLiteralValueAtPath(path) {</span>
        <span class="s2">if </span><span class="s1">(path[</span><span class="s4">0</span><span class="s1">] === SymbolToStringTag) {</span>
            <span class="s2">return </span><span class="s3">'Module'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">UnknownValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getMemberVariables() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.memberVariables) {</span>
            <span class="s2">return this</span><span class="s1">.memberVariables</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">memberVariables = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sortedExports = [...</span><span class="s2">this</span><span class="s1">.context.getExports()</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.context.getReexports()].sort()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of sortedExports) {</span>
            <span class="s2">if </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; name !== </span><span class="s2">this</span><span class="s1">.module.info.syntheticNamedExports) {</span>
                <span class="s2">const </span><span class="s1">exportedVariable = </span><span class="s2">this</span><span class="s1">.context.traceExport(name)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(exportedVariable) {</span>
                    <span class="s1">memberVariables[name] = exportedVariable</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.memberVariables = memberVariables)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffectsOnInteractionAtPath(path</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context) {</span>
        <span class="s2">const </span><span class="s1">{ type } = interaction</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">// This can only be a call anyway</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(path.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; type !== INTERACTION_CALLED) {</span>
            <span class="s2">return </span><span class="s1">type === INTERACTION_ASSIGNED</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">key = path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key !== </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">memberVariable = </span><span class="s2">this</span><span class="s1">.getMemberVariables()[key]</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(!memberVariable ||</span>
            <span class="s1">memberVariable.hasEffectsOnInteractionAtPath(path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">interaction</span><span class="s2">, </span><span class="s1">context))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.context.includeAllExports()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">prepare(accessedGlobalsByScope) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.mergedNamespaces.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE]</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">renderBlock(options) {</span>
        <span class="s2">const </span><span class="s1">{ exportNamesByVariable</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">snippets: { _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } } = options</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">memberVariables = </span><span class="s2">this</span><span class="s1">.getMemberVariables()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">members = Object.entries(memberVariables)</span>
            <span class="s1">.filter(([_</span><span class="s2">, </span><span class="s1">variable]) =&gt; variable.included)</span>
            <span class="s1">.map(([name</span><span class="s2">, </span><span class="s1">original]) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.referencedEarly || original.isReassigned) {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s2">null,</span>
                    <span class="s3">`get </span><span class="s1">${name}${_}</span><span class="s3">()</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}</span><span class="s3">return </span><span class="s1">${original.getName(getPropertyAccess)}${s}${_}</span><span class="s3">}`</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">original.getName(getPropertyAccess)]</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">members.unshift([</span><span class="s2">null, </span><span class="s3">`__proto__:</span><span class="s1">${_}</span><span class="s3">null`</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">output = getObject(members</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: { base: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">t } })</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.mergedNamespaces.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">assignmentArguments = </span><span class="s2">this</span><span class="s1">.mergedNamespaces.map(variable =&gt; variable.getName(getPropertyAccess))</span><span class="s2">;</span>
            <span class="s1">output = </span><span class="s3">`/*#__PURE__*/</span><span class="s1">${MERGE_NAMESPACES_VARIABLE}</span><span class="s3">(</span><span class="s1">${output}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">[</span><span class="s1">${assignmentArguments.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">])`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// The helper to merge namespaces will also take care of freezing and toStringTag</span>
            <span class="s2">if </span><span class="s1">(namespaceToStringTag) {</span>
                <span class="s1">output = </span><span class="s3">`/*#__PURE__*/Object.defineProperty(</span><span class="s1">${output}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">Symbol.toStringTag,</span><span class="s1">${_}${getToStringTagValue(getObject)}</span><span class="s3">)`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(freeze) {</span>
                <span class="s1">output = </span><span class="s3">`/*#__PURE__*/Object.freeze(</span><span class="s1">${output}</span><span class="s3">)`</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.getName(getPropertyAccess)</span><span class="s2">;</span>
        <span class="s1">output = </span><span class="s3">`</span><span class="s1">${cnst} ${name}${_}</span><span class="s3">=</span><span class="s1">${_}${output}</span><span class="s3">;`</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'system' </span><span class="s1">&amp;&amp; exportNamesByVariable.has(</span><span class="s2">this</span><span class="s1">)) {</span>
            <span class="s1">output += </span><span class="s3">`</span><span class="s1">${n}${getSystemExportStatement([</span><span class="s2">this</span><span class="s1">]</span><span class="s2">, </span><span class="s1">options)}</span><span class="s3">;`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">output</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">renderFirst() {</span>
        <span class="s2">return this</span><span class="s1">.referencedEarly</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setMergedNamespaces(mergedNamespaces) {</span>
        <span class="s2">this</span><span class="s1">.mergedNamespaces = mergedNamespaces</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">moduleExecIndex = </span><span class="s2">this</span><span class="s1">.context.getModuleExecIndex()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">identifier of </span><span class="s2">this</span><span class="s1">.references) {</span>
            <span class="s2">if </span><span class="s1">(identifier.context.getModuleExecIndex() &lt;= moduleExecIndex) {</span>
                <span class="s2">this</span><span class="s1">.referencedEarly = </span><span class="s2">true;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">NamespaceVariable.prototype.isNamespace = </span><span class="s2">true;</span>

<span class="s2">class </span><span class="s1">SyntheticNamedExportVariable </span><span class="s2">extends </span><span class="s1">Variable {</span>
    <span class="s1">constructor(context</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">syntheticNamespace) {</span>
        <span class="s2">super</span><span class="s1">(name)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.baseVariable = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.context = context</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.module = context.module</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.syntheticNamespace = syntheticNamespace</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseVariable() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.baseVariable)</span>
            <span class="s2">return this</span><span class="s1">.baseVariable</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">baseVariable = </span><span class="s2">this</span><span class="s1">.syntheticNamespace</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(baseVariable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable ||</span>
            <span class="s1">baseVariable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
            <span class="s2">if </span><span class="s1">(baseVariable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable) {</span>
                <span class="s2">const </span><span class="s1">original = baseVariable.getOriginalVariable()</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(original === baseVariable)</span>
                    <span class="s2">break;</span>
                <span class="s1">baseVariable = original</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(baseVariable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s1">baseVariable = baseVariable.syntheticNamespace</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.baseVariable = baseVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseVariableName() {</span>
        <span class="s2">return this</span><span class="s1">.syntheticNamespace.getBaseVariableName()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getName(getPropertyAccess) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.syntheticNamespace.getName(getPropertyAccess)}${getPropertyAccess(</span><span class="s2">this</span><span class="s1">.name)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">this</span><span class="s1">.included = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.context.includeVariableInModule(</span><span class="s2">this</span><span class="s1">.syntheticNamespace)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setRenderNames(baseName</span><span class="s2">, </span><span class="s1">name) {</span>
        <span class="s2">super</span><span class="s1">.setRenderNames(baseName</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">BuildPhase</span><span class="s2">;</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(BuildPhase) {</span>
    <span class="s1">BuildPhase[BuildPhase[</span><span class="s3">&quot;LOAD_AND_PARSE&quot;</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">] = </span><span class="s3">&quot;LOAD_AND_PARSE&quot;</span><span class="s2">;</span>
    <span class="s1">BuildPhase[BuildPhase[</span><span class="s3">&quot;ANALYSE&quot;</span><span class="s1">] = </span><span class="s4">1</span><span class="s1">] = </span><span class="s3">&quot;ANALYSE&quot;</span><span class="s2">;</span>
    <span class="s1">BuildPhase[BuildPhase[</span><span class="s3">&quot;GENERATE&quot;</span><span class="s1">] = </span><span class="s4">2</span><span class="s1">] = </span><span class="s3">&quot;GENERATE&quot;</span><span class="s2">;</span>
<span class="s1">})(BuildPhase || (BuildPhase = {}))</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getId(m) {</span>
    <span class="s2">return </span><span class="s1">m.id</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getAssertionsFromImportExpression(node) {</span>
    <span class="s2">const </span><span class="s1">assertProperty = node.arguments?.[</span><span class="s4">0</span><span class="s1">]?.properties.find((property) =&gt; getPropertyKey(property) === </span><span class="s3">'assert'</span><span class="s1">)?.value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!assertProperty) {</span>
        <span class="s2">return </span><span class="s1">EMPTY_OBJECT</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">assertFields = assertProperty.properties</span>
        <span class="s1">.map(property =&gt; {</span>
        <span class="s2">const </span><span class="s1">key = getPropertyKey(property)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string' </span><span class="s1">&amp;&amp;</span>
            <span class="s2">typeof </span><span class="s1">property.value.value === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">property.value.value]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">})</span>
        <span class="s1">.filter((property) =&gt; !!property)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(assertFields.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">Object.fromEntries(assertFields)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">EMPTY_OBJECT</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getPropertyKey = (property) =&gt; {</span>
    <span class="s2">const </span><span class="s1">key = property.key</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">key &amp;&amp; (key.name || key.value)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getAssertionsFromImportExportDeclaration(assertions) {</span>
    <span class="s2">return </span><span class="s1">assertions?.length</span>
        <span class="s1">? Object.fromEntries(assertions.map(assertion =&gt; [getPropertyKey(assertion)</span><span class="s2">, </span><span class="s1">assertion.value.value]))</span>
        <span class="s1">: EMPTY_OBJECT</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">doAssertionsDiffer(assertionA</span><span class="s2">, </span><span class="s1">assertionB) {</span>
    <span class="s2">const </span><span class="s1">keysA = Object.keys(assertionA)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(keysA.length !== Object.keys(assertionB).length ||</span>
        <span class="s1">keysA.some(key =&gt; assertionA[key] !== assertionB[key]))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">timers = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getPersistedLabel(label</span><span class="s2">, </span><span class="s1">level) {</span>
    <span class="s2">switch </span><span class="s1">(level) {</span>
        <span class="s2">case </span><span class="s4">1</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`# </span><span class="s1">${label}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s4">2</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`## </span><span class="s1">${label}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s4">3</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">label</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${</span><span class="s3">'  '</span><span class="s1">.repeat(level - </span><span class="s4">4</span><span class="s1">)}</span><span class="s3">- </span><span class="s1">${label}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">timeStartImpl(label</span><span class="s2">, </span><span class="s1">level = </span><span class="s4">3</span><span class="s1">) {</span>
    <span class="s1">label = getPersistedLabel(label</span><span class="s2">, </span><span class="s1">level)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">startMemory = process$1.memoryUsage().heapUsed</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">startTime = performance.now()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">timer = timers.get(label)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(timer === undefined) {</span>
        <span class="s1">timers.set(label</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">memory: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">startMemory</span><span class="s2">,</span>
            <span class="s1">startTime</span><span class="s2">,</span>
            <span class="s1">time: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">totalMemory: </span><span class="s4">0</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">timer.startMemory = startMemory</span><span class="s2">;</span>
        <span class="s1">timer.startTime = startTime</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">timeEndImpl(label</span><span class="s2">, </span><span class="s1">level = </span><span class="s4">3</span><span class="s1">) {</span>
    <span class="s1">label = getPersistedLabel(label</span><span class="s2">, </span><span class="s1">level)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">timer = timers.get(label)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(timer !== undefined) {</span>
        <span class="s2">const </span><span class="s1">currentMemory = process$1.memoryUsage().heapUsed</span><span class="s2">;</span>
        <span class="s1">timer.memory += currentMemory - timer.startMemory</span><span class="s2">;</span>
        <span class="s1">timer.time += performance.now() - timer.startTime</span><span class="s2">;</span>
        <span class="s1">timer.totalMemory = Math.max(timer.totalMemory</span><span class="s2">, </span><span class="s1">currentMemory)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTimings() {</span>
    <span class="s2">const </span><span class="s1">newTimings = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[label</span><span class="s2">, </span><span class="s1">{ memory</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">totalMemory }] of timers) {</span>
        <span class="s1">newTimings[label] = [time</span><span class="s2">, </span><span class="s1">memory</span><span class="s2">, </span><span class="s1">totalMemory]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newTimings</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">timeStart = doNothing</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">timeEnd = doNothing</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TIMED_PLUGIN_HOOKS = [</span>
    <span class="s3">'augmentChunkHash'</span><span class="s2">,</span>
    <span class="s3">'buildEnd'</span><span class="s2">,</span>
    <span class="s3">'buildStart'</span><span class="s2">,</span>
    <span class="s3">'generateBundle'</span><span class="s2">,</span>
    <span class="s3">'load'</span><span class="s2">,</span>
    <span class="s3">'moduleParsed'</span><span class="s2">,</span>
    <span class="s3">'options'</span><span class="s2">,</span>
    <span class="s3">'outputOptions'</span><span class="s2">,</span>
    <span class="s3">'renderChunk'</span><span class="s2">,</span>
    <span class="s3">'renderDynamicImport'</span><span class="s2">,</span>
    <span class="s3">'renderStart'</span><span class="s2">,</span>
    <span class="s3">'resolveDynamicImport'</span><span class="s2">,</span>
    <span class="s3">'resolveFileUrl'</span><span class="s2">,</span>
    <span class="s3">'resolveId'</span><span class="s2">,</span>
    <span class="s3">'resolveImportMeta'</span><span class="s2">,</span>
    <span class="s3">'shouldTransformCachedModule'</span><span class="s2">,</span>
    <span class="s3">'transform'</span><span class="s2">,</span>
    <span class="s3">'writeBundle'</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getPluginWithTimers(plugin</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">hook of TIMED_PLUGIN_HOOKS) {</span>
        <span class="s2">if </span><span class="s1">(hook </span><span class="s2">in </span><span class="s1">plugin) {</span>
            <span class="s2">let </span><span class="s1">timerLabel = </span><span class="s3">`plugin </span><span class="s1">${index}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(plugin.name) {</span>
                <span class="s1">timerLabel += </span><span class="s3">` (</span><span class="s1">${plugin.name}</span><span class="s3">)`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">timerLabel += </span><span class="s3">` - </span><span class="s1">${hook}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">handler = </span><span class="s2">function </span><span class="s1">(...parameters) {</span>
                <span class="s1">timeStart(timerLabel</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">result = hookFunction.apply(</span><span class="s2">this, </span><span class="s1">parameters)</span><span class="s2">;</span>
                <span class="s1">timeEnd(timerLabel</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hookFunction</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">plugin[hook].handler === </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s1">hookFunction = plugin[hook].handler</span><span class="s2">;</span>
                <span class="s1">plugin[hook].handler = handler</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">hookFunction = plugin[hook]</span><span class="s2">;</span>
                <span class="s1">plugin[hook] = handler</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">plugin</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initialiseTimers(inputOptions) {</span>
    <span class="s2">if </span><span class="s1">(inputOptions.perf) {</span>
        <span class="s1">timers = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s1">timeStart = timeStartImpl</span><span class="s2">;</span>
        <span class="s1">timeEnd = timeEndImpl</span><span class="s2">;</span>
        <span class="s1">inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">timeStart = doNothing</span><span class="s2">;</span>
        <span class="s1">timeEnd = doNothing</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">markModuleAndImpureDependenciesAsExecuted(baseModule) {</span>
    <span class="s1">baseModule.isExecuted = </span><span class="s2">true;</span>
    <span class="s2">const </span><span class="s1">modules = [baseModule]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">visitedModules = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of [...module.dependencies</span><span class="s2">, </span><span class="s1">...module.implicitlyLoadedBefore]) {</span>
            <span class="s2">if </span><span class="s1">(!(dependency </span><span class="s2">instanceof </span><span class="s1">ExternalModule) &amp;&amp;</span>
                <span class="s1">!dependency.isExecuted &amp;&amp;</span>
                <span class="s1">(dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &amp;&amp;</span>
                <span class="s1">!visitedModules.has(dependency.id)) {</span>
                <span class="s1">dependency.isExecuted = </span><span class="s2">true;</span>
                <span class="s1">visitedModules.add(dependency.id)</span><span class="s2">;</span>
                <span class="s1">modules.push(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">MISSING_EXPORT_SHIM_DESCRIPTION = {</span>
    <span class="s1">identifier: </span><span class="s2">null,</span>
    <span class="s1">localName: MISSING_EXPORT_SHIM_VARIABLE</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getVariableForExportNameRecursive(target</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, </span><span class="s1">isExportAllSearch</span><span class="s2">, </span><span class="s1">searchedNamesAndModules = </span><span class="s2">new </span><span class="s1">Map()) {</span>
    <span class="s2">const </span><span class="s1">searchedModules = searchedNamesAndModules.get(name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(searchedModules) {</span>
        <span class="s2">if </span><span class="s1">(searchedModules.has(target)) {</span>
            <span class="s2">return </span><span class="s1">isExportAllSearch ? [</span><span class="s2">null</span><span class="s1">] : error(errorCircularReexport(name</span><span class="s2">, </span><span class="s1">target.id))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">searchedModules.add(target)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">searchedNamesAndModules.set(name</span><span class="s2">, new </span><span class="s1">Set([target]))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">target.getVariableForExportName(name</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">importerForSideEffects</span><span class="s2">,</span>
        <span class="s1">isExportAllSearch</span><span class="s2">,</span>
        <span class="s1">searchedNamesAndModules</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAndExtendSideEffectModules(variable</span><span class="s2">, </span><span class="s1">module) {</span>
    <span class="s2">const </span><span class="s1">sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable</span><span class="s2">, </span><span class="s1">variable</span><span class="s2">, </span><span class="s1">(getNewSet))</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">currentVariable = variable</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">referencedVariables = </span><span class="s2">new </span><span class="s1">Set([currentVariable])</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">importingModule = currentVariable.module</span><span class="s2">;</span>
        <span class="s1">currentVariable =</span>
            <span class="s1">currentVariable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable</span>
                <span class="s1">? currentVariable.getDirectOriginalVariable()</span>
                <span class="s1">: currentVariable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable</span>
                    <span class="s1">? currentVariable.syntheticNamespace</span>
                    <span class="s1">: </span><span class="s2">null;</span>
        <span class="s2">if </span><span class="s1">(!currentVariable || referencedVariables.has(currentVariable)) {</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">referencedVariables.add(currentVariable)</span><span class="s2">;</span>
        <span class="s1">sideEffectModules.add(importingModule)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">originalSideEffects = importingModule.sideEffectDependenciesByVariable.get(currentVariable)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(originalSideEffects) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of originalSideEffects) {</span>
                <span class="s1">sideEffectModules.add(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">sideEffectModules</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Module {</span>
    <span class="s1">constructor(graph</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">syntheticNamedExports</span><span class="s2">, </span><span class="s1">meta</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">this</span><span class="s1">.graph = graph</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.id = id</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.alternativeReexportModules = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.chunkFileNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.chunkNames = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.cycles = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicImporters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicImports = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.execIndex = Infinity</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.implicitlyLoadedAfter = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.implicitlyLoadedBefore = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.importDescriptions = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.importMetas = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.importedFromNotTreeshaken = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.importers = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includedDynamicImporters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includedImports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.isExecuted = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.isUserDefinedEntryPoint = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.needsExportShim = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.sideEffectDependenciesByVariable = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.sourcesWithAssertions = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.allExportNames = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.ast = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.exportAllModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportAllSources = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportNamesByVariable = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.exportShimVariable = </span><span class="s2">new </span><span class="s1">ExportShimVariable(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exports = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.namespaceReexportsByName = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.reexportDescriptions = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.relevantDependencies = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.syntheticExports = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.syntheticNamespace = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.transformDependencies = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.transitiveReexports = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.excludeFromSourcemap = </span><span class="s4">/\0/</span><span class="s1">.test(id)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.context = options.moduleContext(id)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.preserveSignature = </span><span class="s2">this</span><span class="s1">.options.preserveEntrySignatures</span><span class="s2">;</span>
        <span class="s0">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s2">const </span><span class="s1">module = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">{ dynamicImports</span><span class="s2">, </span><span class="s1">dynamicImporters</span><span class="s2">, </span><span class="s1">exportAllSources</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">implicitlyLoadedAfter</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore</span><span class="s2">, </span><span class="s1">importers</span><span class="s2">, </span><span class="s1">reexportDescriptions</span><span class="s2">, </span><span class="s1">sourcesWithAssertions } = </span><span class="s2">this;</span>
        <span class="s2">this</span><span class="s1">.info = {</span>
            <span class="s1">assertions</span><span class="s2">,</span>
            <span class="s1">ast: </span><span class="s2">null,</span>
            <span class="s1">code: </span><span class="s2">null,</span>
            <span class="s1">get dynamicallyImportedIdResolutions() {</span>
                <span class="s2">return </span><span class="s1">dynamicImports</span>
                    <span class="s1">.map(({ argument }) =&gt; </span><span class="s2">typeof </span><span class="s1">argument === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; module.resolvedIds[argument])</span>
                    <span class="s1">.filter(Boolean)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get dynamicallyImportedIds() {</span>
                <span class="s0">// We cannot use this.dynamicDependencies because this is needed before</span>
                <span class="s0">// dynamicDependencies are populated</span>
                <span class="s2">return </span><span class="s1">dynamicImports.map(({ id }) =&gt; id).filter((id) =&gt; id != </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get dynamicImporters() {</span>
                <span class="s2">return </span><span class="s1">dynamicImporters.sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get exportedBindings() {</span>
                <span class="s2">const </span><span class="s1">exportBindings = { </span><span class="s3">'.'</span><span class="s1">: [...exports.keys()] }</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">{ source }] of reexportDescriptions) {</span>
                    <span class="s1">(exportBindings[source] ?? (exportBindings[source] = [])).push(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">source of exportAllSources) {</span>
                    <span class="s1">(exportBindings[source] ?? (exportBindings[source] = [])).push(</span><span class="s3">'*'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">exportBindings</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get exports() {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">...exports.keys()</span><span class="s2">,</span>
                    <span class="s1">...reexportDescriptions.keys()</span><span class="s2">,</span>
                    <span class="s1">...[...exportAllSources].map(() =&gt; </span><span class="s3">'*'</span><span class="s1">)</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get hasDefaultExport() {</span>
                <span class="s0">// This information is only valid after parsing</span>
                <span class="s2">if </span><span class="s1">(!module.ast) {</span>
                    <span class="s2">return null;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">module.exports.has(</span><span class="s3">'default'</span><span class="s1">) || reexportDescriptions.has(</span><span class="s3">'default'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get hasModuleSideEffects() {</span>
                <span class="s1">warnDeprecation(</span><span class="s3">'Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.'</span><span class="s2">, </span><span class="s1">URL_THIS_GETMODULEINFO</span><span class="s2">, true, </span><span class="s1">options)</span><span class="s2">;</span>
                <span class="s2">return this</span><span class="s1">.moduleSideEffects</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">id</span><span class="s2">,</span>
            <span class="s1">get implicitlyLoadedAfterOneOf() {</span>
                <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
                <span class="s2">return </span><span class="s1">Array.from(implicitlyLoadedAfter</span><span class="s2">, </span><span class="s1">getId).sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get implicitlyLoadedBefore() {</span>
                <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
                <span class="s2">return </span><span class="s1">Array.from(implicitlyLoadedBefore</span><span class="s2">, </span><span class="s1">getId).sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get importedIdResolutions() {</span>
                <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
                <span class="s2">return </span><span class="s1">Array.from(sourcesWithAssertions.keys()</span><span class="s2">, </span><span class="s1">source =&gt; module.resolvedIds[source]).filter(Boolean)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get importedIds() {</span>
                <span class="s0">// We cannot use this.dependencies because this is needed before</span>
                <span class="s0">// dependencies are populated</span>
                <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
                <span class="s2">return </span><span class="s1">Array.from(sourcesWithAssertions.keys()</span><span class="s2">, </span><span class="s1">source =&gt; module.resolvedIds[source]?.id).filter(Boolean)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get importers() {</span>
                <span class="s2">return </span><span class="s1">importers.sort()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">isEntry</span><span class="s2">,</span>
            <span class="s1">isExternal: </span><span class="s2">false,</span>
            <span class="s1">get isIncluded() {</span>
                <span class="s2">if </span><span class="s1">(graph.phase !== BuildPhase.GENERATE) {</span>
                    <span class="s2">return null;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">module.isIncluded()</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">meta: { ...meta }</span><span class="s2">,</span>
            <span class="s1">moduleSideEffects</span><span class="s2">,</span>
            <span class="s1">syntheticNamedExports</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s0">// Hide the deprecated key so that it only warns when accessed explicitly</span>
        <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
        <span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">.info</span><span class="s2">, </span><span class="s3">'hasModuleSideEffects'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">enumerable: </span><span class="s2">false</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">basename() {</span>
        <span class="s2">const </span><span class="s1">base = basename(</span><span class="s2">this</span><span class="s1">.id)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">extension = extname(</span><span class="s2">this</span><span class="s1">.id)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">makeLegal(extension ? base.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-extension.length) : base)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">bindReferences() {</span>
        <span class="s2">this</span><span class="s1">.ast.bind()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">error(properties</span><span class="s2">, </span><span class="s1">pos) {</span>
        <span class="s2">this</span><span class="s1">.addLocationToLogProps(properties</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">error(properties)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getAllExportNames() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allExportNames) {</span>
            <span class="s2">return this</span><span class="s1">.allExportNames</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.allExportNames = </span><span class="s2">new </span><span class="s1">Set([...</span><span class="s2">this</span><span class="s1">.exports.keys()</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.reexportDescriptions.keys()])</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.exportAllModules) {</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                <span class="s2">this</span><span class="s1">.allExportNames.add(</span><span class="s3">`*</span><span class="s1">${module.id}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of module.getAllExportNames()) {</span>
                <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">'default'</span><span class="s1">)</span>
                    <span class="s2">this</span><span class="s1">.allExportNames.add(name)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// We do not count the synthetic namespace as a regular export to hide it</span>
        <span class="s0">// from entry signatures and namespace objects</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">.info.syntheticNamedExports === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.allExportNames.delete(</span><span class="s2">this</span><span class="s1">.info.syntheticNamedExports)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.allExportNames</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getDependenciesToBeIncluded() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.relevantDependencies)</span>
            <span class="s2">return this</span><span class="s1">.relevantDependencies</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.relevantDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">necessaryDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">alwaysCheckedDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">dependencyVariables = </span><span class="s2">new </span><span class="s1">Set(</span><span class="s2">this</span><span class="s1">.includedImports)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.info.isEntry ||</span>
            <span class="s2">this</span><span class="s1">.includedDynamicImporters.length &gt; </span><span class="s4">0 </span><span class="s1">||</span>
            <span class="s2">this</span><span class="s1">.namespace.included ||</span>
            <span class="s2">this</span><span class="s1">.implicitlyLoadedAfter.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of [...</span><span class="s2">this</span><span class="s1">.getReexports()</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.getExports()]) {</span>
                <span class="s2">const </span><span class="s1">[exportedVariable] = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(exportName)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(exportedVariable) {</span>
                    <span class="s1">dependencyVariables.add(exportedVariable)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">variable of dependencyVariables) {</span>
            <span class="s2">const </span><span class="s1">sideEffectDependencies = </span><span class="s2">this</span><span class="s1">.sideEffectDependenciesByVariable.get(variable)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(sideEffectDependencies) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of sideEffectDependencies) {</span>
                    <span class="s1">alwaysCheckedDependencies.add(module)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s1">variable = variable.getBaseVariable()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable) {</span>
                <span class="s1">variable = variable.getOriginalVariable()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">necessaryDependencies.add(variable.module)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.treeshake || </span><span class="s2">this</span><span class="s1">.info.moduleSideEffects === </span><span class="s3">'no-treeshake'</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of </span><span class="s2">this</span><span class="s1">.dependencies) {</span>
                <span class="s2">this</span><span class="s1">.relevantDependencies.add(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.addRelevantSideEffectDependencies(</span><span class="s2">this</span><span class="s1">.relevantDependencies</span><span class="s2">, </span><span class="s1">necessaryDependencies</span><span class="s2">, </span><span class="s1">alwaysCheckedDependencies)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of necessaryDependencies) {</span>
            <span class="s2">this</span><span class="s1">.relevantDependencies.add(dependency)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.relevantDependencies</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getExportNamesByVariable() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.exportNamesByVariable) {</span>
            <span class="s2">return this</span><span class="s1">.exportNamesByVariable</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">exportNamesByVariable = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.getAllExportNames()) {</span>
            <span class="s2">let </span><span class="s1">[tracedVariable] = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(exportName)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(tracedVariable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable) {</span>
                <span class="s1">tracedVariable = tracedVariable.getOriginalVariable()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!tracedVariable ||</span>
                <span class="s1">!(tracedVariable.included || tracedVariable </span><span class="s2">instanceof </span><span class="s1">ExternalVariable)) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">existingExportNames = exportNamesByVariable.get(tracedVariable)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(existingExportNames) {</span>
                <span class="s1">existingExportNames.push(exportName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">exportNamesByVariable.set(tracedVariable</span><span class="s2">, </span><span class="s1">[exportName])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.exportNamesByVariable = exportNamesByVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getExports() {</span>
        <span class="s2">return </span><span class="s1">[...</span><span class="s2">this</span><span class="s1">.exports.keys()]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReexports() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.transitiveReexports) {</span>
            <span class="s2">return this</span><span class="s1">.transitiveReexports</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// to avoid infinite recursion when using circular `export * from X`</span>
        <span class="s2">this</span><span class="s1">.transitiveReexports = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">reexports = </span><span class="s2">new </span><span class="s1">Set(</span><span class="s2">this</span><span class="s1">.reexportDescriptions.keys())</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.exportAllModules) {</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                <span class="s1">reexports.add(</span><span class="s3">`*</span><span class="s1">${module.id}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of [...module.getReexports()</span><span class="s2">, </span><span class="s1">...module.getExports()]) {</span>
                    <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">'default'</span><span class="s1">)</span>
                        <span class="s1">reexports.add(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.transitiveReexports = [...reexports])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getRenderedExports() {</span>
        <span class="s0">// only direct exports are counted here, not reexports at all</span>
        <span class="s2">const </span><span class="s1">renderedExports = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">removedExports = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.exports.keys()) {</span>
            <span class="s2">const </span><span class="s1">[variable] = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(exportName)</span><span class="s2">;</span>
            <span class="s1">(variable &amp;&amp; variable.included ? renderedExports : removedExports).push(exportName)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ removedExports</span><span class="s2">, </span><span class="s1">renderedExports }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getSyntheticNamespace() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.syntheticNamespace === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.syntheticNamespace = undefined</span><span class="s2">;</span>
            <span class="s1">[</span><span class="s2">this</span><span class="s1">.syntheticNamespace] = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(</span><span class="s2">typeof this</span><span class="s1">.info.syntheticNamedExports === </span><span class="s3">'string'</span>
                <span class="s1">? </span><span class="s2">this</span><span class="s1">.info.syntheticNamedExports</span>
                <span class="s1">: </span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">{ onlyExplicit: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.syntheticNamespace) {</span>
            <span class="s2">return </span><span class="s1">error(errorSyntheticNamedExportsNeedNamespaceExport(</span><span class="s2">this</span><span class="s1">.id</span><span class="s2">, this</span><span class="s1">.info.syntheticNamedExports))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.syntheticNamespace</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getVariableForExportName(name</span><span class="s2">, </span><span class="s1">{ importerForSideEffects</span><span class="s2">, </span><span class="s1">isExportAllSearch</span><span class="s2">, </span><span class="s1">onlyExplicit</span><span class="s2">, </span><span class="s1">searchedNamesAndModules } = EMPTY_OBJECT) {</span>
        <span class="s2">if </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'*'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(name.length === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s0">// export * from './other'</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.namespace]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// export * from 'external'</span>
            <span class="s2">const </span><span class="s1">module = </span><span class="s2">this</span><span class="s1">.graph.modulesById.get(name.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">module.getVariableForExportName(</span><span class="s3">'*'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// export { foo } from './other'</span>
        <span class="s2">const </span><span class="s1">reexportDeclaration = </span><span class="s2">this</span><span class="s1">.reexportDescriptions.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(reexportDeclaration) {</span>
            <span class="s2">const </span><span class="s1">[variable] = getVariableForExportNameRecursive(reexportDeclaration.module</span><span class="s2">, </span><span class="s1">reexportDeclaration.localName</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, false, </span><span class="s1">searchedNamesAndModules)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s2">return this</span><span class="s1">.error(errorMissingExport(reexportDeclaration.localName</span><span class="s2">, this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">reexportDeclaration.module.id)</span><span class="s2">, </span><span class="s1">reexportDeclaration.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(importerForSideEffects) {</span>
                <span class="s1">setAlternativeExporterIfCyclic(variable</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.info.moduleSideEffects) {</span>
                    <span class="s1">getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable</span><span class="s2">, </span><span class="s1">variable</span><span class="s2">, </span><span class="s1">(getNewSet)).add(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[variable]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">exportDeclaration = </span><span class="s2">this</span><span class="s1">.exports.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exportDeclaration) {</span>
            <span class="s2">if </span><span class="s1">(exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.exportShimVariable]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">name = exportDeclaration.localName</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.traceVariable(name</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">importerForSideEffects</span><span class="s2">,</span>
                <span class="s1">searchedNamesAndModules</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(importerForSideEffects) {</span>
                <span class="s1">setAlternativeExporterIfCyclic(variable</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable</span><span class="s2">, </span><span class="s1">variable</span><span class="s2">, </span><span class="s1">(getNewSet)).add(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[variable]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(onlyExplicit) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s2">null</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">'default'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">foundNamespaceReexport = </span><span class="s2">this</span><span class="s1">.namespaceReexportsByName.get(name) ??</span>
                <span class="s2">this</span><span class="s1">.getVariableFromNamespaceReexports(name</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, </span><span class="s1">searchedNamesAndModules)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.namespaceReexportsByName.set(name</span><span class="s2">, </span><span class="s1">foundNamespaceReexport)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(foundNamespaceReexport[</span><span class="s4">0</span><span class="s1">]) {</span>
                <span class="s2">return </span><span class="s1">foundNamespaceReexport</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.info.syntheticNamedExports) {</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">getOrCreate(</span><span class="s2">this</span><span class="s1">.syntheticExports</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">() =&gt; </span><span class="s2">new </span><span class="s1">SyntheticNamedExportVariable(</span><span class="s2">this</span><span class="s1">.astContext</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, this</span><span class="s1">.getSyntheticNamespace()))</span>
            <span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// we don't want to create shims when we are just</span>
        <span class="s0">// probing export * modules for exports</span>
        <span class="s2">if </span><span class="s1">(!isExportAllSearch &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.shimMissingExports) {</span>
            <span class="s2">this</span><span class="s1">.shimMissingExport(name)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.exportShimVariable]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s2">null</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hasEffects() {</span>
        <span class="s2">return this</span><span class="s1">.info.moduleSideEffects === </span><span class="s3">'no-treeshake' </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.ast.hasCachedEffects()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">include() {</span>
        <span class="s2">const </span><span class="s1">context = createInclusionContext()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.ast.shouldBeIncluded(context))</span>
            <span class="s2">this</span><span class="s1">.ast.include(context</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeAllExports(includeNamespaceMembers) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isExecuted) {</span>
            <span class="s1">markModuleAndImpureDependenciesAsExecuted(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.graph.needsTreeshakingPass = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.exports.keys()) {</span>
            <span class="s2">if </span><span class="s1">(includeNamespaceMembers || exportName !== </span><span class="s2">this</span><span class="s1">.info.syntheticNamedExports) {</span>
                <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(exportName)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s1">variable.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!variable.included) {</span>
                    <span class="s2">this</span><span class="s1">.includeVariable(variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of </span><span class="s2">this</span><span class="s1">.getReexports()) {</span>
            <span class="s2">const </span><span class="s1">[variable] = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable) {</span>
                <span class="s1">variable.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!variable.included) {</span>
                    <span class="s2">this</span><span class="s1">.includeVariable(variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">ExternalVariable) {</span>
                    <span class="s1">variable.module.reexported = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(includeNamespaceMembers) {</span>
            <span class="s2">this</span><span class="s1">.namespace.setMergedNamespaces(</span><span class="s2">this</span><span class="s1">.includeAndGetAdditionalMergedNamespaces())</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeAllInBundle() {</span>
        <span class="s2">this</span><span class="s1">.ast.include(createInclusionContext()</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includeAllExports(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeExportsByNames(names) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isExecuted) {</span>
            <span class="s1">markModuleAndImpureDependenciesAsExecuted(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.graph.needsTreeshakingPass = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">includeNamespaceMembers = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of names) {</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.getVariableForExportName(name)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable) {</span>
                <span class="s1">variable.deoptimizePath(UNKNOWN_PATH)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!variable.included) {</span>
                    <span class="s2">this</span><span class="s1">.includeVariable(variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.exports.has(name) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.reexportDescriptions.has(name)) {</span>
                <span class="s1">includeNamespaceMembers = </span><span class="s2">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(includeNamespaceMembers) {</span>
            <span class="s2">this</span><span class="s1">.namespace.setMergedNamespaces(</span><span class="s2">this</span><span class="s1">.includeAndGetAdditionalMergedNamespaces())</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">isIncluded() {</span>
        <span class="s0">// Modules where this.ast is missing have been loaded via this.load and are</span>
        <span class="s0">// not yet fully processed, hence they cannot be included.</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.ast &amp;&amp; (</span><span class="s2">this</span><span class="s1">.ast.included || </span><span class="s2">this</span><span class="s1">.namespace.included || </span><span class="s2">this</span><span class="s1">.importedFromNotTreeshaken))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">linkImports() {</span>
        <span class="s2">this</span><span class="s1">.addModulesToImportDescriptions(</span><span class="s2">this</span><span class="s1">.importDescriptions)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.addModulesToImportDescriptions(</span><span class="s2">this</span><span class="s1">.reexportDescriptions)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">externalExportAllModules = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">source of </span><span class="s2">this</span><span class="s1">.exportAllSources) {</span>
            <span class="s2">const </span><span class="s1">module = </span><span class="s2">this</span><span class="s1">.graph.modulesById.get(</span><span class="s2">this</span><span class="s1">.resolvedIds[source].id)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                <span class="s1">externalExportAllModules.push(module)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.exportAllModules.push(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.exportAllModules.push(...externalExportAllModules)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">render(options) {</span>
        <span class="s2">const </span><span class="s1">source = </span><span class="s2">this</span><span class="s1">.magicString.clone()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.ast.render(source</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">source.trim()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ usesTopLevelAwait } = </span><span class="s2">this</span><span class="s1">.astContext</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(usesTopLevelAwait &amp;&amp; options.format !== </span><span class="s3">'es' </span><span class="s1">&amp;&amp; options.format !== </span><span class="s3">'system'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidFormatForTopLevelAwait(</span><span class="s2">this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">options.format))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ source</span><span class="s2">, </span><span class="s1">usesTopLevelAwait }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setSource({ ast</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">customTransformCache</span><span class="s2">, </span><span class="s1">originalCode</span><span class="s2">, </span><span class="s1">originalSourcemap</span><span class="s2">, </span><span class="s1">resolvedIds</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">transformDependencies</span><span class="s2">, </span><span class="s1">transformFiles</span><span class="s2">, </span><span class="s1">...moduleOptions }) {</span>
        <span class="s1">timeStart(</span><span class="s3">'generate ast'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.info.code = code</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.originalCode = originalCode</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.originalSourcemap = originalSourcemap</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.sourcemapChain = sourcemapChain</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(transformFiles) {</span>
            <span class="s2">this</span><span class="s1">.transformFiles = transformFiles</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.transformDependencies = transformDependencies</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.customTransformCache = customTransformCache</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.updateOptions(moduleOptions)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">moduleAst = ast ?? </span><span class="s2">this</span><span class="s1">.tryParse()</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'generate ast'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">timeStart(</span><span class="s3">'analyze ast'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.resolvedIds = resolvedIds ?? Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s0">// By default, `id` is the file name. Custom resolvers and loaders</span>
        <span class="s0">// can change that, but it makes sense to use it for the source file name</span>
        <span class="s2">const </span><span class="s1">fileName = </span><span class="s2">this</span><span class="s1">.id</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.magicString = </span><span class="s2">new </span><span class="s1">MagicString(code</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">filename: (</span><span class="s2">this</span><span class="s1">.excludeFromSourcemap ? </span><span class="s2">null </span><span class="s1">: fileName)</span><span class="s2">,</span>
            <span class="s1">indentExclusionRanges: []</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.astContext = {</span>
            <span class="s1">addDynamicImport: </span><span class="s2">this</span><span class="s1">.addDynamicImport.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">addExport: </span><span class="s2">this</span><span class="s1">.addExport.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">addImport: </span><span class="s2">this</span><span class="s1">.addImport.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">addImportMeta: </span><span class="s2">this</span><span class="s1">.addImportMeta.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">code</span><span class="s2">,</span>
            <span class="s1">deoptimizationTracker: </span><span class="s2">this</span><span class="s1">.graph.deoptimizationTracker</span><span class="s2">,</span>
            <span class="s1">error: </span><span class="s2">this</span><span class="s1">.error.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">fileName</span><span class="s2">,</span>
            <span class="s1">getExports: </span><span class="s2">this</span><span class="s1">.getExports.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">getModuleExecIndex: () =&gt; </span><span class="s2">this</span><span class="s1">.execIndex</span><span class="s2">,</span>
            <span class="s1">getModuleName: </span><span class="s2">this</span><span class="s1">.basename.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">getNodeConstructor: (name) =&gt; nodeConstructors[name] || nodeConstructors.UnknownNode</span><span class="s2">,</span>
            <span class="s1">getReexports: </span><span class="s2">this</span><span class="s1">.getReexports.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">importDescriptions: </span><span class="s2">this</span><span class="s1">.importDescriptions</span><span class="s2">,</span>
            <span class="s1">includeAllExports: () =&gt; </span><span class="s2">this</span><span class="s1">.includeAllExports(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">includeDynamicImport: </span><span class="s2">this</span><span class="s1">.includeDynamicImport.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">includeVariableInModule: </span><span class="s2">this</span><span class="s1">.includeVariableInModule.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">magicString: </span><span class="s2">this</span><span class="s1">.magicString</span><span class="s2">,</span>
            <span class="s1">manualPureFunctions: </span><span class="s2">this</span><span class="s1">.graph.pureFunctions</span><span class="s2">,</span>
            <span class="s1">module: </span><span class="s2">this,</span>
            <span class="s1">moduleContext: </span><span class="s2">this</span><span class="s1">.context</span><span class="s2">,</span>
            <span class="s1">options: </span><span class="s2">this</span><span class="s1">.options</span><span class="s2">,</span>
            <span class="s1">requestTreeshakingPass: () =&gt; (</span><span class="s2">this</span><span class="s1">.graph.needsTreeshakingPass = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">traceExport: (name) =&gt; </span><span class="s2">this</span><span class="s1">.getVariableForExportName(name)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">traceVariable: </span><span class="s2">this</span><span class="s1">.traceVariable.bind(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">usesTopLevelAwait: </span><span class="s2">false,</span>
            <span class="s1">warn: </span><span class="s2">this</span><span class="s1">.warn.bind(</span><span class="s2">this</span><span class="s1">)</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">ModuleScope(</span><span class="s2">this</span><span class="s1">.graph.scope</span><span class="s2">, this</span><span class="s1">.astContext)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.namespace = </span><span class="s2">new </span><span class="s1">NamespaceVariable(</span><span class="s2">this</span><span class="s1">.astContext)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.ast = </span><span class="s2">new </span><span class="s1">Program(moduleAst</span><span class="s2">, </span><span class="s1">{ context: </span><span class="s2">this</span><span class="s1">.astContext</span><span class="s2">, </span><span class="s1">type: </span><span class="s3">'Module' </span><span class="s1">}</span><span class="s2">, this</span><span class="s1">.scope)</span><span class="s2">;</span>
        <span class="s0">// Assign AST directly if has existing one as there's no way to drop it from memory.</span>
        <span class="s0">// If cache is enabled, also assign directly as otherwise it takes more CPU and memory to re-compute.</span>
        <span class="s2">if </span><span class="s1">(ast || </span><span class="s2">this</span><span class="s1">.options.cache !== </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.info.ast = moduleAst</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Make lazy and apply LRU cache to not hog the memory</span>
            <span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">.info</span><span class="s2">, </span><span class="s3">'ast'</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">get: () =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.graph.astLru.has(fileName)) {</span>
                        <span class="s2">return this</span><span class="s1">.graph.astLru.get(fileName)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">parsedAst = </span><span class="s2">this</span><span class="s1">.tryParse()</span><span class="s2">;</span>
                        <span class="s2">this</span><span class="s1">.graph.astLru.set(fileName</span><span class="s2">, </span><span class="s1">parsedAst)</span><span class="s2">;</span>
                        <span class="s2">return </span><span class="s1">parsedAst</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">timeEnd(</span><span class="s3">'analyze ast'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">toJSON() {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">assertions: </span><span class="s2">this</span><span class="s1">.info.assertions</span><span class="s2">,</span>
            <span class="s1">ast: </span><span class="s2">this</span><span class="s1">.info.ast</span><span class="s2">,</span>
            <span class="s1">code: </span><span class="s2">this</span><span class="s1">.info.code</span><span class="s2">,</span>
            <span class="s1">customTransformCache: </span><span class="s2">this</span><span class="s1">.customTransformCache</span><span class="s2">,</span>
            <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
            <span class="s1">dependencies: Array.from(</span><span class="s2">this</span><span class="s1">.dependencies</span><span class="s2">, </span><span class="s1">getId)</span><span class="s2">,</span>
            <span class="s1">id: </span><span class="s2">this</span><span class="s1">.id</span><span class="s2">,</span>
            <span class="s1">meta: </span><span class="s2">this</span><span class="s1">.info.meta</span><span class="s2">,</span>
            <span class="s1">moduleSideEffects: </span><span class="s2">this</span><span class="s1">.info.moduleSideEffects</span><span class="s2">,</span>
            <span class="s1">originalCode: </span><span class="s2">this</span><span class="s1">.originalCode</span><span class="s2">,</span>
            <span class="s1">originalSourcemap: </span><span class="s2">this</span><span class="s1">.originalSourcemap</span><span class="s2">,</span>
            <span class="s1">resolvedIds: </span><span class="s2">this</span><span class="s1">.resolvedIds</span><span class="s2">,</span>
            <span class="s1">sourcemapChain: </span><span class="s2">this</span><span class="s1">.sourcemapChain</span><span class="s2">,</span>
            <span class="s1">syntheticNamedExports: </span><span class="s2">this</span><span class="s1">.info.syntheticNamedExports</span><span class="s2">,</span>
            <span class="s1">transformDependencies: </span><span class="s2">this</span><span class="s1">.transformDependencies</span><span class="s2">,</span>
            <span class="s1">transformFiles: </span><span class="s2">this</span><span class="s1">.transformFiles</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">traceVariable(name</span><span class="s2">, </span><span class="s1">{ importerForSideEffects</span><span class="s2">, </span><span class="s1">isExportAllSearch</span><span class="s2">, </span><span class="s1">searchedNamesAndModules } = EMPTY_OBJECT) {</span>
        <span class="s2">const </span><span class="s1">localVariable = </span><span class="s2">this</span><span class="s1">.scope.variables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(localVariable) {</span>
            <span class="s2">return </span><span class="s1">localVariable</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">importDescription = </span><span class="s2">this</span><span class="s1">.importDescriptions.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(importDescription) {</span>
            <span class="s2">const </span><span class="s1">otherModule = importDescription.module</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(otherModule </span><span class="s2">instanceof </span><span class="s1">Module &amp;&amp; importDescription.name === </span><span class="s3">'*'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">otherModule.namespace</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">[declaration] = getVariableForExportNameRecursive(otherModule</span><span class="s2">, </span><span class="s1">importDescription.name</span><span class="s2">, </span><span class="s1">importerForSideEffects || </span><span class="s2">this, </span><span class="s1">isExportAllSearch</span><span class="s2">, </span><span class="s1">searchedNamesAndModules)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!declaration) {</span>
                <span class="s2">return this</span><span class="s1">.error(errorMissingExport(importDescription.name</span><span class="s2">, this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">otherModule.id)</span><span class="s2">, </span><span class="s1">importDescription.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">declaration</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s1">updateOptions({ meta</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">syntheticNamedExports }) {</span>
        <span class="s2">if </span><span class="s1">(moduleSideEffects != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.info.moduleSideEffects = moduleSideEffects</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(syntheticNamedExports != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.info.syntheticNamedExports = syntheticNamedExports</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(meta != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">Object.assign(</span><span class="s2">this</span><span class="s1">.info.meta</span><span class="s2">, </span><span class="s1">meta)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">warn(properties</span><span class="s2">, </span><span class="s1">pos) {</span>
        <span class="s2">this</span><span class="s1">.addLocationToLogProps(properties</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options.onwarn(properties)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addDynamicImport(node) {</span>
        <span class="s2">let </span><span class="s1">argument = node.source</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(argument </span><span class="s2">instanceof </span><span class="s1">TemplateLiteral) {</span>
            <span class="s2">if </span><span class="s1">(argument.quasis.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; argument.quasis[</span><span class="s4">0</span><span class="s1">].value.cooked) {</span>
                <span class="s1">argument = argument.quasis[</span><span class="s4">0</span><span class="s1">].value.cooked</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(argument </span><span class="s2">instanceof </span><span class="s1">Literal &amp;&amp; </span><span class="s2">typeof </span><span class="s1">argument.value === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s1">argument = argument.value</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.dynamicImports.push({ argument</span><span class="s2">, </span><span class="s1">id: </span><span class="s2">null, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">resolution: </span><span class="s2">null </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addExport(node) {</span>
        <span class="s2">if </span><span class="s1">(node </span><span class="s2">instanceof </span><span class="s1">ExportDefaultDeclaration) {</span>
            <span class="s0">// export default foo;</span>
            <span class="s2">this</span><span class="s1">.exports.set(</span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">identifier: node.variable.getAssignedVariableName()</span><span class="s2">,</span>
                <span class="s1">localName: </span><span class="s3">'default'</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node </span><span class="s2">instanceof </span><span class="s1">ExportAllDeclaration) {</span>
            <span class="s2">const </span><span class="s1">source = node.source.value</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.addSource(source</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(node.exported) {</span>
                <span class="s0">// export * as name from './other'</span>
                <span class="s2">const </span><span class="s1">name = node.exported.name</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.reexportDescriptions.set(name</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">localName: </span><span class="s3">'*'</span><span class="s2">,</span>
                    <span class="s1">module: </span><span class="s2">null,</span>
                    <span class="s1">source</span><span class="s2">,</span>
                    <span class="s1">start: node.start</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s0">// export * from './other'</span>
                <span class="s2">this</span><span class="s1">.exportAllSources.add(source)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.source </span><span class="s2">instanceof </span><span class="s1">Literal) {</span>
            <span class="s0">// export { name } from './other'</span>
            <span class="s2">const </span><span class="s1">source = node.source.value</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.addSource(source</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ exported</span><span class="s2">, </span><span class="s1">local</span><span class="s2">, </span><span class="s1">start } of node.specifiers) {</span>
                <span class="s2">const </span><span class="s1">name = exported </span><span class="s2">instanceof </span><span class="s1">Literal ? exported.value : exported.name</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.reexportDescriptions.set(name</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">localName: local </span><span class="s2">instanceof </span><span class="s1">Literal ? local.value : local.name</span><span class="s2">,</span>
                    <span class="s1">module: </span><span class="s2">null,</span>
                    <span class="s1">source</span><span class="s2">,</span>
                    <span class="s1">start</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.declaration) {</span>
            <span class="s2">const </span><span class="s1">declaration = node.declaration</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(declaration </span><span class="s2">instanceof </span><span class="s1">VariableDeclaration) {</span>
                <span class="s0">// export var { foo, bar } = ...</span>
                <span class="s0">// export var foo = 1, bar = 2;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declarator of declaration.declarations) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">localName of extractAssignedNames(declarator.id)) {</span>
                        <span class="s2">this</span><span class="s1">.exports.set(localName</span><span class="s2">, </span><span class="s1">{ identifier: </span><span class="s2">null, </span><span class="s1">localName })</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s0">// export function foo () {}</span>
                <span class="s2">const </span><span class="s1">localName = declaration.id.name</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.exports.set(localName</span><span class="s2">, </span><span class="s1">{ identifier: </span><span class="s2">null, </span><span class="s1">localName })</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// export { foo, bar, baz }</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ local</span><span class="s2">, </span><span class="s1">exported } of node.specifiers) {</span>
                <span class="s0">// except for reexports, local must be an Identifier</span>
                <span class="s2">const </span><span class="s1">localName = local.name</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">exportedName = exported </span><span class="s2">instanceof </span><span class="s1">Identifier ? exported.name : exported.value</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.exports.set(exportedName</span><span class="s2">, </span><span class="s1">{ identifier: </span><span class="s2">null, </span><span class="s1">localName })</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addImport(node) {</span>
        <span class="s2">const </span><span class="s1">source = node.source.value</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.addSource(source</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of node.specifiers) {</span>
            <span class="s2">const </span><span class="s1">name = specifier </span><span class="s2">instanceof </span><span class="s1">ImportDefaultSpecifier</span>
                <span class="s1">? </span><span class="s3">'default'</span>
                <span class="s1">: specifier </span><span class="s2">instanceof </span><span class="s1">ImportNamespaceSpecifier</span>
                    <span class="s1">? </span><span class="s3">'*'</span>
                    <span class="s1">: specifier.imported </span><span class="s2">instanceof </span><span class="s1">Identifier</span>
                        <span class="s1">? specifier.imported.name</span>
                        <span class="s1">: specifier.imported.value</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.importDescriptions.set(specifier.local.name</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">module: </span><span class="s2">null,</span>
                <span class="s1">name</span><span class="s2">,</span>
                <span class="s1">source</span><span class="s2">,</span>
                <span class="s1">start: specifier.start</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addImportMeta(node) {</span>
        <span class="s2">this</span><span class="s1">.importMetas.push(node)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addLocationToLogProps(properties</span><span class="s2">, </span><span class="s1">pos) {</span>
        <span class="s1">properties.id = </span><span class="s2">this</span><span class="s1">.id</span><span class="s2">;</span>
        <span class="s1">properties.pos = pos</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">code = </span><span class="s2">this</span><span class="s1">.info.code</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">location = locate(code</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">{ offsetLine: </span><span class="s4">1 </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(location) {</span>
            <span class="s2">let </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line } = location</span><span class="s2">;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">({ column</span><span class="s2">, </span><span class="s1">line } = getOriginalLocation(</span><span class="s2">this</span><span class="s1">.sourcemapChain</span><span class="s2">, </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line }))</span><span class="s2">;</span>
                <span class="s1">code = </span><span class="s2">this</span><span class="s1">.originalCode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">catch </span><span class="s1">(error_) {</span>
                <span class="s2">this</span><span class="s1">.options.onwarn(errorInvalidSourcemapForError(error_</span><span class="s2">, this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">pos))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">augmentCodeLocation(properties</span><span class="s2">, </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line }</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, this</span><span class="s1">.id)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addModulesToImportDescriptions(importDescription) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of importDescription.values()) {</span>
            <span class="s2">const </span><span class="s1">{ id } = </span><span class="s2">this</span><span class="s1">.resolvedIds[specifier.source]</span><span class="s2">;</span>
            <span class="s1">specifier.module = </span><span class="s2">this</span><span class="s1">.graph.modulesById.get(id)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addRelevantSideEffectDependencies(relevantDependencies</span><span class="s2">, </span><span class="s1">necessaryDependencies</span><span class="s2">, </span><span class="s1">alwaysCheckedDependencies) {</span>
        <span class="s2">const </span><span class="s1">handledDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">addSideEffectDependencies = (possibleDependencies) =&gt; {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of possibleDependencies) {</span>
                <span class="s2">if </span><span class="s1">(handledDependencies.has(dependency)) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s1">handledDependencies.add(dependency)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(necessaryDependencies.has(dependency)) {</span>
                    <span class="s1">relevantDependencies.add(dependency)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(dependency </span><span class="s2">instanceof </span><span class="s1">ExternalModule || dependency.hasEffects()) {</span>
                    <span class="s1">relevantDependencies.add(dependency)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s1">addSideEffectDependencies(dependency.dependencies)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">addSideEffectDependencies(</span><span class="s2">this</span><span class="s1">.dependencies)</span><span class="s2">;</span>
        <span class="s1">addSideEffectDependencies(alwaysCheckedDependencies)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addSource(source</span><span class="s2">, </span><span class="s1">declaration) {</span>
        <span class="s2">const </span><span class="s1">parsedAssertions = getAssertionsFromImportExportDeclaration(declaration.assertions)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">existingAssertions = </span><span class="s2">this</span><span class="s1">.sourcesWithAssertions.get(source)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(existingAssertions) {</span>
            <span class="s2">if </span><span class="s1">(doAssertionsDiffer(existingAssertions</span><span class="s2">, </span><span class="s1">parsedAssertions)) {</span>
                <span class="s2">this</span><span class="s1">.warn(errorInconsistentImportAssertions(existingAssertions</span><span class="s2">, </span><span class="s1">parsedAssertions</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, this</span><span class="s1">.id)</span><span class="s2">, </span><span class="s1">declaration.start)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.sourcesWithAssertions.set(source</span><span class="s2">, </span><span class="s1">parsedAssertions)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getVariableFromNamespaceReexports(name</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, </span><span class="s1">searchedNamesAndModules) {</span>
        <span class="s2">let </span><span class="s1">foundSyntheticDeclaration = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">foundInternalDeclarations = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">foundExternalDeclarations = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.exportAllModules) {</span>
            <span class="s0">// Synthetic namespaces should not hide &quot;regular&quot; exports of the same name</span>
            <span class="s2">if </span><span class="s1">(module.info.syntheticNamedExports === name) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">[variable</span><span class="s2">, </span><span class="s1">indirectExternal] = getVariableForExportNameRecursive(module</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">importerForSideEffects</span><span class="s2">, true, </span>
            <span class="s0">// We are creating a copy to handle the case where the same binding is</span>
            <span class="s0">// imported through different namespace reexports gracefully</span>
            <span class="s1">copyNameToModulesMap(searchedNamesAndModules))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule || indirectExternal) {</span>
                <span class="s1">foundExternalDeclarations.add(variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s2">if </span><span class="s1">(!foundSyntheticDeclaration) {</span>
                    <span class="s1">foundSyntheticDeclaration = variable</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(variable) {</span>
                <span class="s1">foundInternalDeclarations.set(variable</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(foundInternalDeclarations.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">foundDeclarationList = [...foundInternalDeclarations]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">usedDeclaration = foundDeclarationList[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(foundDeclarationList.length === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">[usedDeclaration]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.options.onwarn(errorNamespaceConflict(name</span><span class="s2">, this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">foundDeclarationList.map(([</span><span class="s2">, </span><span class="s1">module]) =&gt; module.id)))</span><span class="s2">;</span>
            <span class="s0">// TODO we are pretending it was not found while it should behave like &quot;undefined&quot;</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s2">null</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(foundExternalDeclarations.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">foundDeclarationList = [...foundExternalDeclarations]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">usedDeclaration = foundDeclarationList[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(foundDeclarationList.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.options.onwarn(errorAmbiguousExternalNamespaces(name</span><span class="s2">, this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">usedDeclaration.module.id</span><span class="s2">, </span><span class="s1">foundDeclarationList.map(declaration =&gt; declaration.module.id)))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[usedDeclaration</span><span class="s2">, true</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(foundSyntheticDeclaration) {</span>
            <span class="s2">return </span><span class="s1">[foundSyntheticDeclaration]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s2">null</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeAndGetAdditionalMergedNamespaces() {</span>
        <span class="s2">const </span><span class="s1">externalNamespaces = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">syntheticNamespaces = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of [</span><span class="s2">this, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.exportAllModules]) {</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                <span class="s2">const </span><span class="s1">[externalVariable] = module.getVariableForExportName(</span><span class="s3">'*'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">externalVariable.include()</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.includedImports.add(externalVariable)</span><span class="s2">;</span>
                <span class="s1">externalNamespaces.add(externalVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(module.info.syntheticNamedExports) {</span>
                <span class="s2">const </span><span class="s1">syntheticNamespace = module.getSyntheticNamespace()</span><span class="s2">;</span>
                <span class="s1">syntheticNamespace.include()</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.includedImports.add(syntheticNamespace)</span><span class="s2">;</span>
                <span class="s1">syntheticNamespaces.add(syntheticNamespace)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[...syntheticNamespaces</span><span class="s2">, </span><span class="s1">...externalNamespaces]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">includeDynamicImport(node) {</span>
        <span class="s2">const </span><span class="s1">resolution = </span><span class="s2">this</span><span class="s1">.dynamicImports.find(dynamicImport =&gt; dynamicImport.node === node).resolution</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(resolution </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
            <span class="s1">resolution.includedDynamicImporters.push(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">importedNames = </span><span class="s2">this</span><span class="s1">.options.treeshake</span>
                <span class="s1">? node.getDeterministicImportedNames()</span>
                <span class="s1">: undefined</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(importedNames) {</span>
                <span class="s1">resolution.includeExportsByNames(importedNames)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">resolution.includeAllExports(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeVariable(variable) {</span>
        <span class="s2">if </span><span class="s1">(!variable.included) {</span>
            <span class="s1">variable.include()</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.graph.needsTreeshakingPass = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">variableModule = variable.module</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variableModule </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                <span class="s2">if </span><span class="s1">(!variableModule.isExecuted) {</span>
                    <span class="s1">markModuleAndImpureDependenciesAsExecuted(variableModule)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(variableModule !== </span><span class="s2">this</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">sideEffectModules = getAndExtendSideEffectModules(variable</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of sideEffectModules) {</span>
                        <span class="s2">if </span><span class="s1">(!module.isExecuted) {</span>
                            <span class="s1">markModuleAndImpureDependenciesAsExecuted(module)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeVariableInModule(variable) {</span>
        <span class="s2">this</span><span class="s1">.includeVariable(variable)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">variableModule = variable.module</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variableModule &amp;&amp; variableModule !== </span><span class="s2">this</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.includedImports.add(variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">shimMissingExport(name) {</span>
        <span class="s2">this</span><span class="s1">.options.onwarn(errorShimmedExport(</span><span class="s2">this</span><span class="s1">.id</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exports.set(name</span><span class="s2">, </span><span class="s1">MISSING_EXPORT_SHIM_DESCRIPTION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">tryParse() {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">return this</span><span class="s1">.graph.contextParse(</span><span class="s2">this</span><span class="s1">.info.code)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(error_) {</span>
            <span class="s2">return this</span><span class="s1">.error(errorParseError(error_</span><span class="s2">, this</span><span class="s1">.id)</span><span class="s2">, </span><span class="s1">error_.pos)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// if there is a cyclic import in the reexport chain, we should not</span>
<span class="s0">// import from the original module but from the cyclic module to not</span>
<span class="s0">// mess up execution order.</span>
<span class="s2">function </span><span class="s1">setAlternativeExporterIfCyclic(variable</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">reexporter) {</span>
    <span class="s2">if </span><span class="s1">(variable.module </span><span class="s2">instanceof </span><span class="s1">Module &amp;&amp; variable.module !== reexporter) {</span>
        <span class="s2">const </span><span class="s1">exporterCycles = variable.module.cycles</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exporterCycles.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">importerCycles = reexporter.cycles</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cycleSymbol of importerCycles) {</span>
                <span class="s2">if </span><span class="s1">(exporterCycles.has(cycleSymbol)) {</span>
                    <span class="s1">importer.alternativeReexportModules.set(variable</span><span class="s2">, </span><span class="s1">reexporter)</span><span class="s2">;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">copyNameToModulesMap = (searchedNamesAndModules) =&gt; searchedNamesAndModules &amp;&amp;</span>
    <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
    <span class="s2">new </span><span class="s1">Map(Array.from(searchedNamesAndModules</span><span class="s2">, </span><span class="s1">([name</span><span class="s2">, </span><span class="s1">modules]) =&gt; [name</span><span class="s2">, new </span><span class="s1">Set(modules)]))</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">removeJsExtension(name) {</span>
    <span class="s2">return </span><span class="s1">name.endsWith(</span><span class="s3">'.js'</span><span class="s1">) ? name.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">) : name</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getCompleteAmdId(options</span><span class="s2">, </span><span class="s1">chunkId) {</span>
    <span class="s2">if </span><span class="s1">(options.autoId) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${options.basePath ? options.basePath + </span><span class="s3">'/' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}${removeJsExtension(chunkId)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">options.id ?? </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getExportBlock$1(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">mechanism = </span><span class="s3">'return '</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">getFunctionIntro</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } = snippets</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!namedExportsMode) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${n}${n}${mechanism}${getSingleDefaultExport(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">getPropertyAccess)}</span><span class="s3">;`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">exportBlock = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ defaultVariableName</span><span class="s2">, </span><span class="s1">importPath</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namedExportsMode: depNamedExportsMode</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">reexports } of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(reexports &amp;&amp; namedExportsMode) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of reexports) {</span>
                <span class="s2">if </span><span class="s1">(specifier.reexported !== </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">importName = getReexportedImportName(name</span><span class="s2">, </span><span class="s1">specifier.imported</span><span class="s2">, </span><span class="s1">depNamedExportsMode</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">defaultVariableName</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">importPath</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">getPropertyAccess)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(exportBlock)</span>
                        <span class="s1">exportBlock += n</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(specifier.imported !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; specifier.needsLiveBinding) {</span>
                        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
                            <span class="s1">functionReturn: </span><span class="s2">true,</span>
                            <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                            <span class="s1">name: </span><span class="s2">null</span>
                        <span class="s1">})</span><span class="s2">;</span>
                        <span class="s1">exportBlock +=</span>
                            <span class="s3">`Object.defineProperty(exports,</span><span class="s1">${_}</span><span class="s3">'</span><span class="s1">${specifier.reexported}</span><span class="s3">',</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                                <span class="s3">`</span><span class="s1">${t}</span><span class="s3">enumerable:</span><span class="s1">${_}</span><span class="s3">true,</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                                <span class="s3">`</span><span class="s1">${t}</span><span class="s3">get:</span><span class="s1">${_}${left}${importName}${right}${n}</span><span class="s3">});`</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">exportBlock += </span><span class="s3">`exports</span><span class="s1">${getPropertyAccess(specifier.reexported)}${_}</span><span class="s3">=</span><span class="s1">${_}${importName}</span><span class="s3">;`</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ exported</span><span class="s2">, </span><span class="s1">local } of exports) {</span>
        <span class="s2">const </span><span class="s1">lhs = </span><span class="s3">`exports</span><span class="s1">${getPropertyAccess(exported)}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">rhs = local</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(lhs !== rhs) {</span>
            <span class="s2">if </span><span class="s1">(exportBlock)</span>
                <span class="s1">exportBlock += n</span><span class="s2">;</span>
            <span class="s1">exportBlock += </span><span class="s3">`</span><span class="s1">${lhs}${_}</span><span class="s3">=</span><span class="s1">${_}${rhs}</span><span class="s3">;`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ name</span><span class="s2">, </span><span class="s1">reexports } of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(reexports &amp;&amp; namedExportsMode) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of reexports) {</span>
                <span class="s2">if </span><span class="s1">(specifier.reexported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(exportBlock)</span>
                        <span class="s1">exportBlock += n</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">copyPropertyIfNecessary = </span><span class="s3">`{</span><span class="s1">${n}${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(k</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'default'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">!exports.hasOwnProperty(k))</span><span class="s1">${_}${getDefineProperty(name</span><span class="s2">, </span><span class="s1">specifier.needsLiveBinding</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)}${s}${n}</span><span class="s3">}`</span><span class="s2">;</span>
                    <span class="s1">exportBlock += </span><span class="s3">`Object.keys(</span><span class="s1">${name}</span><span class="s3">).forEach(</span><span class="s1">${getFunctionIntro([</span><span class="s3">'k'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">isAsync: </span><span class="s2">false,</span>
                        <span class="s1">name: </span><span class="s2">null</span>
                    <span class="s1">})}${copyPropertyIfNecessary}</span><span class="s3">);`</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(exportBlock) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${n}${n}${exportBlock}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSingleDefaultExport(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">getPropertyAccess) {</span>
    <span class="s2">if </span><span class="s1">(exports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">exports[</span><span class="s4">0</span><span class="s1">].local</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ defaultVariableName</span><span class="s2">, </span><span class="s1">importPath</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namedExportsMode: depNamedExportsMode</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">reexports } of dependencies) {</span>
            <span class="s2">if </span><span class="s1">(reexports) {</span>
                <span class="s2">return </span><span class="s1">getReexportedImportName(name</span><span class="s2">, </span><span class="s1">reexports[</span><span class="s4">0</span><span class="s1">].imported</span><span class="s2">, </span><span class="s1">depNamedExportsMode</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">defaultVariableName</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">importPath</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">getPropertyAccess)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getReexportedImportName(moduleVariableName</span><span class="s2">, </span><span class="s1">imported</span><span class="s2">, </span><span class="s1">depNamedExportsMode</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">defaultVariableName</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">moduleId</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">getPropertyAccess) {</span>
    <span class="s2">if </span><span class="s1">(imported === </span><span class="s3">'default'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!isChunk) {</span>
            <span class="s2">const </span><span class="s1">moduleInterop = interop(moduleId)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">variableName = defaultInteropHelpersByInteropType[moduleInterop]</span>
                <span class="s1">? defaultVariableName</span>
                <span class="s1">: moduleVariableName</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">isDefaultAProperty(moduleInterop</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span>
                <span class="s1">? </span><span class="s3">`</span><span class="s1">${variableName}${getPropertyAccess(</span><span class="s3">'default'</span><span class="s1">)}</span><span class="s3">`</span>
                <span class="s1">: variableName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">depNamedExportsMode</span>
            <span class="s1">? </span><span class="s3">`</span><span class="s1">${moduleVariableName}${getPropertyAccess(</span><span class="s3">'default'</span><span class="s1">)}</span><span class="s3">`</span>
            <span class="s1">: moduleVariableName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(imported === </span><span class="s3">'*'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(isChunk ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[interop(moduleId)])</span>
            <span class="s1">? namespaceVariableName</span>
            <span class="s1">: moduleVariableName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">`</span><span class="s1">${moduleVariableName}${getPropertyAccess(imported)}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getEsModuleValue(getObject) {</span>
    <span class="s2">return </span><span class="s1">getObject([[</span><span class="s3">'value'</span><span class="s2">, </span><span class="s3">'true'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">lineBreakIndent: </span><span class="s2">null</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNamespaceMarkers(hasNamedExports</span><span class="s2">, </span><span class="s1">addEsModule</span><span class="s2">, </span><span class="s1">addNamespaceToStringTag</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getObject }) {</span>
    <span class="s2">if </span><span class="s1">(hasNamedExports) {</span>
        <span class="s2">if </span><span class="s1">(addEsModule) {</span>
            <span class="s2">if </span><span class="s1">(addNamespaceToStringTag) {</span>
                <span class="s2">return </span><span class="s3">`Object.defineProperties(exports,</span><span class="s1">${_}${getObject([</span>
                    <span class="s1">[</span><span class="s3">'__esModule'</span><span class="s2">, </span><span class="s1">getEsModuleValue(getObject)]</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s2">null, </span><span class="s3">`[Symbol.toStringTag]:</span><span class="s1">${_}${getToStringTagValue(getObject)}</span><span class="s3">`</span><span class="s1">]</span>
                <span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">lineBreakIndent: </span><span class="s2">null</span>
                <span class="s1">})}</span><span class="s3">);`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s3">`Object.defineProperty(exports,</span><span class="s1">${_}</span><span class="s3">'__esModule',</span><span class="s1">${_}${getEsModuleValue(getObject)}</span><span class="s3">);`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(addNamespaceToStringTag) {</span>
            <span class="s2">return </span><span class="s3">`Object.defineProperty(exports,</span><span class="s1">${_}</span><span class="s3">Symbol.toStringTag,</span><span class="s1">${_}${getToStringTagValue(getObject)}</span><span class="s3">);`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getDefineProperty = (name</span><span class="s2">, </span><span class="s1">needsLiveBinding</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getDirectReturnFunction</span><span class="s2">, </span><span class="s1">n }) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(needsLiveBinding) {</span>
        <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction([]</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">functionReturn: </span><span class="s2">true,</span>
            <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
            <span class="s1">name: </span><span class="s2">null</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">`Object.defineProperty(exports,</span><span class="s1">${_}</span><span class="s3">k,</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">enumerable:</span><span class="s1">${_}</span><span class="s3">true,</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">get:</span><span class="s1">${_}${left}${name}</span><span class="s3">[k]</span><span class="s1">${right}${n}${t}</span><span class="s3">})`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">`exports[k]</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${name}</span><span class="s3">[k]`</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getInteropBlock(dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">snippets) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">neededInteropHelpers = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">interopStatements = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">addInteropStatement = (helperVariableName</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">dependencyVariableName) =&gt; {</span>
        <span class="s1">neededInteropHelpers.add(helper)</span><span class="s2">;</span>
        <span class="s1">interopStatements.push(</span><span class="s3">`</span><span class="s1">${cnst} ${helperVariableName}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">/*#__PURE__*/</span><span class="s1">${helper}</span><span class="s3">(</span><span class="s1">${dependencyVariableName}</span><span class="s3">);`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ defaultVariableName</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">importPath</span><span class="s2">, </span><span class="s1">isChunk</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">namespaceVariableName</span><span class="s2">, </span><span class="s1">reexports } of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(isChunk) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imported</span><span class="s2">, </span><span class="s1">reexported } of [</span>
                <span class="s1">...(imports || [])</span><span class="s2">,</span>
                <span class="s1">...(reexports || [])</span>
            <span class="s1">]) {</span>
                <span class="s2">if </span><span class="s1">(imported === </span><span class="s3">'*' </span><span class="s1">&amp;&amp; reexported !== </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!namedExportsMode) {</span>
                        <span class="s1">addInteropStatement(namespaceVariableName</span><span class="s2">, </span><span class="s1">INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">moduleInterop = interop(importPath)</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hasDefault = </span><span class="s2">false;</span>
            <span class="s2">let </span><span class="s1">hasNamespace = </span><span class="s2">false;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imported</span><span class="s2">, </span><span class="s1">reexported } of [</span>
                <span class="s1">...(imports || [])</span><span class="s2">,</span>
                <span class="s1">...(reexports || [])</span>
            <span class="s1">]) {</span>
                <span class="s2">let </span><span class="s1">helper</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">variableName</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(imported === </span><span class="s3">'default'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!hasDefault) {</span>
                        <span class="s1">hasDefault = </span><span class="s2">true;</span>
                        <span class="s2">if </span><span class="s1">(defaultVariableName !== namespaceVariableName) {</span>
                            <span class="s1">variableName = defaultVariableName</span><span class="s2">;</span>
                            <span class="s1">helper = defaultInteropHelpersByInteropType[moduleInterop]</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(imported === </span><span class="s3">'*' </span><span class="s1">&amp;&amp; reexported !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; !hasNamespace) {</span>
                    <span class="s1">hasNamespace = </span><span class="s2">true;</span>
                    <span class="s1">helper = namespaceInteropHelpersByInteropType[moduleInterop]</span><span class="s2">;</span>
                    <span class="s1">variableName = namespaceVariableName</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(helper) {</span>
                    <span class="s1">addInteropStatement(variableName</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">`</span><span class="s1">${getHelpersBlock(neededInteropHelpers</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag)}${interopStatements.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`</span><span class="s1">${interopStatements.join(n)}${n}${n}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">addJsExtension(name) {</span>
    <span class="s2">return </span><span class="s1">name.endsWith(</span><span class="s3">'.js'</span><span class="s1">) ? name : name + </span><span class="s3">'.js'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.</span>
<span class="s0">// The assumption is that this makes sense for all relative ids:</span>
<span class="s0">// https://requirejs.org/docs/api.html#jsfiles</span>
<span class="s2">function </span><span class="s1">updateExtensionForRelativeAmdId(id</span><span class="s2">, </span><span class="s1">forceJsExtensionForImports) {</span>
    <span class="s2">if </span><span class="s1">(id[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'.'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">id</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">forceJsExtensionForImports ? addJsExtension(id) : removeJsExtension(id)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">_staticExports = {}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">_static = {</span>
  <span class="s1">get exports(){ </span><span class="s2">return </span><span class="s1">_staticExports</span><span class="s2">; </span><span class="s1">}</span><span class="s2">,</span>
  <span class="s1">set exports(v){ _staticExports = v</span><span class="s2">; </span><span class="s1">}</span><span class="s2">,</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">require$$0 = [</span>
	<span class="s3">&quot;assert&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;async_hooks&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;buffer&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;child_process&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;cluster&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;console&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;constants&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;crypto&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;dgram&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;diagnostics_channel&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;dns&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;domain&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;events&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;fs&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;http&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;http2&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;https&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;inspector&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;module&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;net&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;os&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;path&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;perf_hooks&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;process&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;punycode&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;querystring&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;readline&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;repl&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;stream&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;string_decoder&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;timers&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;tls&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;trace_events&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;tty&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;url&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;util&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;v8&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;vm&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;wasi&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;worker_threads&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;zlib&quot;</span>
<span class="s1">]</span><span class="s2">;</span>

<span class="s1">(</span><span class="s2">function </span><span class="s1">(module) {</span>
	<span class="s1">module.exports = require$$0</span><span class="s2">;</span>
<span class="s1">} (_static))</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">builtinModules = </span><span class="s0">/*@__PURE__*/</span><span class="s1">getDefaultExportFromCjs(_staticExports)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">nodeBuiltins = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">...builtinModules</span><span class="s2">,</span>
    <span class="s0">// TODO</span>
    <span class="s0">// remove once builtin-modules includes PR: https://github.com/sindresorhus/builtin-modules/pull/17</span>
    <span class="s3">'assert/strict'</span><span class="s2">,</span>
    <span class="s3">'dns/promises'</span><span class="s2">,</span>
    <span class="s3">'fs/promises'</span><span class="s2">,</span>
    <span class="s3">'path/posix'</span><span class="s2">,</span>
    <span class="s3">'path/win32'</span><span class="s2">,</span>
    <span class="s3">'readline/promises'</span><span class="s2">,</span>
    <span class="s3">'stream/consumers'</span><span class="s2">,</span>
    <span class="s3">'stream/promises'</span><span class="s2">,</span>
    <span class="s3">'stream/web'</span><span class="s2">,</span>
    <span class="s3">'timers/promises'</span><span class="s2">,</span>
    <span class="s3">'util/types'</span>
<span class="s1">])</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">warnOnBuiltins(warn</span><span class="s2">, </span><span class="s1">dependencies) {</span>
    <span class="s2">const </span><span class="s1">externalBuiltins = dependencies</span>
        <span class="s1">.map(({ importPath }) =&gt; importPath)</span>
        <span class="s1">.filter(importPath =&gt; nodeBuiltins.has(importPath) || importPath.startsWith(</span><span class="s3">'node:'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(externalBuiltins.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return;</span>
    <span class="s1">warn(errorMissingNodeBuiltins(externalBuiltins))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">amd(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">hasDefaultExport</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">isEntryFacade</span><span class="s2">, </span><span class="s1">isModuleFacade</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">onwarn }</span><span class="s2">, </span><span class="s1">{ amd</span><span class="s2">, </span><span class="s1">esModule</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">strict }) {</span>
    <span class="s1">warnOnBuiltins(onwarn</span><span class="s2">, </span><span class="s1">dependencies)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">deps = dependencies.map(m =&gt; </span><span class="s3">`'</span><span class="s1">${updateExtensionForRelativeAmdId(m.importPath</span><span class="s2">, </span><span class="s1">amd.forceJsExtensionForImports)}</span><span class="s3">'`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">parameters = dependencies.map(m =&gt; m.name)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ n</span><span class="s2">, </span><span class="s1">getNonArrowFunctionIntro</span><span class="s2">, </span><span class="s1">_ } = snippets</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namedExportsMode &amp;&amp; hasExports) {</span>
        <span class="s1">parameters.unshift(</span><span class="s3">`exports`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">deps.unshift(</span><span class="s3">`'exports'`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(accessedGlobals.has(</span><span class="s3">'require'</span><span class="s1">)) {</span>
        <span class="s1">parameters.unshift(</span><span class="s3">'require'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">deps.unshift(</span><span class="s3">`'require'`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(accessedGlobals.has(</span><span class="s3">'module'</span><span class="s1">)) {</span>
        <span class="s1">parameters.unshift(</span><span class="s3">'module'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">deps.unshift(</span><span class="s3">`'module'`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">completeAmdId = getCompleteAmdId(amd</span><span class="s2">, </span><span class="s1">id)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">defineParameters = (completeAmdId ? </span><span class="s3">`'</span><span class="s1">${completeAmdId}</span><span class="s3">',</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">) +</span>
        <span class="s1">(deps.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`[</span><span class="s1">${deps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">],</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">useStrict = strict ? </span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">'use strict';` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s1">magicString.prepend(</span><span class="s3">`</span><span class="s1">${intro}${getInteropBlock(dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exportBlock = getExportBlock$1(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">namespaceMarkers = getNamespaceMarkers(namedExportsMode &amp;&amp; hasExports</span><span class="s2">, </span><span class="s1">isEntryFacade &amp;&amp; (esModule === </span><span class="s2">true </span><span class="s1">|| (esModule === </span><span class="s3">'if-default-prop' </span><span class="s1">&amp;&amp; hasDefaultExport))</span><span class="s2">, </span><span class="s1">isModuleFacade &amp;&amp; namespaceToStringTag</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namespaceMarkers) {</span>
        <span class="s1">namespaceMarkers = n + n + namespaceMarkers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">magicString</span>
        <span class="s1">.append(</span><span class="s3">`</span><span class="s1">${exportBlock}${namespaceMarkers}${outro}</span><span class="s3">`</span><span class="s1">)</span>
        <span class="s1">.indent(t)</span>
        <span class="s0">// factory function should be wrapped by parentheses to avoid lazy parsing,</span>
        <span class="s0">// cf. https://v8.dev/blog/preparser#pife</span>
        <span class="s1">.prepend(</span><span class="s3">`</span><span class="s1">${amd.define}</span><span class="s3">(</span><span class="s1">${defineParameters}</span><span class="s3">(</span><span class="s1">${getNonArrowFunctionIntro(parameters</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">isAsync: </span><span class="s2">false,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})}</span><span class="s3">{</span><span class="s1">${useStrict}${n}${n}</span><span class="s3">`</span><span class="s1">)</span>
        <span class="s1">.append(</span><span class="s3">`</span><span class="s1">${n}${n}</span><span class="s3">}));`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">cjs(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">hasDefaultExport</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">isEntryFacade</span><span class="s2">, </span><span class="s1">isModuleFacade</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">snippets }</span><span class="s2">, </span><span class="s1">{ compact</span><span class="s2">, </span><span class="s1">esModule</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">strict }) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">useStrict = strict ? </span><span class="s3">`'use strict';</span><span class="s1">${n}${n}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">namespaceMarkers = getNamespaceMarkers(namedExportsMode &amp;&amp; hasExports</span><span class="s2">, </span><span class="s1">isEntryFacade &amp;&amp; (esModule === </span><span class="s2">true </span><span class="s1">|| (esModule === </span><span class="s3">'if-default-prop' </span><span class="s1">&amp;&amp; hasDefaultExport))</span><span class="s2">, </span><span class="s1">isModuleFacade &amp;&amp; namespaceToStringTag</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namespaceMarkers) {</span>
        <span class="s1">namespaceMarkers += n + n</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">importBlock = getImportBlock$1(dependencies</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">compact)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">interopBlock = getInteropBlock(dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s1">magicString.prepend(</span><span class="s3">`</span><span class="s1">${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exportBlock = getExportBlock$1(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s3">`module.exports</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">magicString.append(</span><span class="s3">`</span><span class="s1">${exportBlock}${outro}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getImportBlock$1(dependencies</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">n }</span><span class="s2">, </span><span class="s1">compact) {</span>
    <span class="s2">let </span><span class="s1">importBlock = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">definingVariable = </span><span class="s2">false;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ importPath</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">reexports</span><span class="s2">, </span><span class="s1">imports } of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(!reexports &amp;&amp; !imports) {</span>
            <span class="s2">if </span><span class="s1">(importBlock) {</span>
                <span class="s1">importBlock += compact &amp;&amp; !definingVariable ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">`;</span><span class="s1">${n}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">definingVariable = </span><span class="s2">false;</span>
            <span class="s1">importBlock += </span><span class="s3">`require('</span><span class="s1">${importPath}</span><span class="s3">')`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">importBlock += compact &amp;&amp; definingVariable ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">`</span><span class="s1">${importBlock ? </span><span class="s3">`;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}${cnst} </span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">definingVariable = </span><span class="s2">true;</span>
            <span class="s1">importBlock += </span><span class="s3">`</span><span class="s1">${name}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">require('</span><span class="s1">${importPath}</span><span class="s3">')`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(importBlock) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${importBlock}</span><span class="s3">;</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">es(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">snippets }</span><span class="s2">, </span><span class="s1">{ externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag }) {</span>
    <span class="s2">const </span><span class="s1">{ n } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">importBlock = getImportBlock(dependencies</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(importBlock.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">intro += importBlock.join(n) + n + n</span><span class="s2">;</span>
    <span class="s1">intro += getHelpersBlock(</span><span class="s2">null, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(intro)</span>
        <span class="s1">magicString.prepend(intro)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exportBlock = getExportBlock(exports</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(exportBlock.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">magicString.append(n + n + exportBlock.join(n).trim())</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(outro)</span>
        <span class="s1">magicString.append(outro)</span><span class="s2">;</span>
    <span class="s1">magicString.trim()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getImportBlock(dependencies</span><span class="s2">, </span><span class="s1">{ _ }) {</span>
    <span class="s2">const </span><span class="s1">importBlock = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ importPath</span><span class="s2">, </span><span class="s1">reexports</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">assertions } of dependencies) {</span>
        <span class="s2">const </span><span class="s1">assertion = assertions ? </span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">assert</span><span class="s1">${_}${assertions}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">pathWithAssertion = </span><span class="s3">`'</span><span class="s1">${importPath}</span><span class="s3">'</span><span class="s1">${assertion}</span><span class="s3">;`</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!reexports &amp;&amp; !imports) {</span>
            <span class="s1">importBlock.push(</span><span class="s3">`import</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(imports) {</span>
            <span class="s2">let </span><span class="s1">defaultImport = </span><span class="s2">null;</span>
            <span class="s2">let </span><span class="s1">starImport = </span><span class="s2">null;</span>
            <span class="s2">const </span><span class="s1">importedNames = []</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of imports) {</span>
                <span class="s2">if </span><span class="s1">(specifier.imported === </span><span class="s3">'default'</span><span class="s1">) {</span>
                    <span class="s1">defaultImport = specifier</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(specifier.imported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s1">starImport = specifier</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">importedNames.push(specifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(starImport) {</span>
                <span class="s1">importBlock.push(</span><span class="s3">`import</span><span class="s1">${_}</span><span class="s3">*</span><span class="s1">${_}</span><span class="s3">as </span><span class="s1">${starImport.local} </span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(defaultImport &amp;&amp; importedNames.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">importBlock.push(</span><span class="s3">`import </span><span class="s1">${defaultImport.local} </span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(importedNames.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">importBlock.push(</span><span class="s3">`import </span><span class="s1">${defaultImport ? </span><span class="s3">`</span><span class="s1">${defaultImport.local}</span><span class="s3">,</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">{</span><span class="s1">${_}${importedNames</span>
                    <span class="s1">.map(specifier =&gt; specifier.imported === specifier.local</span>
                    <span class="s1">? specifier.imported</span>
                    <span class="s1">: </span><span class="s3">`</span><span class="s1">${specifier.imported} </span><span class="s3">as </span><span class="s1">${specifier.local}</span><span class="s3">`</span><span class="s1">)</span>
                    <span class="s1">.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}${_}</span><span class="s3">}</span><span class="s1">${_}</span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(reexports) {</span>
            <span class="s2">let </span><span class="s1">starExport = </span><span class="s2">null;</span>
            <span class="s2">const </span><span class="s1">namespaceReexports = []</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">namedReexports = []</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of reexports) {</span>
                <span class="s2">if </span><span class="s1">(specifier.reexported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s1">starExport = specifier</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(specifier.imported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s1">namespaceReexports.push(specifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">namedReexports.push(specifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(starExport) {</span>
                <span class="s1">importBlock.push(</span><span class="s3">`export</span><span class="s1">${_}</span><span class="s3">*</span><span class="s1">${_}</span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(namespaceReexports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!imports ||</span>
                    <span class="s1">!imports.some(specifier =&gt; specifier.imported === </span><span class="s3">'*' </span><span class="s1">&amp;&amp; specifier.local === name)) {</span>
                    <span class="s1">importBlock.push(</span><span class="s3">`import</span><span class="s1">${_}</span><span class="s3">*</span><span class="s1">${_}</span><span class="s3">as </span><span class="s1">${name} </span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of namespaceReexports) {</span>
                    <span class="s1">importBlock.push(</span><span class="s3">`export</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}${name === specifier.reexported ? name : </span><span class="s3">`</span><span class="s1">${name} </span><span class="s3">as </span><span class="s1">${specifier.reexported}</span><span class="s3">`</span><span class="s1">} </span><span class="s3">};`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(namedReexports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">importBlock.push(</span><span class="s3">`export</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}${namedReexports</span>
                    <span class="s1">.map(specifier =&gt; specifier.imported === specifier.reexported</span>
                    <span class="s1">? specifier.imported</span>
                    <span class="s1">: </span><span class="s3">`</span><span class="s1">${specifier.imported} </span><span class="s3">as </span><span class="s1">${specifier.reexported}</span><span class="s3">`</span><span class="s1">)</span>
                    <span class="s1">.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}${_}</span><span class="s3">}</span><span class="s1">${_}</span><span class="s3">from</span><span class="s1">${_}${pathWithAssertion}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">importBlock</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExportBlock(exports</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst }) {</span>
    <span class="s2">const </span><span class="s1">exportBlock = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exportDeclaration = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of exports) {</span>
        <span class="s2">if </span><span class="s1">(specifier.expression) {</span>
            <span class="s1">exportBlock.push(</span><span class="s3">`</span><span class="s1">${cnst} ${specifier.local}${_}</span><span class="s3">=</span><span class="s1">${_}${specifier.expression}</span><span class="s3">;`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">exportDeclaration.push(specifier.exported === specifier.local</span>
            <span class="s1">? specifier.local</span>
            <span class="s1">: </span><span class="s3">`</span><span class="s1">${specifier.local} </span><span class="s3">as </span><span class="s1">${specifier.exported}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(exportDeclaration.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">exportBlock.push(</span><span class="s3">`export</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${_}${exportDeclaration.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}${_}</span><span class="s3">};`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">exportBlock</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">keypath = (keypath</span><span class="s2">, </span><span class="s1">getPropertyAccess) =&gt; keypath.split(</span><span class="s3">'.'</span><span class="s1">).map(getPropertyAccess).join(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">setupNamespace(name</span><span class="s2">, </span><span class="s1">root</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">s }</span><span class="s2">, </span><span class="s1">compact) {</span>
    <span class="s2">const </span><span class="s1">parts = name.split(</span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">parts[</span><span class="s4">0</span><span class="s1">] = (</span><span class="s2">typeof </span><span class="s1">globals === </span><span class="s3">'function' </span><span class="s1">? globals(parts[</span><span class="s4">0</span><span class="s1">]) : globals[parts[</span><span class="s4">0</span><span class="s1">]]) || parts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">parts.pop()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">propertyPath = root</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(parts</span>
        <span class="s1">.map(part =&gt; {</span>
        <span class="s1">propertyPath += getPropertyAccess(part)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${propertyPath}${_}</span><span class="s3">=</span><span class="s1">${_}${propertyPath}${_}</span><span class="s3">||</span><span class="s1">${_}</span><span class="s3">{}</span><span class="s1">${s}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">})</span>
        <span class="s1">.join(compact ? </span><span class="s3">',' </span><span class="s1">: </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) + (compact &amp;&amp; parts.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">';' </span><span class="s1">: </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assignToDeepVariable(deepName</span><span class="s2">, </span><span class="s1">root</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">assignment</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getPropertyAccess }) {</span>
    <span class="s2">const </span><span class="s1">parts = deepName.split(</span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">parts[</span><span class="s4">0</span><span class="s1">] = (</span><span class="s2">typeof </span><span class="s1">globals === </span><span class="s3">'function' </span><span class="s1">? globals(parts[</span><span class="s4">0</span><span class="s1">]) : globals[parts[</span><span class="s4">0</span><span class="s1">]]) || parts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">last = parts.pop()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">propertyPath = root</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">deepAssignment = [</span>
        <span class="s1">...parts.map(part =&gt; {</span>
            <span class="s1">propertyPath += getPropertyAccess(part)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${propertyPath}${_}</span><span class="s3">=</span><span class="s1">${_}${propertyPath}${_}</span><span class="s3">||</span><span class="s1">${_}</span><span class="s3">{}`</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">,</span>
        <span class="s3">`</span><span class="s1">${propertyPath}${getPropertyAccess(last)}</span><span class="s3">`</span>
    <span class="s1">].join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">) + </span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${assignment}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parts.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">deepAssignment = </span><span class="s3">`(</span><span class="s1">${deepAssignment}</span><span class="s3">)`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">deepAssignment</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">trimEmptyImports(dependencies) {</span>
    <span class="s2">let </span><span class="s1">index = dependencies.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(index--) {</span>
        <span class="s2">const </span><span class="s1">{ imports</span><span class="s2">, </span><span class="s1">reexports } = dependencies[index]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(imports || reexports) {</span>
            <span class="s2">return </span><span class="s1">dependencies.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">index + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">iife(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">hasDefaultExport</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">onwarn }</span><span class="s2">, </span><span class="s1">{ compact</span><span class="s2">, </span><span class="s1">esModule</span><span class="s2">, </span><span class="s1">extend</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">strict }) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getNonArrowFunctionIntro</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isNamespaced = name &amp;&amp; name.includes(</span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">useVariableAssignment = !extend &amp;&amp; !isNamespaced</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(name &amp;&amp; useVariableAssignment &amp;&amp; !isLegal(name)) {</span>
        <span class="s2">return </span><span class="s1">error(errorIllegalIdentifierAsName(name))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">warnOnBuiltins(onwarn</span><span class="s2">, </span><span class="s1">dependencies)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">external = trimEmptyImports(dependencies)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">deps = external.map(dep =&gt; dep.globalName || </span><span class="s3">'null'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">parameters = external.map(m =&gt; m.name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasExports &amp;&amp; !name) {</span>
        <span class="s1">onwarn(errorMissingNameOptionForIifeExport())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(namedExportsMode &amp;&amp; hasExports) {</span>
        <span class="s2">if </span><span class="s1">(extend) {</span>
            <span class="s1">deps.unshift(</span><span class="s3">`this</span><span class="s1">${keypath(name</span><span class="s2">, </span><span class="s1">getPropertyAccess)}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">this</span><span class="s1">${keypath(name</span><span class="s2">, </span><span class="s1">getPropertyAccess)}${_}</span><span class="s3">||</span><span class="s1">${_}</span><span class="s3">{}`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">parameters.unshift(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">deps.unshift(</span><span class="s3">'{}'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">parameters.unshift(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">useStrict = strict ? </span><span class="s3">`</span><span class="s1">${t}</span><span class="s3">'use strict';</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">interopBlock = getInteropBlock(dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s1">magicString.prepend(</span><span class="s3">`</span><span class="s1">${intro}${interopBlock}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">wrapperIntro = </span><span class="s3">`(</span><span class="s1">${getNonArrowFunctionIntro(parameters</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">isAsync: </span><span class="s2">false,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}${useStrict}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasExports) {</span>
        <span class="s2">if </span><span class="s1">(name &amp;&amp; !(extend &amp;&amp; namedExportsMode)) {</span>
            <span class="s1">wrapperIntro =</span>
                <span class="s1">(useVariableAssignment ? </span><span class="s3">`var </span><span class="s1">${name}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">`this</span><span class="s1">${keypath(name</span><span class="s2">, </span><span class="s1">getPropertyAccess)}</span><span class="s3">`</span><span class="s1">) +</span>
                    <span class="s3">`</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${wrapperIntro}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isNamespaced) {</span>
            <span class="s1">wrapperIntro = setupNamespace(name</span><span class="s2">, </span><span class="s3">'this'</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">compact) + wrapperIntro</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">wrapperOutro = </span><span class="s3">`</span><span class="s1">${n}${n}</span><span class="s3">})(</span><span class="s1">${deps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">);`</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasExports &amp;&amp; !extend &amp;&amp; namedExportsMode) {</span>
        <span class="s1">wrapperOutro = </span><span class="s3">`</span><span class="s1">${n}${n}${t}</span><span class="s3">return exports;</span><span class="s1">${wrapperOutro}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">exportBlock = getExportBlock$1(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">namespaceMarkers = getNamespaceMarkers(namedExportsMode &amp;&amp; hasExports</span><span class="s2">, </span><span class="s1">esModule === </span><span class="s2">true </span><span class="s1">|| (esModule === </span><span class="s3">'if-default-prop' </span><span class="s1">&amp;&amp; hasDefaultExport)</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namespaceMarkers) {</span>
        <span class="s1">namespaceMarkers = n + n + namespaceMarkers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">magicString</span>
        <span class="s1">.append(</span><span class="s3">`</span><span class="s1">${exportBlock}${namespaceMarkers}${outro}</span><span class="s3">`</span><span class="s1">)</span>
        <span class="s1">.indent(t)</span>
        <span class="s1">.prepend(wrapperIntro)</span>
        <span class="s1">.append(wrapperOutro)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">system(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">usesTopLevelAwait }</span><span class="s2">, </span><span class="s1">{ externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">strict</span><span class="s2">, </span><span class="s1">systemNullSetters }) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getFunctionIntro</span><span class="s2">, </span><span class="s1">getNonArrowFunctionIntro</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ importBindings</span><span class="s2">, </span><span class="s1">setters</span><span class="s2">, </span><span class="s1">starExcludes } = analyzeDependencies(dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">registeredName = name ? </span><span class="s3">`'</span><span class="s1">${name}</span><span class="s3">',</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrapperParameters = accessedGlobals.has(</span><span class="s3">'module'</span><span class="s1">)</span>
        <span class="s1">? [</span><span class="s3">'exports'</span><span class="s2">, </span><span class="s3">'module'</span><span class="s1">]</span>
        <span class="s1">: hasExports</span>
            <span class="s1">? [</span><span class="s3">'exports'</span><span class="s1">]</span>
            <span class="s1">: []</span><span class="s2">;</span>
    <span class="s0">// factory function should be wrapped by parentheses to avoid lazy parsing,</span>
    <span class="s0">// cf. https://v8.dev/blog/preparser#pife</span>
    <span class="s2">let </span><span class="s1">wrapperStart = </span><span class="s3">`System.register(</span><span class="s1">${registeredName}</span><span class="s3">[` </span><span class="s1">+</span>
        <span class="s1">dependencies.map(({ importPath }) =&gt; </span><span class="s3">`'</span><span class="s1">${importPath}</span><span class="s3">'`</span><span class="s1">).join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">) +</span>
        <span class="s3">`],</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${getNonArrowFunctionIntro(wrapperParameters</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">isAsync: </span><span class="s2">false,</span>
            <span class="s1">name: </span><span class="s2">null</span>
        <span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}${t}${strict ? </span><span class="s3">&quot;'use strict';&quot; </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">getStarExcludesBlock(starExcludes</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) +</span>
        <span class="s1">getImportBindingsBlock(importBindings</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) +</span>
        <span class="s3">`</span><span class="s1">${n}${t}</span><span class="s3">return</span><span class="s1">${_}</span><span class="s3">{</span><span class="s1">${setters.length &gt; </span><span class="s4">0</span>
            <span class="s1">? </span><span class="s3">`</span><span class="s1">${n}${t}${t}</span><span class="s3">setters:</span><span class="s1">${_}</span><span class="s3">[</span><span class="s1">${setters</span>
                <span class="s1">.map(setter =&gt; setter</span>
                <span class="s1">? </span><span class="s3">`</span><span class="s1">${getFunctionIntro([</span><span class="s3">'module'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">isAsync: </span><span class="s2">false,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}${t}${t}${t}${setter}${n}${t}${t}</span><span class="s3">}`</span>
                <span class="s1">: systemNullSetters</span>
                    <span class="s1">? </span><span class="s3">`null`</span>
                    <span class="s1">: </span><span class="s3">`</span><span class="s1">${getFunctionIntro([]</span><span class="s2">, </span><span class="s1">{ isAsync: </span><span class="s2">false, </span><span class="s1">name: </span><span class="s2">null </span><span class="s1">})}</span><span class="s3">{}`</span><span class="s1">)</span>
                <span class="s1">.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">],`</span>
            <span class="s1">: </span><span class="s3">''</span><span class="s1">}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">wrapperStart += </span><span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">execute:</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${getNonArrowFunctionIntro([]</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">isAsync: usesTopLevelAwait</span><span class="s2">,</span>
        <span class="s1">name: </span><span class="s2">null</span>
    <span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrapperEnd = </span><span class="s3">`</span><span class="s1">${t}${t}</span><span class="s3">})</span><span class="s1">${n}${t}</span><span class="s3">}</span><span class="s1">${s}${n}</span><span class="s3">}));`</span><span class="s2">;</span>
    <span class="s1">magicString</span>
        <span class="s1">.prepend(intro +</span>
        <span class="s1">getHelpersBlock(</span><span class="s2">null, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag) +</span>
        <span class="s1">getHoistedExportsBlock(exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets))</span>
        <span class="s1">.append(</span><span class="s3">`</span><span class="s1">${outro}${n}${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">getSyntheticExportsBlock(exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) +</span>
        <span class="s1">getMissingExportsBlock(exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets))</span>
        <span class="s1">.indent(</span><span class="s3">`</span><span class="s1">${t}${t}${t}</span><span class="s3">`</span><span class="s1">)</span>
        <span class="s1">.append(wrapperEnd)</span>
        <span class="s1">.prepend(wrapperStart)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">analyzeDependencies(dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n }) {</span>
    <span class="s2">const </span><span class="s1">importBindings = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setters = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">starExcludes = </span><span class="s2">null;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imports</span><span class="s2">, </span><span class="s1">reexports } of dependencies) {</span>
        <span class="s2">const </span><span class="s1">setter = []</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(imports) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">specifier of imports) {</span>
                <span class="s1">importBindings.push(specifier.local)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(specifier.imported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s1">setter.push(</span><span class="s3">`</span><span class="s1">${specifier.local}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">module;`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">setter.push(</span><span class="s3">`</span><span class="s1">${specifier.local}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">module</span><span class="s1">${getPropertyAccess(specifier.imported)}</span><span class="s3">;`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(reexports) {</span>
            <span class="s2">const </span><span class="s1">reexportedNames = []</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hasStarReexport = </span><span class="s2">false;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imported</span><span class="s2">, </span><span class="s1">reexported } of reexports) {</span>
                <span class="s2">if </span><span class="s1">(reexported === </span><span class="s3">'*'</span><span class="s1">) {</span>
                    <span class="s1">hasStarReexport = </span><span class="s2">true;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">reexportedNames.push([</span>
                        <span class="s1">reexported</span><span class="s2">,</span>
                        <span class="s1">imported === </span><span class="s3">'*' </span><span class="s1">? </span><span class="s3">'module' </span><span class="s1">: </span><span class="s3">`module</span><span class="s1">${getPropertyAccess(imported)}</span><span class="s3">`</span>
                    <span class="s1">])</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(reexportedNames.length &gt; </span><span class="s4">1 </span><span class="s1">|| hasStarReexport) {</span>
                <span class="s2">const </span><span class="s1">exportMapping = getObject(reexportedNames</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: </span><span class="s2">null </span><span class="s1">})</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hasStarReexport) {</span>
                    <span class="s2">if </span><span class="s1">(!starExcludes) {</span>
                        <span class="s1">starExcludes = getStarExcludes({ dependencies</span><span class="s2">, </span><span class="s1">exports })</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">setter.push(</span><span class="s3">`</span><span class="s1">${cnst} </span><span class="s3">setter</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${exportMapping}</span><span class="s3">;`</span><span class="s2">, </span><span class="s3">`for</span><span class="s1">${_}</span><span class="s3">(</span><span class="s1">${cnst} </span><span class="s3">name in module)</span><span class="s1">${_}</span><span class="s3">{`</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${t}</span><span class="s3">if</span><span class="s1">${_}</span><span class="s3">(!_starExcludes[name])</span><span class="s1">${_}</span><span class="s3">setter[name]</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">module[name];`</span><span class="s2">, </span><span class="s3">'}'</span><span class="s2">, </span><span class="s3">'exports(setter);'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">setter.push(</span><span class="s3">`exports(</span><span class="s1">${exportMapping}</span><span class="s3">);`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">value] = reexportedNames[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s1">setter.push(</span><span class="s3">`exports('</span><span class="s1">${key}</span><span class="s3">',</span><span class="s1">${_}${value}</span><span class="s3">);`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">setters.push(setter.join(</span><span class="s3">`</span><span class="s1">${n}${t}${t}${t}</span><span class="s3">`</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ importBindings</span><span class="s2">, </span><span class="s1">setters</span><span class="s2">, </span><span class="s1">starExcludes }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getStarExcludes = ({ dependencies</span><span class="s2">, </span><span class="s1">exports }) =&gt; {</span>
    <span class="s2">const </span><span class="s1">starExcludes = </span><span class="s2">new </span><span class="s1">Set(exports.map(expt =&gt; expt.exported))</span><span class="s2">;</span>
    <span class="s1">starExcludes.add(</span><span class="s3">'default'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ reexports } of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(reexports) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">reexport of reexports) {</span>
                <span class="s2">if </span><span class="s1">(reexport.reexported !== </span><span class="s3">'*'</span><span class="s1">)</span>
                    <span class="s1">starExcludes.add(reexport.reexported)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">starExcludes</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getStarExcludesBlock = (starExcludes</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getObject</span><span class="s2">, </span><span class="s1">n }) =&gt; starExcludes</span>
    <span class="s1">? </span><span class="s3">`</span><span class="s1">${n}${t}${cnst} </span><span class="s3">_starExcludes</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${getObject([...starExcludes].map(property =&gt; [property</span><span class="s2">, </span><span class="s3">'1'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">{ lineBreakIndent: { base: t</span><span class="s2">, </span><span class="s1">t } })}</span><span class="s3">;`</span>
    <span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getImportBindingsBlock = (importBindings</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n }) =&gt; (importBindings.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`</span><span class="s1">${n}${t}</span><span class="s3">var </span><span class="s1">${importBindings.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">;` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getHoistedExportsBlock = (exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) =&gt; getExportsBlock(exports.filter(expt =&gt; expt.hoisted).map(expt =&gt; ({ name: expt.exported</span><span class="s2">, </span><span class="s1">value: expt.local }))</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getExportsBlock(exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n }) {</span>
    <span class="s2">if </span><span class="s1">(exports.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(exports.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s3">`exports('</span><span class="s1">${exports[</span><span class="s4">0</span><span class="s1">].name}</span><span class="s3">',</span><span class="s1">${_}${exports[</span><span class="s4">0</span><span class="s1">].value}</span><span class="s3">);</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">`exports({</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">exports.map(({ name</span><span class="s2">, </span><span class="s1">value }) =&gt; </span><span class="s3">`</span><span class="s1">${t}${name}</span><span class="s3">:</span><span class="s1">${_}${value}</span><span class="s3">`</span><span class="s1">).join(</span><span class="s3">`,</span><span class="s1">${n}</span><span class="s3">`</span><span class="s1">) +</span>
        <span class="s3">`</span><span class="s1">${n}</span><span class="s3">});</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getSyntheticExportsBlock = (exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) =&gt; getExportsBlock(exports</span>
    <span class="s1">.filter(expt =&gt; expt.expression)</span>
    <span class="s1">.map(expt =&gt; ({ name: expt.exported</span><span class="s2">, </span><span class="s1">value: expt.local }))</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getMissingExportsBlock = (exports</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets) =&gt; getExportsBlock(exports</span>
    <span class="s1">.filter(expt =&gt; expt.local === MISSING_EXPORT_SHIM_VARIABLE)</span>
    <span class="s1">.map(expt =&gt; ({ name: expt.exported</span><span class="s2">, </span><span class="s1">value: MISSING_EXPORT_SHIM_VARIABLE }))</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">globalProperty(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">getPropertyAccess) {</span>
    <span class="s2">if </span><span class="s1">(!name)</span>
        <span class="s2">return </span><span class="s3">'null'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s3">`</span><span class="s1">${globalVariable}${keypath(name</span><span class="s2">, </span><span class="s1">getPropertyAccess)}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">safeAccess(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">getPropertyAccess }) {</span>
    <span class="s2">let </span><span class="s1">propertyPath = globalVariable</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">name</span>
        <span class="s1">.split(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">.map(part =&gt; (propertyPath += getPropertyAccess(part)))</span>
        <span class="s1">.join(</span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">umd(magicString</span><span class="s2">, </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exports</span><span class="s2">, </span><span class="s1">hasDefaultExport</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">indent: t</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">onwarn }</span><span class="s2">, </span><span class="s1">{ amd</span><span class="s2">, </span><span class="s1">compact</span><span class="s2">, </span><span class="s1">esModule</span><span class="s2">, </span><span class="s1">extend</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">noConflict</span><span class="s2">, </span><span class="s1">strict }) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">getFunctionIntro</span><span class="s2">, </span><span class="s1">getNonArrowFunctionIntro</span><span class="s2">, </span><span class="s1">getPropertyAccess</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } = snippets</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">factoryVariable = compact ? </span><span class="s3">'f' </span><span class="s1">: </span><span class="s3">'factory'</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">globalVariable = compact ? </span><span class="s3">'g' </span><span class="s1">: </span><span class="s3">'global'</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasExports &amp;&amp; !name) {</span>
        <span class="s2">return </span><span class="s1">error(errorMissingNameOptionForUmdExport())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">warnOnBuiltins(onwarn</span><span class="s2">, </span><span class="s1">dependencies)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">amdDeps = dependencies.map(m =&gt; </span><span class="s3">`'</span><span class="s1">${updateExtensionForRelativeAmdId(m.importPath</span><span class="s2">, </span><span class="s1">amd.forceJsExtensionForImports)}</span><span class="s3">'`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cjsDeps = dependencies.map(m =&gt; </span><span class="s3">`require('</span><span class="s1">${m.importPath}</span><span class="s3">')`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">trimmedImports = trimEmptyImports(dependencies)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">globalDeps = trimmedImports.map(module =&gt; globalProperty(module.globalName</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">getPropertyAccess))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">factoryParameters = trimmedImports.map(m =&gt; m.name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namedExportsMode &amp;&amp; (hasExports || noConflict)) {</span>
        <span class="s1">amdDeps.unshift(</span><span class="s3">`'exports'`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">cjsDeps.unshift(</span><span class="s3">`exports`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">globalDeps.unshift(assignToDeepVariable(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${extend ? </span><span class="s3">`</span><span class="s1">${globalProperty(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">getPropertyAccess)}${_}</span><span class="s3">||</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">{}`</span><span class="s2">, </span><span class="s1">snippets))</span><span class="s2">;</span>
        <span class="s1">factoryParameters.unshift(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">completeAmdId = getCompleteAmdId(amd</span><span class="s2">, </span><span class="s1">id)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">amdParameters = (completeAmdId ? </span><span class="s3">`'</span><span class="s1">${completeAmdId}</span><span class="s3">',</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">) +</span>
        <span class="s1">(amdDeps.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`[</span><span class="s1">${amdDeps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">],</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">define = amd.define</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cjsExport = !namedExportsMode &amp;&amp; hasExports ? </span><span class="s3">`module.exports</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">useStrict = strict ? </span><span class="s3">`</span><span class="s1">${_}</span><span class="s3">'use strict';</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">iifeExport</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(noConflict) {</span>
        <span class="s2">const </span><span class="s1">noConflictExportsVariable = compact ? </span><span class="s3">'e' </span><span class="s1">: </span><span class="s3">'exports'</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">factory</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!namedExportsMode &amp;&amp; hasExports) {</span>
            <span class="s1">factory = </span><span class="s3">`</span><span class="s1">${cnst} ${noConflictExportsVariable}${_}</span><span class="s3">=</span><span class="s1">${_}${assignToDeepVariable(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s3">`</span><span class="s1">${factoryVariable}</span><span class="s3">(</span><span class="s1">${globalDeps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">)`</span><span class="s2">, </span><span class="s1">snippets)}</span><span class="s3">;`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">module = globalDeps.shift()</span><span class="s2">;</span>
            <span class="s1">factory =</span>
                <span class="s3">`</span><span class="s1">${cnst} ${noConflictExportsVariable}${_}</span><span class="s3">=</span><span class="s1">${_}${module}</span><span class="s3">;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                    <span class="s3">`</span><span class="s1">${t}${t}${factoryVariable}</span><span class="s3">(</span><span class="s1">${[noConflictExportsVariable</span><span class="s2">, </span><span class="s1">...globalDeps].join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">);`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">iifeExport =</span>
            <span class="s3">`(</span><span class="s1">${getFunctionIntro([]</span><span class="s2">, </span><span class="s1">{ isAsync: </span><span class="s2">false, </span><span class="s1">name: </span><span class="s2">null </span><span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}${t}${cnst} </span><span class="s3">current</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${safeAccess(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">snippets)}</span><span class="s3">;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}${t}${factory}${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}${t}${noConflictExportsVariable}</span><span class="s3">.noConflict</span><span class="s1">${_}</span><span class="s3">=</span><span class="s1">${_}${getFunctionIntro([]</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">isAsync: </span><span class="s2">false,</span>
                    <span class="s1">name: </span><span class="s2">null</span>
                <span class="s1">})}</span><span class="s3">{</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${globalProperty(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">getPropertyAccess)}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">current;</span><span class="s1">${_}</span><span class="s3">return </span><span class="s1">${noConflictExportsVariable}${s}${_}</span><span class="s3">};</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${t}</span><span class="s3">})()`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">iifeExport = </span><span class="s3">`</span><span class="s1">${factoryVariable}</span><span class="s3">(</span><span class="s1">${globalDeps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">)`</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!namedExportsMode &amp;&amp; hasExports) {</span>
            <span class="s1">iifeExport = assignToDeepVariable(name</span><span class="s2">, </span><span class="s1">globalVariable</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">iifeExport</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">iifeNeedsGlobal = hasExports || (noConflict &amp;&amp; namedExportsMode) || globalDeps.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrapperParameters = [factoryVariable]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(iifeNeedsGlobal) {</span>
        <span class="s1">wrapperParameters.unshift(globalVariable)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">globalArgument = iifeNeedsGlobal ? </span><span class="s3">`this,</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">iifeStart = iifeNeedsGlobal</span>
        <span class="s1">? </span><span class="s3">`(</span><span class="s1">${globalVariable}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">typeof globalThis</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'undefined'</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}</span><span class="s3">globalThis</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${_}${globalVariable}${_}</span><span class="s3">||</span><span class="s1">${_}</span><span class="s3">self,</span><span class="s1">${_}</span><span class="s3">`</span>
        <span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">iifeEnd = iifeNeedsGlobal ? </span><span class="s3">')' </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cjsIntro = iifeNeedsGlobal</span>
        <span class="s1">? </span><span class="s3">`</span><span class="s1">${t}</span><span class="s3">typeof exports</span><span class="s1">${_}</span><span class="s3">===</span><span class="s1">${_}</span><span class="s3">'object'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}</span><span class="s3">typeof module</span><span class="s1">${_}</span><span class="s3">!==</span><span class="s1">${_}</span><span class="s3">'undefined'</span><span class="s1">${_}</span><span class="s3">?` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s1">${_}${cjsExport}${factoryVariable}</span><span class="s3">(</span><span class="s1">${cjsDeps.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">)</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${n}</span><span class="s3">`</span>
        <span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrapperIntro = </span><span class="s3">`(</span><span class="s1">${getNonArrowFunctionIntro(wrapperParameters</span><span class="s2">, </span><span class="s1">{ isAsync: </span><span class="s2">false, </span><span class="s1">name: </span><span class="s2">null </span><span class="s1">})}</span><span class="s3">{</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s1">cjsIntro +</span>
        <span class="s3">`</span><span class="s1">${t}</span><span class="s3">typeof </span><span class="s1">${define}${_}</span><span class="s3">===</span><span class="s1">${_}</span><span class="s3">'function'</span><span class="s1">${_}</span><span class="s3">&amp;&amp;</span><span class="s1">${_}${define}</span><span class="s3">.amd</span><span class="s1">${_}</span><span class="s3">?</span><span class="s1">${_}${define}</span><span class="s3">(</span><span class="s1">${amdParameters}${factoryVariable}</span><span class="s3">)</span><span class="s1">${_}</span><span class="s3">:</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s3">`</span><span class="s1">${t}${iifeStart}${iifeExport}${iifeEnd}</span><span class="s3">;</span><span class="s1">${n}</span><span class="s3">` </span><span class="s1">+</span>
        <span class="s0">// factory function should be wrapped by parentheses to avoid lazy parsing,</span>
        <span class="s0">// cf. https://v8.dev/blog/preparser#pife</span>
        <span class="s3">`})(</span><span class="s1">${globalArgument}</span><span class="s3">(</span><span class="s1">${getNonArrowFunctionIntro(factoryParameters</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">isAsync: </span><span class="s2">false,</span>
            <span class="s1">name: </span><span class="s2">null</span>
        <span class="s1">})}</span><span class="s3">{</span><span class="s1">${useStrict}${n}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrapperOutro = n + n + </span><span class="s3">'}));'</span><span class="s2">;</span>
    <span class="s1">magicString.prepend(</span><span class="s3">`</span><span class="s1">${intro}${getInteropBlock(dependencies</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">accessedGlobals</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">snippets)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exportBlock = getExportBlock$1(exports</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">namedExportsMode</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">namespaceMarkers = getNamespaceMarkers(namedExportsMode &amp;&amp; hasExports</span><span class="s2">, </span><span class="s1">esModule === </span><span class="s2">true </span><span class="s1">|| (esModule === </span><span class="s3">'if-default-prop' </span><span class="s1">&amp;&amp; hasDefaultExport)</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(namespaceMarkers) {</span>
        <span class="s1">namespaceMarkers = n + n + namespaceMarkers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">magicString</span>
        <span class="s1">.append(</span><span class="s3">`</span><span class="s1">${exportBlock}${namespaceMarkers}${outro}</span><span class="s3">`</span><span class="s1">)</span>
        <span class="s1">.trim()</span>
        <span class="s1">.indent(t)</span>
        <span class="s1">.append(wrapperOutro)</span>
        <span class="s1">.prepend(wrapperIntro)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">finalisers = { amd</span><span class="s2">, </span><span class="s1">cjs</span><span class="s2">, </span><span class="s1">es</span><span class="s2">, </span><span class="s1">iife</span><span class="s2">, </span><span class="s1">system</span><span class="s2">, </span><span class="s1">umd }</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">concatSeparator = (out</span><span class="s2">, </span><span class="s1">next) =&gt; (next ? </span><span class="s3">`</span><span class="s1">${out}</span><span class="s2">\n</span><span class="s1">${next}</span><span class="s3">` </span><span class="s1">: out)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">concatDblSeparator = (out</span><span class="s2">, </span><span class="s1">next) =&gt; (next ? </span><span class="s3">`</span><span class="s1">${out}</span><span class="s2">\n\n</span><span class="s1">${next}</span><span class="s3">` </span><span class="s1">: out)</span><span class="s2">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">createAddons(options</span><span class="s2">, </span><span class="s1">outputPluginDriver</span><span class="s2">, </span><span class="s1">chunk) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">[banner</span><span class="s2">, </span><span class="s1">footer</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">outro] = </span><span class="s2">await </span><span class="s1">Promise.all([</span>
            <span class="s1">outputPluginDriver.hookReduceValue(</span><span class="s3">'banner'</span><span class="s2">, </span><span class="s1">options.banner(chunk)</span><span class="s2">, </span><span class="s1">[chunk]</span><span class="s2">, </span><span class="s1">concatSeparator)</span><span class="s2">,</span>
            <span class="s1">outputPluginDriver.hookReduceValue(</span><span class="s3">'footer'</span><span class="s2">, </span><span class="s1">options.footer(chunk)</span><span class="s2">, </span><span class="s1">[chunk]</span><span class="s2">, </span><span class="s1">concatSeparator)</span><span class="s2">,</span>
            <span class="s1">outputPluginDriver.hookReduceValue(</span><span class="s3">'intro'</span><span class="s2">, </span><span class="s1">options.intro(chunk)</span><span class="s2">, </span><span class="s1">[chunk]</span><span class="s2">, </span><span class="s1">concatDblSeparator)</span><span class="s2">,</span>
            <span class="s1">outputPluginDriver.hookReduceValue(</span><span class="s3">'outro'</span><span class="s2">, </span><span class="s1">options.outro(chunk)</span><span class="s2">, </span><span class="s1">[chunk]</span><span class="s2">, </span><span class="s1">concatDblSeparator)</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(intro)</span>
            <span class="s1">intro += </span><span class="s3">'</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(outro)</span>
            <span class="s1">outro = </span><span class="s3">`</span><span class="s2">\n\n</span><span class="s1">${outro}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(banner)</span>
            <span class="s1">banner += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(footer)</span>
            <span class="s1">footer = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ footer</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{ banner</span><span class="s2">, </span><span class="s1">footer</span><span class="s2">, </span><span class="s1">intro</span><span class="s2">, </span><span class="s1">outro }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(error_) {</span>
        <span class="s2">return </span><span class="s1">error(errorAddonNotGenerated(error_.message</span><span class="s2">, </span><span class="s1">error_.hook</span><span class="s2">, </span><span class="s1">error_.plugin))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {</span>
    <span class="s1">amd: deconflictImportsOther</span><span class="s2">,</span>
    <span class="s1">cjs: deconflictImportsOther</span><span class="s2">,</span>
    <span class="s1">es: deconflictImportsEsmOrSystem</span><span class="s2">,</span>
    <span class="s1">iife: deconflictImportsOther</span><span class="s2">,</span>
    <span class="s1">system: deconflictImportsEsmOrSystem</span><span class="s2">,</span>
    <span class="s1">umd: deconflictImportsOther</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">deconflictChunk(modules</span><span class="s2">, </span><span class="s1">dependenciesToBeDeconflicted</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">syntheticExports</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">includedNamespaces) {</span>
    <span class="s2">const </span><span class="s1">reversedModules = [...modules].reverse()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of reversedModules) {</span>
        <span class="s1">module.scope.addUsedOutsideNames(usedNames</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deconflictTopLevelVariables(usedNames</span><span class="s2">, </span><span class="s1">reversedModules</span><span class="s2">, </span><span class="s1">includedNamespaces)</span><span class="s2">;</span>
    <span class="s1">DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">dependenciesToBeDeconflicted</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">syntheticExports)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of reversedModules) {</span>
        <span class="s1">module.scope.deconflict(format</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deconflictImportsEsmOrSystem(usedNames</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">dependenciesToBeDeconflicted</span><span class="s2">, </span><span class="s1">_interop</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">_externalLiveBindings</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">syntheticExports) {</span>
    <span class="s0">// This is needed for namespace reexports</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of dependenciesToBeDeconflicted.dependencies) {</span>
        <span class="s2">if </span><span class="s1">(preserveModules || dependency </span><span class="s2">instanceof </span><span class="s1">ExternalChunk) {</span>
            <span class="s1">dependency.variableName = getSafeName(dependency.suggestedVariableName</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of imports) {</span>
        <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">name = variable.name</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variable.isNamespace &amp;&amp; (preserveModules || module </span><span class="s2">instanceof </span><span class="s1">ExternalModule)) {</span>
            <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule</span>
                <span class="s1">? externalChunkByModule.get(module)</span>
                <span class="s1">: chunkByModule.get(module)).variableName)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule &amp;&amp; name === </span><span class="s3">'default'</span><span class="s1">) {</span>
            <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName([...module.exportedVariables].some(([exportedVariable</span><span class="s2">, </span><span class="s1">exportedName]) =&gt; exportedName === </span><span class="s3">'*' </span><span class="s1">&amp;&amp; exportedVariable.included)</span>
                <span class="s1">? module.suggestedVariableName + </span><span class="s3">'__default'</span>
                <span class="s1">: module.suggestedVariableName</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">variable.forbiddenNames))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName(name</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">variable.forbiddenNames))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of syntheticExports) {</span>
        <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName(variable.name</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">variable.forbiddenNames))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deconflictImportsOther(usedNames</span><span class="s2">, </span><span class="s1">imports</span><span class="s2">, </span><span class="s1">{ deconflictedDefault</span><span class="s2">, </span><span class="s1">deconflictedNamespace</span><span class="s2">, </span><span class="s1">dependencies }</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of dependencies) {</span>
        <span class="s1">chunk.variableName = getSafeName(chunk.suggestedVariableName</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of deconflictedNamespace) {</span>
        <span class="s1">chunk.namespaceVariableName = getSafeName(</span><span class="s3">`</span><span class="s1">${chunk.suggestedVariableName}</span><span class="s3">__namespace`</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">externalModule of deconflictedDefault) {</span>
        <span class="s1">externalModule.defaultVariableName =</span>
            <span class="s1">deconflictedNamespace.has(externalModule) &amp;&amp;</span>
                <span class="s1">canDefaultBeTakenFromNamespace(interop(externalModule.id)</span><span class="s2">, </span><span class="s1">externalLiveBindings)</span>
                <span class="s1">? externalModule.namespaceVariableName</span>
                <span class="s1">: getSafeName(</span><span class="s3">`</span><span class="s1">${externalModule.suggestedVariableName}</span><span class="s3">__default`</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of imports) {</span>
        <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
            <span class="s2">const </span><span class="s1">chunk = externalChunkByModule.get(module)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">name = variable.name</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'default'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">moduleInterop = interop(module.id)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">variableName = defaultInteropHelpersByInteropType[moduleInterop]</span>
                    <span class="s1">? chunk.defaultVariableName</span>
                    <span class="s1">: chunk.variableName</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isDefaultAProperty(moduleInterop</span><span class="s2">, </span><span class="s1">externalLiveBindings)) {</span>
                    <span class="s1">variable.setRenderNames(variableName</span><span class="s2">, </span><span class="s3">'default'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">variableName)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(name === </span><span class="s3">'*'</span><span class="s1">) {</span>
                <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">namespaceInteropHelpersByInteropType[interop(module.id)]</span>
                    <span class="s1">? chunk.namespaceVariableName</span>
                    <span class="s1">: chunk.variableName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s0">// if the second parameter is `null`, it uses its &quot;name&quot; for the property name</span>
                <span class="s1">variable.setRenderNames(chunk.variableName</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">chunk = chunkByModule.get(module)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(preserveModules &amp;&amp; variable.isNamespace) {</span>
                <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">chunk.exportMode === </span><span class="s3">'default' </span><span class="s1">? chunk.namespaceVariableName : chunk.variableName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(chunk.exportMode === </span><span class="s3">'default'</span><span class="s1">) {</span>
                <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">chunk.variableName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">variable.setRenderNames(chunk.variableName</span><span class="s2">, </span><span class="s1">chunk.getVariableExportName(variable))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deconflictTopLevelVariables(usedNames</span><span class="s2">, </span><span class="s1">modules</span><span class="s2">, </span><span class="s1">includedNamespaces) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of module.scope.variables.values()) {</span>
            <span class="s2">if </span><span class="s1">(variable.included &amp;&amp;</span>
                <span class="s0">// this will only happen for exports in some formats</span>
                <span class="s1">!(variable.renderBaseName ||</span>
                    <span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable &amp;&amp; variable.getOriginalVariable() !== variable))) {</span>
                <span class="s1">variable.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName(variable.name</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">variable.forbiddenNames))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(includedNamespaces.has(module)) {</span>
            <span class="s2">const </span><span class="s1">namespace = module.namespace</span><span class="s2">;</span>
            <span class="s1">namespace.setRenderNames(</span><span class="s2">null, </span><span class="s1">getSafeName(namespace.name</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">namespace.forbiddenNames))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">assignExportsToMangledNames(exports</span><span class="s2">, </span><span class="s1">exportsByName</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
    <span class="s2">let </span><span class="s1">nameIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of exports) {</span>
        <span class="s2">let </span><span class="s1">[exportName] = variable.name</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exportsByName.has(exportName)) {</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">exportName = toBase64(++nameIndex)</span><span class="s2">;</span>
                <span class="s0">// skip past leading number identifiers</span>
                <span class="s2">if </span><span class="s1">(exportName.charCodeAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s4">49 </span><span class="s0">/* '1' */</span><span class="s1">) {</span>
                    <span class="s1">nameIndex += </span><span class="s4">9 </span><span class="s1">* </span><span class="s4">64 </span><span class="s1">** (exportName.length - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">exportName = toBase64(nameIndex)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(RESERVED_NAMES$1.has(exportName) || exportsByName.has(exportName))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">exportsByName.set(exportName</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s1">exportNamesByVariable.set(variable</span><span class="s2">, </span><span class="s1">[exportName])</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assignExportsToNames(exports</span><span class="s2">, </span><span class="s1">exportsByName</span><span class="s2">, </span><span class="s1">exportNamesByVariable) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of exports) {</span>
        <span class="s2">let </span><span class="s1">nameIndex = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">exportName = variable.name</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(exportsByName.has(exportName)) {</span>
            <span class="s1">exportName = variable.name + </span><span class="s3">'$' </span><span class="s1">+ ++nameIndex</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">exportsByName.set(exportName</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s1">exportNamesByVariable.set(variable</span><span class="s2">, </span><span class="s1">[exportName])</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getExportMode(chunk</span><span class="s2">, </span><span class="s1">{ exports: exportMode</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">format }</span><span class="s2">, </span><span class="s1">facadeModuleId</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">const </span><span class="s1">exportKeys = chunk.getExportNames()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(exportMode === </span><span class="s3">'default'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(exportKeys.length !== </span><span class="s4">1 </span><span class="s1">|| exportKeys[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'default'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">error(errorIncompatibleExportOptionValue(</span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">exportKeys</span><span class="s2">, </span><span class="s1">facadeModuleId))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(exportMode === </span><span class="s3">'none' </span><span class="s1">&amp;&amp; exportKeys.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorIncompatibleExportOptionValue(</span><span class="s3">'none'</span><span class="s2">, </span><span class="s1">exportKeys</span><span class="s2">, </span><span class="s1">facadeModuleId))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(exportMode === </span><span class="s3">'auto'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(exportKeys.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">exportMode = </span><span class="s3">'none'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(exportKeys.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; exportKeys[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'default'</span><span class="s1">) {</span>
            <span class="s1">exportMode = </span><span class="s3">'default'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(format !== </span><span class="s3">'es' </span><span class="s1">&amp;&amp; format !== </span><span class="s3">'system' </span><span class="s1">&amp;&amp; exportKeys.includes(</span><span class="s3">'default'</span><span class="s1">)) {</span>
                <span class="s1">warn(errorMixedExport(facadeModuleId</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">exportMode = </span><span class="s3">'named'</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">exportMode</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">guessIndentString(code) {</span>
    <span class="s2">const </span><span class="s1">lines = code.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">tabbed = lines.filter(line =&gt; </span><span class="s4">/^\t+/</span><span class="s1">.test(line))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">spaced = lines.filter(line =&gt; </span><span class="s4">/^ {2,}/</span><span class="s1">.test(line))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(tabbed.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; spaced.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s0">// More lines tabbed than spaced? Assume tabs, and</span>
    <span class="s0">// default to tabs in the case of a tie (or nothing</span>
    <span class="s0">// to go on)</span>
    <span class="s2">if </span><span class="s1">(tabbed.length &gt;= spaced.length) {</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Otherwise, we need to guess the multiple</span>
    <span class="s2">const </span><span class="s1">min = spaced.reduce((previous</span><span class="s2">, </span><span class="s1">current) =&gt; {</span>
        <span class="s2">const </span><span class="s1">numberSpaces = </span><span class="s4">/^ +/</span><span class="s1">.exec(current)[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">Math.min(numberSpaces</span><span class="s2">, </span><span class="s1">previous)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">Infinity)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s3">' '</span><span class="s1">.repeat(min)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getIndentString(modules</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(options.indent !== </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">options.indent</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules) {</span>
        <span class="s2">const </span><span class="s1">indent = guessIndentString(module.originalCode)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(indent !== </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">indent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getStaticDependencies(chunk</span><span class="s2">, </span><span class="s1">orderedModules</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule) {</span>
    <span class="s2">const </span><span class="s1">staticDependencyBlocks = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">handledDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">modulePos = orderedModules.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">modulePos &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">modulePos--) {</span>
        <span class="s2">const </span><span class="s1">module = orderedModules[modulePos]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!handledDependencies.has(module)) {</span>
            <span class="s2">const </span><span class="s1">staticDependencies = []</span><span class="s2">;</span>
            <span class="s1">addStaticDependencies(module</span><span class="s2">, </span><span class="s1">staticDependencies</span><span class="s2">, </span><span class="s1">handledDependencies</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule)</span><span class="s2">;</span>
            <span class="s1">staticDependencyBlocks.unshift(staticDependencies)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">dependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">block of staticDependencyBlocks) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of block) {</span>
            <span class="s1">dependencies.add(dependency)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">dependencies</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addStaticDependencies(module</span><span class="s2">, </span><span class="s1">staticDependencies</span><span class="s2">, </span><span class="s1">handledModules</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule) {</span>
    <span class="s2">const </span><span class="s1">dependencies = module.getDependenciesToBeIncluded()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of dependencies) {</span>
        <span class="s2">if </span><span class="s1">(dependency </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
            <span class="s1">staticDependencies.push(externalChunkByModule.get(dependency))</span><span class="s2">;</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">dependencyChunk = chunkByModule.get(dependency)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(dependencyChunk !== chunk) {</span>
            <span class="s1">staticDependencies.push(dependencyChunk)</span><span class="s2">;</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!handledModules.has(dependency)) {</span>
            <span class="s1">handledModules.add(dependency)</span><span class="s2">;</span>
            <span class="s1">addStaticDependencies(dependency</span><span class="s2">, </span><span class="s1">staticDependencies</span><span class="s2">, </span><span class="s1">handledModules</span><span class="s2">, </span><span class="s1">chunk</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// Four random characters from the private use area to minimize risk of conflicts</span>
<span class="s2">const </span><span class="s1">hashPlaceholderLeft = </span><span class="s3">'!~{'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hashPlaceholderRight = </span><span class="s3">'}~'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length</span><span class="s2">;</span>
<span class="s0">// This is the size of a sha256</span>
<span class="s2">const </span><span class="s1">maxHashSize = </span><span class="s4">64</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">defaultHashSize = </span><span class="s4">8</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getHashPlaceholderGenerator = () =&gt; {</span>
    <span class="s2">let </span><span class="s1">nextIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(optionName</span><span class="s2">, </span><span class="s1">hashSize = defaultHashSize) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(hashSize &gt; maxHashSize) {</span>
            <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Hashes cannot be longer than </span><span class="s1">${maxHashSize} </span><span class="s3">characters, received </span><span class="s1">${hashSize}</span><span class="s3">. Check the &quot;</span><span class="s1">${optionName}</span><span class="s3">&quot; option.`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">placeholder = </span><span class="s3">`</span><span class="s1">${hashPlaceholderLeft}${toBase64(++nextIndex).padStart(hashSize - hashPlaceholderOverhead</span><span class="s2">, </span><span class="s3">'0'</span><span class="s1">)}${hashPlaceholderRight}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(placeholder.length &gt; hashSize) {</span>
            <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`To generate hashes for this number of chunks (currently </span><span class="s1">${nextIndex}</span><span class="s3">), you need a minimum hash size of </span><span class="s1">${placeholder.length}</span><span class="s3">, received </span><span class="s1">${hashSize}</span><span class="s3">. Check the &quot;</span><span class="s1">${optionName}</span><span class="s3">&quot; option.`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">placeholder</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">REPLACER_REGEX = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">`</span><span class="s1">${hashPlaceholderLeft}</span><span class="s3">[0-9a-zA-Z_$]{1,</span><span class="s1">${maxHashSize - hashPlaceholderOverhead}</span><span class="s3">}</span><span class="s1">${hashPlaceholderRight}</span><span class="s3">`</span><span class="s2">, </span><span class="s3">'g'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">replacePlaceholders = (code</span><span class="s2">, </span><span class="s1">hashesByPlaceholder) =&gt; code.replace(REPLACER_REGEX</span><span class="s2">, </span><span class="s1">placeholder =&gt; hashesByPlaceholder.get(placeholder) || placeholder)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">replaceSinglePlaceholder = (code</span><span class="s2">, </span><span class="s1">placeholder</span><span class="s2">, </span><span class="s1">value) =&gt; code.replace(REPLACER_REGEX</span><span class="s2">, </span><span class="s1">match =&gt; (match === placeholder ? value : match))</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">replacePlaceholdersWithDefaultAndGetContainedPlaceholders = (code</span><span class="s2">, </span><span class="s1">placeholders) =&gt; {</span>
    <span class="s2">const </span><span class="s1">containedPlaceholders = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">transformedCode = code.replace(REPLACER_REGEX</span><span class="s2">, </span><span class="s1">placeholder =&gt; {</span>
        <span class="s2">if </span><span class="s1">(placeholders.has(placeholder)) {</span>
            <span class="s1">containedPlaceholders.add(placeholder)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${hashPlaceholderLeft}${</span><span class="s3">'0'</span><span class="s1">.repeat(placeholder.length - hashPlaceholderOverhead)}${hashPlaceholderRight}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">placeholder</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ containedPlaceholders</span><span class="s2">, </span><span class="s1">transformedCode }</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">lowercaseBundleKeys = Symbol(</span><span class="s3">'bundleKeys'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">FILE_PLACEHOLDER = {</span>
    <span class="s1">type: </span><span class="s3">'placeholder'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getOutputBundle = (outputBundleBase) =&gt; {</span>
    <span class="s2">const </span><span class="s1">reservedLowercaseBundleKeys = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">return new </span><span class="s1">Proxy(outputBundleBase</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">deleteProperty(target</span><span class="s2">, </span><span class="s1">key) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s1">reservedLowercaseBundleKeys.delete(key.toLowerCase())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.deleteProperty(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
            <span class="s2">if </span><span class="s1">(key === lowercaseBundleKeys) {</span>
                <span class="s2">return </span><span class="s1">reservedLowercaseBundleKeys</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.get(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s1">reservedLowercaseBundleKeys.add(key.toLowerCase())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Reflect.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">removeUnreferencedAssets = (outputBundle) =&gt; {</span>
    <span class="s2">const </span><span class="s1">unreferencedAssets = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">bundleEntries = Object.values(outputBundle)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">asset of bundleEntries) {</span>
        <span class="s1">asset.type === </span><span class="s3">'asset' </span><span class="s1">&amp;&amp; asset.needsCodeReference &amp;&amp; unreferencedAssets.add(asset.fileName)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of bundleEntries) {</span>
        <span class="s2">if </span><span class="s1">(chunk.type === </span><span class="s3">'chunk'</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">referencedFile of chunk.referencedFiles) {</span>
                <span class="s1">unreferencedAssets.has(referencedFile) &amp;&amp; unreferencedAssets.delete(referencedFile)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of unreferencedAssets) {</span>
        <span class="s2">delete </span><span class="s1">outputBundle[file]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">renderNamePattern(pattern</span><span class="s2">, </span><span class="s1">patternName</span><span class="s2">, </span><span class="s1">replacements) {</span>
    <span class="s2">if </span><span class="s1">(isPathFragment(pattern))</span>
        <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Invalid pattern &quot;</span><span class="s1">${pattern}</span><span class="s3">&quot; for &quot;</span><span class="s1">${patternName}</span><span class="s3">&quot;, patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">pattern.replace(</span><span class="s4">/\[(\w+)(:\d+)?]/g</span><span class="s2">, </span><span class="s1">(_match</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">size) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!replacements.hasOwnProperty(type) || (size &amp;&amp; type !== </span><span class="s3">'hash'</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`&quot;[</span><span class="s1">${type}${size || </span><span class="s3">''</span><span class="s1">}</span><span class="s3">]&quot; is not a valid placeholder in the &quot;</span><span class="s1">${patternName}</span><span class="s3">&quot; pattern.`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">replacement = replacements[type](size &amp;&amp; Number.parseInt(size.slice(</span><span class="s4">1</span><span class="s1">)))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPathFragment(replacement))</span>
            <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Invalid substitution &quot;</span><span class="s1">${replacement}</span><span class="s3">&quot; for placeholder &quot;[</span><span class="s1">${type}</span><span class="s3">]&quot; in &quot;</span><span class="s1">${patternName}</span><span class="s3">&quot; pattern, can be neither absolute nor relative path.`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">replacement</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeUnique(name</span><span class="s2">, </span><span class="s1">{ [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {</span>
    <span class="s2">if </span><span class="s1">(!reservedLowercaseBundleKeys.has(name.toLowerCase()))</span>
        <span class="s2">return </span><span class="s1">name</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">extension = extname(name)</span><span class="s2">;</span>
    <span class="s1">name = name.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">Math.max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">name.length - extension.length))</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">uniqueName</span><span class="s2">, </span><span class="s1">uniqueIndex = </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + extension).toLowerCase()))</span>
        <span class="s2">;</span>
    <span class="s2">return </span><span class="s1">uniqueName</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">NON_ASSET_EXTENSIONS = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s3">'.js'</span><span class="s2">,</span>
    <span class="s3">'.jsx'</span><span class="s2">,</span>
    <span class="s3">'.ts'</span><span class="s2">,</span>
    <span class="s3">'.tsx'</span><span class="s2">,</span>
    <span class="s3">'.mjs'</span><span class="s2">,</span>
    <span class="s3">'.mts'</span><span class="s2">,</span>
    <span class="s3">'.cjs'</span><span class="s2">,</span>
    <span class="s3">'.cts'</span>
<span class="s1">])</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getGlobalName(chunk</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">, </span><span class="s1">hasExports</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">const </span><span class="s1">globalName = </span><span class="s2">typeof </span><span class="s1">globals === </span><span class="s3">'function' </span><span class="s1">? globals(chunk.id) : globals[chunk.id]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(globalName) {</span>
        <span class="s2">return </span><span class="s1">globalName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(hasExports) {</span>
        <span class="s1">warn(errorMissingGlobalName(chunk.id</span><span class="s2">, </span><span class="s1">chunk.variableName))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">chunk.variableName</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Chunk {</span>
    <span class="s1">constructor(orderedModules</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">modulesById</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">facadeChunkByModule</span><span class="s2">, </span><span class="s1">includedNamespaces</span><span class="s2">, </span><span class="s1">manualChunkAlias</span><span class="s2">, </span><span class="s1">getPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">inputBase</span><span class="s2">, </span><span class="s1">snippets) {</span>
        <span class="s2">this</span><span class="s1">.orderedModules = orderedModules</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inputOptions = inputOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.outputOptions = outputOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unsetOptions = unsetOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginDriver = pluginDriver</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modulesById = modulesById</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.chunkByModule = chunkByModule</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.externalChunkByModule = externalChunkByModule</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.facadeChunkByModule = facadeChunkByModule</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includedNamespaces = includedNamespaces</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.manualChunkAlias = manualChunkAlias</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.getPlaceholder = getPlaceholder</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.bundle = bundle</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inputBase = inputBase</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.snippets = snippets</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.entryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportMode = </span><span class="s3">'named'</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.facadeModule = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.namespaceVariableName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.variableName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.accessedGlobalsByScope = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicEntryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dynamicName = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.exportNamesByVariable = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.exportsByName = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.fileName = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.implicitEntryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.implicitlyLoadedBefore = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.imports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includedDynamicImports = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.includedReexportsByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s0">// This may be updated in the constructor</span>
        <span class="s2">this</span><span class="s1">.isEmpty = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.name = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.needsExportsShim = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.preRenderedChunkInfo = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.preliminaryFileName = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.renderedChunkInfo = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.renderedDependencies = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.renderedModules = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.sortedExportNames = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.strictFacade = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.execIndex = orderedModules.length &gt; </span><span class="s4">0 </span><span class="s1">? orderedModules[</span><span class="s4">0</span><span class="s1">].execIndex : Infinity</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">chunkModules = </span><span class="s2">new </span><span class="s1">Set(orderedModules)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of orderedModules) {</span>
            <span class="s1">chunkByModule.set(module</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(module.namespace.included &amp;&amp; !outputOptions.preserveModules) {</span>
                <span class="s1">includedNamespaces.add(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isEmpty &amp;&amp; module.isIncluded()) {</span>
                <span class="s2">this</span><span class="s1">.isEmpty = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(module.info.isEntry || outputOptions.preserveModules) {</span>
                <span class="s2">this</span><span class="s1">.entryModules.push(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importer of module.includedDynamicImporters) {</span>
                <span class="s2">if </span><span class="s1">(!chunkModules.has(importer)) {</span>
                    <span class="s2">this</span><span class="s1">.dynamicEntryModules.push(module)</span><span class="s2">;</span>
                    <span class="s0">// Modules with synthetic exports need an artificial namespace for dynamic imports</span>
                    <span class="s2">if </span><span class="s1">(module.info.syntheticNamedExports) {</span>
                        <span class="s1">includedNamespaces.add(module)</span><span class="s2">;</span>
                        <span class="s2">this</span><span class="s1">.exports.add(module.namespace)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(module.implicitlyLoadedAfter.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.implicitEntryModules.push(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.suggestedVariableName = makeLegal(</span><span class="s2">this</span><span class="s1">.generateVariableName())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">static </span><span class="s1">generateFacade(inputOptions</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">modulesById</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">facadeChunkByModule</span><span class="s2">, </span><span class="s1">includedNamespaces</span><span class="s2">, </span><span class="s1">facadedModule</span><span class="s2">, </span><span class="s1">facadeName</span><span class="s2">, </span><span class="s1">getPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">inputBase</span><span class="s2">, </span><span class="s1">snippets) {</span>
        <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk([]</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">modulesById</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, </span><span class="s1">facadeChunkByModule</span><span class="s2">, </span><span class="s1">includedNamespaces</span><span class="s2">, null, </span><span class="s1">getPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">inputBase</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
        <span class="s1">chunk.assignFacadeName(facadeName</span><span class="s2">, </span><span class="s1">facadedModule)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!facadeChunkByModule.has(facadedModule)) {</span>
            <span class="s1">facadeChunkByModule.set(facadedModule</span><span class="s2">, </span><span class="s1">chunk)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of facadedModule.getDependenciesToBeIncluded()) {</span>
            <span class="s1">chunk.dependencies.add(dependency </span><span class="s2">instanceof </span><span class="s1">Module</span>
                <span class="s1">? chunkByModule.get(dependency)</span>
                <span class="s1">: externalChunkByModule.get(dependency))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!chunk.dependencies.has(chunkByModule.get(facadedModule)) &amp;&amp;</span>
            <span class="s1">facadedModule.info.moduleSideEffects &amp;&amp;</span>
            <span class="s1">facadedModule.hasEffects()) {</span>
            <span class="s1">chunk.dependencies.add(chunkByModule.get(facadedModule))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">chunk.ensureReexportsAreAvailableForModule(facadedModule)</span><span class="s2">;</span>
        <span class="s1">chunk.facadeModule = facadedModule</span><span class="s2">;</span>
        <span class="s1">chunk.strictFacade = </span><span class="s2">true;</span>
        <span class="s2">return </span><span class="s1">chunk</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">canModuleBeFacade(module</span><span class="s2">, </span><span class="s1">exposedVariables) {</span>
        <span class="s2">const </span><span class="s1">moduleExportNamesByVariable = module.getExportNamesByVariable()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exposedVariable of </span><span class="s2">this</span><span class="s1">.exports) {</span>
            <span class="s2">if </span><span class="s1">(!moduleExportNamesByVariable.has(exposedVariable)) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exposedVariable of exposedVariables) {</span>
            <span class="s2">if </span><span class="s1">(!(moduleExportNamesByVariable.has(exposedVariable) || exposedVariable.module === module)) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s1">finalizeChunk(code</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">hashesByPlaceholder) {</span>
        <span class="s2">const </span><span class="s1">renderedChunkInfo = </span><span class="s2">this</span><span class="s1">.getRenderedChunkInfo()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">finalize = (code) =&gt; replacePlaceholders(code</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">fileName = (</span><span class="s2">this</span><span class="s1">.fileName = finalize(renderedChunkInfo.fileName))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...renderedChunkInfo</span><span class="s2">,</span>
            <span class="s1">code</span><span class="s2">,</span>
            <span class="s1">dynamicImports: renderedChunkInfo.dynamicImports.map(finalize)</span><span class="s2">,</span>
            <span class="s1">fileName</span><span class="s2">,</span>
            <span class="s1">implicitlyLoadedBefore: renderedChunkInfo.implicitlyLoadedBefore.map(finalize)</span><span class="s2">,</span>
            <span class="s1">importedBindings: Object.fromEntries(Object.entries(renderedChunkInfo.importedBindings).map(([fileName</span><span class="s2">, </span><span class="s1">bindings]) =&gt; [</span>
                <span class="s1">finalize(fileName)</span><span class="s2">,</span>
                <span class="s1">bindings</span>
            <span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">imports: renderedChunkInfo.imports.map(finalize)</span><span class="s2">,</span>
            <span class="s1">map</span><span class="s2">,</span>
            <span class="s1">referencedFiles: renderedChunkInfo.referencedFiles.map(finalize)</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">generateExports() {</span>
        <span class="s2">this</span><span class="s1">.sortedExportNames = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">remainingExports = </span><span class="s2">new </span><span class="s1">Set(</span><span class="s2">this</span><span class="s1">.exports)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.facadeModule !== </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.facadeModule.preserveSignature !== </span><span class="s2">false </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.strictFacade)) {</span>
            <span class="s2">const </span><span class="s1">exportNamesByVariable = </span><span class="s2">this</span><span class="s1">.facadeModule.getExportNamesByVariable()</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[variable</span><span class="s2">, </span><span class="s1">exportNames] of exportNamesByVariable) {</span>
                <span class="s2">this</span><span class="s1">.exportNamesByVariable.set(variable</span><span class="s2">, </span><span class="s1">[...exportNames])</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of exportNames) {</span>
                    <span class="s2">this</span><span class="s1">.exportsByName.set(exportName</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">remainingExports.delete(variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.minifyInternalExports) {</span>
            <span class="s1">assignExportsToMangledNames(remainingExports</span><span class="s2">, this</span><span class="s1">.exportsByName</span><span class="s2">, this</span><span class="s1">.exportNamesByVariable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">assignExportsToNames(remainingExports</span><span class="s2">, this</span><span class="s1">.exportsByName</span><span class="s2">, this</span><span class="s1">.exportNamesByVariable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules || (</span><span class="s2">this</span><span class="s1">.facadeModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.facadeModule.info.isEntry))</span>
            <span class="s2">this</span><span class="s1">.exportMode = getExportMode(</span><span class="s2">this, this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.facadeModule.id</span><span class="s2">, this</span><span class="s1">.inputOptions.onwarn)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">generateFacades() {</span>
        <span class="s2">const </span><span class="s1">facades = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">entryModules = </span><span class="s2">new </span><span class="s1">Set([...</span><span class="s2">this</span><span class="s1">.entryModules</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.implicitEntryModules])</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">exposedVariables = </span><span class="s2">new </span><span class="s1">Set(</span><span class="s2">this</span><span class="s1">.dynamicEntryModules.map(({ namespace }) =&gt; namespace))</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of entryModules) {</span>
            <span class="s2">if </span><span class="s1">(module.preserveSignature) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportedVariable of module.getExportNamesByVariable().keys()) {</span>
                    <span class="s1">exposedVariables.add(exportedVariable)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of entryModules) {</span>
            <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
            <span class="s2">const </span><span class="s1">requiredFacades = Array.from(</span><span class="s2">new </span><span class="s1">Set(module.chunkNames.filter(({ isUserDefined }) =&gt; isUserDefined).map(({ name }) =&gt; name))</span><span class="s2">, </span>
            <span class="s0">// mapping must run after Set 'name' dedupe</span>
            <span class="s1">name =&gt; ({</span>
                <span class="s1">name</span>
            <span class="s1">}))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(requiredFacades.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; module.isUserDefinedEntryPoint) {</span>
                <span class="s1">requiredFacades.push({})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
            <span class="s1">requiredFacades.push(...Array.from(module.chunkFileNames</span><span class="s2">, </span><span class="s1">fileName =&gt; ({ fileName })))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(requiredFacades.length === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">requiredFacades.push({})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.facadeModule) {</span>
                <span class="s2">const </span><span class="s1">needsStrictFacade = !</span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules &amp;&amp;</span>
                    <span class="s1">(module.preserveSignature === </span><span class="s3">'strict' </span><span class="s1">||</span>
                        <span class="s1">(module.preserveSignature === </span><span class="s3">'exports-only' </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">module.getExportNamesByVariable().size &gt; </span><span class="s4">0</span><span class="s1">))</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!needsStrictFacade || </span><span class="s2">this</span><span class="s1">.canModuleBeFacade(module</span><span class="s2">, </span><span class="s1">exposedVariables)) {</span>
                    <span class="s2">this</span><span class="s1">.facadeModule = module</span><span class="s2">;</span>
                    <span class="s2">this</span><span class="s1">.facadeChunkByModule.set(module</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(module.preserveSignature) {</span>
                        <span class="s2">this</span><span class="s1">.strictFacade = needsStrictFacade</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">this</span><span class="s1">.assignFacadeName(requiredFacades.shift()</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, this</span><span class="s1">.outputOptions.preserveModules)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">facadeName of requiredFacades) {</span>
                <span class="s1">facades.push(Chunk.generateFacade(</span><span class="s2">this</span><span class="s1">.inputOptions</span><span class="s2">, this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.unsetOptions</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.modulesById</span><span class="s2">, this</span><span class="s1">.chunkByModule</span><span class="s2">, this</span><span class="s1">.externalChunkByModule</span><span class="s2">, this</span><span class="s1">.facadeChunkByModule</span><span class="s2">, this</span><span class="s1">.includedNamespaces</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">facadeName</span><span class="s2">, this</span><span class="s1">.getPlaceholder</span><span class="s2">, this</span><span class="s1">.bundle</span><span class="s2">, this</span><span class="s1">.inputBase</span><span class="s2">, this</span><span class="s1">.snippets))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.dynamicEntryModules) {</span>
            <span class="s2">if </span><span class="s1">(module.info.syntheticNamedExports)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.facadeModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.canModuleBeFacade(module</span><span class="s2">, </span><span class="s1">exposedVariables)) {</span>
                <span class="s2">this</span><span class="s1">.facadeModule = module</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.facadeChunkByModule.set(module</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.strictFacade = </span><span class="s2">true;</span>
                <span class="s2">this</span><span class="s1">.dynamicName = getChunkNameFromModule(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.facadeModule === module &amp;&amp;</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.strictFacade &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.canModuleBeFacade(module</span><span class="s2">, </span><span class="s1">exposedVariables)) {</span>
                <span class="s2">this</span><span class="s1">.strictFacade = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.facadeChunkByModule.get(module)?.strictFacade) {</span>
                <span class="s2">this</span><span class="s1">.includedNamespaces.add(module)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.exports.add(module.namespace)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules) {</span>
            <span class="s2">this</span><span class="s1">.addNecessaryImportsForFacades()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">facades</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getChunkName() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.name ?? (</span><span class="s2">this</span><span class="s1">.name = </span><span class="s2">this</span><span class="s1">.outputOptions.sanitizeFileName(</span><span class="s2">this</span><span class="s1">.getFallbackChunkName())))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getExportNames() {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.sortedExportNames ?? (</span><span class="s2">this</span><span class="s1">.sortedExportNames = [...</span><span class="s2">this</span><span class="s1">.exportsByName.keys()].sort()))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getFileName() {</span>
        <span class="s2">return this</span><span class="s1">.fileName || </span><span class="s2">this</span><span class="s1">.getPreliminaryFileName().fileName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getImportPath(importer) {</span>
        <span class="s2">return </span><span class="s1">escapeId(getImportPath(importer</span><span class="s2">, this</span><span class="s1">.getFileName()</span><span class="s2">, this</span><span class="s1">.outputOptions.format === </span><span class="s3">'amd' </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.outputOptions.amd.forceJsExtensionForImports</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getPreliminaryFileName() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.preliminaryFileName) {</span>
            <span class="s2">return this</span><span class="s1">.preliminaryFileName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">fileName</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hashPlaceholder = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">{ chunkFileNames</span><span class="s2">, </span><span class="s1">entryFileNames</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">preserveModules } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(file) {</span>
            <span class="s1">fileName = basename(file)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fileName === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">[pattern</span><span class="s2">, </span><span class="s1">patternName] = preserveModules || </span><span class="s2">this</span><span class="s1">.facadeModule?.isUserDefinedEntryPoint</span>
                <span class="s1">? [entryFileNames</span><span class="s2">, </span><span class="s3">'output.entryFileNames'</span><span class="s1">]</span>
                <span class="s1">: [chunkFileNames</span><span class="s2">, </span><span class="s3">'output.chunkFileNames'</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s1">fileName = renderNamePattern(</span><span class="s2">typeof </span><span class="s1">pattern === </span><span class="s3">'function' </span><span class="s1">? pattern(</span><span class="s2">this</span><span class="s1">.getPreRenderedChunkInfo()) : pattern</span><span class="s2">, </span><span class="s1">patternName</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">format: () =&gt; format</span><span class="s2">,</span>
                <span class="s1">hash: size =&gt; hashPlaceholder || (hashPlaceholder = </span><span class="s2">this</span><span class="s1">.getPlaceholder(patternName</span><span class="s2">, </span><span class="s1">size))</span><span class="s2">,</span>
                <span class="s1">name: () =&gt; </span><span class="s2">this</span><span class="s1">.getChunkName()</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!hashPlaceholder) {</span>
                <span class="s1">fileName = makeUnique(fileName</span><span class="s2">, this</span><span class="s1">.bundle)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">fileName = </span><span class="s2">this</span><span class="s1">.fileName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!hashPlaceholder) {</span>
            <span class="s2">this</span><span class="s1">.bundle[fileName] = FILE_PLACEHOLDER</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// Caching is essential to not conflict with the file name reservation above</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.preliminaryFileName = { fileName</span><span class="s2">, </span><span class="s1">hashPlaceholder })</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getRenderedChunkInfo() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderedChunkInfo) {</span>
            <span class="s2">return this</span><span class="s1">.renderedChunkInfo</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderedChunkInfo = {</span>
            <span class="s1">...</span><span class="s2">this</span><span class="s1">.getPreRenderedChunkInfo()</span><span class="s2">,</span>
            <span class="s1">dynamicImports: </span><span class="s2">this</span><span class="s1">.getDynamicDependencies().map(resolveFileName)</span><span class="s2">,</span>
            <span class="s1">fileName: </span><span class="s2">this</span><span class="s1">.getFileName()</span><span class="s2">,</span>
            <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
            <span class="s1">implicitlyLoadedBefore: Array.from(</span><span class="s2">this</span><span class="s1">.implicitlyLoadedBefore</span><span class="s2">, </span><span class="s1">resolveFileName)</span><span class="s2">,</span>
            <span class="s1">importedBindings: getImportedBindingsPerDependency(</span><span class="s2">this</span><span class="s1">.getRenderedDependencies()</span><span class="s2">, </span><span class="s1">resolveFileName)</span><span class="s2">,</span>
            <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
            <span class="s1">imports: Array.from(</span><span class="s2">this</span><span class="s1">.dependencies</span><span class="s2">, </span><span class="s1">resolveFileName)</span><span class="s2">,</span>
            <span class="s1">modules: </span><span class="s2">this</span><span class="s1">.renderedModules</span><span class="s2">,</span>
            <span class="s1">referencedFiles: </span><span class="s2">this</span><span class="s1">.getReferencedFiles()</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getVariableExportName(variable) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules &amp;&amp; variable </span><span class="s2">instanceof </span><span class="s1">NamespaceVariable) {</span>
            <span class="s2">return </span><span class="s3">'*'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.exportNamesByVariable.get(variable)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">link() {</span>
        <span class="s2">this</span><span class="s1">.dependencies = getStaticDependencies(</span><span class="s2">this, this</span><span class="s1">.orderedModules</span><span class="s2">, this</span><span class="s1">.chunkByModule</span><span class="s2">, this</span><span class="s1">.externalChunkByModule)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.orderedModules) {</span>
            <span class="s2">this</span><span class="s1">.addImplicitlyLoadedBeforeFromModule(module)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.setUpChunkImportsAndExportsForModule(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async render() {</span>
        <span class="s2">const </span><span class="s1">{ dependencies</span><span class="s2">, </span><span class="s1">exportMode</span><span class="s2">, </span><span class="s1">facadeModule</span><span class="s2">, </span><span class="s1">inputOptions: { onwarn }</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">snippets } = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">{ format</span><span class="s2">, </span><span class="s1">hoistTransitiveImports</span><span class="s2">, </span><span class="s1">preserveModules } = outputOptions</span><span class="s2">;</span>
        <span class="s0">// for static and dynamic entry points, add transitive dependencies to this</span>
        <span class="s0">// chunk's dependencies to avoid loading latency</span>
        <span class="s2">if </span><span class="s1">(hoistTransitiveImports &amp;&amp; !preserveModules &amp;&amp; facadeModule !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of dependencies) {</span>
                <span class="s2">if </span><span class="s1">(dep </span><span class="s2">instanceof </span><span class="s1">Chunk)</span>
                    <span class="s2">this</span><span class="s1">.inlineChunkDependencies(dep)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">preliminaryFileName = </span><span class="s2">this</span><span class="s1">.getPreliminaryFileName()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">magicString</span><span class="s2">, </span><span class="s1">renderedSource</span><span class="s2">, </span><span class="s1">usedModules</span><span class="s2">, </span><span class="s1">usesTopLevelAwait } = </span><span class="s2">this</span><span class="s1">.renderModules(preliminaryFileName.fileName)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">renderedDependencies = [...</span><span class="s2">this</span><span class="s1">.getRenderedDependencies().values()]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">renderedExports = exportMode === </span><span class="s3">'none' </span><span class="s1">? [] : </span><span class="s2">this</span><span class="s1">.getChunkExportDeclarations(format)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hasExports = renderedExports.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hasDefaultExport = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">renderedDependence of renderedDependencies) {</span>
            <span class="s2">const </span><span class="s1">{ reexports } = renderedDependence</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(reexports?.length) {</span>
                <span class="s1">hasExports = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(!hasDefaultExport &amp;&amp; reexports.some(reexport =&gt; reexport.reexported === </span><span class="s3">'default'</span><span class="s1">)) {</span>
                    <span class="s1">hasDefaultExport = </span><span class="s2">true;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'es'</span><span class="s1">) {</span>
                    <span class="s1">renderedDependence.reexports = reexports.filter(</span>
                    <span class="s0">// eslint-disable-next-line unicorn/prefer-array-some</span>
                    <span class="s1">({ reexported }) =&gt; !renderedExports.find(({ exported }) =&gt; exported === reexported))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!hasDefaultExport) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ exported } of renderedExports) {</span>
                <span class="s2">if </span><span class="s1">(exported === </span><span class="s3">'default'</span><span class="s1">) {</span>
                    <span class="s1">hasDefaultExport = </span><span class="s2">true;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ intro</span><span class="s2">, </span><span class="s1">outro</span><span class="s2">, </span><span class="s1">banner</span><span class="s2">, </span><span class="s1">footer } = </span><span class="s2">await </span><span class="s1">createAddons(outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, this</span><span class="s1">.getRenderedChunkInfo())</span><span class="s2">;</span>
        <span class="s1">finalisers[format](renderedSource</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">accessedGlobals</span><span class="s2">,</span>
            <span class="s1">dependencies: renderedDependencies</span><span class="s2">,</span>
            <span class="s1">exports: renderedExports</span><span class="s2">,</span>
            <span class="s1">hasDefaultExport</span><span class="s2">,</span>
            <span class="s1">hasExports</span><span class="s2">,</span>
            <span class="s1">id: preliminaryFileName.fileName</span><span class="s2">,</span>
            <span class="s1">indent</span><span class="s2">,</span>
            <span class="s1">intro</span><span class="s2">,</span>
            <span class="s1">isEntryFacade: preserveModules || (facadeModule !== </span><span class="s2">null </span><span class="s1">&amp;&amp; facadeModule.info.isEntry)</span><span class="s2">,</span>
            <span class="s1">isModuleFacade: facadeModule !== </span><span class="s2">null,</span>
            <span class="s1">namedExportsMode: exportMode !== </span><span class="s3">'default'</span><span class="s2">,</span>
            <span class="s1">onwarn</span><span class="s2">,</span>
            <span class="s1">outro</span><span class="s2">,</span>
            <span class="s1">snippets</span><span class="s2">,</span>
            <span class="s1">usesTopLevelAwait</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">outputOptions)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(banner)</span>
            <span class="s1">magicString.prepend(banner)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(footer)</span>
            <span class="s1">magicString.append(footer)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">chunk: </span><span class="s2">this,</span>
            <span class="s1">magicString</span><span class="s2">,</span>
            <span class="s1">preliminaryFileName</span><span class="s2">,</span>
            <span class="s1">usedModules</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addImplicitlyLoadedBeforeFromModule(baseModule) {</span>
        <span class="s2">const </span><span class="s1">{ chunkByModule</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore } = </span><span class="s2">this;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of baseModule.implicitlyLoadedBefore) {</span>
            <span class="s2">const </span><span class="s1">chunk = chunkByModule.get(module)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(chunk &amp;&amp; chunk !== </span><span class="s2">this</span><span class="s1">) {</span>
                <span class="s1">implicitlyLoadedBefore.add(chunk)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addNecessaryImportsForFacades() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[module</span><span class="s2">, </span><span class="s1">variables] of </span><span class="s2">this</span><span class="s1">.includedReexportsByModule) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.includedNamespaces.has(module)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of variables) {</span>
                    <span class="s2">this</span><span class="s1">.imports.add(variable)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">assignFacadeName({ fileName</span><span class="s2">, </span><span class="s1">name }</span><span class="s2">, </span><span class="s1">facadedModule</span><span class="s2">, </span><span class="s1">preservePath) {</span>
        <span class="s2">if </span><span class="s1">(fileName) {</span>
            <span class="s2">this</span><span class="s1">.fileName = fileName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.name = </span><span class="s2">this</span><span class="s1">.outputOptions.sanitizeFileName(name ||</span>
                <span class="s1">(preservePath</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.getPreserveModulesChunkNameFromModule(facadedModule)</span>
                    <span class="s1">: getChunkNameFromModule(facadedModule)))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">checkCircularDependencyImport(variable</span><span class="s2">, </span><span class="s1">importingModule) {</span>
        <span class="s2">const </span><span class="s1">variableModule = variable.module</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(variableModule </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
            <span class="s2">const </span><span class="s1">exportChunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(variableModule)</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">alternativeReexportModule</span><span class="s2">;</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">alternativeReexportModule = importingModule.alternativeReexportModules.get(variable)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(alternativeReexportModule) {</span>
                    <span class="s2">const </span><span class="s1">exportingChunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(alternativeReexportModule)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(exportingChunk !== exportChunk) {</span>
                        <span class="s2">this</span><span class="s1">.inputOptions.onwarn(errorCyclicCrossChunkReexport(</span>
                        <span class="s0">// Namespaces do not have an export name</span>
                        <span class="s1">variableModule.getExportNamesByVariable().get(variable)?.[</span><span class="s4">0</span><span class="s1">] || </span><span class="s3">'*'</span><span class="s2">, </span><span class="s1">variableModule.id</span><span class="s2">, </span><span class="s1">alternativeReexportModule.id</span><span class="s2">, </span><span class="s1">importingModule.id</span><span class="s2">, this</span><span class="s1">.outputOptions.preserveModules))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">importingModule = alternativeReexportModule</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(alternativeReexportModule)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ensureReexportsAreAvailableForModule(module) {</span>
        <span class="s2">const </span><span class="s1">includedReexports = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">map = module.getExportNamesByVariable()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportedVariable of map.keys()) {</span>
            <span class="s2">const </span><span class="s1">isSynthetic = exportedVariable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.checkCircularDependencyImport(importedVariable</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
            <span class="s0">// When preserving modules, we do not create namespace objects but directly</span>
            <span class="s0">// use the actual namespaces, which would be broken by this logic.</span>
            <span class="s2">if </span><span class="s1">(!(importedVariable </span><span class="s2">instanceof </span><span class="s1">NamespaceVariable &amp;&amp; </span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules)) {</span>
                <span class="s2">const </span><span class="s1">exportingModule = importedVariable.module</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(exportingModule </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                    <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(exportingModule)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(chunk &amp;&amp; chunk !== </span><span class="s2">this</span><span class="s1">) {</span>
                        <span class="s1">chunk.exports.add(importedVariable)</span><span class="s2">;</span>
                        <span class="s1">includedReexports.push(importedVariable)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(isSynthetic) {</span>
                            <span class="s2">this</span><span class="s1">.imports.add(importedVariable)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(includedReexports.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.includedReexportsByModule.set(module</span><span class="s2">, </span><span class="s1">includedReexports)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">generateVariableName() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.manualChunkAlias) {</span>
            <span class="s2">return this</span><span class="s1">.manualChunkAlias</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">moduleForNaming = </span><span class="s2">this</span><span class="s1">.entryModules[</span><span class="s4">0</span><span class="s1">] ||</span>
            <span class="s2">this</span><span class="s1">.implicitEntryModules[</span><span class="s4">0</span><span class="s1">] ||</span>
            <span class="s2">this</span><span class="s1">.dynamicEntryModules[</span><span class="s4">0</span><span class="s1">] ||</span>
            <span class="s2">this</span><span class="s1">.orderedModules[</span><span class="s2">this</span><span class="s1">.orderedModules.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(moduleForNaming) {</span>
            <span class="s2">return </span><span class="s1">getChunkNameFromModule(moduleForNaming)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s3">'chunk'</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getChunkExportDeclarations(format) {</span>
        <span class="s2">const </span><span class="s1">exports = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.getExportNames()) {</span>
            <span class="s2">if </span><span class="s1">(exportName[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'*'</span><span class="s1">)</span>
                <span class="s2">continue;</span>
            <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.exportsByName.get(exportName)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable)) {</span>
                <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(module) {</span>
                    <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(module)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(chunk !== </span><span class="s2">this</span><span class="s1">) {</span>
                        <span class="s2">if </span><span class="s1">(!chunk || format !== </span><span class="s3">'es'</span><span class="s1">) {</span>
                            <span class="s2">continue;</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">chunkDep = </span><span class="s2">this</span><span class="s1">.renderedDependencies.get(chunk)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(!chunkDep) {</span>
                            <span class="s2">continue;</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">{ imports</span><span class="s2">, </span><span class="s1">reexports } = chunkDep</span><span class="s2">;</span>
                        <span class="s2">const </span><span class="s1">importedByReexported = reexports?.find(({ reexported }) =&gt; reexported === exportName)</span><span class="s2">;</span>
                        <span class="s2">const </span><span class="s1">isImported = imports?.find(({ imported }) =&gt; imported === importedByReexported?.imported)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(!isImported) {</span>
                            <span class="s2">continue;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">expression = </span><span class="s2">null;</span>
            <span class="s2">let </span><span class="s1">hoisted = </span><span class="s2">false;</span>
            <span class="s2">let </span><span class="s1">local = variable.getName(</span><span class="s2">this</span><span class="s1">.snippets.getPropertyAccess)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">LocalVariable) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">declaration of variable.declarations) {</span>
                    <span class="s2">if </span><span class="s1">(declaration.parent </span><span class="s2">instanceof </span><span class="s1">FunctionDeclaration ||</span>
                        <span class="s1">(declaration </span><span class="s2">instanceof </span><span class="s1">ExportDefaultDeclaration &amp;&amp;</span>
                            <span class="s1">declaration.declaration </span><span class="s2">instanceof </span><span class="s1">FunctionDeclaration)) {</span>
                        <span class="s1">hoisted = </span><span class="s2">true;</span>
                        <span class="s2">break;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s1">expression = local</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(format === </span><span class="s3">'es'</span><span class="s1">) {</span>
                    <span class="s1">local = variable.renderName</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">exports.push({</span>
                <span class="s1">exported: exportName</span><span class="s2">,</span>
                <span class="s1">expression</span><span class="s2">,</span>
                <span class="s1">hoisted</span><span class="s2">,</span>
                <span class="s1">local</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">exports</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getDependenciesToBeDeconflicted(addNonNamespacesAndInteropHelpers</span><span class="s2">, </span><span class="s1">addDependenciesWithoutBindings</span><span class="s2">, </span><span class="s1">interop) {</span>
        <span class="s2">const </span><span class="s1">dependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">deconflictedDefault = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">deconflictedNamespace = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of [...</span><span class="s2">this</span><span class="s1">.exportNamesByVariable.keys()</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.imports]) {</span>
            <span class="s2">if </span><span class="s1">(addNonNamespacesAndInteropHelpers || variable.isNamespace) {</span>
                <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                    <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(module)</span><span class="s2">;</span>
                    <span class="s1">dependencies.add(chunk)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(addNonNamespacesAndInteropHelpers) {</span>
                        <span class="s2">if </span><span class="s1">(variable.name === </span><span class="s3">'default'</span><span class="s1">) {</span>
                            <span class="s2">if </span><span class="s1">(defaultInteropHelpersByInteropType[interop(module.id)]) {</span>
                                <span class="s1">deconflictedDefault.add(chunk)</span><span class="s2">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(variable.name === </span><span class="s3">'*' </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">namespaceInteropHelpersByInteropType[interop(module.id)]) {</span>
                            <span class="s1">deconflictedNamespace.add(chunk)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(module)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(chunk !== </span><span class="s2">this</span><span class="s1">) {</span>
                        <span class="s1">dependencies.add(chunk)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(addNonNamespacesAndInteropHelpers &amp;&amp;</span>
                            <span class="s1">chunk.exportMode === </span><span class="s3">'default' </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">variable.isNamespace) {</span>
                            <span class="s1">deconflictedNamespace.add(chunk)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(addDependenciesWithoutBindings) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of </span><span class="s2">this</span><span class="s1">.dependencies) {</span>
                <span class="s1">dependencies.add(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ deconflictedDefault</span><span class="s2">, </span><span class="s1">deconflictedNamespace</span><span class="s2">, </span><span class="s1">dependencies }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getDynamicDependencies() {</span>
        <span class="s2">return this</span><span class="s1">.getIncludedDynamicImports()</span>
            <span class="s1">.map(resolvedDynamicImport =&gt; resolvedDynamicImport.facadeChunk ||</span>
            <span class="s1">resolvedDynamicImport.chunk ||</span>
            <span class="s1">resolvedDynamicImport.externalChunk ||</span>
            <span class="s1">resolvedDynamicImport.resolution)</span>
            <span class="s1">.filter((resolution) =&gt; resolution !== </span><span class="s2">this </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(resolution </span><span class="s2">instanceof </span><span class="s1">Chunk || resolution </span><span class="s2">instanceof </span><span class="s1">ExternalChunk))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getDynamicImportStringAndAssertions(resolution</span><span class="s2">, </span><span class="s1">fileName) {</span>
        <span class="s2">if </span><span class="s1">(resolution </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
            <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(resolution)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">`'</span><span class="s1">${chunk.getImportPath(fileName)}</span><span class="s3">'`</span><span class="s2">, </span><span class="s1">chunk.getImportAssertions(</span><span class="s2">this</span><span class="s1">.snippets)]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">resolution || </span><span class="s3">''</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.format === </span><span class="s3">'es' </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.outputOptions.externalImportAssertions) || </span><span class="s2">null</span>
        <span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getFallbackChunkName() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.manualChunkAlias) {</span>
            <span class="s2">return this</span><span class="s1">.manualChunkAlias</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.dynamicName) {</span>
            <span class="s2">return this</span><span class="s1">.dynamicName</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.fileName) {</span>
            <span class="s2">return </span><span class="s1">getAliasName(</span><span class="s2">this</span><span class="s1">.fileName)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">getAliasName(</span><span class="s2">this</span><span class="s1">.orderedModules[</span><span class="s2">this</span><span class="s1">.orderedModules.length - </span><span class="s4">1</span><span class="s1">].id)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getImportSpecifiers() {</span>
        <span class="s2">const </span><span class="s1">{ interop } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">importsByDependency = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of </span><span class="s2">this</span><span class="s1">.imports) {</span>
            <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">dependency</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">imported</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
                <span class="s1">dependency = </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(module)</span><span class="s2">;</span>
                <span class="s1">imported = variable.name</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(imported !== </span><span class="s3">'default' </span><span class="s1">&amp;&amp; imported !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; interop(module.id) === </span><span class="s3">'defaultOnly'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">error(errorUnexpectedNamedImport(module.id</span><span class="s2">, </span><span class="s1">imported</span><span class="s2">, false</span><span class="s1">))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">dependency = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(module)</span><span class="s2">;</span>
                <span class="s1">imported = dependency.getVariableExportName(variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">getOrCreate(importsByDependency</span><span class="s2">, </span><span class="s1">dependency</span><span class="s2">, </span><span class="s1">getNewArray).push({</span>
                <span class="s1">imported</span><span class="s2">,</span>
                <span class="s1">local: variable.getName(</span><span class="s2">this</span><span class="s1">.snippets.getPropertyAccess)</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">importsByDependency</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getIncludedDynamicImports() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.includedDynamicImports) {</span>
            <span class="s2">return this</span><span class="s1">.includedDynamicImports</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">includedDynamicImports = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.orderedModules) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ node</span><span class="s2">, </span><span class="s1">resolution } of module.dynamicImports) {</span>
                <span class="s2">if </span><span class="s1">(!node.included) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s1">includedDynamicImports.push(resolution </span><span class="s2">instanceof </span><span class="s1">Module</span>
                    <span class="s1">? {</span>
                        <span class="s1">chunk: </span><span class="s2">this</span><span class="s1">.chunkByModule.get(resolution)</span><span class="s2">,</span>
                        <span class="s1">externalChunk: </span><span class="s2">null,</span>
                        <span class="s1">facadeChunk: </span><span class="s2">this</span><span class="s1">.facadeChunkByModule.get(resolution)</span><span class="s2">,</span>
                        <span class="s1">node</span><span class="s2">,</span>
                        <span class="s1">resolution</span>
                    <span class="s1">}</span>
                    <span class="s1">: resolution </span><span class="s2">instanceof </span><span class="s1">ExternalModule</span>
                        <span class="s1">? {</span>
                            <span class="s1">chunk: </span><span class="s2">null,</span>
                            <span class="s1">externalChunk: </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(resolution)</span><span class="s2">,</span>
                            <span class="s1">facadeChunk: </span><span class="s2">null,</span>
                            <span class="s1">node</span><span class="s2">,</span>
                            <span class="s1">resolution</span>
                        <span class="s1">}</span>
                        <span class="s1">: { chunk: </span><span class="s2">null, </span><span class="s1">externalChunk: </span><span class="s2">null, </span><span class="s1">facadeChunk: </span><span class="s2">null, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">resolution })</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.includedDynamicImports = includedDynamicImports)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getPreRenderedChunkInfo() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.preRenderedChunkInfo) {</span>
            <span class="s2">return this</span><span class="s1">.preRenderedChunkInfo</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ dynamicEntryModules</span><span class="s2">, </span><span class="s1">facadeModule</span><span class="s2">, </span><span class="s1">implicitEntryModules</span><span class="s2">, </span><span class="s1">orderedModules } = </span><span class="s2">this;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.preRenderedChunkInfo = {</span>
            <span class="s1">exports: </span><span class="s2">this</span><span class="s1">.getExportNames()</span><span class="s2">,</span>
            <span class="s1">facadeModuleId: facadeModule &amp;&amp; facadeModule.id</span><span class="s2">,</span>
            <span class="s1">isDynamicEntry: dynamicEntryModules.length &gt; </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">isEntry: !!facadeModule?.info.isEntry</span><span class="s2">,</span>
            <span class="s1">isImplicitEntry: implicitEntryModules.length &gt; </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">moduleIds: orderedModules.map(({ id }) =&gt; id)</span><span class="s2">,</span>
            <span class="s1">name: </span><span class="s2">this</span><span class="s1">.getChunkName()</span><span class="s2">,</span>
            <span class="s1">type: </span><span class="s3">'chunk'</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getPreserveModulesChunkNameFromModule(module) {</span>
        <span class="s2">const </span><span class="s1">predefinedChunkName = getPredefinedChunkNameFromModule(module)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(predefinedChunkName)</span>
            <span class="s2">return </span><span class="s1">predefinedChunkName</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ preserveModulesRoot</span><span class="s2">, </span><span class="s1">sanitizeFileName } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sanitizedId = sanitizeFileName(normalize(module.id.split(QUERY_HASH_REGEX</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">extensionName = extname(sanitizedId)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">idWithoutExtension = NON_ASSET_EXTENSIONS.has(extensionName)</span>
            <span class="s1">? sanitizedId.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-extensionName.length)</span>
            <span class="s1">: sanitizedId</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isAbsolute(idWithoutExtension)) {</span>
            <span class="s2">return </span><span class="s1">preserveModulesRoot &amp;&amp; resolve(idWithoutExtension).startsWith(preserveModulesRoot)</span>
                <span class="s1">? idWithoutExtension.slice(preserveModulesRoot.length).replace(</span><span class="s4">/^[/\\]/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
                <span class="s1">: relative(</span><span class="s2">this</span><span class="s1">.inputBase</span><span class="s2">, </span><span class="s1">idWithoutExtension)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s3">`_virtual/</span><span class="s1">${basename(idWithoutExtension)}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getReexportSpecifiers() {</span>
        <span class="s2">const </span><span class="s1">{ externalLiveBindings</span><span class="s2">, </span><span class="s1">interop } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">reexportSpecifiers = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.getExportNames()) {</span>
            <span class="s2">let </span><span class="s1">dependency</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">imported</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">needsLiveBinding = </span><span class="s2">false;</span>
            <span class="s2">if </span><span class="s1">(exportName[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'*'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">id = exportName.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(interop(id) === </span><span class="s3">'defaultOnly'</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.inputOptions.onwarn(errorUnexpectedNamespaceReexport(id))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">needsLiveBinding = externalLiveBindings</span><span class="s2">;</span>
                <span class="s1">dependency = </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(</span><span class="s2">this</span><span class="s1">.modulesById.get(id))</span><span class="s2">;</span>
                <span class="s1">imported = exportName = </span><span class="s3">'*'</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.exportsByName.get(exportName)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable)</span>
                    <span class="s2">continue;</span>
                <span class="s2">const </span><span class="s1">module = variable.module</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                    <span class="s1">dependency = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(module)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(dependency === </span><span class="s2">this</span><span class="s1">)</span>
                        <span class="s2">continue;</span>
                    <span class="s1">imported = dependency.getVariableExportName(variable)</span><span class="s2">;</span>
                    <span class="s1">needsLiveBinding = variable.isReassigned</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">dependency = </span><span class="s2">this</span><span class="s1">.externalChunkByModule.get(module)</span><span class="s2">;</span>
                    <span class="s1">imported = variable.name</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(imported !== </span><span class="s3">'default' </span><span class="s1">&amp;&amp; imported !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp; interop(module.id) === </span><span class="s3">'defaultOnly'</span><span class="s1">) {</span>
                        <span class="s2">return </span><span class="s1">error(errorUnexpectedNamedImport(module.id</span><span class="s2">, </span><span class="s1">imported</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">needsLiveBinding =</span>
                        <span class="s1">externalLiveBindings &amp;&amp;</span>
                            <span class="s1">(imported !== </span><span class="s3">'default' </span><span class="s1">|| isDefaultAProperty(interop(module.id)</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">getOrCreate(reexportSpecifiers</span><span class="s2">, </span><span class="s1">dependency</span><span class="s2">, </span><span class="s1">getNewArray).push({</span>
                <span class="s1">imported</span><span class="s2">,</span>
                <span class="s1">needsLiveBinding</span><span class="s2">,</span>
                <span class="s1">reexported: exportName</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">reexportSpecifiers</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getReferencedFiles() {</span>
        <span class="s2">const </span><span class="s1">referencedFiles = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.orderedModules) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">meta of module.importMetas) {</span>
                <span class="s2">const </span><span class="s1">fileName = meta.getReferencedFileName(</span><span class="s2">this</span><span class="s1">.pluginDriver)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(fileName) {</span>
                    <span class="s1">referencedFiles.add(fileName)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[...referencedFiles]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getRenderedDependencies() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderedDependencies) {</span>
            <span class="s2">return this</span><span class="s1">.renderedDependencies</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">importSpecifiers = </span><span class="s2">this</span><span class="s1">.getImportSpecifiers()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">reexportSpecifiers = </span><span class="s2">this</span><span class="s1">.getReexportSpecifiers()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">renderedDependencies = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">fileName = </span><span class="s2">this</span><span class="s1">.getFileName()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of </span><span class="s2">this</span><span class="s1">.dependencies) {</span>
            <span class="s2">const </span><span class="s1">imports = importSpecifiers.get(dep) || </span><span class="s2">null;</span>
            <span class="s2">const </span><span class="s1">reexports = reexportSpecifiers.get(dep) || </span><span class="s2">null;</span>
            <span class="s2">const </span><span class="s1">namedExportsMode = dep </span><span class="s2">instanceof </span><span class="s1">ExternalChunk || dep.exportMode !== </span><span class="s3">'default'</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">importPath = dep.getImportPath(fileName)</span><span class="s2">;</span>
            <span class="s1">renderedDependencies.set(dep</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">assertions: dep </span><span class="s2">instanceof </span><span class="s1">ExternalChunk ? dep.getImportAssertions(</span><span class="s2">this</span><span class="s1">.snippets) : </span><span class="s2">null,</span>
                <span class="s1">defaultVariableName: dep.defaultVariableName</span><span class="s2">,</span>
                <span class="s1">globalName: dep </span><span class="s2">instanceof </span><span class="s1">ExternalChunk &amp;&amp;</span>
                    <span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.format === </span><span class="s3">'umd' </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.outputOptions.format === </span><span class="s3">'iife'</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">getGlobalName(dep</span><span class="s2">, this</span><span class="s1">.outputOptions.globals</span><span class="s2">, </span><span class="s1">(imports || reexports) !== </span><span class="s2">null, this</span><span class="s1">.inputOptions.onwarn)</span><span class="s2">,</span>
                <span class="s1">importPath</span><span class="s2">,</span>
                <span class="s1">imports</span><span class="s2">,</span>
                <span class="s1">isChunk: dep </span><span class="s2">instanceof </span><span class="s1">Chunk</span><span class="s2">,</span>
                <span class="s1">name: dep.variableName</span><span class="s2">,</span>
                <span class="s1">namedExportsMode</span><span class="s2">,</span>
                <span class="s1">namespaceVariableName: dep.namespaceVariableName</span><span class="s2">,</span>
                <span class="s1">reexports</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderedDependencies = renderedDependencies)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">inlineChunkDependencies(chunk) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of chunk.dependencies) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.dependencies.has(dep))</span>
                <span class="s2">continue;</span>
            <span class="s2">this</span><span class="s1">.dependencies.add(dep)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(dep </span><span class="s2">instanceof </span><span class="s1">Chunk) {</span>
                <span class="s2">this</span><span class="s1">.inlineChunkDependencies(dep)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// This method changes properties on the AST before rendering and must not be async</span>
    <span class="s1">renderModules(fileName) {</span>
        <span class="s2">const </span><span class="s1">{ accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">exportNamesByVariable</span><span class="s2">, </span><span class="s1">includedNamespaces</span><span class="s2">, </span><span class="s1">inputOptions: { onwarn }</span><span class="s2">, </span><span class="s1">isEmpty</span><span class="s2">, </span><span class="s1">orderedModules</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">renderedModules</span><span class="s2">, </span><span class="s1">snippets } = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">{ compact</span><span class="s2">, </span><span class="s1">dynamicImportFunction</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">freeze</span><span class="s2">, </span><span class="s1">namespaceToStringTag } = outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">cnst</span><span class="s2">, </span><span class="s1">n } = snippets</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setDynamicImportResolutions(fileName)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setImportMetaResolutions(fileName)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setIdentifierRenderResolutions()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">magicString = </span><span class="s2">new </span><span class="s1">Bundle$1({ separator: </span><span class="s3">`</span><span class="s1">${n}${n}</span><span class="s3">` </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">indent = getIndentString(orderedModules</span><span class="s2">, </span><span class="s1">outputOptions)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">usedModules = []</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hoistedSource = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">accessedGlobals = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">renderedModuleSources = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">renderOptions = {</span>
            <span class="s1">dynamicImportFunction</span><span class="s2">,</span>
            <span class="s1">exportNamesByVariable</span><span class="s2">,</span>
            <span class="s1">format</span><span class="s2">,</span>
            <span class="s1">freeze</span><span class="s2">,</span>
            <span class="s1">indent</span><span class="s2">,</span>
            <span class="s1">namespaceToStringTag</span><span class="s2">,</span>
            <span class="s1">pluginDriver</span><span class="s2">,</span>
            <span class="s1">snippets</span><span class="s2">,</span>
            <span class="s1">useOriginalName: </span><span class="s2">null</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">usesTopLevelAwait = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of orderedModules) {</span>
            <span class="s2">let </span><span class="s1">renderedLength = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">source</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(module.isIncluded() || includedNamespaces.has(module)) {</span>
                <span class="s2">const </span><span class="s1">rendered = module.render(renderOptions)</span><span class="s2">;</span>
                <span class="s1">({ source } = rendered)</span><span class="s2">;</span>
                <span class="s1">usesTopLevelAwait || (usesTopLevelAwait = rendered.usesTopLevelAwait)</span><span class="s2">;</span>
                <span class="s1">renderedLength = source.length()</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(renderedLength) {</span>
                    <span class="s2">if </span><span class="s1">(compact &amp;&amp; source.lastLine().includes(</span><span class="s3">'//'</span><span class="s1">))</span>
                        <span class="s1">source.append(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">renderedModuleSources.set(module</span><span class="s2">, </span><span class="s1">source)</span><span class="s2">;</span>
                    <span class="s1">magicString.addSource(source)</span><span class="s2">;</span>
                    <span class="s1">usedModules.push(module)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">namespace = module.namespace</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(includedNamespaces.has(module)) {</span>
                    <span class="s2">const </span><span class="s1">rendered = namespace.renderBlock(renderOptions)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(namespace.renderFirst())</span>
                        <span class="s1">hoistedSource += n + rendered</span><span class="s2">;</span>
                    <span class="s2">else</span>
                        <span class="s1">magicString.addSource(</span><span class="s2">new </span><span class="s1">MagicString(rendered))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">accessedGlobalVariables = accessedGlobalsByScope.get(module.scope)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(accessedGlobalVariables) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name of accessedGlobalVariables) {</span>
                        <span class="s1">accessedGlobals.add(name)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ renderedExports</span><span class="s2">, </span><span class="s1">removedExports } = module.getRenderedExports()</span><span class="s2">;</span>
            <span class="s1">renderedModules[module.id] = {</span>
                <span class="s1">get code() {</span>
                    <span class="s2">return </span><span class="s1">source?.toString() ?? </span><span class="s2">null;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">originalLength: module.originalCode.length</span><span class="s2">,</span>
                <span class="s1">removedExports</span><span class="s2">,</span>
                <span class="s1">renderedExports</span><span class="s2">,</span>
                <span class="s1">renderedLength</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hoistedSource)</span>
            <span class="s1">magicString.prepend(hoistedSource + n + n)</span><span class="s2">;</span>
        <span class="s0">// eslint-disable-next-line unicorn/consistent-destructuring</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.needsExportsShim) {</span>
            <span class="s1">magicString.prepend(</span><span class="s3">`</span><span class="s1">${n}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">void 0;</span><span class="s1">${n}${n}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">renderedSource = compact ? magicString : magicString.trim()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isEmpty &amp;&amp; </span><span class="s2">this</span><span class="s1">.getExportNames().length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; dependencies.size === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">onwarn(errorEmptyChunk(</span><span class="s2">this</span><span class="s1">.getChunkName()))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ accessedGlobals</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">magicString</span><span class="s2">, </span><span class="s1">renderedSource</span><span class="s2">, </span><span class="s1">usedModules</span><span class="s2">, </span><span class="s1">usesTopLevelAwait }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setDynamicImportResolutions(fileName) {</span>
        <span class="s2">const </span><span class="s1">{ accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">snippets } = </span><span class="s2">this;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">resolvedDynamicImport of </span><span class="s2">this</span><span class="s1">.getIncludedDynamicImports()) {</span>
            <span class="s2">if </span><span class="s1">(resolvedDynamicImport.chunk) {</span>
                <span class="s2">const </span><span class="s1">{ chunk</span><span class="s2">, </span><span class="s1">facadeChunk</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">resolution } = resolvedDynamicImport</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(chunk === </span><span class="s2">this</span><span class="s1">) {</span>
                    <span class="s1">node.setInternalResolution(resolution.namespace)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">node.setExternalResolution((facadeChunk || chunk).exportMode</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s3">`'</span><span class="s1">${(facadeChunk || chunk).getImportPath(fileName)}</span><span class="s3">'`</span><span class="s2">, </span><span class="s1">!facadeChunk?.strictFacade &amp;&amp; chunk.exportNamesByVariable.get(resolution.namespace)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">{ node</span><span class="s2">, </span><span class="s1">resolution } = resolvedDynamicImport</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">[resolutionString</span><span class="s2">, </span><span class="s1">assertions] = </span><span class="s2">this</span><span class="s1">.getDynamicImportStringAndAssertions(resolution</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
                <span class="s1">node.setExternalResolution(</span><span class="s3">'external'</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">snippets</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">resolutionString</span><span class="s2">, false, </span><span class="s1">assertions)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setIdentifierRenderResolutions() {</span>
        <span class="s2">const </span><span class="s1">{ format</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">namespaceToStringTag</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">externalLiveBindings } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">syntheticExports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">exportName of </span><span class="s2">this</span><span class="s1">.getExportNames()) {</span>
            <span class="s2">const </span><span class="s1">exportVariable = </span><span class="s2">this</span><span class="s1">.exportsByName.get(exportName)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(format !== </span><span class="s3">'es' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">format !== </span><span class="s3">'system' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">exportVariable.isReassigned &amp;&amp;</span>
                <span class="s1">!exportVariable.isId) {</span>
                <span class="s1">exportVariable.setRenderNames(</span><span class="s3">'exports'</span><span class="s2">, </span><span class="s1">exportName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(exportVariable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s1">syntheticExports.add(exportVariable)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">exportVariable.setRenderNames(</span><span class="s2">null, null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.orderedModules) {</span>
            <span class="s2">if </span><span class="s1">(module.needsExportShim) {</span>
                <span class="s2">this</span><span class="s1">.needsExportsShim = </span><span class="s2">true;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">usedNames = </span><span class="s2">new </span><span class="s1">Set([</span><span class="s3">'Object'</span><span class="s2">, </span><span class="s3">'Promise'</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.needsExportsShim) {</span>
            <span class="s1">usedNames.add(MISSING_EXPORT_SHIM_VARIABLE)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(namespaceToStringTag) {</span>
            <span class="s1">usedNames.add(</span><span class="s3">'Symbol'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">switch </span><span class="s1">(format) {</span>
            <span class="s2">case </span><span class="s3">'system'</span><span class="s1">: {</span>
                <span class="s1">usedNames.add(</span><span class="s3">'module'</span><span class="s1">).add(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'es'</span><span class="s1">: {</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s3">'cjs'</span><span class="s1">: {</span>
                <span class="s1">usedNames.add(</span><span class="s3">'module'</span><span class="s1">).add(</span><span class="s3">'require'</span><span class="s1">).add(</span><span class="s3">'__filename'</span><span class="s1">).add(</span><span class="s3">'__dirname'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// fallthrough</span>
            <span class="s2">default</span><span class="s1">: {</span>
                <span class="s1">usedNames.add(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">helper of HELPER_NAMES) {</span>
                    <span class="s1">usedNames.add(helper)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">deconflictChunk(</span><span class="s2">this</span><span class="s1">.orderedModules</span><span class="s2">, this</span><span class="s1">.getDependenciesToBeDeconflicted(format !== </span><span class="s3">'es' </span><span class="s1">&amp;&amp; format !== </span><span class="s3">'system'</span><span class="s2">, </span><span class="s1">format === </span><span class="s3">'amd' </span><span class="s1">|| format === </span><span class="s3">'umd' </span><span class="s1">|| format === </span><span class="s3">'iife'</span><span class="s2">, </span><span class="s1">interop)</span><span class="s2">, this</span><span class="s1">.imports</span><span class="s2">, </span><span class="s1">usedNames</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">interop</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">externalLiveBindings</span><span class="s2">, this</span><span class="s1">.chunkByModule</span><span class="s2">, this</span><span class="s1">.externalChunkByModule</span><span class="s2">, </span><span class="s1">syntheticExports</span><span class="s2">, this</span><span class="s1">.exportNamesByVariable</span><span class="s2">, this</span><span class="s1">.accessedGlobalsByScope</span><span class="s2">, this</span><span class="s1">.includedNamespaces)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setImportMetaResolutions(fileName) {</span>
        <span class="s2">const </span><span class="s1">{ accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">includedNamespaces</span><span class="s2">, </span><span class="s1">orderedModules</span><span class="s2">, </span><span class="s1">outputOptions: { format } } = </span><span class="s2">this;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of orderedModules) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importMeta of module.importMetas) {</span>
                <span class="s1">importMeta.setResolution(format</span><span class="s2">, </span><span class="s1">accessedGlobalsByScope</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(includedNamespaces.has(module)) {</span>
                <span class="s1">module.namespace.prepare(accessedGlobalsByScope)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">setUpChunkImportsAndExportsForModule(module) {</span>
        <span class="s2">const </span><span class="s1">moduleImports = </span><span class="s2">new </span><span class="s1">Set(module.includedImports)</span><span class="s2">;</span>
        <span class="s0">// when we are not preserving modules, we need to make all namespace variables available for</span>
        <span class="s0">// rendering the namespace object</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules &amp;&amp; </span><span class="s2">this</span><span class="s1">.includedNamespaces.has(module)) {</span>
            <span class="s2">const </span><span class="s1">memberVariables = module.namespace.getMemberVariables()</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">variable of Object.values(memberVariables)) {</span>
                <span class="s1">moduleImports.add(variable)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">variable of moduleImports) {</span>
            <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">ExportDefaultVariable) {</span>
                <span class="s1">variable = variable.getOriginalVariable()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(variable </span><span class="s2">instanceof </span><span class="s1">SyntheticNamedExportVariable) {</span>
                <span class="s1">variable = variable.getBaseVariable()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">this</span><span class="s1">.chunkByModule.get(variable.module)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(chunk !== </span><span class="s2">this</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.imports.add(variable)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(variable.module </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                    <span class="s2">this</span><span class="s1">.checkCircularDependencyImport(variable</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
                    <span class="s0">// When preserving modules, we do not create namespace objects but directly</span>
                    <span class="s0">// use the actual namespaces, which would be broken by this logic.</span>
                    <span class="s2">if </span><span class="s1">(!(variable </span><span class="s2">instanceof </span><span class="s1">NamespaceVariable &amp;&amp; </span><span class="s2">this</span><span class="s1">.outputOptions.preserveModules)) {</span>
                        <span class="s1">chunk.exports.add(variable)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.includedNamespaces.has(module) ||</span>
            <span class="s1">(module.info.isEntry &amp;&amp; module.preserveSignature !== </span><span class="s2">false</span><span class="s1">) ||</span>
            <span class="s1">module.includedDynamicImporters.some(importer =&gt; </span><span class="s2">this</span><span class="s1">.chunkByModule.get(importer) !== </span><span class="s2">this</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.ensureReexportsAreAvailableForModule(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ node</span><span class="s2">, </span><span class="s1">resolution } of module.dynamicImports) {</span>
            <span class="s2">if </span><span class="s1">(node.included &amp;&amp;</span>
                <span class="s1">resolution </span><span class="s2">instanceof </span><span class="s1">Module &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.chunkByModule.get(resolution) === </span><span class="s2">this </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.includedNamespaces.has(resolution)) {</span>
                <span class="s2">this</span><span class="s1">.includedNamespaces.add(resolution)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.ensureReexportsAreAvailableForModule(resolution)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunkNameFromModule(module) {</span>
    <span class="s2">return </span><span class="s1">getPredefinedChunkNameFromModule(module) ?? getAliasName(module.id)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPredefinedChunkNameFromModule(module) {</span>
    <span class="s2">return </span><span class="s1">(module.chunkNames.find(({ isUserDefined }) =&gt; isUserDefined)?.name ?? module.chunkNames[</span><span class="s4">0</span><span class="s1">]?.name)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getImportedBindingsPerDependency(renderedDependencies</span><span class="s2">, </span><span class="s1">resolveFileName) {</span>
    <span class="s2">const </span><span class="s1">importedBindingsPerDependency = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[dependency</span><span class="s2">, </span><span class="s1">declaration] of renderedDependencies) {</span>
        <span class="s2">const </span><span class="s1">specifiers = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(declaration.imports) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imported } of declaration.imports) {</span>
                <span class="s1">specifiers.add(imported)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(declaration.reexports) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ imported } of declaration.reexports) {</span>
                <span class="s1">specifiers.add(imported)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">importedBindingsPerDependency[resolveFileName(dependency)] = [...specifiers]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">importedBindingsPerDependency</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">QUERY_HASH_REGEX = </span><span class="s4">/[#?]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">resolveFileName = (dependency) =&gt; dependency.getFileName()</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Concatenate a number of iterables to a new iterable without fully evaluating</span>
 <span class="s5">* their iterators. Useful when e.g. working with large sets or lists and when</span>
 <span class="s5">* there is a chance that the iterators will not be fully exhausted.</span>
 <span class="s5">*/</span>
<span class="s2">function</span><span class="s1">* concatLazy(iterables) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">iterable of iterables) {</span>
        <span class="s2">yield</span><span class="s1">* iterable</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* At its core, the algorithm first starts from each static or dynamic entry</span>
 <span class="s5">* point and then assigns that entry point to all modules than can be reached</span>
 <span class="s5">* via static imports. We call this the *dependent entry points* of that</span>
 <span class="s5">* module.</span>
 <span class="s5">*</span>
 <span class="s5">* Then we group all modules with the same dependent entry points into chunks</span>
 <span class="s5">* as those modules will always be loaded together.</span>
 <span class="s5">*</span>
 <span class="s5">* One non-trivial optimization we can apply is that dynamic entries are</span>
 <span class="s5">* different from static entries in so far as when a dynamic import occurs,</span>
 <span class="s5">* some</span>
 <span class="s5">* modules are already in memory. If some of these modules are also</span>
 <span class="s5">* dependencies</span>
 <span class="s5">* of the dynamic entry, then it does not make sense to create a separate chunk</span>
 <span class="s5">* for them. Instead, the dynamic import target can load them from the</span>
 <span class="s5">* importing</span>
 <span class="s5">* chunk.</span>
 <span class="s5">*</span>
 <span class="s5">* With regard to chunking, if B is implicitly loaded after A, then this can be</span>
 <span class="s5">* handled the same way as if there was a dynamic import A =&gt; B.</span>
 <span class="s5">*</span>
 <span class="s5">* Example:</span>
 <span class="s5">* Assume A -&gt; B (A imports B), A =&gt; C (A dynamically imports C) and C -&gt; B.</span>
 <span class="s5">* Then the initial algorithm would assign A into the A chunk, C into the C</span>
 <span class="s5">* chunk and B into the AC chunk, i.e. the chunk with the dependent entry</span>
 <span class="s5">* points</span>
 <span class="s5">* A and C.</span>
 <span class="s5">* However we know that C can only be loaded from A, so A and its dependency B</span>
 <span class="s5">* must already be in memory when C is loaded. So it is enough to create only</span>
 <span class="s5">* two chunks A containing [AB] and C containing [C].</span>
 <span class="s5">*</span>
 <span class="s5">* So we do not assign the dynamic entry C as dependent entry point to modules</span>
 <span class="s5">* that are already loaded.</span>
 <span class="s5">*</span>
 <span class="s5">* In a more complex example, let us assume that we have entry points X and Y.</span>
 <span class="s5">* Further, let us assume</span>
 <span class="s5">* X -&gt; A, X -&gt; B, X -&gt; C,</span>
 <span class="s5">* Y -&gt; A, Y -&gt; B,</span>
 <span class="s5">* A =&gt; D,</span>
 <span class="s5">* D -&gt; B, D -&gt; C</span>
 <span class="s5">* So without dynamic import optimization, the dependent entry points are</span>
 <span class="s5">* A: XY, B: DXY, C: DX, D: D, X: X, Y: Y,</span>
 <span class="s5">* so we would for now create six chunks.</span>
 <span class="s5">*</span>
 <span class="s5">* Now D is loaded only after A is loaded. But A is loaded if either X is</span>
 <span class="s5">* loaded</span>
 <span class="s5">* or Y is loaded. So the modules that are already in memory when D is loaded</span>
 <span class="s5">* are the intersection of all modules that X depends on with all modules that</span>
 <span class="s5">* Y</span>
 <span class="s5">* depends on, which in this case are the modules A and B.</span>
 <span class="s5">* We could also say they are all modules that have both X and Y as dependent</span>
 <span class="s5">* entry points.</span>
 <span class="s5">*</span>
 <span class="s5">* So we can remove D as dependent entry point from A and B, which means they</span>
 <span class="s5">* both now have only XY as dependent entry points and can be merged into the</span>
 <span class="s5">* same chunk.</span>
 <span class="s5">*</span>
 <span class="s5">* Now let us extend this to the most general case where we have several</span>
 <span class="s5">* dynamic</span>
 <span class="s5">* importers for one dynamic entry point.</span>
 <span class="s5">*</span>
 <span class="s5">* In the most general form, it works like this:</span>
 <span class="s5">* For each dynamic entry point, we have a number of dynamic importers, which</span>
 <span class="s5">* are the modules importing it. Using the previous ideas, we can determine</span>
 <span class="s5">* the modules already in memory for each dynamic importer by looking for all</span>
 <span class="s5">* modules that have all the dependent entry points of the dynamic importer as</span>
 <span class="s5">* dependent entry points.</span>
 <span class="s5">* So the modules that are guaranteed to be in memory when the dynamic entry</span>
 <span class="s5">* point is loaded are the intersection of the modules already in memory for</span>
 <span class="s5">* each dynamic importer.</span>
 <span class="s5">*</span>
 <span class="s5">* Assuming that A =&gt; D and B =&gt; D and A has dependent entry points XY and B</span>
 <span class="s5">* has</span>
 <span class="s5">* dependent entry points YZ, then the modules guaranteed to be in memory are</span>
 <span class="s5">* all modules that have at least XYZ as dependent entry points.</span>
 <span class="s5">* We call XYZ the *dynamically dependent entry points* of D.</span>
 <span class="s5">*</span>
 <span class="s5">* Now there is one last case to consider: If one of the dynamically dependent</span>
 <span class="s5">* entries is itself a dynamic entry, then any module is in memory that either</span>
 <span class="s5">* is a dependency of that dynamic entry or again has the dynamic dependent</span>
 <span class="s5">* entries of that dynamic entry as dependent entry points.</span>
 <span class="s5">*</span>
 <span class="s5">* A naive algorithm for this proved to be costly as it contained an O(n^3)</span>
 <span class="s5">* complexity with regard to dynamic entries that blew up for very large</span>
 <span class="s5">* projects.</span>
 <span class="s5">*</span>
 <span class="s5">* If we have an efficient way to do Set operations, an alternative approach</span>
 <span class="s5">* would be to instead collect already loaded modules per dynamic entry. And as</span>
 <span class="s5">* all chunks from the initial grouping would behave the same, we can instead</span>
 <span class="s5">* collect already loaded chunks for a performance improvement.</span>
 <span class="s5">*</span>
 <span class="s5">* To do that efficiently, need</span>
 <span class="s5">* - a Map of dynamic imports per dynamic entry, which contains all dynamic</span>
 <span class="s5">*   imports that can be triggered by a dynamic entry</span>
 <span class="s5">* - a Map of static dependencies per entry</span>
 <span class="s5">* - a Map of already loaded chunks per entry that we initially populate with</span>
 <span class="s5">*   empty Sets for static entries and Sets containing all entries for dynamic</span>
 <span class="s5">*   entries</span>
 <span class="s5">*</span>
 <span class="s5">* For efficient operations, we assign each entry a numerical index and</span>
 <span class="s5">* represent Sets of Chunks as BigInt values where each chunk corresponds to a</span>
 <span class="s5">* bit index. Then thw last two maps can be represented as arrays of BigInt</span>
 <span class="s5">* values.</span>
 <span class="s5">*</span>
 <span class="s5">* Then we iterate through each dynamic entry. We set the already loaded modules</span>
 <span class="s5">* to the intersection of the previously already loaded modules with the union</span>
 <span class="s5">* of the already loaded modules of that chunk with its static dependencies.</span>
 <span class="s5">*</span>
 <span class="s5">* If the already loaded modules changed, then we use the Map of dynamic imports</span>
 <span class="s5">* per dynamic entry to marks all dynamic entry dependencies as &quot;dirty&quot; and put</span>
 <span class="s5">* them back into the iteration. As an additional optimization, we note for</span>
 <span class="s5">* each dynamic entry which dynamic dependent entries have changed and only</span>
 <span class="s5">* intersect those entries again on subsequent interations.</span>
 <span class="s5">*</span>
 <span class="s5">* Then we remove the dynamic entries from the list of dependent entries for</span>
 <span class="s5">* those chunks that are already loaded for that dynamic entry and create</span>
 <span class="s5">* another round of chunks.</span>
 <span class="s5">*/</span>
<span class="s2">function </span><span class="s1">getChunkAssignments(entries</span><span class="s2">, </span><span class="s1">manualChunkAliasByEntry</span><span class="s2">, </span><span class="s1">minChunkSize) {</span>
    <span class="s2">const </span><span class="s1">{ chunkDefinitions</span><span class="s2">, </span><span class="s1">modulesInManualChunks } = getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ allEntries</span><span class="s2">, </span><span class="s1">dependentEntriesByModule</span><span class="s2">, </span><span class="s1">dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">, </span><span class="s1">dynamicImportsByEntry } = analyzeModuleGraph(entries)</span><span class="s2">;</span>
    <span class="s0">// Each chunk is identified by its position in this array</span>
    <span class="s2">const </span><span class="s1">initialChunks = Object.values(getChunksBySignature(getModulesWithDependentEntries(dependentEntriesByModule</span><span class="s2">, </span><span class="s1">modulesInManualChunks)))</span><span class="s2">;</span>
    <span class="s0">// This mutates initialChunks but also clears</span>
    <span class="s0">// dynamicallyDependentEntriesByDynamicEntry as side effect</span>
    <span class="s1">removeUnnecessaryDependentEntries(initialChunks</span><span class="s2">, </span><span class="s1">dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">, </span><span class="s1">dynamicImportsByEntry</span><span class="s2">, </span><span class="s1">allEntries)</span><span class="s2">;</span>
    <span class="s1">chunkDefinitions.push(...createChunks(allEntries</span><span class="s2">, </span><span class="s1">getChunksBySignature(initialChunks)</span><span class="s2">, </span><span class="s1">minChunkSize))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">chunkDefinitions</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry) {</span>
    <span class="s2">const </span><span class="s1">chunkDefinitions = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">modulesInManualChunks = </span><span class="s2">new </span><span class="s1">Set(manualChunkAliasByEntry.keys())</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">manualChunkModulesByAlias = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entry</span><span class="s2">, </span><span class="s1">alias] of manualChunkAliasByEntry) {</span>
        <span class="s1">addStaticDependenciesToManualChunk(entry</span><span class="s2">, </span><span class="s1">(manualChunkModulesByAlias[alias] || (manualChunkModulesByAlias[alias] = []))</span><span class="s2">, </span><span class="s1">modulesInManualChunks)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[alias</span><span class="s2">, </span><span class="s1">modules] of Object.entries(manualChunkModulesByAlias)) {</span>
        <span class="s1">chunkDefinitions.push({ alias</span><span class="s2">, </span><span class="s1">modules })</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ chunkDefinitions</span><span class="s2">, </span><span class="s1">modulesInManualChunks }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addStaticDependenciesToManualChunk(entry</span><span class="s2">, </span><span class="s1">manualChunkModules</span><span class="s2">, </span><span class="s1">modulesInManualChunks) {</span>
    <span class="s2">const </span><span class="s1">modulesToHandle = </span><span class="s2">new </span><span class="s1">Set([entry])</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modulesToHandle) {</span>
        <span class="s1">modulesInManualChunks.add(module)</span><span class="s2">;</span>
        <span class="s1">manualChunkModules.push(module)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.dependencies) {</span>
            <span class="s2">if </span><span class="s1">(!(dependency </span><span class="s2">instanceof </span><span class="s1">ExternalModule || modulesInManualChunks.has(dependency))) {</span>
                <span class="s1">modulesToHandle.add(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">analyzeModuleGraph(entries) {</span>
    <span class="s2">const </span><span class="s1">dynamicEntryModules = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dependentEntriesByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicImportModulesByEntry = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">allEntriesSet = </span><span class="s2">new </span><span class="s1">Set(entries)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">entryIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">currentEntry of allEntriesSet) {</span>
        <span class="s2">const </span><span class="s1">dynamicImportsForCurrentEntry = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s1">dynamicImportModulesByEntry.push(dynamicImportsForCurrentEntry)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">modulesToHandle = </span><span class="s2">new </span><span class="s1">Set([currentEntry])</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modulesToHandle) {</span>
            <span class="s1">getOrCreate(dependentEntriesByModule</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">(getNewSet)).add(entryIndex)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.getDependenciesToBeIncluded()) {</span>
                <span class="s2">if </span><span class="s1">(!(dependency </span><span class="s2">instanceof </span><span class="s1">ExternalModule)) {</span>
                    <span class="s1">modulesToHandle.add(dependency)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ resolution } of module.dynamicImports) {</span>
                <span class="s2">if </span><span class="s1">(resolution </span><span class="s2">instanceof </span><span class="s1">Module &amp;&amp;</span>
                    <span class="s1">resolution.includedDynamicImporters.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!allEntriesSet.has(resolution)) {</span>
                    <span class="s1">dynamicEntryModules.add(resolution)</span><span class="s2">;</span>
                    <span class="s1">allEntriesSet.add(resolution)</span><span class="s2">;</span>
                    <span class="s1">dynamicImportsForCurrentEntry.add(resolution)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.implicitlyLoadedBefore) {</span>
                <span class="s2">if </span><span class="s1">(!allEntriesSet.has(dependency)) {</span>
                    <span class="s1">dynamicEntryModules.add(dependency)</span><span class="s2">;</span>
                    <span class="s1">allEntriesSet.add(dependency)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">entryIndex++</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">allEntries = [...allEntriesSet]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ dynamicEntries</span><span class="s2">, </span><span class="s1">dynamicImportsByEntry } = getDynamicEntries(allEntries</span><span class="s2">, </span><span class="s1">dynamicEntryModules</span><span class="s2">, </span><span class="s1">dynamicImportModulesByEntry)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">allEntries</span><span class="s2">,</span>
        <span class="s1">dependentEntriesByModule</span><span class="s2">,</span>
        <span class="s1">dynamicallyDependentEntriesByDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule</span><span class="s2">, </span><span class="s1">dynamicEntries</span><span class="s2">, </span><span class="s1">allEntries)</span><span class="s2">,</span>
        <span class="s1">dynamicImportsByEntry</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDynamicEntries(allEntries</span><span class="s2">, </span><span class="s1">dynamicEntryModules</span><span class="s2">, </span><span class="s1">dynamicImportModulesByEntry) {</span>
    <span class="s2">const </span><span class="s1">entryIndexByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicEntries = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[entryIndex</span><span class="s2">, </span><span class="s1">entry] of allEntries.entries()) {</span>
        <span class="s1">entryIndexByModule.set(entry</span><span class="s2">, </span><span class="s1">entryIndex)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(dynamicEntryModules.has(entry)) {</span>
            <span class="s1">dynamicEntries.add(entryIndex)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">dynamicImportsByEntry = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dynamicImportModules of dynamicImportModulesByEntry) {</span>
        <span class="s2">const </span><span class="s1">dynamicImports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dynamicEntry of dynamicImportModules) {</span>
            <span class="s1">dynamicImports.add(entryIndexByModule.get(dynamicEntry))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">dynamicImportsByEntry.push(dynamicImports)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ dynamicEntries</span><span class="s2">, </span><span class="s1">dynamicImportsByEntry }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule</span><span class="s2">, </span><span class="s1">dynamicEntries</span><span class="s2">, </span><span class="s1">allEntries) {</span>
    <span class="s2">const </span><span class="s1">dynamicallyDependentEntriesByDynamicEntry = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dynamicEntryIndex of dynamicEntries) {</span>
        <span class="s2">const </span><span class="s1">dynamicallyDependentEntries = getOrCreate(dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">, </span><span class="s1">dynamicEntryIndex</span><span class="s2">, </span><span class="s1">(getNewSet))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">dynamicEntry = allEntries[dynamicEntryIndex]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importer of concatLazy([</span>
            <span class="s1">dynamicEntry.includedDynamicImporters</span><span class="s2">,</span>
            <span class="s1">dynamicEntry.implicitlyLoadedAfter</span>
        <span class="s1">])) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entry of dependentEntriesByModule.get(importer)) {</span>
                <span class="s1">dynamicallyDependentEntries.add(entry)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunksBySignature(modulesWithDependentEntries) {</span>
    <span class="s2">var </span><span class="s1">_a</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">chunkModules = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ dependentEntries</span><span class="s2">, </span><span class="s1">modules } of modulesWithDependentEntries) {</span>
        <span class="s2">let </span><span class="s1">chunkSignature = </span><span class="s4">0n</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of dependentEntries) {</span>
            <span class="s1">chunkSignature |= </span><span class="s4">1n </span><span class="s1">&lt;&lt; BigInt(entryIndex)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">(chunkModules[_a = String(chunkSignature)] || (chunkModules[_a] = {</span>
            <span class="s1">dependentEntries: </span><span class="s2">new </span><span class="s1">Set(dependentEntries)</span><span class="s2">,</span>
            <span class="s1">modules: []</span>
        <span class="s1">})).modules.push(...modules)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">chunkModules</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function</span><span class="s1">* getModulesWithDependentEntries(dependentEntriesByModule</span><span class="s2">, </span><span class="s1">modulesInManualChunks) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[module</span><span class="s2">, </span><span class="s1">dependentEntries] of dependentEntriesByModule) {</span>
        <span class="s2">if </span><span class="s1">(!modulesInManualChunks.has(module)) {</span>
            <span class="s2">yield </span><span class="s1">{ dependentEntries</span><span class="s2">, </span><span class="s1">modules: [module] }</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* This removes all unnecessary dynamic entries from the dependenEntries in its</span>
 <span class="s5">* first argument. It will also consume its second argument, so if</span>
 <span class="s5">* dynamicallyDependentEntriesByDynamicEntry is ever needed after this, we</span>
 <span class="s5">* should make a copy.</span>
 <span class="s5">*/</span>
<span class="s2">function </span><span class="s1">removeUnnecessaryDependentEntries(chunks</span><span class="s2">, </span><span class="s1">dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">, </span><span class="s1">dynamicImportsByEntry</span><span class="s2">, </span><span class="s1">allEntries) {</span>
    <span class="s0">// The indices correspond to the indices in allEntries. The chunks correspond</span>
    <span class="s0">// to bits in the bigint values where chunk 0 is the lowest bit.</span>
    <span class="s2">const </span><span class="s1">staticDependenciesPerEntry = allEntries.map(() =&gt; </span><span class="s4">0n</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">alreadyLoadedChunksPerEntry = allEntries.map((_entry</span><span class="s2">, </span><span class="s1">entryIndex) =&gt; dynamicallyDependentEntriesByDynamicEntry.has(entryIndex) ? -</span><span class="s4">1n </span><span class="s1">: </span><span class="s4">0n</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">// This toggles the bits for each chunk that is a dependency of an entry</span>
    <span class="s2">let </span><span class="s1">chunkMask = </span><span class="s4">1n</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ dependentEntries } of chunks) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of dependentEntries) {</span>
            <span class="s1">staticDependenciesPerEntry[entryIndex] |= chunkMask</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">chunkMask &lt;&lt;= </span><span class="s4">1n</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Warning: This will consume dynamicallyDependentEntriesByDynamicEntry.</span>
    <span class="s0">// If we no longer want this, we should make a copy here.</span>
    <span class="s2">const </span><span class="s1">updatedDynamicallyDependentEntriesByDynamicEntry = dynamicallyDependentEntriesByDynamicEntry</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[dynamicEntryIndex</span><span class="s2">, </span><span class="s1">updatedDynamicallyDependentEntries] of updatedDynamicallyDependentEntriesByDynamicEntry) {</span>
        <span class="s1">updatedDynamicallyDependentEntriesByDynamicEntry.delete(dynamicEntryIndex)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">previousLoadedModules = alreadyLoadedChunksPerEntry[dynamicEntryIndex]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">newLoadedModules = previousLoadedModules</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of updatedDynamicallyDependentEntries) {</span>
            <span class="s1">newLoadedModules &amp;=</span>
                <span class="s1">staticDependenciesPerEntry[entryIndex] | alreadyLoadedChunksPerEntry[entryIndex]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(newLoadedModules !== previousLoadedModules) {</span>
            <span class="s1">alreadyLoadedChunksPerEntry[dynamicEntryIndex] = newLoadedModules</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dynamicImport of dynamicImportsByEntry[dynamicEntryIndex]) {</span>
                <span class="s1">getOrCreate(updatedDynamicallyDependentEntriesByDynamicEntry</span><span class="s2">, </span><span class="s1">dynamicImport</span><span class="s2">, </span><span class="s1">(getNewSet)).add(dynamicEntryIndex)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// Remove entries from dependent entries if a chunk is already loaded without</span>
    <span class="s0">// that entry.</span>
    <span class="s1">chunkMask = </span><span class="s4">1n</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ dependentEntries } of chunks) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of dependentEntries) {</span>
            <span class="s2">if </span><span class="s1">((alreadyLoadedChunksPerEntry[entryIndex] &amp; chunkMask) === chunkMask) {</span>
                <span class="s1">dependentEntries.delete(entryIndex)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">chunkMask &lt;&lt;= </span><span class="s4">1n</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createChunks(allEntries</span><span class="s2">, </span><span class="s1">chunkModulesBySignature</span><span class="s2">, </span><span class="s1">minChunkSize) {</span>
    <span class="s2">return </span><span class="s1">minChunkSize === </span><span class="s4">0</span>
        <span class="s1">? Object.values(chunkModulesBySignature).map(({ modules }) =&gt; ({</span>
            <span class="s1">alias: </span><span class="s2">null,</span>
            <span class="s1">modules</span>
        <span class="s1">}))</span>
        <span class="s1">: getOptimizedChunks(chunkModulesBySignature</span><span class="s2">, </span><span class="s1">allEntries.length</span><span class="s2">, </span><span class="s1">minChunkSize).map(({ modules }) =&gt; ({</span>
            <span class="s1">alias: </span><span class="s2">null,</span>
            <span class="s1">modules</span>
        <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* This function tries to get rid of small chunks by merging them with other</span>
 <span class="s5">* chunks.</span>
 <span class="s5">*</span>
 <span class="s5">* We can only merge chunks safely if after the merge, loading any entry point</span>
 <span class="s5">* in any allowed order will not trigger side effects that should not have been</span>
 <span class="s5">* triggered. While side effects are usually things like global function calls,</span>
 <span class="s5">* global variable mutations or potentially thrown errors, details do not</span>
 <span class="s5">* matter here, and we just discern chunks without side effects (pure chunks)</span>
 <span class="s5">* from other chunks.</span>
 <span class="s5">*</span>
 <span class="s5">* As a first step, we assign each pre-generated chunk with side effects a</span>
 <span class="s5">* label. I.e. we have side effect &quot;A&quot; if the non-pure chunk &quot;A&quot; is loaded.</span>
 <span class="s5">*</span>
 <span class="s5">* Now to determine the side effects of loading a chunk, one also has to take</span>
 <span class="s5">* the side effects of its dependencies into account. So if A depends on B</span>
 <span class="s5">* (A -&gt; B) and both have side effects, loading A triggers effects AB.</span>
 <span class="s5">*</span>
 <span class="s5">* Now from the previous step we know that each chunk is uniquely determine by</span>
 <span class="s5">* the entry points that depend on it and cause it to load, which we will call</span>
 <span class="s5">* its dependent entry points.</span>
 <span class="s5">*</span>
 <span class="s5">* E.g. if X -&gt; A and Y -&gt; A, then the dependent entry points of A are XY.</span>
 <span class="s5">* Starting from that idea, we can determine a set of chunks—and thus a set</span>
 <span class="s5">* of side effects—that must have been triggered if a certain chunk has been</span>
 <span class="s5">* loaded. Basically, it is the intersection of all chunks loaded by the</span>
 <span class="s5">* dependent entry points of a given chunk. We call the corresponding side</span>
 <span class="s5">* effects the correlated side effects of that chunk.</span>
 <span class="s5">*</span>
 <span class="s5">* Example:</span>
 <span class="s5">* X -&gt; ABC, Y -&gt; ADE, A-&gt; F, B -&gt; D</span>
 <span class="s5">* Then taking dependencies into account, X -&gt; ABCDF, Y -&gt; ADEF</span>
 <span class="s5">* The intersection is ADF. So we know that when A is loaded, D and F must also</span>
 <span class="s5">* be in memory even though neither D nor A is a dependency of the other.</span>
 <span class="s5">* If all have side effects, we call ADF the correlated side effects of A. The</span>
 <span class="s5">* correlated side effects need to remain constant when merging chunks.</span>
 <span class="s5">*</span>
 <span class="s5">* In contrast, we have the dependency side effects of A, which represents</span>
 <span class="s5">* the side effects we trigger if we directly load A. In this example, the</span>
 <span class="s5">* dependency side effects are AF.</span>
 <span class="s5">* For entry chunks, dependency and correlated side effects are the same.</span>
 <span class="s5">*</span>
 <span class="s5">* With these concepts, merging chunks is allowed if the correlated side effects</span>
 <span class="s5">* of each entry do not change. Thus, we are allowed to merge two chunks if</span>
 <span class="s5">* a) the dependency side effects of each chunk are a subset of the correlated</span>
 <span class="s5">*    side effects of the other chunk, so no additional side effects are</span>
 <span class="s5">*    triggered for any entry, or</span>
 <span class="s5">* b) The signature of chunk A is a subset of the signature of chunk B while the</span>
 <span class="s5">*    dependency side effects of A are a subset of the correlated side effects</span>
 <span class="s5">*    of B. Because in that scenario, whenever A is loaded, B is loaded as well.</span>
 <span class="s5">*    But there are cases when B is loaded where A is not loaded. So if we merge</span>
 <span class="s5">*    the chunks, all dependency side effects of A will be added to the</span>
 <span class="s5">*    correlated side effects of B, and as the latter is not allowed to change,</span>
 <span class="s5">*    the former need to be a subset of the latter.</span>
 <span class="s5">*</span>
 <span class="s5">* Another consideration when merging small chunks into other chunks is to avoid</span>
 <span class="s5">* that too much additional code is loaded. This is achieved when the dependent</span>
 <span class="s5">* entries of the small chunk are a subset of the dependent entries of the other</span>
 <span class="s5">* chunk. Because then when the small chunk is loaded, the other chunk was</span>
 <span class="s5">* loaded/in memory anyway, so at most when the other chunk is loaded, the</span>
 <span class="s5">* additional size of the small chunk is loaded unnecessarily.</span>
 <span class="s5">*</span>
 <span class="s5">* So the algorithm performs merges in two passes:</span>
 <span class="s5">* 1. First we try to merge small chunks A only into other chunks B if the</span>
 <span class="s5">*    dependent entries of A are a subset of the dependent entries of B and the</span>
 <span class="s5">*    dependency side effects of A are a subset of the correlated side effects</span>
 <span class="s5">*    of B.</span>
 <span class="s5">* 2. Only then for all remaining small chunks, we look for arbitrary merges</span>
 <span class="s5">*    following the above rules (a) and (b), starting with the smallest chunks</span>
 <span class="s5">*    to look for possible merge targets.</span>
 <span class="s5">*/</span>
<span class="s0">// TODO instead of picking the &quot;closest&quot; chunk, we could actually use a</span>
<span class="s0">//  technique similar to what we do for side effects to compare the size of the</span>
<span class="s0">//  static dependencies that are not part of the correlated dependencies</span>
<span class="s2">function </span><span class="s1">getOptimizedChunks(chunkModulesBySignature</span><span class="s2">, </span><span class="s1">numberOfEntries</span><span class="s2">, </span><span class="s1">minChunkSize) {</span>
    <span class="s1">timeStart(</span><span class="s3">'optimize chunks'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">chunkPartition = getPartitionedChunks(chunkModulesBySignature</span><span class="s2">, </span><span class="s1">numberOfEntries</span><span class="s2">, </span><span class="s1">minChunkSize)</span><span class="s2">;</span>
    <span class="s1">console.log(</span><span class="s3">'Before eliminating small chunks, there were</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">Object.keys(chunkModulesBySignature).length</span><span class="s2">, </span><span class="s3">'chunks, of which</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">chunkPartition.small.size</span><span class="s2">, </span><span class="s3">'were below minChunkSize.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(chunkPartition.small.size &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">mergeChunks(chunkPartition</span><span class="s2">, </span><span class="s1">minChunkSize)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">console.log(</span><span class="s3">'After merging chunks,</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">chunkPartition.small.size + chunkPartition.big.size</span><span class="s2">, </span><span class="s3">'chunks remain, of which</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">chunkPartition.small.size</span><span class="s2">, </span><span class="s3">'are below minChunkSize.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">timeEnd(</span><span class="s3">'optimize chunks'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[...chunkPartition.small</span><span class="s2">, </span><span class="s1">...chunkPartition.big]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPartitionedChunks(chunkModulesBySignature</span><span class="s2">, </span><span class="s1">numberOfEntries</span><span class="s2">, </span><span class="s1">minChunkSize) {</span>
    <span class="s2">const </span><span class="s1">smallChunks = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">bigChunks = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">chunkByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">sideEffectsByEntry = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">index &lt; numberOfEntries</span><span class="s2">; </span><span class="s1">index++) {</span>
        <span class="s1">sideEffectsByEntry.push(</span><span class="s2">new </span><span class="s1">Set())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[signature</span><span class="s2">, </span><span class="s1">{ dependentEntries</span><span class="s2">, </span><span class="s1">modules }] of Object.entries(chunkModulesBySignature)) {</span>
        <span class="s2">const </span><span class="s1">chunkDescription = {</span>
            <span class="s1">correlatedSideEffects: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
            <span class="s1">dependencies: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
            <span class="s1">dependentChunks: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
            <span class="s1">dependentEntries</span><span class="s2">,</span>
            <span class="s1">modules</span><span class="s2">,</span>
            <span class="s1">pure: </span><span class="s2">true,</span>
            <span class="s1">sideEffects: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
            <span class="s1">size: </span><span class="s4">0</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">size = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">pure = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules) {</span>
            <span class="s1">chunkByModule.set(module</span><span class="s2">, </span><span class="s1">chunkDescription)</span><span class="s2">;</span>
            <span class="s1">pure &amp;&amp; (pure = !module.hasEffects())</span><span class="s2">;</span>
            <span class="s0">// Unfortunately, we cannot take tree-shaking into account here because</span>
            <span class="s0">// rendering did not happen yet</span>
            <span class="s1">size += module.originalCode.length</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">chunkDescription.pure = pure</span><span class="s2">;</span>
        <span class="s1">chunkDescription.size = size</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!pure) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of dependentEntries) {</span>
                <span class="s1">sideEffectsByEntry[entryIndex].add(signature)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// In the beginning, each chunk is only its own side effect. After</span>
            <span class="s0">// merging, additional side effects can accumulate.</span>
            <span class="s1">chunkDescription.sideEffects.add(signature)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">(size &lt; minChunkSize ? smallChunks : bigChunks).push(chunkDescription)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">sortChunksAndAddDependenciesAndEffects([bigChunks</span><span class="s2">, </span><span class="s1">smallChunks]</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">sideEffectsByEntry)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">big: </span><span class="s2">new </span><span class="s1">Set(bigChunks)</span><span class="s2">,</span>
        <span class="s1">small: </span><span class="s2">new </span><span class="s1">Set(smallChunks)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sortChunksAndAddDependenciesAndEffects(chunkLists</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">sideEffectsByEntry) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunks of chunkLists) {</span>
        <span class="s1">chunks.sort(compareChunkSize)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of chunks) {</span>
            <span class="s2">const </span><span class="s1">{ dependencies</span><span class="s2">, </span><span class="s1">modules</span><span class="s2">, </span><span class="s1">correlatedSideEffects</span><span class="s2">, </span><span class="s1">dependentEntries } = chunk</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modules) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.getDependenciesToBeIncluded()) {</span>
                    <span class="s2">const </span><span class="s1">dependencyChunk = chunkByModule.get(dependency)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(dependencyChunk &amp;&amp; dependencyChunk !== chunk) {</span>
                        <span class="s1">dependencies.add(dependencyChunk)</span><span class="s2">;</span>
                        <span class="s1">dependencyChunk.dependentChunks.add(chunk)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">firstEntry = </span><span class="s2">true;</span>
            <span class="s0">// Correlated side effects is the intersection of all entry side effects</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of dependentEntries) {</span>
                <span class="s2">const </span><span class="s1">entryEffects = sideEffectsByEntry[entryIndex]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(firstEntry) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of entryEffects) {</span>
                        <span class="s1">correlatedSideEffects.add(sideEffect)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">firstEntry = </span><span class="s2">false;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of correlatedSideEffects) {</span>
                        <span class="s2">if </span><span class="s1">(!entryEffects.has(sideEffect)) {</span>
                            <span class="s1">correlatedSideEffects.delete(sideEffect)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">compareChunkSize({ size: sizeA }</span><span class="s2">, </span><span class="s1">{ size: sizeB }) {</span>
    <span class="s2">return </span><span class="s1">sizeA - sizeB</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeChunks(chunkPartition</span><span class="s2">, </span><span class="s1">minChunkSize) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">allowArbitraryMerges of [</span><span class="s2">false, true</span><span class="s1">]) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">mergedChunk of chunkPartition.small) {</span>
            <span class="s2">let </span><span class="s1">closestChunk = </span><span class="s2">null;</span>
            <span class="s2">let </span><span class="s1">closestChunkDistance = Infinity</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ modules</span><span class="s2">, </span><span class="s1">pure</span><span class="s2">, </span><span class="s1">size } = mergedChunk</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">targetChunk of concatLazy([chunkPartition.small</span><span class="s2">, </span><span class="s1">chunkPartition.big])) {</span>
                <span class="s2">if </span><span class="s1">(mergedChunk === targetChunk)</span>
                    <span class="s2">continue;</span>
                <span class="s0">// If both chunks are small, we also allow for unrelated merges during</span>
                <span class="s0">// the first pass</span>
                <span class="s2">const </span><span class="s1">onlySubsetMerge = !allowArbitraryMerges &amp;&amp; targetChunk.size &gt;= minChunkSize</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">distance = getChunkEntryDistance(mergedChunk</span><span class="s2">, </span><span class="s1">targetChunk</span><span class="s2">, </span><span class="s1">onlySubsetMerge)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(distance &lt; closestChunkDistance &amp;&amp;</span>
                    <span class="s1">isValidMerge(mergedChunk</span><span class="s2">, </span><span class="s1">targetChunk</span><span class="s2">, </span><span class="s1">onlySubsetMerge)) {</span>
                    <span class="s1">closestChunk = targetChunk</span><span class="s2">;</span>
                    <span class="s1">closestChunkDistance = distance</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(closestChunk) {</span>
                <span class="s1">chunkPartition.small.delete(mergedChunk)</span><span class="s2">;</span>
                <span class="s1">getChunksInPartition(closestChunk</span><span class="s2">, </span><span class="s1">minChunkSize</span><span class="s2">, </span><span class="s1">chunkPartition).delete(closestChunk)</span><span class="s2">;</span>
                <span class="s1">closestChunk.modules.push(...modules)</span><span class="s2">;</span>
                <span class="s1">closestChunk.size += size</span><span class="s2">;</span>
                <span class="s1">closestChunk.pure &amp;&amp; (closestChunk.pure = pure)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">{ correlatedSideEffects</span><span class="s2">, </span><span class="s1">dependencies</span><span class="s2">, </span><span class="s1">dependentChunks</span><span class="s2">, </span><span class="s1">dependentEntries</span><span class="s2">, </span><span class="s1">sideEffects } = closestChunk</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of correlatedSideEffects) {</span>
                    <span class="s2">if </span><span class="s1">(!mergedChunk.correlatedSideEffects.has(sideEffect)) {</span>
                        <span class="s1">correlatedSideEffects.delete(sideEffect)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entry of mergedChunk.dependentEntries) {</span>
                    <span class="s1">dependentEntries.add(entry)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of mergedChunk.sideEffects) {</span>
                    <span class="s1">sideEffects.add(sideEffect)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of mergedChunk.dependencies) {</span>
                    <span class="s1">dependencies.add(dependency)</span><span class="s2">;</span>
                    <span class="s1">dependency.dependentChunks.delete(mergedChunk)</span><span class="s2">;</span>
                    <span class="s1">dependency.dependentChunks.add(closestChunk)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependentChunk of mergedChunk.dependentChunks) {</span>
                    <span class="s1">dependentChunks.add(dependentChunk)</span><span class="s2">;</span>
                    <span class="s1">dependentChunk.dependencies.delete(mergedChunk)</span><span class="s2">;</span>
                    <span class="s1">dependentChunk.dependencies.add(closestChunk)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">dependencies.delete(closestChunk)</span><span class="s2">;</span>
                <span class="s1">dependentChunks.delete(closestChunk)</span><span class="s2">;</span>
                <span class="s1">getChunksInPartition(closestChunk</span><span class="s2">, </span><span class="s1">minChunkSize</span><span class="s2">, </span><span class="s1">chunkPartition).add(closestChunk)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// Merging will not produce cycles if none of the direct non-merged dependencies</span>
<span class="s0">// of a chunk have the other chunk as a transitive dependency</span>
<span class="s2">function </span><span class="s1">isValidMerge(mergedChunk</span><span class="s2">, </span><span class="s1">targetChunk</span><span class="s2">, </span><span class="s1">onlySubsetMerge) {</span>
    <span class="s2">return </span><span class="s1">!(hasTransitiveDependencyOrNonCorrelatedSideEffect(mergedChunk</span><span class="s2">, </span><span class="s1">targetChunk</span><span class="s2">, true</span><span class="s1">) ||</span>
        <span class="s1">hasTransitiveDependencyOrNonCorrelatedSideEffect(targetChunk</span><span class="s2">, </span><span class="s1">mergedChunk</span><span class="s2">, </span><span class="s1">!onlySubsetMerge))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasTransitiveDependencyOrNonCorrelatedSideEffect(dependentChunk</span><span class="s2">, </span><span class="s1">dependencyChunk</span><span class="s2">, </span><span class="s1">checkSideEffects) {</span>
    <span class="s2">const </span><span class="s1">{ correlatedSideEffects } = dependencyChunk</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(checkSideEffects) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of dependentChunk.sideEffects) {</span>
            <span class="s2">if </span><span class="s1">(!correlatedSideEffects.has(sideEffect)) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">chunksToCheck = </span><span class="s2">new </span><span class="s1">Set(dependentChunk.dependencies)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ dependencies</span><span class="s2">, </span><span class="s1">sideEffects } of chunksToCheck) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of dependencies) {</span>
            <span class="s2">if </span><span class="s1">(dependency === dependencyChunk) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s1">chunksToCheck.add(dependency)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(checkSideEffects) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">sideEffect of sideEffects) {</span>
                <span class="s2">if </span><span class="s1">(!correlatedSideEffects.has(sideEffect)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunksInPartition(chunk</span><span class="s2">, </span><span class="s1">minChunkSize</span><span class="s2">, </span><span class="s1">chunkPartition) {</span>
    <span class="s2">return </span><span class="s1">chunk.size &lt; minChunkSize ? chunkPartition.small : chunkPartition.big</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunkEntryDistance({ dependentEntries: sourceEntries }</span><span class="s2">, </span><span class="s1">{ dependentEntries: targetEntries }</span><span class="s2">, </span><span class="s1">enforceSubest) {</span>
    <span class="s2">let </span><span class="s1">distance = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of targetEntries) {</span>
        <span class="s2">if </span><span class="s1">(!sourceEntries.has(entryIndex)) {</span>
            <span class="s1">distance++</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entryIndex of sourceEntries) {</span>
        <span class="s2">if </span><span class="s1">(!targetEntries.has(entryIndex)) {</span>
            <span class="s2">if </span><span class="s1">(enforceSubest) {</span>
                <span class="s2">return </span><span class="s1">Infinity</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">distance++</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">distance</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// ported from https://github.com/substack/node-commondir</span>
<span class="s2">function </span><span class="s1">commondir(files) {</span>
    <span class="s2">if </span><span class="s1">(files.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'/'</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(files.length === </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">dirname(files[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">commonSegments = files.slice(</span><span class="s4">1</span><span class="s1">).reduce((commonSegments</span><span class="s2">, </span><span class="s1">file) =&gt; {</span>
        <span class="s2">const </span><span class="s1">pathSegements = file.split(</span><span class="s4">/\/+|\\+/</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">index</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">commonSegments[index] === pathSegements[index] &amp;&amp;</span>
            <span class="s1">index &lt; Math.min(commonSegments.length</span><span class="s2">, </span><span class="s1">pathSegements.length)</span><span class="s2">; </span><span class="s1">index++)</span>
            <span class="s2">;</span>
        <span class="s2">return </span><span class="s1">commonSegments.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">index)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">files[</span><span class="s4">0</span><span class="s1">].split(</span><span class="s4">/\/+|\\+/</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s0">// Windows correctly handles paths with forward-slashes</span>
    <span class="s2">return </span><span class="s1">commonSegments.length &gt; </span><span class="s4">1 </span><span class="s1">? commonSegments.join(</span><span class="s3">'/'</span><span class="s1">) : </span><span class="s3">'/'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">compareExecIndex = (unitA</span><span class="s2">, </span><span class="s1">unitB) =&gt; unitA.execIndex &gt; unitB.execIndex ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">sortByExecutionOrder(units) {</span>
    <span class="s1">units.sort(compareExecIndex)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">analyseModuleExecution(entryModules) {</span>
    <span class="s2">let </span><span class="s1">nextExecIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cyclePaths = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">analysedModules = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicImports = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">parents = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">orderedModules = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">analyseModule = (module) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.dependencies) {</span>
                <span class="s2">if </span><span class="s1">(parents.has(dependency)) {</span>
                    <span class="s2">if </span><span class="s1">(!analysedModules.has(dependency)) {</span>
                        <span class="s1">cyclePaths.push(getCyclePath(dependency</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">parents))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s1">parents.set(dependency</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
                <span class="s1">analyseModule(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.implicitlyLoadedBefore) {</span>
                <span class="s1">dynamicImports.add(dependency)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ resolution } of module.dynamicImports) {</span>
                <span class="s2">if </span><span class="s1">(resolution </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                    <span class="s1">dynamicImports.add(resolution)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">orderedModules.push(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">module.execIndex = nextExecIndex++</span><span class="s2">;</span>
        <span class="s1">analysedModules.add(module)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">currentEntry of entryModules) {</span>
        <span class="s2">if </span><span class="s1">(!parents.has(currentEntry)) {</span>
            <span class="s1">parents.set(currentEntry</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">analyseModule(currentEntry)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">currentEntry of dynamicImports) {</span>
        <span class="s2">if </span><span class="s1">(!parents.has(currentEntry)) {</span>
            <span class="s1">parents.set(currentEntry</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">analyseModule(currentEntry)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ cyclePaths</span><span class="s2">, </span><span class="s1">orderedModules }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCyclePath(module</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parents) {</span>
    <span class="s2">const </span><span class="s1">cycleSymbol = Symbol(module.id)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">path = [module.id]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">nextModule = parent</span><span class="s2">;</span>
    <span class="s1">module.cycles.add(cycleSymbol)</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(nextModule !== module) {</span>
        <span class="s1">nextModule.cycles.add(cycleSymbol)</span><span class="s2">;</span>
        <span class="s1">path.push(nextModule.id)</span><span class="s2">;</span>
        <span class="s1">nextModule = parents.get(nextModule)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">path.push(path[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">path.reverse()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">path</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getGenerateCodeSnippets({ compact</span><span class="s2">, </span><span class="s1">generatedCode: { arrowFunctions</span><span class="s2">, </span><span class="s1">constBindings</span><span class="s2">, </span><span class="s1">objectShorthand</span><span class="s2">, </span><span class="s1">reservedNamesAsProps } }) {</span>
    <span class="s2">const </span><span class="s1">{ _</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">s } = compact ? { _: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">n: </span><span class="s3">''</span><span class="s2">, </span><span class="s1">s: </span><span class="s3">'' </span><span class="s1">} : { _: </span><span class="s3">' '</span><span class="s2">, </span><span class="s1">n: </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s1">s: </span><span class="s3">';' </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cnst = constBindings ? </span><span class="s3">'const' </span><span class="s1">: </span><span class="s3">'var'</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getNonArrowFunctionIntro = (parameters</span><span class="s2">, </span><span class="s1">{ isAsync</span><span class="s2">, </span><span class="s1">name }) =&gt; </span><span class="s3">`</span><span class="s1">${isAsync ? </span><span class="s3">`async ` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">function</span><span class="s1">${name ? </span><span class="s3">` </span><span class="s1">${name}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}${_}</span><span class="s3">(</span><span class="s1">${parameters.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">)</span><span class="s1">${_}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getFunctionIntro = arrowFunctions</span>
        <span class="s1">? (parameters</span><span class="s2">, </span><span class="s1">{ isAsync</span><span class="s2">, </span><span class="s1">name }) =&gt; {</span>
            <span class="s2">const </span><span class="s1">singleParameter = parameters.length === </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">asyncString = isAsync ? </span><span class="s3">`async</span><span class="s1">${singleParameter ? </span><span class="s3">' ' </span><span class="s1">: _}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${name ? </span><span class="s3">`</span><span class="s1">${cnst} ${name}${_}</span><span class="s3">=</span><span class="s1">${_}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}${asyncString}${singleParameter ? parameters[</span><span class="s4">0</span><span class="s1">] : </span><span class="s3">`(</span><span class="s1">${parameters.join(</span><span class="s3">`,</span><span class="s1">${_}</span><span class="s3">`</span><span class="s1">)}</span><span class="s3">)`</span><span class="s1">}${_}</span><span class="s3">=&gt;</span><span class="s1">${_}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">: getNonArrowFunctionIntro</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getDirectReturnFunction = (parameters</span><span class="s2">, </span><span class="s1">{ functionReturn</span><span class="s2">, </span><span class="s1">lineBreakIndent</span><span class="s2">, </span><span class="s1">name }) =&gt; [</span>
        <span class="s3">`</span><span class="s1">${getFunctionIntro(parameters</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">isAsync: </span><span class="s2">false,</span>
            <span class="s1">name</span>
        <span class="s1">})}${arrowFunctions</span>
            <span class="s1">? lineBreakIndent</span>
                <span class="s1">? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}${lineBreakIndent.t}</span><span class="s3">`</span>
                <span class="s1">: </span><span class="s3">''</span>
            <span class="s1">: </span><span class="s3">`{</span><span class="s1">${lineBreakIndent ? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}${lineBreakIndent.t}</span><span class="s3">` </span><span class="s1">: _}${functionReturn ? </span><span class="s3">'return ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">`</span><span class="s1">}</span><span class="s3">`</span><span class="s2">,</span>
        <span class="s1">arrowFunctions</span>
            <span class="s1">? </span><span class="s3">`</span><span class="s1">${name ? </span><span class="s3">';' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}${lineBreakIndent ? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span><span class="s3">`</span>
            <span class="s1">: </span><span class="s3">`</span><span class="s1">${s}${lineBreakIndent ? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}</span><span class="s3">` </span><span class="s1">: _}</span><span class="s3">}`</span>
    <span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isValidPropertyName = reservedNamesAsProps</span>
        <span class="s1">? (name) =&gt; validPropertyName.test(name)</span>
        <span class="s1">: (name) =&gt; !RESERVED_NAMES$1.has(name) &amp;&amp; validPropertyName.test(name)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">_</span><span class="s2">,</span>
        <span class="s1">cnst</span><span class="s2">,</span>
        <span class="s1">getDirectReturnFunction</span><span class="s2">,</span>
        <span class="s1">getDirectReturnIifeLeft: (parameters</span><span class="s2">, </span><span class="s1">returned</span><span class="s2">, </span><span class="s1">{ needsArrowReturnParens</span><span class="s2">, </span><span class="s1">needsWrappedFunction }) =&gt; {</span>
            <span class="s2">const </span><span class="s1">[left</span><span class="s2">, </span><span class="s1">right] = getDirectReturnFunction(parameters</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">functionReturn: </span><span class="s2">true,</span>
                <span class="s1">lineBreakIndent: </span><span class="s2">null,</span>
                <span class="s1">name: </span><span class="s2">null</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${wrapIfNeeded(</span><span class="s3">`</span><span class="s1">${left}${wrapIfNeeded(returned</span><span class="s2">, </span><span class="s1">arrowFunctions &amp;&amp; needsArrowReturnParens)}${right}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">arrowFunctions || needsWrappedFunction)}</span><span class="s3">(`</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">getFunctionIntro</span><span class="s2">,</span>
        <span class="s1">getNonArrowFunctionIntro</span><span class="s2">,</span>
        <span class="s1">getObject(fields</span><span class="s2">, </span><span class="s1">{ lineBreakIndent }) {</span>
            <span class="s2">const </span><span class="s1">prefix = lineBreakIndent ? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}${lineBreakIndent.t}</span><span class="s3">` </span><span class="s1">: _</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s3">`{</span><span class="s1">${fields</span>
                <span class="s1">.map(([key</span><span class="s2">, </span><span class="s1">value]) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(key === </span><span class="s2">null</span><span class="s1">)</span>
                    <span class="s2">return </span><span class="s3">`</span><span class="s1">${prefix}${value}</span><span class="s3">`</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">needsQuotes = !isValidPropertyName(key)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">key === value &amp;&amp; objectShorthand &amp;&amp; !needsQuotes</span>
                    <span class="s1">? prefix + key</span>
                    <span class="s1">: </span><span class="s3">`</span><span class="s1">${prefix}${needsQuotes ? </span><span class="s3">`'</span><span class="s1">${key}</span><span class="s3">'` </span><span class="s1">: key}</span><span class="s3">:</span><span class="s1">${_}${value}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">})</span>
                <span class="s1">.join(</span><span class="s3">`,`</span><span class="s1">)}${fields.length === </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: lineBreakIndent ? </span><span class="s3">`</span><span class="s1">${n}${lineBreakIndent.base}</span><span class="s3">` </span><span class="s1">: _}</span><span class="s3">}`</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">getPropertyAccess: (name) =&gt; isValidPropertyName(name) ? </span><span class="s3">`.</span><span class="s1">${name}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">`[</span><span class="s1">${JSON.stringify(name)}</span><span class="s3">]`</span><span class="s2">,</span>
        <span class="s1">n</span><span class="s2">,</span>
        <span class="s1">s</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">wrapIfNeeded = (code</span><span class="s2">, </span><span class="s1">needsParens) =&gt; needsParens ? </span><span class="s3">`(</span><span class="s1">${code}</span><span class="s3">)` </span><span class="s1">: code</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">validPropertyName = </span><span class="s4">/^(?!\d)[\w$]+$/</span><span class="s2">;</span>

<span class="s2">class </span><span class="s1">Source {</span>
    <span class="s1">constructor(filename</span><span class="s2">, </span><span class="s1">content) {</span>
        <span class="s2">this</span><span class="s1">.isOriginal = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.filename = filename</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.content = content</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">traceSegment(line</span><span class="s2">, </span><span class="s1">column</span><span class="s2">, </span><span class="s1">name) {</span>
        <span class="s2">return </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">source: </span><span class="s2">this </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Link {</span>
    <span class="s1">constructor(map</span><span class="s2">, </span><span class="s1">sources) {</span>
        <span class="s2">this</span><span class="s1">.sources = sources</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.names = map.names</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.mappings = map.mappings</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">traceMappings() {</span>
        <span class="s2">const </span><span class="s1">sources = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sourceIndexMap = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sourcesContent = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">names = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">nameIndexMap = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">mappings = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">line of </span><span class="s2">this</span><span class="s1">.mappings) {</span>
            <span class="s2">const </span><span class="s1">tracedLine = []</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of line) {</span>
                <span class="s2">if </span><span class="s1">(segment.length === </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s2">continue;</span>
                <span class="s2">const </span><span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[segment[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!source)</span>
                    <span class="s2">continue;</span>
                <span class="s2">const </span><span class="s1">traced = source.traceSegment(segment[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">segment[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">segment.length === </span><span class="s4">5 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.names[segment[</span><span class="s4">4</span><span class="s1">]] : </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(traced) {</span>
                    <span class="s2">const </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">source: { content</span><span class="s2">, </span><span class="s1">filename } } = traced</span><span class="s2">;</span>
                    <span class="s2">let </span><span class="s1">sourceIndex = sourceIndexMap.get(filename)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(sourceIndex === undefined) {</span>
                        <span class="s1">sourceIndex = sources.length</span><span class="s2">;</span>
                        <span class="s1">sources.push(filename)</span><span class="s2">;</span>
                        <span class="s1">sourceIndexMap.set(filename</span><span class="s2">, </span><span class="s1">sourceIndex)</span><span class="s2">;</span>
                        <span class="s1">sourcesContent[sourceIndex] = content</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(sourcesContent[sourceIndex] == </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s1">sourcesContent[sourceIndex] = content</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(content != </span><span class="s2">null </span><span class="s1">&amp;&amp; sourcesContent[sourceIndex] !== content) {</span>
                        <span class="s2">return </span><span class="s1">error(errorConflictingSourcemapSources(filename))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">tracedSegment = [segment[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sourceIndex</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">column]</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(name) {</span>
                        <span class="s2">let </span><span class="s1">nameIndex = nameIndexMap.get(name)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(nameIndex === undefined) {</span>
                            <span class="s1">nameIndex = names.length</span><span class="s2">;</span>
                            <span class="s1">names.push(name)</span><span class="s2">;</span>
                            <span class="s1">nameIndexMap.set(name</span><span class="s2">, </span><span class="s1">nameIndex)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">tracedSegment[</span><span class="s4">4</span><span class="s1">] = nameIndex</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">tracedLine.push(tracedSegment)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">mappings.push(tracedLine)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{ mappings</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">sourcesContent }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">traceSegment(line</span><span class="s2">, </span><span class="s1">column</span><span class="s2">, </span><span class="s1">name) {</span>
        <span class="s2">const </span><span class="s1">segments = </span><span class="s2">this</span><span class="s1">.mappings[line]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!segments)</span>
            <span class="s2">return null;</span>
        <span class="s0">// binary search through segments for the given column</span>
        <span class="s2">let </span><span class="s1">searchStart = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">searchEnd = segments.length - </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(searchStart &lt;= searchEnd) {</span>
            <span class="s2">const </span><span class="s1">m = (searchStart + searchEnd) &gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">segment = segments[m]</span><span class="s2">;</span>
            <span class="s0">// If a sourcemap does not have sufficient resolution to contain a</span>
            <span class="s0">// necessary mapping, e.g. because it only contains line information, we</span>
            <span class="s0">// use the best approximation we could find</span>
            <span class="s2">if </span><span class="s1">(segment[</span><span class="s4">0</span><span class="s1">] === column || searchStart === searchEnd) {</span>
                <span class="s2">if </span><span class="s1">(segment.length == </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s2">return null;</span>
                <span class="s2">const </span><span class="s1">source = </span><span class="s2">this</span><span class="s1">.sources[segment[</span><span class="s4">1</span><span class="s1">]]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!source)</span>
                    <span class="s2">return null;</span>
                <span class="s2">return </span><span class="s1">source.traceSegment(segment[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">segment[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">segment.length === </span><span class="s4">5 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.names[segment[</span><span class="s4">4</span><span class="s1">]] : name)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(segment[</span><span class="s4">0</span><span class="s1">] &gt; column) {</span>
                <span class="s1">searchEnd = m - </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">searchStart = m + </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getLinkMap(warn) {</span>
    <span class="s2">return function </span><span class="s1">linkMap(source</span><span class="s2">, </span><span class="s1">map) {</span>
        <span class="s2">if </span><span class="s1">(map.mappings) {</span>
            <span class="s2">return new </span><span class="s1">Link(map</span><span class="s2">, </span><span class="s1">[source])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">warn(errorSourcemapBroken(map.plugin))</span><span class="s2">;</span>
        <span class="s2">return new </span><span class="s1">Link({</span>
            <span class="s1">mappings: []</span><span class="s2">,</span>
            <span class="s1">names: []</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">[source])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCollapsedSourcemap(id</span><span class="s2">, </span><span class="s1">originalCode</span><span class="s2">, </span><span class="s1">originalSourcemap</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">linkMap) {</span>
    <span class="s2">let </span><span class="s1">source</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(originalSourcemap) {</span>
        <span class="s2">const </span><span class="s1">sources = originalSourcemap.sources</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sourcesContent = originalSourcemap.sourcesContent || []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">directory = dirname(id) || </span><span class="s3">'.'</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">sourceRoot = originalSourcemap.sourceRoot || </span><span class="s3">'.'</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">baseSources = sources.map((source</span><span class="s2">, </span><span class="s1">index) =&gt; </span><span class="s2">new </span><span class="s1">Source(resolve(directory</span><span class="s2">, </span><span class="s1">sourceRoot</span><span class="s2">, </span><span class="s1">source)</span><span class="s2">, </span><span class="s1">sourcesContent[index]))</span><span class="s2">;</span>
        <span class="s1">source = </span><span class="s2">new </span><span class="s1">Link(originalSourcemap</span><span class="s2">, </span><span class="s1">baseSources)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">source = </span><span class="s2">new </span><span class="s1">Source(id</span><span class="s2">, </span><span class="s1">originalCode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">sourcemapChain.reduce(linkMap</span><span class="s2">, </span><span class="s1">source)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">collapseSourcemaps(file</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">modules</span><span class="s2">, </span><span class="s1">bundleSourcemapChain</span><span class="s2">, </span><span class="s1">excludeContent</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">const </span><span class="s1">linkMap = getLinkMap(warn)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">moduleSources = modules</span>
        <span class="s1">.filter(module =&gt; !module.excludeFromSourcemap)</span>
        <span class="s1">.map(module =&gt; getCollapsedSourcemap(module.id</span><span class="s2">, </span><span class="s1">module.originalCode</span><span class="s2">, </span><span class="s1">module.originalSourcemap</span><span class="s2">, </span><span class="s1">module.sourcemapChain</span><span class="s2">, </span><span class="s1">linkMap))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">link = </span><span class="s2">new </span><span class="s1">Link(map</span><span class="s2">, </span><span class="s1">moduleSources)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">source = bundleSourcemapChain.reduce(linkMap</span><span class="s2">, </span><span class="s1">link)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">{ sources</span><span class="s2">, </span><span class="s1">sourcesContent</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">mappings } = source.traceMappings()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(file) {</span>
        <span class="s2">const </span><span class="s1">directory = dirname(file)</span><span class="s2">;</span>
        <span class="s1">sources = sources.map((source) =&gt; relative$1(directory</span><span class="s2">, </span><span class="s1">source))</span><span class="s2">;</span>
        <span class="s1">file = basename(file)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">sourcesContent = (excludeContent ? </span><span class="s2">null </span><span class="s1">: sourcesContent)</span><span class="s2">;</span>
    <span class="s2">return new </span><span class="s1">SourceMap({ file</span><span class="s2">, </span><span class="s1">mappings</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">sources</span><span class="s2">, </span><span class="s1">sourcesContent })</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">collapseSourcemap(id</span><span class="s2">, </span><span class="s1">originalCode</span><span class="s2">, </span><span class="s1">originalSourcemap</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">if </span><span class="s1">(sourcemapChain.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">originalSourcemap</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">source = getCollapsedSourcemap(id</span><span class="s2">, </span><span class="s1">originalCode</span><span class="s2">, </span><span class="s1">originalSourcemap</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">getLinkMap(warn))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">map = source.traceMappings()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ version: </span><span class="s4">3</span><span class="s2">, </span><span class="s1">...map }</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createHash = () =&gt; createHash$1(</span><span class="s3">'sha256'</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">decodedSourcemap(map) {</span>
    <span class="s2">if </span><span class="s1">(!map)</span>
        <span class="s2">return null;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">map === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s1">map = JSON.parse(map)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(map.mappings === </span><span class="s3">''</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">mappings: []</span><span class="s2">,</span>
            <span class="s1">names: []</span><span class="s2">,</span>
            <span class="s1">sources: []</span><span class="s2">,</span>
            <span class="s1">version: </span><span class="s4">3</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">mappings = </span><span class="s2">typeof </span><span class="s1">map.mappings === </span><span class="s3">'string' </span><span class="s1">? decode(map.mappings) : map.mappings</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ ...map</span><span class="s2">, </span><span class="s1">mappings }</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">renderChunks(chunks</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">onwarn) {</span>
    <span class="s1">timeStart(</span><span class="s3">'render chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">reserveEntryChunksInBundle(chunks)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">renderedChunks = </span><span class="s2">await </span><span class="s1">Promise.all(chunks.map(chunk =&gt; chunk.render()))</span><span class="s2">;</span>
    <span class="s1">timeEnd(</span><span class="s3">'render chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">timeStart(</span><span class="s3">'transform chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">chunkGraph = getChunkGraph(chunks)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ nonHashedChunksWithPlaceholders</span><span class="s2">, </span><span class="s1">renderedChunksByPlaceholder</span><span class="s2">, </span><span class="s1">hashDependenciesByPlaceholder } = </span><span class="s2">await </span><span class="s1">transformChunksAndGenerateContentHashes(renderedChunks</span><span class="s2">, </span><span class="s1">chunkGraph</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">onwarn)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hashesByPlaceholder = generateFinalHashes(renderedChunksByPlaceholder</span><span class="s2">, </span><span class="s1">hashDependenciesByPlaceholder</span><span class="s2">, </span><span class="s1">bundle)</span><span class="s2">;</span>
    <span class="s1">addChunksToBundle(renderedChunksByPlaceholder</span><span class="s2">, </span><span class="s1">hashesByPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">nonHashedChunksWithPlaceholders</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">outputOptions)</span><span class="s2">;</span>
    <span class="s1">timeEnd(</span><span class="s3">'transform chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reserveEntryChunksInBundle(chunks) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of chunks) {</span>
        <span class="s2">if </span><span class="s1">(chunk.facadeModule &amp;&amp; chunk.facadeModule.isUserDefinedEntryPoint) {</span>
            <span class="s0">// reserves name in bundle as side effect if it does not contain a hash</span>
            <span class="s1">chunk.getPreliminaryFileName()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunkGraph(chunks) {</span>
    <span class="s2">return </span><span class="s1">Object.fromEntries(chunks.map(chunk =&gt; {</span>
        <span class="s2">const </span><span class="s1">renderedChunkInfo = chunk.getRenderedChunkInfo()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">[renderedChunkInfo.fileName</span><span class="s2">, </span><span class="s1">renderedChunkInfo]</span><span class="s2">;</span>
    <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">transformChunk(magicString</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">usedModules</span><span class="s2">, </span><span class="s1">chunkGraph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">outputPluginDriver</span><span class="s2">, </span><span class="s1">onwarn) {</span>
    <span class="s2">let </span><span class="s1">map = </span><span class="s2">null;</span>
    <span class="s2">const </span><span class="s1">sourcemapChain = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">code = </span><span class="s2">await </span><span class="s1">outputPluginDriver.hookReduceArg0(</span><span class="s3">'renderChunk'</span><span class="s2">, </span><span class="s1">[magicString.toString()</span><span class="s2">, </span><span class="s1">chunkGraph[fileName]</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{ chunks: chunkGraph }]</span><span class="s2">, </span><span class="s1">(code</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">plugin) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(result == </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">code</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">result === </span><span class="s3">'string'</span><span class="s1">)</span>
            <span class="s1">result = {</span>
                <span class="s1">code: result</span><span class="s2">,</span>
                <span class="s1">map: undefined</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s0">// strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning</span>
        <span class="s2">if </span><span class="s1">(result.map !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">map = decodedSourcemap(result.map)</span><span class="s2">;</span>
            <span class="s1">sourcemapChain.push(map || { missing: </span><span class="s2">true, </span><span class="s1">plugin: plugin.name })</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result.code</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ compact</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">sourcemap</span><span class="s2">, </span><span class="s1">sourcemapExcludeSources</span><span class="s2">, </span><span class="s1">sourcemapFile</span><span class="s2">, </span><span class="s1">sourcemapPathTransform</span><span class="s2">, </span><span class="s1">sourcemapIgnoreList } = options</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!compact &amp;&amp; code[code.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s1">code += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(sourcemap) {</span>
        <span class="s1">timeStart(</span><span class="s3">'sourcemaps'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">resultingFile</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(file)</span>
            <span class="s1">resultingFile = resolve(sourcemapFile || file)</span><span class="s2">;</span>
        <span class="s2">else if </span><span class="s1">(dir)</span>
            <span class="s1">resultingFile = resolve(dir</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
        <span class="s2">else</span>
            <span class="s1">resultingFile = resolve(fileName)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">decodedMap = magicString.generateDecodedMap({})</span><span class="s2">;</span>
        <span class="s1">map = collapseSourcemaps(resultingFile</span><span class="s2">, </span><span class="s1">decodedMap</span><span class="s2">, </span><span class="s1">usedModules</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">sourcemapExcludeSources</span><span class="s2">, </span><span class="s1">onwarn)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">sourcesIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">sourcesIndex &lt; map.sources.length</span><span class="s2">; </span><span class="s1">++sourcesIndex) {</span>
            <span class="s2">let </span><span class="s1">sourcePath = map.sources[sourcesIndex]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">sourcemapPath = </span><span class="s3">`</span><span class="s1">${resultingFile}</span><span class="s3">.map`</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">ignoreList = sourcemapIgnoreList(sourcePath</span><span class="s2">, </span><span class="s1">sourcemapPath)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ignoreList !== </span><span class="s3">'boolean'</span><span class="s1">) {</span>
                <span class="s1">error(errorFailedValidation(</span><span class="s3">'sourcemapIgnoreList function must return a boolean.'</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(ignoreList) {</span>
                <span class="s2">if </span><span class="s1">(map.x_google_ignoreList === undefined) {</span>
                    <span class="s1">map.x_google_ignoreList = []</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!map.x_google_ignoreList.includes(sourcesIndex)) {</span>
                    <span class="s1">map.x_google_ignoreList.push(sourcesIndex)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(sourcemapPathTransform) {</span>
                <span class="s1">sourcePath = sourcemapPathTransform(sourcePath</span><span class="s2">, </span><span class="s1">sourcemapPath)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">sourcePath !== </span><span class="s3">'string'</span><span class="s1">) {</span>
                    <span class="s1">error(errorFailedValidation(</span><span class="s3">`sourcemapPathTransform function must return a string.`</span><span class="s1">))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">map.sources[sourcesIndex] = normalize(sourcePath)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">timeEnd(</span><span class="s3">'sourcemaps'</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">code</span><span class="s2">,</span>
        <span class="s1">map</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">transformChunksAndGenerateContentHashes(renderedChunks</span><span class="s2">, </span><span class="s1">chunkGraph</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">onwarn) {</span>
    <span class="s2">const </span><span class="s1">nonHashedChunksWithPlaceholders = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">renderedChunksByPlaceholder = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hashDependenciesByPlaceholder = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">placeholders = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ preliminaryFileName: { hashPlaceholder } } of renderedChunks) {</span>
        <span class="s2">if </span><span class="s1">(hashPlaceholder)</span>
            <span class="s1">placeholders.add(hashPlaceholder)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">Promise.all(renderedChunks.map(async ({ chunk</span><span class="s2">, </span><span class="s1">preliminaryFileName: { fileName</span><span class="s2">, </span><span class="s1">hashPlaceholder }</span><span class="s2">, </span><span class="s1">magicString</span><span class="s2">, </span><span class="s1">usedModules }) =&gt; {</span>
        <span class="s2">const </span><span class="s1">transformedChunk = {</span>
            <span class="s1">chunk</span><span class="s2">,</span>
            <span class="s1">fileName</span><span class="s2">,</span>
            <span class="s1">...(</span><span class="s2">await </span><span class="s1">transformChunk(magicString</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">usedModules</span><span class="s2">, </span><span class="s1">chunkGraph</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">onwarn))</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ code } = transformedChunk</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hashPlaceholder) {</span>
            <span class="s0">// To create a reproducible content-only hash, all placeholders are</span>
            <span class="s0">// replaced with the same value before hashing</span>
            <span class="s2">const </span><span class="s1">{ containedPlaceholders</span><span class="s2">, </span><span class="s1">transformedCode } = replacePlaceholdersWithDefaultAndGetContainedPlaceholders(code</span><span class="s2">, </span><span class="s1">placeholders)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">hash = createHash().update(transformedCode)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">hashAugmentation = pluginDriver.hookReduceValueSync(</span><span class="s3">'augmentChunkHash'</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">[chunk.getRenderedChunkInfo()]</span><span class="s2">, </span><span class="s1">(augmentation</span><span class="s2">, </span><span class="s1">pluginHash) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(pluginHash) {</span>
                    <span class="s1">augmentation += pluginHash</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">augmentation</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(hashAugmentation) {</span>
                <span class="s1">hash.update(hashAugmentation)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">renderedChunksByPlaceholder.set(hashPlaceholder</span><span class="s2">, </span><span class="s1">transformedChunk)</span><span class="s2">;</span>
            <span class="s1">hashDependenciesByPlaceholder.set(hashPlaceholder</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">containedPlaceholders</span><span class="s2">,</span>
                <span class="s1">contentHash: hash.digest(</span><span class="s3">'hex'</span><span class="s1">)</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">nonHashedChunksWithPlaceholders.push(transformedChunk)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">hashDependenciesByPlaceholder</span><span class="s2">,</span>
        <span class="s1">nonHashedChunksWithPlaceholders</span><span class="s2">,</span>
        <span class="s1">renderedChunksByPlaceholder</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateFinalHashes(renderedChunksByPlaceholder</span><span class="s2">, </span><span class="s1">hashDependenciesByPlaceholder</span><span class="s2">, </span><span class="s1">bundle) {</span>
    <span class="s2">const </span><span class="s1">hashesByPlaceholder = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[placeholder</span><span class="s2">, </span><span class="s1">{ fileName }] of renderedChunksByPlaceholder) {</span>
        <span class="s2">let </span><span class="s1">hash = createHash()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">hashDependencyPlaceholders = </span><span class="s2">new </span><span class="s1">Set([placeholder])</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependencyPlaceholder of hashDependencyPlaceholders) {</span>
            <span class="s2">const </span><span class="s1">{ containedPlaceholders</span><span class="s2">, </span><span class="s1">contentHash } = hashDependenciesByPlaceholder.get(dependencyPlaceholder)</span><span class="s2">;</span>
            <span class="s1">hash.update(contentHash)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">containedPlaceholder of containedPlaceholders) {</span>
                <span class="s0">// When looping over a map, setting an entry only causes a new iteration if the key is new</span>
                <span class="s1">hashDependencyPlaceholders.add(containedPlaceholder)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">finalFileName</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">finalHash</span><span class="s2">;</span>
        <span class="s2">do </span><span class="s1">{</span>
            <span class="s0">// In case of a hash collision, create a hash of the hash</span>
            <span class="s2">if </span><span class="s1">(finalHash) {</span>
                <span class="s1">hash = createHash().update(finalHash)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">finalHash = hash.digest(</span><span class="s3">'hex'</span><span class="s1">).slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">placeholder.length)</span><span class="s2">;</span>
            <span class="s1">finalFileName = replaceSinglePlaceholder(fileName</span><span class="s2">, </span><span class="s1">placeholder</span><span class="s2">, </span><span class="s1">finalHash)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(bundle[lowercaseBundleKeys].has(finalFileName.toLowerCase()))</span><span class="s2">;</span>
        <span class="s1">bundle[finalFileName] = FILE_PLACEHOLDER</span><span class="s2">;</span>
        <span class="s1">hashesByPlaceholder.set(placeholder</span><span class="s2">, </span><span class="s1">finalHash)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hashesByPlaceholder</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addChunksToBundle(renderedChunksByPlaceholder</span><span class="s2">, </span><span class="s1">hashesByPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">nonHashedChunksWithPlaceholders</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ chunk</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">map } of renderedChunksByPlaceholder.values()) {</span>
        <span class="s2">let </span><span class="s1">updatedCode = replacePlaceholders(code</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">finalFileName = replacePlaceholders(fileName</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(map) {</span>
            <span class="s1">map.file = replacePlaceholders(map.file</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
            <span class="s1">updatedCode += emitSourceMapAndGetComment(finalFileName</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">bundle[finalFileName] = chunk.finalizeChunk(updatedCode</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ chunk</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">map } of nonHashedChunksWithPlaceholders) {</span>
        <span class="s2">let </span><span class="s1">updatedCode = hashesByPlaceholder.size &gt; </span><span class="s4">0 </span><span class="s1">? replacePlaceholders(code</span><span class="s2">, </span><span class="s1">hashesByPlaceholder) : code</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(map) {</span>
            <span class="s1">updatedCode += emitSourceMapAndGetComment(fileName</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">bundle[fileName] = chunk.finalizeChunk(updatedCode</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">hashesByPlaceholder)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emitSourceMapAndGetComment(fileName</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">{ sourcemap</span><span class="s2">, </span><span class="s1">sourcemapBaseUrl }) {</span>
    <span class="s2">let </span><span class="s1">url</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(sourcemap === </span><span class="s3">'inline'</span><span class="s1">) {</span>
        <span class="s1">url = map.toUrl()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">sourcemapFileName = </span><span class="s3">`</span><span class="s1">${basename(fileName)}</span><span class="s3">.map`</span><span class="s2">;</span>
        <span class="s1">url = sourcemapBaseUrl</span>
            <span class="s1">? </span><span class="s2">new </span><span class="s1">URL(sourcemapFileName</span><span class="s2">, </span><span class="s1">sourcemapBaseUrl).toString()</span>
            <span class="s1">: sourcemapFileName</span><span class="s2">;</span>
        <span class="s1">pluginDriver.emitFile({ fileName: </span><span class="s3">`</span><span class="s1">${fileName}</span><span class="s3">.map`</span><span class="s2">, </span><span class="s1">source: map.toString()</span><span class="s2">, </span><span class="s1">type: </span><span class="s3">'asset' </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">sourcemap === </span><span class="s3">'hidden' </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">`//# </span><span class="s1">${SOURCEMAPPING_URL}</span><span class="s3">=</span><span class="s1">${url}</span><span class="s2">\n</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Bundle {</span>
    <span class="s1">constructor(outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">graph) {</span>
        <span class="s2">this</span><span class="s1">.outputOptions = outputOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unsetOptions = unsetOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.inputOptions = inputOptions</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginDriver = pluginDriver</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.graph = graph</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.facadeChunkByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includedNamespaces = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async generate(isWrite) {</span>
        <span class="s1">timeStart(</span><span class="s3">'GENERATE'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">outputBundleBase = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">outputBundle = getOutputBundle(outputBundleBase)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginDriver.setOutputBundle(outputBundle</span><span class="s2">, this</span><span class="s1">.outputOptions)</span><span class="s2">;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">timeStart(</span><span class="s3">'initialize render'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">await this</span><span class="s1">.pluginDriver.hookParallel(</span><span class="s3">'renderStart'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.inputOptions])</span><span class="s2">;</span>
            <span class="s1">timeEnd(</span><span class="s3">'initialize render'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">timeStart(</span><span class="s3">'generate chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">getHashPlaceholder = getHashPlaceholderGenerator()</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">chunks = </span><span class="s2">await this</span><span class="s1">.generateChunks(outputBundle</span><span class="s2">, </span><span class="s1">getHashPlaceholder)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(chunks.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">validateOptionsForMultiChunkOutput(</span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.inputOptions.onwarn)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.pluginDriver.setChunkInformation(</span><span class="s2">this</span><span class="s1">.facadeChunkByModule)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of chunks) {</span>
                <span class="s1">chunk.generateExports()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">timeEnd(</span><span class="s3">'generate chunks'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">renderChunks(chunks</span><span class="s2">, </span><span class="s1">outputBundle</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.inputOptions.onwarn)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(error_) {</span>
            <span class="s2">await this</span><span class="s1">.pluginDriver.hookParallel(</span><span class="s3">'renderError'</span><span class="s2">, </span><span class="s1">[error_])</span><span class="s2">;</span>
            <span class="s2">throw </span><span class="s1">error_</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">removeUnreferencedAssets(outputBundle)</span><span class="s2">;</span>
        <span class="s1">timeStart(</span><span class="s3">'generate bundle'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">await this</span><span class="s1">.pluginDriver.hookSeq(</span><span class="s3">'generateBundle'</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">,</span>
            <span class="s1">outputBundle</span><span class="s2">,</span>
            <span class="s1">isWrite</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.finaliseAssets(outputBundle)</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'generate bundle'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'GENERATE'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">outputBundleBase</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async addManualChunks(manualChunks) {</span>
        <span class="s2">const </span><span class="s1">manualChunkAliasByEntry = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">chunkEntries = </span><span class="s2">await </span><span class="s1">Promise.all(Object.entries(manualChunks).map(async ([alias</span><span class="s2">, </span><span class="s1">files]) =&gt; ({</span>
            <span class="s1">alias</span><span class="s2">,</span>
            <span class="s1">entries: </span><span class="s2">await this</span><span class="s1">.graph.moduleLoader.addAdditionalModules(files)</span>
        <span class="s1">})))</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ alias</span><span class="s2">, </span><span class="s1">entries } of chunkEntries) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">entry of entries) {</span>
                <span class="s1">addModuleToManualChunk(alias</span><span class="s2">, </span><span class="s1">entry</span><span class="s2">, </span><span class="s1">manualChunkAliasByEntry)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">manualChunkAliasByEntry</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">assignManualChunks(getManualChunk) {</span>
        <span class="s0">// eslint-disable-next-line unicorn/prefer-module</span>
        <span class="s2">const </span><span class="s1">manualChunkAliasesWithEntry = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">manualChunksApi = {</span>
            <span class="s1">getModuleIds: () =&gt; </span><span class="s2">this</span><span class="s1">.graph.modulesById.keys()</span><span class="s2">,</span>
            <span class="s1">getModuleInfo: </span><span class="s2">this</span><span class="s1">.graph.getModuleInfo</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.graph.modulesById.values()) {</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                <span class="s2">const </span><span class="s1">manualChunkAlias = getManualChunk(module.id</span><span class="s2">, </span><span class="s1">manualChunksApi)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">manualChunkAlias === </span><span class="s3">'string'</span><span class="s1">) {</span>
                    <span class="s1">manualChunkAliasesWithEntry.push([manualChunkAlias</span><span class="s2">, </span><span class="s1">module])</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">manualChunkAliasesWithEntry.sort(([aliasA]</span><span class="s2">, </span><span class="s1">[aliasB]) =&gt; aliasA &gt; aliasB ? </span><span class="s4">1 </span><span class="s1">: aliasA &lt; aliasB ? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">manualChunkAliasByEntry = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[alias</span><span class="s2">, </span><span class="s1">module] of manualChunkAliasesWithEntry) {</span>
            <span class="s1">addModuleToManualChunk(alias</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">manualChunkAliasByEntry)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">manualChunkAliasByEntry</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">finaliseAssets(bundle) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.outputOptions.validate) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">file of Object.values(bundle)) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s3">'code' </span><span class="s2">in </span><span class="s1">file) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s2">this</span><span class="s1">.graph.contextParse(file.code</span><span class="s2">, </span><span class="s1">{</span>
                            <span class="s1">ecmaVersion: </span><span class="s3">'latest'</span>
                        <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">catch </span><span class="s1">(error_) {</span>
                        <span class="s2">this</span><span class="s1">.inputOptions.onwarn(errorChunkInvalid(file</span><span class="s2">, </span><span class="s1">error_))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.pluginDriver.finaliseAssets()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async generateChunks(bundle</span><span class="s2">, </span><span class="s1">getHashPlaceholder) {</span>
        <span class="s2">const </span><span class="s1">{ experimentalMinChunkSize</span><span class="s2">, </span><span class="s1">inlineDynamicImports</span><span class="s2">, </span><span class="s1">manualChunks</span><span class="s2">, </span><span class="s1">preserveModules } = </span><span class="s2">this</span><span class="s1">.outputOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">manualChunkAliasByEntry = </span><span class="s2">typeof </span><span class="s1">manualChunks === </span><span class="s3">'object'</span>
            <span class="s1">? </span><span class="s2">await this</span><span class="s1">.addManualChunks(manualChunks)</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.assignManualChunks(manualChunks)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">snippets = getGenerateCodeSnippets(</span><span class="s2">this</span><span class="s1">.outputOptions)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">includedModules = getIncludedModules(</span><span class="s2">this</span><span class="s1">.graph.modulesById)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">inputBase = commondir(getAbsoluteEntryModulePaths(includedModules</span><span class="s2">, </span><span class="s1">preserveModules))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">externalChunkByModule = getExternalChunkByModule(</span><span class="s2">this</span><span class="s1">.graph.modulesById</span><span class="s2">, this</span><span class="s1">.outputOptions</span><span class="s2">, </span><span class="s1">inputBase)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">chunks = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">chunkByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ alias</span><span class="s2">, </span><span class="s1">modules } of inlineDynamicImports</span>
            <span class="s1">? [{ alias: </span><span class="s2">null, </span><span class="s1">modules: includedModules }]</span>
            <span class="s1">: preserveModules</span>
                <span class="s1">? includedModules.map(module =&gt; ({ alias: </span><span class="s2">null, </span><span class="s1">modules: [module] }))</span>
                <span class="s1">: getChunkAssignments(</span><span class="s2">this</span><span class="s1">.graph.entryModules</span><span class="s2">, </span><span class="s1">manualChunkAliasByEntry</span><span class="s2">, </span><span class="s1">experimentalMinChunkSize)) {</span>
            <span class="s1">sortByExecutionOrder(modules)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">chunk = </span><span class="s2">new </span><span class="s1">Chunk(modules</span><span class="s2">, this</span><span class="s1">.inputOptions</span><span class="s2">, this</span><span class="s1">.outputOptions</span><span class="s2">, this</span><span class="s1">.unsetOptions</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.graph.modulesById</span><span class="s2">, </span><span class="s1">chunkByModule</span><span class="s2">, </span><span class="s1">externalChunkByModule</span><span class="s2">, this</span><span class="s1">.facadeChunkByModule</span><span class="s2">, this</span><span class="s1">.includedNamespaces</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">getHashPlaceholder</span><span class="s2">, </span><span class="s1">bundle</span><span class="s2">, </span><span class="s1">inputBase</span><span class="s2">, </span><span class="s1">snippets)</span><span class="s2">;</span>
            <span class="s1">chunks.push(chunk)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of chunks) {</span>
            <span class="s1">chunk.link()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">facades = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">chunk of chunks) {</span>
            <span class="s1">facades.push(...chunk.generateFacades())</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[...chunks</span><span class="s2">, </span><span class="s1">...facades]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateOptionsForMultiChunkOutput(outputOptions</span><span class="s2">, </span><span class="s1">onWarn) {</span>
    <span class="s2">if </span><span class="s1">(outputOptions.format === </span><span class="s3">'umd' </span><span class="s1">|| outputOptions.format === </span><span class="s3">'iife'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.format'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_FORMAT</span><span class="s2">, </span><span class="s3">'UMD and IIFE output formats are not supported for code-splitting builds'</span><span class="s2">, </span><span class="s1">outputOptions.format))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">outputOptions.file === </span><span class="s3">'string'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.file'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_DIR</span><span class="s2">, </span><span class="s3">'when building multiple chunks, the &quot;output.dir&quot; option must be used, not &quot;output.file&quot;. To inline dynamic imports, set the &quot;inlineDynamicImports&quot; option'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(outputOptions.sourcemapFile)</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.sourcemapFile'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_SOURCEMAPFILE</span><span class="s2">, </span><span class="s3">'&quot;output.sourcemapFile&quot; is only supported for single-file builds'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!outputOptions.amd.autoId &amp;&amp; outputOptions.amd.id)</span>
        <span class="s1">onWarn(errorInvalidOption(</span><span class="s3">'output.amd.id'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_AMD_ID</span><span class="s2">, </span><span class="s3">'this option is only properly supported for single-file builds. Use &quot;output.amd.autoId&quot; and &quot;output.amd.basePath&quot; instead'</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getIncludedModules(modulesById) {</span>
    <span class="s2">const </span><span class="s1">includedModules = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modulesById.values()) {</span>
        <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">Module &amp;&amp;</span>
            <span class="s1">(module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s1">includedModules.push(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">includedModules</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAbsoluteEntryModulePaths(includedModules</span><span class="s2">, </span><span class="s1">preserveModules) {</span>
    <span class="s2">const </span><span class="s1">absoluteEntryModulePaths = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of includedModules) {</span>
        <span class="s2">if </span><span class="s1">((module.info.isEntry || preserveModules) &amp;&amp; isAbsolute(module.id)) {</span>
            <span class="s1">absoluteEntryModulePaths.push(module.id)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">absoluteEntryModulePaths</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExternalChunkByModule(modulesById</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">inputBase) {</span>
    <span class="s2">const </span><span class="s1">externalChunkByModule = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of modulesById.values()) {</span>
        <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">ExternalModule) {</span>
            <span class="s1">externalChunkByModule.set(module</span><span class="s2">, new </span><span class="s1">ExternalChunk(module</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">inputBase))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">externalChunkByModule</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addModuleToManualChunk(alias</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">manualChunkAliasByEntry) {</span>
    <span class="s2">const </span><span class="s1">existingAlias = manualChunkAliasByEntry.get(module)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">existingAlias === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; existingAlias !== alias) {</span>
        <span class="s2">return </span><span class="s1">error(errorCannotAssignModuleToChunk(module.id</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">existingAlias))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">manualChunkAliasByEntry.set(module</span><span class="s2">, </span><span class="s1">alias)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// This file was generated. Do not modify manually!</span>
<span class="s2">var </span><span class="s1">astralIdentifierCodes = [</span><span class="s4">509</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">227</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">150</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">294</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">1368</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">166</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">574</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">370</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">81</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">123</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">83</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">158</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">193</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">82</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">214</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">83</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">82</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">84</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">243</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">166</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">406</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">57</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">123</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">330</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">5351</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">13835</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">87</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">1014</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">82</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">19628</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4706</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">543</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">149</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1418</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">513</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">49</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">1361</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">101</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">161</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">357</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">62</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">499</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">983</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">4759</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">787719</span><span class="s2">, </span><span class="s4">239</span><span class="s1">]</span><span class="s2">;</span>

<span class="s0">// This file was generated. Do not modify manually!</span>
<span class="s2">var </span><span class="s1">astralIdentifierStartCodes = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">122</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">268</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">157</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">51</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">68</span><span class="s2">, </span><span class="s4">310</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">66</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">71</span><span class="s2">, </span><span class="s4">55</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">65</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">53</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">111</span><span class="s2">, </span><span class="s4">72</span><span class="s2">, </span><span class="s4">56</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">349</span><span class="s2">, </span><span class="s4">41</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">79</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">28</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">58</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">35</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">34</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">64</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">159</span><span class="s2">, </span><span class="s4">52</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">185</span><span class="s2">, </span><span class="s4">46</span><span class="s2">, </span><span class="s4">42</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">21</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">42</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">72</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">38</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">186</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">117</span><span class="s2">, </span><span class="s4">63</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">95</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">38</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">39</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">72</span><span class="s2">, </span><span class="s4">264</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">113</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">328</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">125</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">80</span><span class="s2">, </span><span class="s4">921</span><span class="s2">, </span><span class="s4">103</span><span class="s2">, </span><span class="s4">110</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">195</span><span class="s2">, </span><span class="s4">2637</span><span class="s2">, </span><span class="s4">96</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">1071</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4026</span><span class="s2">, </span><span class="s4">582</span><span class="s2">, </span><span class="s4">8634</span><span class="s2">, </span><span class="s4">568</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">78</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">47</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">18</span><span class="s2">, </span><span class="s4">689</span><span class="s2">, </span><span class="s4">63</span><span class="s2">, </span><span class="s4">129</span><span class="s2">, </span><span class="s4">74</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">65</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">6135</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">1237</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">8936</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">290</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">395</span><span class="s2">, </span><span class="s4">2309</span><span class="s2">, </span><span class="s4">106</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">5991</span><span class="s2">, </span><span class="s4">84</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">70</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">64</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">339</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">24</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">1845</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">262</span><span class="s2">, </span><span class="s4">61</span><span class="s2">, </span><span class="s4">147</span><span class="s2">, </span><span class="s4">44</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">322</span><span class="s2">, </span><span class="s4">29</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">485</span><span class="s2">, </span><span class="s4">27</span><span class="s2">, </span><span class="s4">757</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">196</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">67</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1205</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">26</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">16</span><span class="s2">, </span><span class="s4">4421</span><span class="s2">, </span><span class="s4">42719</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">4153</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">221</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5761</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">7472</span><span class="s2">, </span><span class="s4">3104</span><span class="s2">, </span><span class="s4">541</span><span class="s2">, </span><span class="s4">1507</span><span class="s2">, </span><span class="s4">4938</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4191</span><span class="s1">]</span><span class="s2">;</span>

<span class="s0">// This file was generated. Do not modify manually!</span>
<span class="s2">var </span><span class="s1">nonASCIIidentifierChars = </span><span class="s3">&quot;</span><span class="s2">\u200c\u200d\xb7\u0300</span><span class="s3">-</span><span class="s2">\u036f\u0387\u0483</span><span class="s3">-</span><span class="s2">\u0487\u0591</span><span class="s3">-</span><span class="s2">\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610</span><span class="s3">-</span><span class="s2">\u061a\u064b</span><span class="s3">-</span><span class="s2">\u0669\u0670\u06d6</span><span class="s3">-</span><span class="s2">\u06dc\u06df</span><span class="s3">-</span><span class="s2">\u06e4\u06e7\u06e8\u06ea</span><span class="s3">-</span><span class="s2">\u06ed\u06f0</span><span class="s3">-</span><span class="s2">\u06f9\u0711\u0730</span><span class="s3">-</span><span class="s2">\u074a\u07a6</span><span class="s3">-</span><span class="s2">\u07b0\u07c0</span><span class="s3">-</span><span class="s2">\u07c9\u07eb</span><span class="s3">-</span><span class="s2">\u07f3\u07fd\u0816</span><span class="s3">-</span><span class="s2">\u0819\u081b</span><span class="s3">-</span><span class="s2">\u0823\u0825</span><span class="s3">-</span><span class="s2">\u0827\u0829</span><span class="s3">-</span><span class="s2">\u082d\u0859</span><span class="s3">-</span><span class="s2">\u085b\u0898</span><span class="s3">-</span><span class="s2">\u089f\u08ca</span><span class="s3">-</span><span class="s2">\u08e1\u08e3</span><span class="s3">-</span><span class="s2">\u0903\u093a</span><span class="s3">-</span><span class="s2">\u093c\u093e</span><span class="s3">-</span><span class="s2">\u094f\u0951</span><span class="s3">-</span><span class="s2">\u0957\u0962\u0963\u0966</span><span class="s3">-</span><span class="s2">\u096f\u0981</span><span class="s3">-</span><span class="s2">\u0983\u09bc\u09be</span><span class="s3">-</span><span class="s2">\u09c4\u09c7\u09c8\u09cb</span><span class="s3">-</span><span class="s2">\u09cd\u09d7\u09e2\u09e3\u09e6</span><span class="s3">-</span><span class="s2">\u09ef\u09fe\u0a01</span><span class="s3">-</span><span class="s2">\u0a03\u0a3c\u0a3e</span><span class="s3">-</span><span class="s2">\u0a42\u0a47\u0a48\u0a4b</span><span class="s3">-</span><span class="s2">\u0a4d\u0a51\u0a66</span><span class="s3">-</span><span class="s2">\u0a71\u0a75\u0a81</span><span class="s3">-</span><span class="s2">\u0a83\u0abc\u0abe</span><span class="s3">-</span><span class="s2">\u0ac5\u0ac7</span><span class="s3">-</span><span class="s2">\u0ac9\u0acb</span><span class="s3">-</span><span class="s2">\u0acd\u0ae2\u0ae3\u0ae6</span><span class="s3">-</span><span class="s2">\u0aef\u0afa</span><span class="s3">-</span><span class="s2">\u0aff\u0b01</span><span class="s3">-</span><span class="s2">\u0b03\u0b3c\u0b3e</span><span class="s3">-</span><span class="s2">\u0b44\u0b47\u0b48\u0b4b</span><span class="s3">-</span><span class="s2">\u0b4d\u0b55</span><span class="s3">-</span><span class="s2">\u0b57\u0b62\u0b63\u0b66</span><span class="s3">-</span><span class="s2">\u0b6f\u0b82\u0bbe</span><span class="s3">-</span><span class="s2">\u0bc2\u0bc6</span><span class="s3">-</span><span class="s2">\u0bc8\u0bca</span><span class="s3">-</span><span class="s2">\u0bcd\u0bd7\u0be6</span><span class="s3">-</span><span class="s2">\u0bef\u0c00</span><span class="s3">-</span><span class="s2">\u0c04\u0c3c\u0c3e</span><span class="s3">-</span><span class="s2">\u0c44\u0c46</span><span class="s3">-</span><span class="s2">\u0c48\u0c4a</span><span class="s3">-</span><span class="s2">\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66</span><span class="s3">-</span><span class="s2">\u0c6f\u0c81</span><span class="s3">-</span><span class="s2">\u0c83\u0cbc\u0cbe</span><span class="s3">-</span><span class="s2">\u0cc4\u0cc6</span><span class="s3">-</span><span class="s2">\u0cc8\u0cca</span><span class="s3">-</span><span class="s2">\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6</span><span class="s3">-</span><span class="s2">\u0cef\u0cf3\u0d00</span><span class="s3">-</span><span class="s2">\u0d03\u0d3b\u0d3c\u0d3e</span><span class="s3">-</span><span class="s2">\u0d44\u0d46</span><span class="s3">-</span><span class="s2">\u0d48\u0d4a</span><span class="s3">-</span><span class="s2">\u0d4d\u0d57\u0d62\u0d63\u0d66</span><span class="s3">-</span><span class="s2">\u0d6f\u0d81</span><span class="s3">-</span><span class="s2">\u0d83\u0dca\u0dcf</span><span class="s3">-</span><span class="s2">\u0dd4\u0dd6\u0dd8</span><span class="s3">-</span><span class="s2">\u0ddf\u0de6</span><span class="s3">-</span><span class="s2">\u0def\u0df2\u0df3\u0e31\u0e34</span><span class="s3">-</span><span class="s2">\u0e3a\u0e47</span><span class="s3">-</span><span class="s2">\u0e4e\u0e50</span><span class="s3">-</span><span class="s2">\u0e59\u0eb1\u0eb4</span><span class="s3">-</span><span class="s2">\u0ebc\u0ec8</span><span class="s3">-</span><span class="s2">\u0ece\u0ed0</span><span class="s3">-</span><span class="s2">\u0ed9\u0f18\u0f19\u0f20</span><span class="s3">-</span><span class="s2">\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71</span><span class="s3">-</span><span class="s2">\u0f84\u0f86\u0f87\u0f8d</span><span class="s3">-</span><span class="s2">\u0f97\u0f99</span><span class="s3">-</span><span class="s2">\u0fbc\u0fc6\u102b</span><span class="s3">-</span><span class="s2">\u103e\u1040</span><span class="s3">-</span><span class="s2">\u1049\u1056</span><span class="s3">-</span><span class="s2">\u1059\u105e</span><span class="s3">-</span><span class="s2">\u1060\u1062</span><span class="s3">-</span><span class="s2">\u1064\u1067</span><span class="s3">-</span><span class="s2">\u106d\u1071</span><span class="s3">-</span><span class="s2">\u1074\u1082</span><span class="s3">-</span><span class="s2">\u108d\u108f</span><span class="s3">-</span><span class="s2">\u109d\u135d</span><span class="s3">-</span><span class="s2">\u135f\u1369</span><span class="s3">-</span><span class="s2">\u1371\u1712</span><span class="s3">-</span><span class="s2">\u1715\u1732</span><span class="s3">-</span><span class="s2">\u1734\u1752\u1753\u1772\u1773\u17b4</span><span class="s3">-</span><span class="s2">\u17d3\u17dd\u17e0</span><span class="s3">-</span><span class="s2">\u17e9\u180b</span><span class="s3">-</span><span class="s2">\u180d\u180f</span><span class="s3">-</span><span class="s2">\u1819\u18a9\u1920</span><span class="s3">-</span><span class="s2">\u192b\u1930</span><span class="s3">-</span><span class="s2">\u193b\u1946</span><span class="s3">-</span><span class="s2">\u194f\u19d0</span><span class="s3">-</span><span class="s2">\u19da\u1a17</span><span class="s3">-</span><span class="s2">\u1a1b\u1a55</span><span class="s3">-</span><span class="s2">\u1a5e\u1a60</span><span class="s3">-</span><span class="s2">\u1a7c\u1a7f</span><span class="s3">-</span><span class="s2">\u1a89\u1a90</span><span class="s3">-</span><span class="s2">\u1a99\u1ab0</span><span class="s3">-</span><span class="s2">\u1abd\u1abf</span><span class="s3">-</span><span class="s2">\u1ace\u1b00</span><span class="s3">-</span><span class="s2">\u1b04\u1b34</span><span class="s3">-</span><span class="s2">\u1b44\u1b50</span><span class="s3">-</span><span class="s2">\u1b59\u1b6b</span><span class="s3">-</span><span class="s2">\u1b73\u1b80</span><span class="s3">-</span><span class="s2">\u1b82\u1ba1</span><span class="s3">-</span><span class="s2">\u1bad\u1bb0</span><span class="s3">-</span><span class="s2">\u1bb9\u1be6</span><span class="s3">-</span><span class="s2">\u1bf3\u1c24</span><span class="s3">-</span><span class="s2">\u1c37\u1c40</span><span class="s3">-</span><span class="s2">\u1c49\u1c50</span><span class="s3">-</span><span class="s2">\u1c59\u1cd0</span><span class="s3">-</span><span class="s2">\u1cd2\u1cd4</span><span class="s3">-</span><span class="s2">\u1ce8\u1ced\u1cf4\u1cf7</span><span class="s3">-</span><span class="s2">\u1cf9\u1dc0</span><span class="s3">-</span><span class="s2">\u1dff\u203f\u2040\u2054\u20d0</span><span class="s3">-</span><span class="s2">\u20dc\u20e1\u20e5</span><span class="s3">-</span><span class="s2">\u20f0\u2cef</span><span class="s3">-</span><span class="s2">\u2cf1\u2d7f\u2de0</span><span class="s3">-</span><span class="s2">\u2dff\u302a</span><span class="s3">-</span><span class="s2">\u302f\u3099\u309a\ua620</span><span class="s3">-</span><span class="s2">\ua629\ua66f\ua674</span><span class="s3">-</span><span class="s2">\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823</span><span class="s3">-</span><span class="s2">\ua827\ua82c\ua880\ua881\ua8b4</span><span class="s3">-</span><span class="s2">\ua8c5\ua8d0</span><span class="s3">-</span><span class="s2">\ua8d9\ua8e0</span><span class="s3">-</span><span class="s2">\ua8f1\ua8ff</span><span class="s3">-</span><span class="s2">\ua909\ua926</span><span class="s3">-</span><span class="s2">\ua92d\ua947</span><span class="s3">-</span><span class="s2">\ua953\ua980</span><span class="s3">-</span><span class="s2">\ua983\ua9b3</span><span class="s3">-</span><span class="s2">\ua9c0\ua9d0</span><span class="s3">-</span><span class="s2">\ua9d9\ua9e5\ua9f0</span><span class="s3">-</span><span class="s2">\ua9f9\uaa29</span><span class="s3">-</span><span class="s2">\uaa36\uaa43\uaa4c\uaa4d\uaa50</span><span class="s3">-</span><span class="s2">\uaa59\uaa7b</span><span class="s3">-</span><span class="s2">\uaa7d\uaab0\uaab2</span><span class="s3">-</span><span class="s2">\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb</span><span class="s3">-</span><span class="s2">\uaaef\uaaf5\uaaf6\uabe3</span><span class="s3">-</span><span class="s2">\uabea\uabec\uabed\uabf0</span><span class="s3">-</span><span class="s2">\uabf9\ufb1e\ufe00</span><span class="s3">-</span><span class="s2">\ufe0f\ufe20</span><span class="s3">-</span><span class="s2">\ufe2f\ufe33\ufe34\ufe4d</span><span class="s3">-</span><span class="s2">\ufe4f\uff10</span><span class="s3">-</span><span class="s2">\uff19\uff3f</span><span class="s3">&quot;</span><span class="s2">;</span>

<span class="s0">// This file was generated. Do not modify manually!</span>
<span class="s2">var </span><span class="s1">nonASCIIidentifierStartChars = </span><span class="s3">&quot;</span><span class="s2">\xaa\xb5\xba\xc0</span><span class="s3">-</span><span class="s2">\xd6\xd8</span><span class="s3">-</span><span class="s2">\xf6\xf8</span><span class="s3">-</span><span class="s2">\u02c1\u02c6</span><span class="s3">-</span><span class="s2">\u02d1\u02e0</span><span class="s3">-</span><span class="s2">\u02e4\u02ec\u02ee\u0370</span><span class="s3">-</span><span class="s2">\u0374\u0376\u0377\u037a</span><span class="s3">-</span><span class="s2">\u037d\u037f\u0386\u0388</span><span class="s3">-</span><span class="s2">\u038a\u038c\u038e</span><span class="s3">-</span><span class="s2">\u03a1\u03a3</span><span class="s3">-</span><span class="s2">\u03f5\u03f7</span><span class="s3">-</span><span class="s2">\u0481\u048a</span><span class="s3">-</span><span class="s2">\u052f\u0531</span><span class="s3">-</span><span class="s2">\u0556\u0559\u0560</span><span class="s3">-</span><span class="s2">\u0588\u05d0</span><span class="s3">-</span><span class="s2">\u05ea\u05ef</span><span class="s3">-</span><span class="s2">\u05f2\u0620</span><span class="s3">-</span><span class="s2">\u064a\u066e\u066f\u0671</span><span class="s3">-</span><span class="s2">\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa</span><span class="s3">-</span><span class="s2">\u06fc\u06ff\u0710\u0712</span><span class="s3">-</span><span class="s2">\u072f\u074d</span><span class="s3">-</span><span class="s2">\u07a5\u07b1\u07ca</span><span class="s3">-</span><span class="s2">\u07ea\u07f4\u07f5\u07fa\u0800</span><span class="s3">-</span><span class="s2">\u0815\u081a\u0824\u0828\u0840</span><span class="s3">-</span><span class="s2">\u0858\u0860</span><span class="s3">-</span><span class="s2">\u086a\u0870</span><span class="s3">-</span><span class="s2">\u0887\u0889</span><span class="s3">-</span><span class="s2">\u088e\u08a0</span><span class="s3">-</span><span class="s2">\u08c9\u0904</span><span class="s3">-</span><span class="s2">\u0939\u093d\u0950\u0958</span><span class="s3">-</span><span class="s2">\u0961\u0971</span><span class="s3">-</span><span class="s2">\u0980\u0985</span><span class="s3">-</span><span class="s2">\u098c\u098f\u0990\u0993</span><span class="s3">-</span><span class="s2">\u09a8\u09aa</span><span class="s3">-</span><span class="s2">\u09b0\u09b2\u09b6</span><span class="s3">-</span><span class="s2">\u09b9\u09bd\u09ce\u09dc\u09dd\u09df</span><span class="s3">-</span><span class="s2">\u09e1\u09f0\u09f1\u09fc\u0a05</span><span class="s3">-</span><span class="s2">\u0a0a\u0a0f\u0a10\u0a13</span><span class="s3">-</span><span class="s2">\u0a28\u0a2a</span><span class="s3">-</span><span class="s2">\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59</span><span class="s3">-</span><span class="s2">\u0a5c\u0a5e\u0a72</span><span class="s3">-</span><span class="s2">\u0a74\u0a85</span><span class="s3">-</span><span class="s2">\u0a8d\u0a8f</span><span class="s3">-</span><span class="s2">\u0a91\u0a93</span><span class="s3">-</span><span class="s2">\u0aa8\u0aaa</span><span class="s3">-</span><span class="s2">\u0ab0\u0ab2\u0ab3\u0ab5</span><span class="s3">-</span><span class="s2">\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05</span><span class="s3">-</span><span class="s2">\u0b0c\u0b0f\u0b10\u0b13</span><span class="s3">-</span><span class="s2">\u0b28\u0b2a</span><span class="s3">-</span><span class="s2">\u0b30\u0b32\u0b33\u0b35</span><span class="s3">-</span><span class="s2">\u0b39\u0b3d\u0b5c\u0b5d\u0b5f</span><span class="s3">-</span><span class="s2">\u0b61\u0b71\u0b83\u0b85</span><span class="s3">-</span><span class="s2">\u0b8a\u0b8e</span><span class="s3">-</span><span class="s2">\u0b90\u0b92</span><span class="s3">-</span><span class="s2">\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8</span><span class="s3">-</span><span class="s2">\u0baa\u0bae</span><span class="s3">-</span><span class="s2">\u0bb9\u0bd0\u0c05</span><span class="s3">-</span><span class="s2">\u0c0c\u0c0e</span><span class="s3">-</span><span class="s2">\u0c10\u0c12</span><span class="s3">-</span><span class="s2">\u0c28\u0c2a</span><span class="s3">-</span><span class="s2">\u0c39\u0c3d\u0c58</span><span class="s3">-</span><span class="s2">\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85</span><span class="s3">-</span><span class="s2">\u0c8c\u0c8e</span><span class="s3">-</span><span class="s2">\u0c90\u0c92</span><span class="s3">-</span><span class="s2">\u0ca8\u0caa</span><span class="s3">-</span><span class="s2">\u0cb3\u0cb5</span><span class="s3">-</span><span class="s2">\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04</span><span class="s3">-</span><span class="s2">\u0d0c\u0d0e</span><span class="s3">-</span><span class="s2">\u0d10\u0d12</span><span class="s3">-</span><span class="s2">\u0d3a\u0d3d\u0d4e\u0d54</span><span class="s3">-</span><span class="s2">\u0d56\u0d5f</span><span class="s3">-</span><span class="s2">\u0d61\u0d7a</span><span class="s3">-</span><span class="s2">\u0d7f\u0d85</span><span class="s3">-</span><span class="s2">\u0d96\u0d9a</span><span class="s3">-</span><span class="s2">\u0db1\u0db3</span><span class="s3">-</span><span class="s2">\u0dbb\u0dbd\u0dc0</span><span class="s3">-</span><span class="s2">\u0dc6\u0e01</span><span class="s3">-</span><span class="s2">\u0e30\u0e32\u0e33\u0e40</span><span class="s3">-</span><span class="s2">\u0e46\u0e81\u0e82\u0e84\u0e86</span><span class="s3">-</span><span class="s2">\u0e8a\u0e8c</span><span class="s3">-</span><span class="s2">\u0ea3\u0ea5\u0ea7</span><span class="s3">-</span><span class="s2">\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0</span><span class="s3">-</span><span class="s2">\u0ec4\u0ec6\u0edc</span><span class="s3">-</span><span class="s2">\u0edf\u0f00\u0f40</span><span class="s3">-</span><span class="s2">\u0f47\u0f49</span><span class="s3">-</span><span class="s2">\u0f6c\u0f88</span><span class="s3">-</span><span class="s2">\u0f8c\u1000</span><span class="s3">-</span><span class="s2">\u102a\u103f\u1050</span><span class="s3">-</span><span class="s2">\u1055\u105a</span><span class="s3">-</span><span class="s2">\u105d\u1061\u1065\u1066\u106e</span><span class="s3">-</span><span class="s2">\u1070\u1075</span><span class="s3">-</span><span class="s2">\u1081\u108e\u10a0</span><span class="s3">-</span><span class="s2">\u10c5\u10c7\u10cd\u10d0</span><span class="s3">-</span><span class="s2">\u10fa\u10fc</span><span class="s3">-</span><span class="s2">\u1248\u124a</span><span class="s3">-</span><span class="s2">\u124d\u1250</span><span class="s3">-</span><span class="s2">\u1256\u1258\u125a</span><span class="s3">-</span><span class="s2">\u125d\u1260</span><span class="s3">-</span><span class="s2">\u1288\u128a</span><span class="s3">-</span><span class="s2">\u128d\u1290</span><span class="s3">-</span><span class="s2">\u12b0\u12b2</span><span class="s3">-</span><span class="s2">\u12b5\u12b8</span><span class="s3">-</span><span class="s2">\u12be\u12c0\u12c2</span><span class="s3">-</span><span class="s2">\u12c5\u12c8</span><span class="s3">-</span><span class="s2">\u12d6\u12d8</span><span class="s3">-</span><span class="s2">\u1310\u1312</span><span class="s3">-</span><span class="s2">\u1315\u1318</span><span class="s3">-</span><span class="s2">\u135a\u1380</span><span class="s3">-</span><span class="s2">\u138f\u13a0</span><span class="s3">-</span><span class="s2">\u13f5\u13f8</span><span class="s3">-</span><span class="s2">\u13fd\u1401</span><span class="s3">-</span><span class="s2">\u166c\u166f</span><span class="s3">-</span><span class="s2">\u167f\u1681</span><span class="s3">-</span><span class="s2">\u169a\u16a0</span><span class="s3">-</span><span class="s2">\u16ea\u16ee</span><span class="s3">-</span><span class="s2">\u16f8\u1700</span><span class="s3">-</span><span class="s2">\u1711\u171f</span><span class="s3">-</span><span class="s2">\u1731\u1740</span><span class="s3">-</span><span class="s2">\u1751\u1760</span><span class="s3">-</span><span class="s2">\u176c\u176e</span><span class="s3">-</span><span class="s2">\u1770\u1780</span><span class="s3">-</span><span class="s2">\u17b3\u17d7\u17dc\u1820</span><span class="s3">-</span><span class="s2">\u1878\u1880</span><span class="s3">-</span><span class="s2">\u18a8\u18aa\u18b0</span><span class="s3">-</span><span class="s2">\u18f5\u1900</span><span class="s3">-</span><span class="s2">\u191e\u1950</span><span class="s3">-</span><span class="s2">\u196d\u1970</span><span class="s3">-</span><span class="s2">\u1974\u1980</span><span class="s3">-</span><span class="s2">\u19ab\u19b0</span><span class="s3">-</span><span class="s2">\u19c9\u1a00</span><span class="s3">-</span><span class="s2">\u1a16\u1a20</span><span class="s3">-</span><span class="s2">\u1a54\u1aa7\u1b05</span><span class="s3">-</span><span class="s2">\u1b33\u1b45</span><span class="s3">-</span><span class="s2">\u1b4c\u1b83</span><span class="s3">-</span><span class="s2">\u1ba0\u1bae\u1baf\u1bba</span><span class="s3">-</span><span class="s2">\u1be5\u1c00</span><span class="s3">-</span><span class="s2">\u1c23\u1c4d</span><span class="s3">-</span><span class="s2">\u1c4f\u1c5a</span><span class="s3">-</span><span class="s2">\u1c7d\u1c80</span><span class="s3">-</span><span class="s2">\u1c88\u1c90</span><span class="s3">-</span><span class="s2">\u1cba\u1cbd</span><span class="s3">-</span><span class="s2">\u1cbf\u1ce9</span><span class="s3">-</span><span class="s2">\u1cec\u1cee</span><span class="s3">-</span><span class="s2">\u1cf3\u1cf5\u1cf6\u1cfa\u1d00</span><span class="s3">-</span><span class="s2">\u1dbf\u1e00</span><span class="s3">-</span><span class="s2">\u1f15\u1f18</span><span class="s3">-</span><span class="s2">\u1f1d\u1f20</span><span class="s3">-</span><span class="s2">\u1f45\u1f48</span><span class="s3">-</span><span class="s2">\u1f4d\u1f50</span><span class="s3">-</span><span class="s2">\u1f57\u1f59\u1f5b\u1f5d\u1f5f</span><span class="s3">-</span><span class="s2">\u1f7d\u1f80</span><span class="s3">-</span><span class="s2">\u1fb4\u1fb6</span><span class="s3">-</span><span class="s2">\u1fbc\u1fbe\u1fc2</span><span class="s3">-</span><span class="s2">\u1fc4\u1fc6</span><span class="s3">-</span><span class="s2">\u1fcc\u1fd0</span><span class="s3">-</span><span class="s2">\u1fd3\u1fd6</span><span class="s3">-</span><span class="s2">\u1fdb\u1fe0</span><span class="s3">-</span><span class="s2">\u1fec\u1ff2</span><span class="s3">-</span><span class="s2">\u1ff4\u1ff6</span><span class="s3">-</span><span class="s2">\u1ffc\u2071\u207f\u2090</span><span class="s3">-</span><span class="s2">\u209c\u2102\u2107\u210a</span><span class="s3">-</span><span class="s2">\u2113\u2115\u2118</span><span class="s3">-</span><span class="s2">\u211d\u2124\u2126\u2128\u212a</span><span class="s3">-</span><span class="s2">\u2139\u213c</span><span class="s3">-</span><span class="s2">\u213f\u2145</span><span class="s3">-</span><span class="s2">\u2149\u214e\u2160</span><span class="s3">-</span><span class="s2">\u2188\u2c00</span><span class="s3">-</span><span class="s2">\u2ce4\u2ceb</span><span class="s3">-</span><span class="s2">\u2cee\u2cf2\u2cf3\u2d00</span><span class="s3">-</span><span class="s2">\u2d25\u2d27\u2d2d\u2d30</span><span class="s3">-</span><span class="s2">\u2d67\u2d6f\u2d80</span><span class="s3">-</span><span class="s2">\u2d96\u2da0</span><span class="s3">-</span><span class="s2">\u2da6\u2da8</span><span class="s3">-</span><span class="s2">\u2dae\u2db0</span><span class="s3">-</span><span class="s2">\u2db6\u2db8</span><span class="s3">-</span><span class="s2">\u2dbe\u2dc0</span><span class="s3">-</span><span class="s2">\u2dc6\u2dc8</span><span class="s3">-</span><span class="s2">\u2dce\u2dd0</span><span class="s3">-</span><span class="s2">\u2dd6\u2dd8</span><span class="s3">-</span><span class="s2">\u2dde\u3005</span><span class="s3">-</span><span class="s2">\u3007\u3021</span><span class="s3">-</span><span class="s2">\u3029\u3031</span><span class="s3">-</span><span class="s2">\u3035\u3038</span><span class="s3">-</span><span class="s2">\u303c\u3041</span><span class="s3">-</span><span class="s2">\u3096\u309b</span><span class="s3">-</span><span class="s2">\u309f\u30a1</span><span class="s3">-</span><span class="s2">\u30fa\u30fc</span><span class="s3">-</span><span class="s2">\u30ff\u3105</span><span class="s3">-</span><span class="s2">\u312f\u3131</span><span class="s3">-</span><span class="s2">\u318e\u31a0</span><span class="s3">-</span><span class="s2">\u31bf\u31f0</span><span class="s3">-</span><span class="s2">\u31ff\u3400</span><span class="s3">-</span><span class="s2">\u4dbf\u4e00</span><span class="s3">-</span><span class="s2">\ua48c\ua4d0</span><span class="s3">-</span><span class="s2">\ua4fd\ua500</span><span class="s3">-</span><span class="s2">\ua60c\ua610</span><span class="s3">-</span><span class="s2">\ua61f\ua62a\ua62b\ua640</span><span class="s3">-</span><span class="s2">\ua66e\ua67f</span><span class="s3">-</span><span class="s2">\ua69d\ua6a0</span><span class="s3">-</span><span class="s2">\ua6ef\ua717</span><span class="s3">-</span><span class="s2">\ua71f\ua722</span><span class="s3">-</span><span class="s2">\ua788\ua78b</span><span class="s3">-</span><span class="s2">\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5</span><span class="s3">-</span><span class="s2">\ua7d9\ua7f2</span><span class="s3">-</span><span class="s2">\ua801\ua803</span><span class="s3">-</span><span class="s2">\ua805\ua807</span><span class="s3">-</span><span class="s2">\ua80a\ua80c</span><span class="s3">-</span><span class="s2">\ua822\ua840</span><span class="s3">-</span><span class="s2">\ua873\ua882</span><span class="s3">-</span><span class="s2">\ua8b3\ua8f2</span><span class="s3">-</span><span class="s2">\ua8f7\ua8fb\ua8fd\ua8fe\ua90a</span><span class="s3">-</span><span class="s2">\ua925\ua930</span><span class="s3">-</span><span class="s2">\ua946\ua960</span><span class="s3">-</span><span class="s2">\ua97c\ua984</span><span class="s3">-</span><span class="s2">\ua9b2\ua9cf\ua9e0</span><span class="s3">-</span><span class="s2">\ua9e4\ua9e6</span><span class="s3">-</span><span class="s2">\ua9ef\ua9fa</span><span class="s3">-</span><span class="s2">\ua9fe\uaa00</span><span class="s3">-</span><span class="s2">\uaa28\uaa40</span><span class="s3">-</span><span class="s2">\uaa42\uaa44</span><span class="s3">-</span><span class="s2">\uaa4b\uaa60</span><span class="s3">-</span><span class="s2">\uaa76\uaa7a\uaa7e</span><span class="s3">-</span><span class="s2">\uaaaf\uaab1\uaab5\uaab6\uaab9</span><span class="s3">-</span><span class="s2">\uaabd\uaac0\uaac2\uaadb</span><span class="s3">-</span><span class="s2">\uaadd\uaae0</span><span class="s3">-</span><span class="s2">\uaaea\uaaf2</span><span class="s3">-</span><span class="s2">\uaaf4\uab01</span><span class="s3">-</span><span class="s2">\uab06\uab09</span><span class="s3">-</span><span class="s2">\uab0e\uab11</span><span class="s3">-</span><span class="s2">\uab16\uab20</span><span class="s3">-</span><span class="s2">\uab26\uab28</span><span class="s3">-</span><span class="s2">\uab2e\uab30</span><span class="s3">-</span><span class="s2">\uab5a\uab5c</span><span class="s3">-</span><span class="s2">\uab69\uab70</span><span class="s3">-</span><span class="s2">\uabe2\uac00</span><span class="s3">-</span><span class="s2">\ud7a3\ud7b0</span><span class="s3">-</span><span class="s2">\ud7c6\ud7cb</span><span class="s3">-</span><span class="s2">\ud7fb\uf900</span><span class="s3">-</span><span class="s2">\ufa6d\ufa70</span><span class="s3">-</span><span class="s2">\ufad9\ufb00</span><span class="s3">-</span><span class="s2">\ufb06\ufb13</span><span class="s3">-</span><span class="s2">\ufb17\ufb1d\ufb1f</span><span class="s3">-</span><span class="s2">\ufb28\ufb2a</span><span class="s3">-</span><span class="s2">\ufb36\ufb38</span><span class="s3">-</span><span class="s2">\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46</span><span class="s3">-</span><span class="s2">\ufbb1\ufbd3</span><span class="s3">-</span><span class="s2">\ufd3d\ufd50</span><span class="s3">-</span><span class="s2">\ufd8f\ufd92</span><span class="s3">-</span><span class="s2">\ufdc7\ufdf0</span><span class="s3">-</span><span class="s2">\ufdfb\ufe70</span><span class="s3">-</span><span class="s2">\ufe74\ufe76</span><span class="s3">-</span><span class="s2">\ufefc\uff21</span><span class="s3">-</span><span class="s2">\uff3a\uff41</span><span class="s3">-</span><span class="s2">\uff5a\uff66</span><span class="s3">-</span><span class="s2">\uffbe\uffc2</span><span class="s3">-</span><span class="s2">\uffc7\uffca</span><span class="s3">-</span><span class="s2">\uffcf\uffd2</span><span class="s3">-</span><span class="s2">\uffd7\uffda</span><span class="s3">-</span><span class="s2">\uffdc</span><span class="s3">&quot;</span><span class="s2">;</span>

<span class="s0">// These are a run-length and offset encoded representation of the</span>

<span class="s0">// Reserved word lists for various dialects of the language</span>

<span class="s2">var </span><span class="s1">reservedWords = {</span>
  <span class="s4">3</span><span class="s1">: </span><span class="s3">&quot;abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile&quot;</span><span class="s2">,</span>
  <span class="s4">5</span><span class="s1">: </span><span class="s3">&quot;class enum extends super const export import&quot;</span><span class="s2">,</span>
  <span class="s4">6</span><span class="s1">: </span><span class="s3">&quot;enum&quot;</span><span class="s2">,</span>
  <span class="s1">strict: </span><span class="s3">&quot;implements interface let package private protected public static yield&quot;</span><span class="s2">,</span>
  <span class="s1">strictBind: </span><span class="s3">&quot;eval arguments&quot;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// And the keywords</span>

<span class="s2">var </span><span class="s1">ecma5AndLessKeywords = </span><span class="s3">&quot;break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this&quot;</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">keywords$1 = {</span>
  <span class="s4">5</span><span class="s1">: ecma5AndLessKeywords</span><span class="s2">,</span>
  <span class="s3">&quot;5module&quot;</span><span class="s1">: ecma5AndLessKeywords + </span><span class="s3">&quot; export import&quot;</span><span class="s2">,</span>
  <span class="s4">6</span><span class="s1">: ecma5AndLessKeywords + </span><span class="s3">&quot; const class extends export import super&quot;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">keywordRelationalOperator = </span><span class="s4">/^in(stanceof)?$/</span><span class="s2">;</span>

<span class="s0">// ## Character categories</span>

<span class="s2">var </span><span class="s1">nonASCIIidentifierStart = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">&quot;[&quot; </span><span class="s1">+ nonASCIIidentifierStartChars + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">nonASCIIidentifier = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">&quot;[&quot; </span><span class="s1">+ nonASCIIidentifierStartChars + nonASCIIidentifierChars + </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">;</span>

<span class="s0">// This has a complexity linear to the value of the code. The</span>
<span class="s0">// assumption is that looking up astral identifier characters is</span>
<span class="s0">// rare.</span>
<span class="s2">function </span><span class="s1">isInAstralSet(code</span><span class="s2">, </span><span class="s1">set) {</span>
  <span class="s2">var </span><span class="s1">pos = </span><span class="s4">0x10000</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; set.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s1">pos += set[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pos &gt; code) { </span><span class="s2">return false </span><span class="s1">}</span>
    <span class="s1">pos += set[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pos &gt;= code) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span>

<span class="s0">// Test whether a given character code starts an identifier.</span>

<span class="s2">function </span><span class="s1">isIdentifierStart(code</span><span class="s2">, </span><span class="s1">astral) {</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">65</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code === </span><span class="s4">36 </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">91</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">97</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code === </span><span class="s4">95 </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">123</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt;= </span><span class="s4">0xffff</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code &gt;= </span><span class="s4">0xaa </span><span class="s1">&amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code)) }</span>
  <span class="s2">if </span><span class="s1">(astral === </span><span class="s2">false</span><span class="s1">) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">isInAstralSet(code</span><span class="s2">, </span><span class="s1">astralIdentifierStartCodes)</span>
<span class="s1">}</span>

<span class="s0">// Test whether a given character is part of an identifier.</span>

<span class="s2">function </span><span class="s1">isIdentifierChar(code</span><span class="s2">, </span><span class="s1">astral) {</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">48</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code === </span><span class="s4">36 </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">58</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">65</span><span class="s1">) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">91</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">97</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code === </span><span class="s4">95 </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">123</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(code &lt;= </span><span class="s4">0xffff</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code &gt;= </span><span class="s4">0xaa </span><span class="s1">&amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code)) }</span>
  <span class="s2">if </span><span class="s1">(astral === </span><span class="s2">false</span><span class="s1">) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">isInAstralSet(code</span><span class="s2">, </span><span class="s1">astralIdentifierStartCodes) || isInAstralSet(code</span><span class="s2">, </span><span class="s1">astralIdentifierCodes)</span>
<span class="s1">}</span>

<span class="s0">// ## Token types</span>

<span class="s0">// The assignment of fine-grained, information-carrying type objects</span>
<span class="s0">// allows the tokenizer to store the information it has about a</span>
<span class="s0">// token in a way that is very cheap for the parser to look up.</span>

<span class="s0">// All token type variables start with an underscore, to make them</span>
<span class="s0">// easy to recognize.</span>

<span class="s0">// The `beforeExpr` property is used to disambiguate between regular</span>
<span class="s0">// expressions and divisions. It is set on all token types that can</span>
<span class="s0">// be followed by an expression (thus, a slash after them would be a</span>
<span class="s0">// regular expression).</span>
<span class="s0">//</span>
<span class="s0">// The `startsExpr` property is used to check if the token ends a</span>
<span class="s0">// `yield` expression. It is set on all token types that either can</span>
<span class="s0">// directly start an expression (like a quotation mark) or can</span>
<span class="s0">// continue an expression (like the body of a string).</span>
<span class="s0">//</span>
<span class="s0">// `isLoop` marks a keyword as starting a loop, which is important</span>
<span class="s0">// to know when parsing a label, in order to allow or disallow</span>
<span class="s0">// continue jumps to that label.</span>

<span class="s2">var </span><span class="s1">TokenType = </span><span class="s2">function </span><span class="s1">TokenType(label</span><span class="s2">, </span><span class="s1">conf) {</span>
  <span class="s2">if </span><span class="s1">( conf === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) conf = {}</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.label = label</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.keyword = conf.keyword</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.beforeExpr = !!conf.beforeExpr</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.startsExpr = !!conf.startsExpr</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.isLoop = !!conf.isLoop</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.isAssign = !!conf.isAssign</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.prefix = !!conf.prefix</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.postfix = !!conf.postfix</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.binop = conf.binop || </span><span class="s2">null;</span>
  <span class="s2">this</span><span class="s1">.updateContext = </span><span class="s2">null;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">binop(name</span><span class="s2">, </span><span class="s1">prec) {</span>
  <span class="s2">return new </span><span class="s1">TokenType(name</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">binop: prec})</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">beforeExpr = {beforeExpr: </span><span class="s2">true</span><span class="s1">}</span><span class="s2">, </span><span class="s1">startsExpr = {startsExpr: </span><span class="s2">true</span><span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Map keyword names to token types.</span>

<span class="s2">var </span><span class="s1">keywords = {}</span><span class="s2">;</span>

<span class="s0">// Succinct definitions of keyword token types</span>
<span class="s2">function </span><span class="s1">kw(name</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">if </span><span class="s1">( options === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) options = {}</span><span class="s2">;</span>

  <span class="s1">options.keyword = name</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">keywords[name] = </span><span class="s2">new </span><span class="s1">TokenType(name</span><span class="s2">, </span><span class="s1">options)</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">types$1 = {</span>
  <span class="s1">num: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;num&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">regexp: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;regexp&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">string: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;string&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">name: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">privateId: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;privateId&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">eof: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;eof&quot;</span><span class="s1">)</span><span class="s2">,</span>

  <span class="s0">// Punctuation token types.</span>
  <span class="s1">bracketL: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;[&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">bracketR: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;]&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">braceL: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;{&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">braceR: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;}&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">parenL: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;(&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">parenR: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;)&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">comma: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">semi: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;;&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">colon: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;:&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">dot: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">question: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;?&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">questionDot: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;?.&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">arrow: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;=&gt;&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">template: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;template&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">invalidTemplate: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;invalidTemplate&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">ellipsis: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;...&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">backQuote: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;`&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">dollarBraceL: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;${&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>

  <span class="s0">// Operators. These carry several kinds of properties to help the</span>
  <span class="s0">// parser use them properly (the presence of these properties is</span>
  <span class="s0">// what categorizes them as operators).</span>
  <span class="s0">//</span>
  <span class="s0">// `binop`, when present, specifies that this operator is a binary</span>
  <span class="s0">// operator, and will refer to its precedence.</span>
  <span class="s0">//</span>
  <span class="s0">// `prefix` and `postfix` mark the operator as a prefix or postfix</span>
  <span class="s0">// unary operator.</span>
  <span class="s0">//</span>
  <span class="s0">// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as</span>
  <span class="s0">// binary operators with a very low precedence, that should result</span>
  <span class="s0">// in AssignmentExpression nodes.</span>

  <span class="s1">eq: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;=&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">isAssign: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">assign: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;_=&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">isAssign: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">incDec: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;++/--&quot;</span><span class="s2">, </span><span class="s1">{prefix: </span><span class="s2">true, </span><span class="s1">postfix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">prefix: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;!/~&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">prefix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">logicalOR: binop(</span><span class="s3">&quot;||&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">logicalAND: binop(</span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bitwiseOR: binop(</span><span class="s3">&quot;|&quot;</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bitwiseXOR: binop(</span><span class="s3">&quot;^&quot;</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bitwiseAND: binop(</span><span class="s3">&quot;&amp;&quot;</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">equality: binop(</span><span class="s3">&quot;==/!=/===/!==&quot;</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">relational: binop(</span><span class="s3">&quot;&lt;/&gt;/&lt;=/&gt;=&quot;</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bitShift: binop(</span><span class="s3">&quot;&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;&quot;</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">plusMin: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;+/-&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">binop: </span><span class="s4">9</span><span class="s2">, </span><span class="s1">prefix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">modulo: binop(</span><span class="s3">&quot;%&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">star: binop(</span><span class="s3">&quot;*&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">slash: binop(</span><span class="s3">&quot;/&quot;</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">starstar: </span><span class="s2">new </span><span class="s1">TokenType(</span><span class="s3">&quot;**&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">coalesce: binop(</span><span class="s3">&quot;??&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>

  <span class="s0">// Keyword token types.</span>
  <span class="s1">_break: kw(</span><span class="s3">&quot;break&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_case: kw(</span><span class="s3">&quot;case&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_catch: kw(</span><span class="s3">&quot;catch&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_continue: kw(</span><span class="s3">&quot;continue&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_debugger: kw(</span><span class="s3">&quot;debugger&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_default: kw(</span><span class="s3">&quot;default&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_do: kw(</span><span class="s3">&quot;do&quot;</span><span class="s2">, </span><span class="s1">{isLoop: </span><span class="s2">true, </span><span class="s1">beforeExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_else: kw(</span><span class="s3">&quot;else&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_finally: kw(</span><span class="s3">&quot;finally&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_for: kw(</span><span class="s3">&quot;for&quot;</span><span class="s2">, </span><span class="s1">{isLoop: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_function: kw(</span><span class="s3">&quot;function&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_if: kw(</span><span class="s3">&quot;if&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_return: kw(</span><span class="s3">&quot;return&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_switch: kw(</span><span class="s3">&quot;switch&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_throw: kw(</span><span class="s3">&quot;throw&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_try: kw(</span><span class="s3">&quot;try&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_var: kw(</span><span class="s3">&quot;var&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_const: kw(</span><span class="s3">&quot;const&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_while: kw(</span><span class="s3">&quot;while&quot;</span><span class="s2">, </span><span class="s1">{isLoop: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_with: kw(</span><span class="s3">&quot;with&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_new: kw(</span><span class="s3">&quot;new&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_this: kw(</span><span class="s3">&quot;this&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_super: kw(</span><span class="s3">&quot;super&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_class: kw(</span><span class="s3">&quot;class&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_extends: kw(</span><span class="s3">&quot;extends&quot;</span><span class="s2">, </span><span class="s1">beforeExpr)</span><span class="s2">,</span>
  <span class="s1">_export: kw(</span><span class="s3">&quot;export&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">_import: kw(</span><span class="s3">&quot;import&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_null: kw(</span><span class="s3">&quot;null&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_true: kw(</span><span class="s3">&quot;true&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_false: kw(</span><span class="s3">&quot;false&quot;</span><span class="s2">, </span><span class="s1">startsExpr)</span><span class="s2">,</span>
  <span class="s1">_in: kw(</span><span class="s3">&quot;in&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">binop: </span><span class="s4">7</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_instanceof: kw(</span><span class="s3">&quot;instanceof&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">binop: </span><span class="s4">7</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_typeof: kw(</span><span class="s3">&quot;typeof&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">prefix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_void: kw(</span><span class="s3">&quot;void&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">prefix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">_delete: kw(</span><span class="s3">&quot;delete&quot;</span><span class="s2">, </span><span class="s1">{beforeExpr: </span><span class="s2">true, </span><span class="s1">prefix: </span><span class="s2">true, </span><span class="s1">startsExpr: </span><span class="s2">true</span><span class="s1">})</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Matches a whole line break (where CRLF is considered a single</span>
<span class="s0">// line break). Used to count lines.</span>

<span class="s2">var </span><span class="s1">lineBreak = </span><span class="s4">/\r\n?|\n|\u2028|\u2029/</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">lineBreakG = </span><span class="s2">new </span><span class="s1">RegExp(lineBreak.source</span><span class="s2">, </span><span class="s3">&quot;g&quot;</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">isNewLine(code) {</span>
  <span class="s2">return </span><span class="s1">code === </span><span class="s4">10 </span><span class="s1">|| code === </span><span class="s4">13 </span><span class="s1">|| code === </span><span class="s4">0x2028 </span><span class="s1">|| code === </span><span class="s4">0x2029</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">nextLineBreak(code</span><span class="s2">, </span><span class="s1">from</span><span class="s2">, </span><span class="s1">end) {</span>
  <span class="s2">if </span><span class="s1">( end === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) end = code.length</span><span class="s2">;</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = from</span><span class="s2">; </span><span class="s1">i &lt; end</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">var </span><span class="s1">next = code.charCodeAt(i)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isNewLine(next))</span>
      <span class="s1">{ </span><span class="s2">return </span><span class="s1">i &lt; end - </span><span class="s4">1 </span><span class="s1">&amp;&amp; next === </span><span class="s4">13 </span><span class="s1">&amp;&amp; code.charCodeAt(i + </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">10 </span><span class="s1">? i + </span><span class="s4">2 </span><span class="s1">: i + </span><span class="s4">1 </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">nonASCIIwhitespace = </span><span class="s4">/[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">skipWhiteSpace = </span><span class="s4">/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">ref = Object.prototype</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasOwnProperty = ref.hasOwnProperty</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toString = ref.toString</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">hasOwn = Object.hasOwn || (</span><span class="s2">function </span><span class="s1">(obj</span><span class="s2">, </span><span class="s1">propName) { </span><span class="s2">return </span><span class="s1">(</span>
  <span class="s1">hasOwnProperty.call(obj</span><span class="s2">, </span><span class="s1">propName)</span>
<span class="s1">)</span><span class="s2">; </span><span class="s1">})</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">isArray = Array.isArray || (</span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">(</span>
  <span class="s1">toString.call(obj) === </span><span class="s3">&quot;[object Array]&quot;</span>
<span class="s1">)</span><span class="s2">; </span><span class="s1">})</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">wordsRegexp(words) {</span>
  <span class="s2">return new </span><span class="s1">RegExp(</span><span class="s3">&quot;^(?:&quot; </span><span class="s1">+ words.replace(</span><span class="s4">/ /g</span><span class="s2">, </span><span class="s3">&quot;|&quot;</span><span class="s1">) + </span><span class="s3">&quot;)$&quot;</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">codePointToString(code) {</span>
  <span class="s0">// UTF-16 Decoding</span>
  <span class="s2">if </span><span class="s1">(code &lt;= </span><span class="s4">0xFFFF</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">String.fromCharCode(code) }</span>
  <span class="s1">code -= </span><span class="s4">0x10000</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">String.fromCharCode((code &gt;&gt; </span><span class="s4">10</span><span class="s1">) + </span><span class="s4">0xD800</span><span class="s2">, </span><span class="s1">(code &amp; </span><span class="s4">1023</span><span class="s1">) + </span><span class="s4">0xDC00</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">loneSurrogate = </span><span class="s4">/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/</span><span class="s2">;</span>

<span class="s0">// These are used when `options.locations` is on, for the</span>
<span class="s0">// `startLoc` and `endLoc` properties.</span>

<span class="s2">var </span><span class="s1">Position = </span><span class="s2">function </span><span class="s1">Position(line</span><span class="s2">, </span><span class="s1">col) {</span>
  <span class="s2">this</span><span class="s1">.line = line</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.column = col</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Position.prototype.offset = </span><span class="s2">function </span><span class="s1">offset (n) {</span>
  <span class="s2">return new </span><span class="s1">Position(</span><span class="s2">this</span><span class="s1">.line</span><span class="s2">, this</span><span class="s1">.column + n)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">SourceLocation = </span><span class="s2">function </span><span class="s1">SourceLocation(p</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
  <span class="s2">this</span><span class="s1">.start = start</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.end = end</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(p.sourceFile !== </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.source = p.sourceFile</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The `getLineInfo` function is mostly useful when the</span>
<span class="s0">// `locations` option is off (for performance reasons) and you</span>
<span class="s0">// want to find the line/column position for a given character</span>
<span class="s0">// offset. `input` should be the code string that the offset refers</span>
<span class="s0">// into.</span>

<span class="s2">function </span><span class="s1">getLineInfo(input</span><span class="s2">, </span><span class="s1">offset) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">line = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">cur = </span><span class="s4">0</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">nextBreak = nextLineBreak(input</span><span class="s2">, </span><span class="s1">cur</span><span class="s2">, </span><span class="s1">offset)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextBreak &lt; </span><span class="s4">0</span><span class="s1">) { </span><span class="s2">return new </span><span class="s1">Position(line</span><span class="s2">, </span><span class="s1">offset - cur) }</span>
    <span class="s1">++line</span><span class="s2">;</span>
    <span class="s1">cur = nextBreak</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// A second argument must be given to configure the parser process.</span>
<span class="s0">// These options are recognized (only `ecmaVersion` is required):</span>

<span class="s2">var </span><span class="s1">defaultOptions = {</span>
  <span class="s0">// `ecmaVersion` indicates the ECMAScript version to parse. Must be</span>
  <span class="s0">// either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10</span>
  <span class="s0">// (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `&quot;latest&quot;`</span>
  <span class="s0">// (the latest version the library supports). This influences</span>
  <span class="s0">// support for strict mode, the set of reserved words, and support</span>
  <span class="s0">// for new syntax features.</span>
  <span class="s1">ecmaVersion: </span><span class="s2">null,</span>
  <span class="s0">// `sourceType` indicates the mode the code should be parsed in.</span>
  <span class="s0">// Can be either `&quot;script&quot;` or `&quot;module&quot;`. This influences global</span>
  <span class="s0">// strict mode and parsing of `import` and `export` declarations.</span>
  <span class="s1">sourceType: </span><span class="s3">&quot;script&quot;</span><span class="s2">,</span>
  <span class="s0">// `onInsertedSemicolon` can be a callback that will be called</span>
  <span class="s0">// when a semicolon is automatically inserted. It will be passed</span>
  <span class="s0">// the position of the comma as an offset, and if `locations` is</span>
  <span class="s0">// enabled, it is given the location as a `{line, column}` object</span>
  <span class="s0">// as second argument.</span>
  <span class="s1">onInsertedSemicolon: </span><span class="s2">null,</span>
  <span class="s0">// `onTrailingComma` is similar to `onInsertedSemicolon`, but for</span>
  <span class="s0">// trailing commas.</span>
  <span class="s1">onTrailingComma: </span><span class="s2">null,</span>
  <span class="s0">// By default, reserved words are only enforced if ecmaVersion &gt;= 5.</span>
  <span class="s0">// Set `allowReserved` to a boolean value to explicitly turn this on</span>
  <span class="s0">// an off. When this option has the value &quot;never&quot;, reserved words</span>
  <span class="s0">// and keywords can also not be used as property names.</span>
  <span class="s1">allowReserved: </span><span class="s2">null,</span>
  <span class="s0">// When enabled, a return at the top level is not considered an</span>
  <span class="s0">// error.</span>
  <span class="s1">allowReturnOutsideFunction: </span><span class="s2">false,</span>
  <span class="s0">// When enabled, import/export statements are not constrained to</span>
  <span class="s0">// appearing at the top of the program, and an import.meta expression</span>
  <span class="s0">// in a script isn't considered an error.</span>
  <span class="s1">allowImportExportEverywhere: </span><span class="s2">false,</span>
  <span class="s0">// By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion &gt;= 2022.</span>
  <span class="s0">// When enabled, await identifiers are allowed to appear at the top-level scope,</span>
  <span class="s0">// but they are still not allowed in non-async functions.</span>
  <span class="s1">allowAwaitOutsideFunction: </span><span class="s2">null,</span>
  <span class="s0">// When enabled, super identifiers are not constrained to</span>
  <span class="s0">// appearing in methods and do not raise an error when they appear elsewhere.</span>
  <span class="s1">allowSuperOutsideMethod: </span><span class="s2">null,</span>
  <span class="s0">// When enabled, hashbang directive in the beginning of file is</span>
  <span class="s0">// allowed and treated as a line comment. Enabled by default when</span>
  <span class="s0">// `ecmaVersion` &gt;= 2023.</span>
  <span class="s1">allowHashBang: </span><span class="s2">false,</span>
  <span class="s0">// When `locations` is on, `loc` properties holding objects with</span>
  <span class="s0">// `start` and `end` properties in `{line, column}` form (with</span>
  <span class="s0">// line being 1-based and column 0-based) will be attached to the</span>
  <span class="s0">// nodes.</span>
  <span class="s1">locations: </span><span class="s2">false,</span>
  <span class="s0">// A function can be passed as `onToken` option, which will</span>
  <span class="s0">// cause Acorn to call that function with object in the same</span>
  <span class="s0">// format as tokens returned from `tokenizer().getToken()`. Note</span>
  <span class="s0">// that you are not allowed to call the parser from the</span>
  <span class="s0">// callback—that will corrupt its internal state.</span>
  <span class="s1">onToken: </span><span class="s2">null,</span>
  <span class="s0">// A function can be passed as `onComment` option, which will</span>
  <span class="s0">// cause Acorn to call that function with `(block, text, start,</span>
  <span class="s0">// end)` parameters whenever a comment is skipped. `block` is a</span>
  <span class="s0">// boolean indicating whether this is a block (`/* */`) comment,</span>
  <span class="s0">// `text` is the content of the comment, and `start` and `end` are</span>
  <span class="s0">// character offsets that denote the start and end of the comment.</span>
  <span class="s0">// When the `locations` option is on, two more parameters are</span>
  <span class="s0">// passed, the full `{line, column}` locations of the start and</span>
  <span class="s0">// end of the comments. Note that you are not allowed to call the</span>
  <span class="s0">// parser from the callback—that will corrupt its internal state.</span>
  <span class="s1">onComment: </span><span class="s2">null,</span>
  <span class="s0">// Nodes have their start and end characters offsets recorded in</span>
  <span class="s0">// `start` and `end` properties (directly on the node, rather than</span>
  <span class="s0">// the `loc` object, which holds line/column data. To also add a</span>
  <span class="s0">// [semi-standardized][range] `range` property holding a `[start,</span>
  <span class="s0">// end]` array with the same numbers, set the `ranges` option to</span>
  <span class="s0">// `true`.</span>
  <span class="s0">//</span>
  <span class="s0">// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678</span>
  <span class="s1">ranges: </span><span class="s2">false,</span>
  <span class="s0">// It is possible to parse multiple files into a single AST by</span>
  <span class="s0">// passing the tree produced by parsing the first file as</span>
  <span class="s0">// `program` option in subsequent parses. This will add the</span>
  <span class="s0">// toplevel forms of the parsed file to the `Program` (top) node</span>
  <span class="s0">// of an existing parse tree.</span>
  <span class="s1">program: </span><span class="s2">null,</span>
  <span class="s0">// When `locations` is on, you can pass this to record the source</span>
  <span class="s0">// file in every node's `loc` object.</span>
  <span class="s1">sourceFile: </span><span class="s2">null,</span>
  <span class="s0">// This value, if given, is stored in every node, whether</span>
  <span class="s0">// `locations` is on or off.</span>
  <span class="s1">directSourceFile: </span><span class="s2">null,</span>
  <span class="s0">// When enabled, parenthesized expressions are represented by</span>
  <span class="s0">// (non-standard) ParenthesizedExpression nodes</span>
  <span class="s1">preserveParens: </span><span class="s2">false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Interpret and default an options object</span>

<span class="s2">var </span><span class="s1">warnedAboutEcmaVersion = </span><span class="s2">false;</span>

<span class="s2">function </span><span class="s1">getOptions(opts) {</span>
  <span class="s2">var </span><span class="s1">options = {}</span><span class="s2">;</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">defaultOptions)</span>
    <span class="s1">{ options[opt] = opts &amp;&amp; hasOwn(opts</span><span class="s2">, </span><span class="s1">opt) ? opts[opt] : defaultOptions[opt]</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(options.ecmaVersion === </span><span class="s3">&quot;latest&quot;</span><span class="s1">) {</span>
    <span class="s1">options.ecmaVersion = </span><span class="s4">1e8</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(options.ecmaVersion == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!warnedAboutEcmaVersion &amp;&amp; </span><span class="s2">typeof </span><span class="s1">console === </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp; console.warn) {</span>
      <span class="s1">warnedAboutEcmaVersion = </span><span class="s2">true;</span>
      <span class="s1">console.warn(</span><span class="s3">&quot;Since Acorn 8.0.0, options.ecmaVersion is required.</span><span class="s2">\n</span><span class="s3">Defaulting to 2020, but this will stop working in the future.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">options.ecmaVersion = </span><span class="s4">11</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(options.ecmaVersion &gt;= </span><span class="s4">2015</span><span class="s1">) {</span>
    <span class="s1">options.ecmaVersion -= </span><span class="s4">2009</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(options.allowReserved == </span><span class="s2">null</span><span class="s1">)</span>
    <span class="s1">{ options.allowReserved = options.ecmaVersion &lt; </span><span class="s4">5</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!opts || opts.allowHashBang == </span><span class="s2">null</span><span class="s1">)</span>
    <span class="s1">{ options.allowHashBang = options.ecmaVersion &gt;= </span><span class="s4">14</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(isArray(options.onToken)) {</span>
    <span class="s2">var </span><span class="s1">tokens = options.onToken</span><span class="s2">;</span>
    <span class="s1">options.onToken = </span><span class="s2">function </span><span class="s1">(token) { </span><span class="s2">return </span><span class="s1">tokens.push(token)</span><span class="s2">; </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isArray(options.onComment))</span>
    <span class="s1">{ options.onComment = pushComment(options</span><span class="s2">, </span><span class="s1">options.onComment)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">return </span><span class="s1">options</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">pushComment(options</span><span class="s2">, </span><span class="s1">array) {</span>
  <span class="s2">return function</span><span class="s1">(block</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">endLoc) {</span>
    <span class="s2">var </span><span class="s1">comment = {</span>
      <span class="s1">type: block ? </span><span class="s3">&quot;Block&quot; </span><span class="s1">: </span><span class="s3">&quot;Line&quot;</span><span class="s2">,</span>
      <span class="s1">value: text</span><span class="s2">,</span>
      <span class="s1">start: start</span><span class="s2">,</span>
      <span class="s1">end: end</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.locations)</span>
      <span class="s1">{ comment.loc = </span><span class="s2">new </span><span class="s1">SourceLocation(</span><span class="s2">this, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">endLoc)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.ranges)</span>
      <span class="s1">{ comment.range = [start</span><span class="s2">, </span><span class="s1">end]</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">array.push(comment)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// Each scope gets a bitset that may contain these flags</span>
<span class="s2">var</span>
    <span class="s1">SCOPE_TOP = </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">SCOPE_FUNCTION = </span><span class="s4">2</span><span class="s2">,</span>
    <span class="s1">SCOPE_ASYNC = </span><span class="s4">4</span><span class="s2">,</span>
    <span class="s1">SCOPE_GENERATOR = </span><span class="s4">8</span><span class="s2">,</span>
    <span class="s1">SCOPE_ARROW = </span><span class="s4">16</span><span class="s2">,</span>
    <span class="s1">SCOPE_SIMPLE_CATCH = </span><span class="s4">32</span><span class="s2">,</span>
    <span class="s1">SCOPE_SUPER = </span><span class="s4">64</span><span class="s2">,</span>
    <span class="s1">SCOPE_DIRECT_SUPER = </span><span class="s4">128</span><span class="s2">,</span>
    <span class="s1">SCOPE_CLASS_STATIC_BLOCK = </span><span class="s4">256</span><span class="s2">,</span>
    <span class="s1">SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">functionFlags(async</span><span class="s2">, </span><span class="s1">generator) {</span>
  <span class="s2">return </span><span class="s1">SCOPE_FUNCTION | (async ? SCOPE_ASYNC : </span><span class="s4">0</span><span class="s1">) | (generator ? SCOPE_GENERATOR : </span><span class="s4">0</span><span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// Used in checkLVal* and declareName to determine the type of a binding</span>
<span class="s2">var</span>
    <span class="s1">BIND_NONE = </span><span class="s4">0</span><span class="s2">, </span><span class="s0">// Not a binding</span>
    <span class="s1">BIND_VAR = </span><span class="s4">1</span><span class="s2">, </span><span class="s0">// Var-style binding</span>
    <span class="s1">BIND_LEXICAL = </span><span class="s4">2</span><span class="s2">, </span><span class="s0">// Let- or const-style binding</span>
    <span class="s1">BIND_FUNCTION = </span><span class="s4">3</span><span class="s2">, </span><span class="s0">// Function declaration</span>
    <span class="s1">BIND_SIMPLE_CATCH = </span><span class="s4">4</span><span class="s2">, </span><span class="s0">// Simple (identifier pattern) catch binding</span>
    <span class="s1">BIND_OUTSIDE = </span><span class="s4">5</span><span class="s2">; </span><span class="s0">// Special case for function names as bound inside the function</span>

<span class="s2">var </span><span class="s1">Parser = </span><span class="s2">function </span><span class="s1">Parser(options</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">startPos) {</span>
  <span class="s2">this</span><span class="s1">.options = options = getOptions(options)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.sourceFile = options.sourceFile</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.keywords = wordsRegexp(keywords$1[options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">? </span><span class="s4">6 </span><span class="s1">: options.sourceType === </span><span class="s3">&quot;module&quot; </span><span class="s1">? </span><span class="s3">&quot;5module&quot; </span><span class="s1">: </span><span class="s4">5</span><span class="s1">])</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">reserved = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(options.allowReserved !== </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">reserved = reservedWords[options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">? </span><span class="s4">6 </span><span class="s1">: options.ecmaVersion === </span><span class="s4">5 </span><span class="s1">? </span><span class="s4">5 </span><span class="s1">: </span><span class="s4">3</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.sourceType === </span><span class="s3">&quot;module&quot;</span><span class="s1">) { reserved += </span><span class="s3">&quot; await&quot;</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.reservedWords = wordsRegexp(reserved)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">reservedStrict = (reserved ? reserved + </span><span class="s3">&quot; &quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">) + reservedWords.strict</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.reservedWordsStrict = wordsRegexp(reservedStrict)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.reservedWordsStrictBind = wordsRegexp(reservedStrict + </span><span class="s3">&quot; &quot; </span><span class="s1">+ reservedWords.strictBind)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.input = String(input)</span><span class="s2">;</span>

  <span class="s0">// Used to signal to callers of `readWord1` whether the word</span>
  <span class="s0">// contained any escape sequences. This is needed because words with</span>
  <span class="s0">// escape sequences must not be interpreted as keywords.</span>
  <span class="s2">this</span><span class="s1">.containsEsc = </span><span class="s2">false;</span>

  <span class="s0">// Set up token state</span>

  <span class="s0">// The current position of the tokenizer in the input.</span>
  <span class="s2">if </span><span class="s1">(startPos) {</span>
    <span class="s2">this</span><span class="s1">.pos = startPos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.lineStart = </span><span class="s2">this</span><span class="s1">.input.lastIndexOf(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">startPos - </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.curLine = </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s4">0</span><span class="s2">, this</span><span class="s1">.lineStart).split(lineBreak).length</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.pos = </span><span class="s2">this</span><span class="s1">.lineStart = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.curLine = </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Properties of the current token:</span>
  <span class="s0">// Its type</span>
  <span class="s2">this</span><span class="s1">.type = types$1.eof</span><span class="s2">;</span>
  <span class="s0">// For tokens that include more information than their type, the value</span>
  <span class="s2">this</span><span class="s1">.value = </span><span class="s2">null;</span>
  <span class="s0">// Its start and end offset</span>
  <span class="s2">this</span><span class="s1">.start = </span><span class="s2">this</span><span class="s1">.end = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s0">// And, if locations are used, the {line, column} object</span>
  <span class="s0">// corresponding to those offsets</span>
  <span class="s2">this</span><span class="s1">.startLoc = </span><span class="s2">this</span><span class="s1">.endLoc = </span><span class="s2">this</span><span class="s1">.curPosition()</span><span class="s2">;</span>

  <span class="s0">// Position information for the previous token</span>
  <span class="s2">this</span><span class="s1">.lastTokEndLoc = </span><span class="s2">this</span><span class="s1">.lastTokStartLoc = </span><span class="s2">null;</span>
  <span class="s2">this</span><span class="s1">.lastTokStart = </span><span class="s2">this</span><span class="s1">.lastTokEnd = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>

  <span class="s0">// The context stack is used to superficially track syntactic</span>
  <span class="s0">// context to predict whether a regular expression is allowed in a</span>
  <span class="s0">// given position.</span>
  <span class="s2">this</span><span class="s1">.context = </span><span class="s2">this</span><span class="s1">.initialContext()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>

  <span class="s0">// Figure out if it's a module code.</span>
  <span class="s2">this</span><span class="s1">.inModule = options.sourceType === </span><span class="s3">&quot;module&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.strict = </span><span class="s2">this</span><span class="s1">.inModule || </span><span class="s2">this</span><span class="s1">.strictDirective(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>

  <span class="s0">// Used to signify the start of a potential arrow function</span>
  <span class="s2">this</span><span class="s1">.potentialArrowAt = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.potentialArrowInForAwait = </span><span class="s2">false;</span>

  <span class="s0">// Positions to delayed-check that yield/await does not exist in default parameters.</span>
  <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s2">this</span><span class="s1">.awaitIdentPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s0">// Labels in scope.</span>
  <span class="s2">this</span><span class="s1">.labels = []</span><span class="s2">;</span>
  <span class="s0">// Thus-far undefined exports.</span>
  <span class="s2">this</span><span class="s1">.undefinedExports = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s0">// If enabled, skip leading hashbang line.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos === </span><span class="s4">0 </span><span class="s1">&amp;&amp; options.allowHashBang &amp;&amp; </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) === </span><span class="s3">&quot;#!&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.skipLineComment(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s0">// Scope tracking for duplicate variable names (see scope.js)</span>
  <span class="s2">this</span><span class="s1">.scopeStack = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(SCOPE_TOP)</span><span class="s2">;</span>

  <span class="s0">// For RegExp validation</span>
  <span class="s2">this</span><span class="s1">.regexpState = </span><span class="s2">null;</span>

  <span class="s0">// The stack of private names.</span>
  <span class="s0">// Each element has two properties: 'declared' and 'used'.</span>
  <span class="s0">// When it exited from the outermost class definition, all used private names must be declared.</span>
  <span class="s2">this</span><span class="s1">.privateNameStack = []</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">prototypeAccessors = { inFunction: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">inGenerator: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">inAsync: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">canAwait: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">allowSuper: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">allowDirectSuper: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">treatFunctionsAsVar: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">allowNewDotTarget: { configurable: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">,</span><span class="s1">inClassStaticBlock: { configurable: </span><span class="s2">true </span><span class="s1">} }</span><span class="s2">;</span>

<span class="s1">Parser.prototype.parse = </span><span class="s2">function </span><span class="s1">parse () {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.options.program || </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.nextToken()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.parseTopLevel(node)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.inFunction.get = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; </span><span class="s4">0 </span><span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.inGenerator.get = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.currentVarScope().inClassFieldInit }</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.inAsync.get = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.currentVarScope().inClassFieldInit }</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.canAwait.get = </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.scopeStack.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
    <span class="s2">var </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.scopeStack[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(scope.inClassFieldInit || scope.flags &amp; SCOPE_CLASS_STATIC_BLOCK) { </span><span class="s2">return false </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(scope.flags &amp; SCOPE_FUNCTION) { </span><span class="s2">return </span><span class="s1">(scope.flags &amp; SCOPE_ASYNC) &gt; </span><span class="s4">0 </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">13</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.options.allowAwaitOutsideFunction</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.allowSuper.get = </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">ref = </span><span class="s2">this</span><span class="s1">.currentThisScope()</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">flags = ref.flags</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">inClassFieldInit = ref.inClassFieldInit</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(flags &amp; SCOPE_SUPER) &gt; </span><span class="s4">0 </span><span class="s1">|| inClassFieldInit || </span><span class="s2">this</span><span class="s1">.options.allowSuperOutsideMethod</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.allowDirectSuper.get = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; </span><span class="s4">0 </span><span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.treatFunctionsAsVar.get = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return this</span><span class="s1">.treatFunctionsAsVarInScope(</span><span class="s2">this</span><span class="s1">.currentScope()) }</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.allowNewDotTarget.get = </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">ref = </span><span class="s2">this</span><span class="s1">.currentThisScope()</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">flags = ref.flags</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">inClassFieldInit = ref.inClassFieldInit</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(flags &amp; (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) &gt; </span><span class="s4">0 </span><span class="s1">|| inClassFieldInit</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">prototypeAccessors.inClassStaticBlock.get = </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentVarScope().flags &amp; SCOPE_CLASS_STATIC_BLOCK) &gt; </span><span class="s4">0</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Parser.extend = </span><span class="s2">function </span><span class="s1">extend () {</span>
    <span class="s2">var </span><span class="s1">plugins = []</span><span class="s2">, </span><span class="s1">len = arguments.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">( len-- ) plugins[ len ] = arguments[ len ]</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">cls = </span><span class="s2">this;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; plugins.length</span><span class="s2">; </span><span class="s1">i++) { cls = plugins[i](cls)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">cls</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Parser.parse = </span><span class="s2">function </span><span class="s1">parse (input</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return new this</span><span class="s1">(options</span><span class="s2">, </span><span class="s1">input).parse()</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Parser.parseExpressionAt = </span><span class="s2">function </span><span class="s1">parseExpressionAt (input</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">var </span><span class="s1">parser = </span><span class="s2">new this</span><span class="s1">(options</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
  <span class="s1">parser.nextToken()</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">parser.parseExpression()</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Parser.tokenizer = </span><span class="s2">function </span><span class="s1">tokenizer (input</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return new this</span><span class="s1">(options</span><span class="s2">, </span><span class="s1">input)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">Object.defineProperties( Parser.prototype</span><span class="s2">, </span><span class="s1">prototypeAccessors )</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$9 = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// ## Parser utilities</span>

<span class="s2">var </span><span class="s1">literal = </span><span class="s4">/^(?:'((?:\\.|[^'\\])*?)'|&quot;((?:\\.|[^&quot;\\])*?)&quot;)/</span><span class="s2">;</span>
<span class="s1">pp$9.strictDirective = </span><span class="s2">function</span><span class="s1">(start) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">5</span><span class="s1">) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s0">// Try to find string literal.</span>
    <span class="s1">skipWhiteSpace.lastIndex = start</span><span class="s2">;</span>
    <span class="s1">start += skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">match = literal.exec(</span><span class="s2">this</span><span class="s1">.input.slice(start))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!match) { </span><span class="s2">return false </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((match[</span><span class="s4">1</span><span class="s1">] || match[</span><span class="s4">2</span><span class="s1">]) === </span><span class="s3">&quot;use strict&quot;</span><span class="s1">) {</span>
      <span class="s1">skipWhiteSpace.lastIndex = start + match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">spaceAfter = skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)</span><span class="s2">, </span><span class="s1">end = spaceAfter.index + spaceAfter[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charAt(end)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">next === </span><span class="s3">&quot;;&quot; </span><span class="s1">|| next === </span><span class="s3">&quot;}&quot; </span><span class="s1">||</span>
        <span class="s1">(lineBreak.test(spaceAfter[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
         <span class="s1">!(</span><span class="s4">/[(`.[+\-/*%&lt;&gt;=,?^&amp;]/</span><span class="s1">.test(next) || next === </span><span class="s3">&quot;!&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charAt(end + </span><span class="s4">1</span><span class="s1">) === </span><span class="s3">&quot;=&quot;</span><span class="s1">))</span>
    <span class="s1">}</span>
    <span class="s1">start += match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>

    <span class="s0">// Skip semicolon, if any.</span>
    <span class="s1">skipWhiteSpace.lastIndex = start</span><span class="s2">;</span>
    <span class="s1">start += skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input[start] === </span><span class="s3">&quot;;&quot;</span><span class="s1">)</span>
      <span class="s1">{ start++</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Predicate that tests whether the next token is of the given</span>
<span class="s0">// type, and if yes, consumes it as a side effect.</span>

<span class="s1">pp$9.eat = </span><span class="s2">function</span><span class="s1">(type) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === type) {</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return false</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Tests whether parsed token is a contextual keyword.</span>

<span class="s1">pp$9.isContextual = </span><span class="s2">function</span><span class="s1">(name) {</span>
  <span class="s2">return this</span><span class="s1">.type === types$1.name &amp;&amp; </span><span class="s2">this</span><span class="s1">.value === name &amp;&amp; !</span><span class="s2">this</span><span class="s1">.containsEsc</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Consumes contextual keyword if possible.</span>

<span class="s1">pp$9.eatContextual = </span><span class="s2">function</span><span class="s1">(name) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isContextual(name)) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return true</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Asserts that following token is given contextual keyword.</span>

<span class="s1">pp$9.expectContextual = </span><span class="s2">function</span><span class="s1">(name) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eatContextual(name)) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Test whether a semicolon can be inserted at the current position.</span>

<span class="s1">pp$9.canInsertSemicolon = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return this</span><span class="s1">.type === types$1.eof ||</span>
    <span class="s2">this</span><span class="s1">.type === types$1.braceR ||</span>
    <span class="s1">lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.start))</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.insertSemicolon = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.onInsertedSemicolon)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.options.onInsertedSemicolon(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.lastTokEndLoc)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Consume a semicolon, or, failing that, see if we are allowed to</span>
<span class="s0">// pretend that there is a semicolon at this position.</span>

<span class="s1">pp$9.semicolon = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.semi) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.insertSemicolon()) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.afterTrailingComma = </span><span class="s2">function</span><span class="s1">(tokType</span><span class="s2">, </span><span class="s1">notNext) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tokType) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.onTrailingComma)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.options.onTrailingComma(</span><span class="s2">this</span><span class="s1">.lastTokStart</span><span class="s2">, this</span><span class="s1">.lastTokStartLoc)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!notNext)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Expect a token of a given type. If found, consume it, otherwise,</span>
<span class="s0">// raise an unexpected token error.</span>

<span class="s1">pp$9.expect = </span><span class="s2">function</span><span class="s1">(type) {</span>
  <span class="s2">this</span><span class="s1">.eat(type) || </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Raise an unexpected token error.</span>

<span class="s1">pp$9.unexpected = </span><span class="s2">function</span><span class="s1">(pos) {</span>
  <span class="s2">this</span><span class="s1">.raise(pos != </span><span class="s2">null </span><span class="s1">? pos : </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unexpected token&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">DestructuringErrors = </span><span class="s2">function </span><span class="s1">DestructuringErrors() {</span>
  <span class="s2">this</span><span class="s1">.shorthandAssign =</span>
  <span class="s2">this</span><span class="s1">.trailingComma =</span>
  <span class="s2">this</span><span class="s1">.parenthesizedAssign =</span>
  <span class="s2">this</span><span class="s1">.parenthesizedBind =</span>
  <span class="s2">this</span><span class="s1">.doubleProto =</span>
    <span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.checkPatternErrors = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors</span><span class="s2">, </span><span class="s1">isAssign) {</span>
  <span class="s2">if </span><span class="s1">(!refDestructuringErrors) { </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(refDestructuringErrors.trailingComma &gt; -</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(refDestructuringErrors.trailingComma</span><span class="s2">, </span><span class="s3">&quot;Comma is not permitted after the rest element&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(parens &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(parens</span><span class="s2">, </span><span class="s1">isAssign ? </span><span class="s3">&quot;Assigning to rvalue&quot; </span><span class="s1">: </span><span class="s3">&quot;Parenthesized pattern&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.checkExpressionErrors = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors</span><span class="s2">, </span><span class="s1">andThrow) {</span>
  <span class="s2">if </span><span class="s1">(!refDestructuringErrors) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">shorthandAssign = refDestructuringErrors.shorthandAssign</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">doubleProto = refDestructuringErrors.doubleProto</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!andThrow) { </span><span class="s2">return </span><span class="s1">shorthandAssign &gt;= </span><span class="s4">0 </span><span class="s1">|| doubleProto &gt;= </span><span class="s4">0 </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(shorthandAssign &gt;= </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(shorthandAssign</span><span class="s2">, </span><span class="s3">&quot;Shorthand property assignments are valid only in destructuring patterns&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(doubleProto &gt;= </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(doubleProto</span><span class="s2">, </span><span class="s3">&quot;Redefinition of __proto__ property&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.checkYieldAwaitInDefaultParams = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.yieldPos &amp;&amp; (!</span><span class="s2">this</span><span class="s1">.awaitPos || </span><span class="s2">this</span><span class="s1">.yieldPos &lt; </span><span class="s2">this</span><span class="s1">.awaitPos))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s3">&quot;Yield expression cannot be a default value&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.awaitPos)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s3">&quot;Await expression cannot be a default value&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$9.isSimpleAssignTarget = </span><span class="s2">function</span><span class="s1">(expr) {</span>
  <span class="s2">if </span><span class="s1">(expr.type === </span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.isSimpleAssignTarget(expr.expression) }</span>
  <span class="s2">return </span><span class="s1">expr.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">|| expr.type === </span><span class="s3">&quot;MemberExpression&quot;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$8 = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// ### Statement parsing</span>

<span class="s0">// Parse a program. Initializes the parser, reads any number of</span>
<span class="s0">// statements, and wraps them in a Program node.  Optionally takes a</span>
<span class="s0">// `program` argument.  If present, the statements will be appended</span>
<span class="s0">// to its body instead of creating a new node.</span>

<span class="s1">pp$8.parseTopLevel = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">var </span><span class="s1">exports = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!node.body) { node.body = []</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.eof) {</span>
    <span class="s2">var </span><span class="s1">stmt = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null, true, </span><span class="s1">exports)</span><span class="s2">;</span>
    <span class="s1">node.body.push(stmt)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inModule)</span>
    <span class="s1">{ </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = Object.keys(</span><span class="s2">this</span><span class="s1">.undefinedExports)</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">name = list[i]</span><span class="s2">;</span>

        <span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.undefinedExports[name].start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Export '&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;' is not defined&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">} }</span>
  <span class="s2">this</span><span class="s1">.adaptDirectivePrologue(node.body)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.sourceType = </span><span class="s2">this</span><span class="s1">.options.sourceType</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;Program&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">loopLabel = {kind: </span><span class="s3">&quot;loop&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s1">switchLabel = {kind: </span><span class="s3">&quot;switch&quot;</span><span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.isLet = </span><span class="s2">function</span><span class="s1">(context) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">6 </span><span class="s1">|| !</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s1">)) { </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s1">skipWhiteSpace.lastIndex = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">skip = skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.pos + skip[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">, </span><span class="s1">nextCh = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(next)</span><span class="s2">;</span>
  <span class="s0">// For ambiguous cases, determine if a LexicalDeclaration (or only a</span>
  <span class="s0">// Statement) is allowed here. If context is not empty then only a Statement</span>
  <span class="s0">// is allowed. However, `let [` is an explicit negative lookahead for</span>
  <span class="s0">// ExpressionStatement, so special-case it first.</span>
  <span class="s2">if </span><span class="s1">(nextCh === </span><span class="s4">91 </span><span class="s1">|| nextCh === </span><span class="s4">92</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">} </span><span class="s0">// '[', '/'</span>
  <span class="s2">if </span><span class="s1">(context) { </span><span class="s2">return false </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(nextCh === </span><span class="s4">123 </span><span class="s1">|| nextCh &gt; </span><span class="s4">0xd7ff </span><span class="s1">&amp;&amp; nextCh &lt; </span><span class="s4">0xdc00</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">} </span><span class="s0">// '{', astral</span>
  <span class="s2">if </span><span class="s1">(isIdentifierStart(nextCh</span><span class="s2">, true</span><span class="s1">)) {</span>
    <span class="s2">var </span><span class="s1">pos = next + </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(isIdentifierChar(nextCh = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(pos)</span><span class="s2">, true</span><span class="s1">)) { ++pos</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nextCh === </span><span class="s4">92 </span><span class="s1">|| nextCh &gt; </span><span class="s4">0xd7ff </span><span class="s1">&amp;&amp; nextCh &lt; </span><span class="s4">0xdc00</span><span class="s1">) { </span><span class="s2">return true </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">ident = </span><span class="s2">this</span><span class="s1">.input.slice(next</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!keywordRelationalOperator.test(ident)) { </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// check 'async [no LineTerminator here] function'</span>
<span class="s0">// - 'async /*foo*/ function' is OK.</span>
<span class="s0">// - 'async /*\n*/ function' is invalid.</span>
<span class="s1">pp$8.isAsyncFunction = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">8 </span><span class="s1">|| !</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;async&quot;</span><span class="s1">))</span>
    <span class="s1">{ </span><span class="s2">return false </span><span class="s1">}</span>

  <span class="s1">skipWhiteSpace.lastIndex = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">skip = skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.pos + skip[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">, </span><span class="s1">after</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">!lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">next)) &amp;&amp;</span>
    <span class="s2">this</span><span class="s1">.input.slice(next</span><span class="s2">, </span><span class="s1">next + </span><span class="s4">8</span><span class="s1">) === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(next + </span><span class="s4">8 </span><span class="s1">=== </span><span class="s2">this</span><span class="s1">.input.length ||</span>
     <span class="s1">!(isIdentifierChar(after = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(next + </span><span class="s4">8</span><span class="s1">)) || after &gt; </span><span class="s4">0xd7ff </span><span class="s1">&amp;&amp; after &lt; </span><span class="s4">0xdc00</span><span class="s1">))</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a single statement.</span>
<span class="s0">//</span>
<span class="s0">// If expecting a statement and finding a slash operator, parse a</span>
<span class="s0">// regular expression literal. This is to handle cases like</span>
<span class="s0">// `if (foo) /blah/.exec(foo)`, where looking at the previous token</span>
<span class="s0">// does not help.</span>

<span class="s1">pp$8.parseStatement = </span><span class="s2">function</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">topLevel</span><span class="s2">, </span><span class="s1">exports) {</span>
  <span class="s2">var </span><span class="s1">starttype = </span><span class="s2">this</span><span class="s1">.type</span><span class="s2">, </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLet(context)) {</span>
    <span class="s1">starttype = types$1._var</span><span class="s2">;</span>
    <span class="s1">kind = </span><span class="s3">&quot;let&quot;</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Most types of statements are recognized by the keyword they</span>
  <span class="s0">// start with. Many are trivial to parse, some require a bit of</span>
  <span class="s0">// complexity.</span>

  <span class="s2">switch </span><span class="s1">(starttype) {</span>
  <span class="s2">case </span><span class="s1">types$1._break: </span><span class="s2">case </span><span class="s1">types$1._continue: </span><span class="s2">return this</span><span class="s1">.parseBreakContinueStatement(node</span><span class="s2">, </span><span class="s1">starttype.keyword)</span>
  <span class="s2">case </span><span class="s1">types$1._debugger: </span><span class="s2">return this</span><span class="s1">.parseDebuggerStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._do: </span><span class="s2">return this</span><span class="s1">.parseDoStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._for: </span><span class="s2">return this</span><span class="s1">.parseForStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._function:</span>
    <span class="s0">// Function as sole body of either an if statement or a labeled statement</span>
    <span class="s0">// works, but not when it is part of a labeled statement that is the sole</span>
    <span class="s0">// body of an if statement.</span>
    <span class="s2">if </span><span class="s1">((context &amp;&amp; (</span><span class="s2">this</span><span class="s1">.strict || context !== </span><span class="s3">&quot;if&quot; </span><span class="s1">&amp;&amp; context !== </span><span class="s3">&quot;label&quot;</span><span class="s1">)) &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseFunctionStatement(node</span><span class="s2">, false, </span><span class="s1">!context)</span>
  <span class="s2">case </span><span class="s1">types$1._class:</span>
    <span class="s2">if </span><span class="s1">(context) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseClass(node</span><span class="s2">, true</span><span class="s1">)</span>
  <span class="s2">case </span><span class="s1">types$1._if: </span><span class="s2">return this</span><span class="s1">.parseIfStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._return: </span><span class="s2">return this</span><span class="s1">.parseReturnStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._switch: </span><span class="s2">return this</span><span class="s1">.parseSwitchStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._throw: </span><span class="s2">return this</span><span class="s1">.parseThrowStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._try: </span><span class="s2">return this</span><span class="s1">.parseTryStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._const: </span><span class="s2">case </span><span class="s1">types$1._var:</span>
    <span class="s1">kind = kind || </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(context &amp;&amp; kind !== </span><span class="s3">&quot;var&quot;</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseVarStatement(node</span><span class="s2">, </span><span class="s1">kind)</span>
  <span class="s2">case </span><span class="s1">types$1._while: </span><span class="s2">return this</span><span class="s1">.parseWhileStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._with: </span><span class="s2">return this</span><span class="s1">.parseWithStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1.braceL: </span><span class="s2">return this</span><span class="s1">.parseBlock(</span><span class="s2">true, </span><span class="s1">node)</span>
  <span class="s2">case </span><span class="s1">types$1.semi: </span><span class="s2">return this</span><span class="s1">.parseEmptyStatement(node)</span>
  <span class="s2">case </span><span class="s1">types$1._export:</span>
  <span class="s2">case </span><span class="s1">types$1._import:</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt; </span><span class="s4">10 </span><span class="s1">&amp;&amp; starttype === types$1._import) {</span>
      <span class="s1">skipWhiteSpace.lastIndex = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">skip = skipWhiteSpace.exec(</span><span class="s2">this</span><span class="s1">.input)</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.pos + skip[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">, </span><span class="s1">nextCh = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(next)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(nextCh === </span><span class="s4">40 </span><span class="s1">|| nextCh === </span><span class="s4">46</span><span class="s1">) </span><span class="s0">// '(' or '.'</span>
        <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.parseExpressionStatement(node</span><span class="s2">, this</span><span class="s1">.parseExpression()) }</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.allowImportExportEverywhere) {</span>
      <span class="s2">if </span><span class="s1">(!topLevel)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;'import' and 'export' may only appear at the top level&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.inModule)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;'import' and 'export' may appear only with 'sourceType: module'&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">starttype === types$1._import ? </span><span class="s2">this</span><span class="s1">.parseImport(node) : </span><span class="s2">this</span><span class="s1">.parseExport(node</span><span class="s2">, </span><span class="s1">exports)</span>

    <span class="s0">// If the statement does not start with a statement keyword or a</span>
    <span class="s0">// brace, it's an ExpressionStatement or LabeledStatement. We</span>
    <span class="s0">// simply start parsing an expression, and afterwards, if the</span>
    <span class="s0">// next token is a colon and the expression was a simple</span>
    <span class="s0">// Identifier node, we switch to interpreting it as a label.</span>
  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAsyncFunction()) {</span>
      <span class="s2">if </span><span class="s1">(context) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.parseFunctionStatement(node</span><span class="s2">, true, </span><span class="s1">!context)</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">maybeName = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">, </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(starttype === types$1.name &amp;&amp; expr.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.colon))</span>
      <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.parseLabeledStatement(node</span><span class="s2">, </span><span class="s1">maybeName</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">context) }</span>
    <span class="s2">else </span><span class="s1">{ </span><span class="s2">return this</span><span class="s1">.parseExpressionStatement(node</span><span class="s2">, </span><span class="s1">expr) }</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseBreakContinueStatement = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">keyword) {</span>
  <span class="s2">var </span><span class="s1">isBreak = keyword === </span><span class="s3">&quot;break&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.semi) || </span><span class="s2">this</span><span class="s1">.insertSemicolon()) { node.label = </span><span class="s2">null; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.name) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else </span><span class="s1">{</span>
    <span class="s1">node.label = </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Verify that there is an actual destination to break or</span>
  <span class="s0">// continue to.</span>
  <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">; </span><span class="s1">i &lt; </span><span class="s2">this</span><span class="s1">.labels.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s2">var </span><span class="s1">lab = </span><span class="s2">this</span><span class="s1">.labels[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.label == </span><span class="s2">null </span><span class="s1">|| lab.name === node.label.name) {</span>
      <span class="s2">if </span><span class="s1">(lab.kind != </span><span class="s2">null </span><span class="s1">&amp;&amp; (isBreak || lab.kind === </span><span class="s3">&quot;loop&quot;</span><span class="s1">)) { </span><span class="s2">break </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(node.label &amp;&amp; isBreak) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(i === </span><span class="s2">this</span><span class="s1">.labels.length) { </span><span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s3">&quot;Unsyntactic &quot; </span><span class="s1">+ keyword)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">isBreak ? </span><span class="s3">&quot;BreakStatement&quot; </span><span class="s1">: </span><span class="s3">&quot;ContinueStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseDebuggerStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;DebuggerStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseDoStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.push(loopLabel)</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;do&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1._while)</span><span class="s2">;</span>
  <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.eat(types$1.semi)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Disambiguating between a `for` and a `for`/`in` or `for`/`of`</span>
<span class="s0">// loop is non-trivial. Basically, we have to parse the init `var`</span>
<span class="s0">// statement or expression, disallowing the `in` operator (see</span>
<span class="s0">// the second parameter to `parseExpression`), and then check</span>
<span class="s0">// whether the next token is `in` or `of`. When there is no init</span>
<span class="s0">// part (semicolon immediately after the opening parenthesis), it</span>
<span class="s0">// is a regular `for` loop.</span>

<span class="s1">pp$8.parseForStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">awaitAt = (</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.canAwait &amp;&amp; </span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;await&quot;</span><span class="s1">)) ? </span><span class="s2">this</span><span class="s1">.lastTokStart : -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.push(loopLabel)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenL)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.semi) {</span>
    <span class="s2">if </span><span class="s1">(awaitAt &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseFor(node</span><span class="s2">, null</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">isLet = </span><span class="s2">this</span><span class="s1">.isLet()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._var || </span><span class="s2">this</span><span class="s1">.type === types$1._const || isLet) {</span>
    <span class="s2">var </span><span class="s1">init$1 = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">kind = isLet ? </span><span class="s3">&quot;let&quot; </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parseVar(init$1</span><span class="s2">, true, </span><span class="s1">kind)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.finishNode(init$1</span><span class="s2">, </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s2">this</span><span class="s1">.type === types$1._in || (</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s1">))) &amp;&amp; init$1.declarations.length === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._in) {</span>
          <span class="s2">if </span><span class="s1">(awaitAt &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{ node.await = awaitAt &gt; -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.parseForIn(node</span><span class="s2">, </span><span class="s1">init$1)</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(awaitAt &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.parseFor(node</span><span class="s2">, </span><span class="s1">init$1)</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">startsWithLet = </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;let&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">isForOf = </span><span class="s2">false;</span>
  <span class="s2">var </span><span class="s1">refDestructuringErrors = </span><span class="s2">new </span><span class="s1">DestructuringErrors</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">init = </span><span class="s2">this</span><span class="s1">.parseExpression(awaitAt &gt; -</span><span class="s4">1 </span><span class="s1">? </span><span class="s3">&quot;await&quot; </span><span class="s1">: </span><span class="s2">true, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._in || (isForOf = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s1">))) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._in) {</span>
        <span class="s2">if </span><span class="s1">(awaitAt &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{ node.await = awaitAt &gt; -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(startsWithLet &amp;&amp; isForOf) { </span><span class="s2">this</span><span class="s1">.raise(init.start</span><span class="s2">, </span><span class="s3">&quot;The left-hand side of a for-of loop may not start with 'let'.&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.toAssignable(init</span><span class="s2">, false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.checkLValPattern(init)</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.parseForIn(node</span><span class="s2">, </span><span class="s1">init)</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(awaitAt &gt; -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected(awaitAt)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.parseFor(node</span><span class="s2">, </span><span class="s1">init)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseFunctionStatement = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">declarationPosition) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.parseFunction(node</span><span class="s2">, </span><span class="s1">FUNC_STATEMENT$1 | (declarationPosition ? </span><span class="s4">0 </span><span class="s1">: FUNC_HANGING_STATEMENT)</span><span class="s2">, false, </span><span class="s1">isAsync)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseIfStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s0">// allow function declarations in branches, but only in non-strict mode</span>
  <span class="s1">node.consequent = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">node.alternate = </span><span class="s2">this</span><span class="s1">.eat(types$1._else) ? </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;if&quot;</span><span class="s1">) : </span><span class="s2">null;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;IfStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseReturnStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.inFunction &amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowReturnOutsideFunction)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;'return' outside of function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>

  <span class="s0">// In `return` (and `break`/`continue`), the keywords with</span>
  <span class="s0">// optional arguments, we eagerly look for a semicolon or the</span>
  <span class="s0">// possibility to insert one.</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.semi) || </span><span class="s2">this</span><span class="s1">.insertSemicolon()) { node.argument = </span><span class="s2">null; </span><span class="s1">}</span>
  <span class="s2">else </span><span class="s1">{ node.argument = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">; this</span><span class="s1">.semicolon()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseSwitchStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.discriminant = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s1">node.cases = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.braceL)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.push(switchLabel)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s0">// Statements under must be grouped (by label) in SwitchCase</span>
  <span class="s0">// nodes. `cur` is used to keep the node that we are currently</span>
  <span class="s0">// adding statements to.</span>

  <span class="s2">var </span><span class="s1">cur</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">sawDefault = </span><span class="s2">false; this</span><span class="s1">.type !== types$1.braceR</span><span class="s2">;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._case || </span><span class="s2">this</span><span class="s1">.type === types$1._default) {</span>
      <span class="s2">var </span><span class="s1">isCase = </span><span class="s2">this</span><span class="s1">.type === types$1._case</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(cur) { </span><span class="s2">this</span><span class="s1">.finishNode(cur</span><span class="s2">, </span><span class="s3">&quot;SwitchCase&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">node.cases.push(cur = </span><span class="s2">this</span><span class="s1">.startNode())</span><span class="s2">;</span>
      <span class="s1">cur.consequent = []</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isCase) {</span>
        <span class="s1">cur.test = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(sawDefault) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.lastTokStart</span><span class="s2">, </span><span class="s3">&quot;Multiple default clauses&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">sawDefault = </span><span class="s2">true;</span>
        <span class="s1">cur.test = </span><span class="s2">null;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.colon)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(!cur) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">cur.consequent.push(</span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cur) { </span><span class="s2">this</span><span class="s1">.finishNode(cur</span><span class="s2">, </span><span class="s3">&quot;SwitchCase&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s0">// Closing brace</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseThrowStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.start)))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, </span><span class="s3">&quot;Illegal newline after throw&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ThrowStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Reused empty array added for node fields that are always empty.</span>

<span class="s2">var </span><span class="s1">empty$1 = []</span><span class="s2">;</span>

<span class="s1">pp$8.parseTryStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.block = </span><span class="s2">this</span><span class="s1">.parseBlock()</span><span class="s2">;</span>
  <span class="s1">node.handler = </span><span class="s2">null;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._catch) {</span>
    <span class="s2">var </span><span class="s1">clause = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.parenL)) {</span>
      <span class="s1">clause.param = </span><span class="s2">this</span><span class="s1">.parseBindingAtom()</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">simple = clause.param.type === </span><span class="s3">&quot;Identifier&quot;</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.enterScope(simple ? SCOPE_SIMPLE_CATCH : </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.checkLValPattern(clause.param</span><span class="s2">, </span><span class="s1">simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.parenR)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">10</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">clause.param = </span><span class="s2">null;</span>
      <span class="s2">this</span><span class="s1">.enterScope(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">clause.body = </span><span class="s2">this</span><span class="s1">.parseBlock(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
    <span class="s1">node.handler = </span><span class="s2">this</span><span class="s1">.finishNode(clause</span><span class="s2">, </span><span class="s3">&quot;CatchClause&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">node.finalizer = </span><span class="s2">this</span><span class="s1">.eat(types$1._finally) ? </span><span class="s2">this</span><span class="s1">.parseBlock() : </span><span class="s2">null;</span>
  <span class="s2">if </span><span class="s1">(!node.handler &amp;&amp; !node.finalizer)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s3">&quot;Missing catch or finally clause&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;TryStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseVarStatement = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">kind) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parseVar(node</span><span class="s2">, false, </span><span class="s1">kind)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseWhileStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.push(loopLabel)</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;while&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseWithStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;'with' in strict mode&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.object = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;with&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;WithStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseEmptyStatement = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseLabeledStatement = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">maybeName</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, </span><span class="s1">context) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i$1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = </span><span class="s2">this</span><span class="s1">.labels</span><span class="s2">; </span><span class="s1">i$1 &lt; list.length</span><span class="s2">; </span><span class="s1">i$1 += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">label = list[i$1]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(label.name === maybeName)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(expr.start</span><span class="s2">, </span><span class="s3">&quot;Label '&quot; </span><span class="s1">+ maybeName + </span><span class="s3">&quot;' is already declared&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} }</span>
  <span class="s2">var </span><span class="s1">kind = </span><span class="s2">this</span><span class="s1">.type.isLoop ? </span><span class="s3">&quot;loop&quot; </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.type === types$1._switch ? </span><span class="s3">&quot;switch&quot; </span><span class="s1">: </span><span class="s2">null;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.labels.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
    <span class="s2">var </span><span class="s1">label$1 = </span><span class="s2">this</span><span class="s1">.labels[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(label$1.statementStart === node.start) {</span>
      <span class="s0">// Update information about previous labels on this node</span>
      <span class="s1">label$1.statementStart = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
      <span class="s1">label$1.kind = kind</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ </span><span class="s2">break </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.labels.push({name: maybeName</span><span class="s2">, </span><span class="s1">kind: kind</span><span class="s2">, </span><span class="s1">statementStart: </span><span class="s2">this</span><span class="s1">.start})</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(context ? context.indexOf(</span><span class="s3">&quot;label&quot;</span><span class="s1">) === -</span><span class="s4">1 </span><span class="s1">? context + </span><span class="s3">&quot;label&quot; </span><span class="s1">: context : </span><span class="s3">&quot;label&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s1">node.label = expr</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseExpressionStatement = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">expr) {</span>
  <span class="s1">node.expression = expr</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a semicolon-enclosed block of statements, handling `&quot;use</span>
<span class="s0">// strict&quot;` declarations when `allowStrict` is true (used for</span>
<span class="s0">// function bodies).</span>

<span class="s1">pp$8.parseBlock = </span><span class="s2">function</span><span class="s1">(createNewLexicalScope</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">exitStrict) {</span>
  <span class="s2">if </span><span class="s1">( createNewLexicalScope === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) createNewLexicalScope = </span><span class="s2">true;</span>
  <span class="s2">if </span><span class="s1">( node === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>

  <span class="s1">node.body = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.braceL)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(createNewLexicalScope) { </span><span class="s2">this</span><span class="s1">.enterScope(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.braceR) {</span>
    <span class="s2">var </span><span class="s1">stmt = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">node.body.push(stmt)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(exitStrict) { </span><span class="s2">this</span><span class="s1">.strict = </span><span class="s2">false; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(createNewLexicalScope) { </span><span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a regular `for` loop. The disambiguation code in</span>
<span class="s0">// `parseStatement` will already have parsed the init statement or</span>
<span class="s0">// expression.</span>

<span class="s1">pp$8.parseFor = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">init) {</span>
  <span class="s1">node.init = init</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.semi)</span><span class="s2">;</span>
  <span class="s1">node.test = </span><span class="s2">this</span><span class="s1">.type === types$1.semi ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.semi)</span><span class="s2">;</span>
  <span class="s1">node.update = </span><span class="s2">this</span><span class="s1">.type === types$1.parenR ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenR)</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ForStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a `for`/`in` and `for`/`of` loop, which are almost</span>
<span class="s0">// same from parser's perspective.</span>

<span class="s1">pp$8.parseForIn = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">init) {</span>
  <span class="s2">var </span><span class="s1">isForIn = </span><span class="s2">this</span><span class="s1">.type === types$1._in</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">init.type === </span><span class="s3">&quot;VariableDeclaration&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">init.declarations[</span><span class="s4">0</span><span class="s1">].init != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(</span>
      <span class="s1">!isForIn ||</span>
      <span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">8 </span><span class="s1">||</span>
      <span class="s2">this</span><span class="s1">.strict ||</span>
      <span class="s1">init.kind !== </span><span class="s3">&quot;var&quot; </span><span class="s1">||</span>
      <span class="s1">init.declarations[</span><span class="s4">0</span><span class="s1">].id.type !== </span><span class="s3">&quot;Identifier&quot;</span>
    <span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.raise(</span>
      <span class="s1">init.start</span><span class="s2">,</span>
      <span class="s1">((isForIn ? </span><span class="s3">&quot;for-in&quot; </span><span class="s1">: </span><span class="s3">&quot;for-of&quot;</span><span class="s1">) + </span><span class="s3">&quot; loop variable declaration may not have an initializer&quot;</span><span class="s1">)</span>
    <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">node.left = init</span><span class="s2">;</span>
  <span class="s1">node.right = isForIn ? </span><span class="s2">this</span><span class="s1">.parseExpression() : </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenR)</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s3">&quot;for&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels.pop()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">isForIn ? </span><span class="s3">&quot;ForInStatement&quot; </span><span class="s1">: </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a list of variable declarations.</span>

<span class="s1">pp$8.parseVar = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isFor</span><span class="s2">, </span><span class="s1">kind) {</span>
  <span class="s1">node.declarations = []</span><span class="s2">;</span>
  <span class="s1">node.kind = kind</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">decl = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parseVarId(decl</span><span class="s2">, </span><span class="s1">kind)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.eq)) {</span>
      <span class="s1">decl.init = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(isFor)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(kind === </span><span class="s3">&quot;const&quot; </span><span class="s1">&amp;&amp; !(</span><span class="s2">this</span><span class="s1">.type === types$1._in || (</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s1">)))) {</span>
      <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(decl.id.type !== </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; !(isFor &amp;&amp; (</span><span class="s2">this</span><span class="s1">.type === types$1._in || </span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;of&quot;</span><span class="s1">)))) {</span>
      <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, </span><span class="s3">&quot;Complex binding patterns require an initialization value&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">decl.init = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s1">node.declarations.push(</span><span class="s2">this</span><span class="s1">.finishNode(decl</span><span class="s2">, </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.comma)) { </span><span class="s2">break </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseVarId = </span><span class="s2">function</span><span class="s1">(decl</span><span class="s2">, </span><span class="s1">kind) {</span>
  <span class="s1">decl.id = </span><span class="s2">this</span><span class="s1">.parseBindingAtom()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.checkLValPattern(decl.id</span><span class="s2">, </span><span class="s1">kind === </span><span class="s3">&quot;var&quot; </span><span class="s1">? BIND_VAR : BIND_LEXICAL</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">FUNC_STATEMENT$1 = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">FUNC_HANGING_STATEMENT = </span><span class="s4">2</span><span class="s2">, </span><span class="s1">FUNC_NULLABLE_ID$1 = </span><span class="s4">4</span><span class="s2">;</span>

<span class="s0">// Parse a function declaration or literal (depending on the</span>
<span class="s0">// `statement &amp; FUNC_STATEMENT`).</span>

<span class="s0">// Remove `allowExpressionBody` for 7.0.0, as it is only called with false</span>
<span class="s1">pp$8.parseFunction = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">, </span><span class="s1">allowExpressionBody</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">this</span><span class="s1">.initFunction(node)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; !isAsync) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.generator = </span><span class="s2">this</span><span class="s1">.eat(types$1.star)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">{ node.async = !!isAsync</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(statement &amp; FUNC_STATEMENT$1) {</span>
    <span class="s1">node.id = (statement &amp; FUNC_NULLABLE_ID$1) &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.name ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.id &amp;&amp; !(statement &amp; FUNC_HANGING_STATEMENT))</span>
      <span class="s0">// If it is a regular function declaration in sloppy mode, then it is</span>
      <span class="s0">// subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding</span>
      <span class="s0">// mode depends on properties of the current scope (see</span>
      <span class="s0">// treatFunctionsAsVar).</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkLValSimple(node.id</span><span class="s2">, </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict || node.generator || node.async) ? </span><span class="s2">this</span><span class="s1">.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">oldYieldPos = </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s1">oldAwaitPos = </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s1">oldAwaitIdentPos = </span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(functionFlags(node.async</span><span class="s2">, </span><span class="s1">node.generator))</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(!(statement &amp; FUNC_STATEMENT$1))</span>
    <span class="s1">{ node.id = </span><span class="s2">this</span><span class="s1">.type === types$1.name ? </span><span class="s2">this</span><span class="s1">.parseIdent() : </span><span class="s2">null; </span><span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.parseFunctionParams(node)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parseFunctionBody(node</span><span class="s2">, </span><span class="s1">allowExpressionBody</span><span class="s2">, false, </span><span class="s1">forInit)</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = oldAwaitIdentPos</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">(statement &amp; FUNC_STATEMENT$1) ? </span><span class="s3">&quot;FunctionDeclaration&quot; </span><span class="s1">: </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseFunctionParams = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenL)</span><span class="s2">;</span>
  <span class="s1">node.params = </span><span class="s2">this</span><span class="s1">.parseBindingList(types$1.parenR</span><span class="s2">, false, this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.checkYieldAwaitInDefaultParams()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a class declaration or literal (depending on the</span>
<span class="s0">// `isStatement` parameter).</span>

<span class="s1">pp$8.parseClass = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isStatement) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>

  <span class="s0">// ecma-262 14.6 Class Definitions</span>
  <span class="s0">// A class definition is always strict mode code.</span>
  <span class="s2">var </span><span class="s1">oldStrict = </span><span class="s2">this</span><span class="s1">.strict</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.strict = </span><span class="s2">true;</span>

  <span class="s2">this</span><span class="s1">.parseClassId(node</span><span class="s2">, </span><span class="s1">isStatement)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parseClassSuper(node)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">privateNameMap = </span><span class="s2">this</span><span class="s1">.enterClassBody()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">classBody = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">hadConstructor = </span><span class="s2">false;</span>
  <span class="s1">classBody.body = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.braceL)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.braceR) {</span>
    <span class="s2">var </span><span class="s1">element = </span><span class="s2">this</span><span class="s1">.parseClassElement(node.superClass !== </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(element) {</span>
      <span class="s1">classBody.body.push(element)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(element.type === </span><span class="s3">&quot;MethodDefinition&quot; </span><span class="s1">&amp;&amp; element.kind === </span><span class="s3">&quot;constructor&quot;</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(hadConstructor) { </span><span class="s2">this</span><span class="s1">.raise(element.start</span><span class="s2">, </span><span class="s3">&quot;Duplicate constructor in the same class&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">hadConstructor = </span><span class="s2">true;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(element.key &amp;&amp; element.key.type === </span><span class="s3">&quot;PrivateIdentifier&quot; </span><span class="s1">&amp;&amp; isPrivateNameConflicted(privateNameMap</span><span class="s2">, </span><span class="s1">element)) {</span>
        <span class="s2">this</span><span class="s1">.raiseRecoverable(element.key.start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Identifier '#&quot; </span><span class="s1">+ (element.key.name) + </span><span class="s3">&quot;' has already been declared&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.strict = oldStrict</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.finishNode(classBody</span><span class="s2">, </span><span class="s3">&quot;ClassBody&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exitClassBody()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">isStatement ? </span><span class="s3">&quot;ClassDeclaration&quot; </span><span class="s1">: </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassElement = </span><span class="s2">function</span><span class="s1">(constructorAllowsSuper) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.semi)) { </span><span class="s2">return null </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ecmaVersion = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">keyName = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">isGenerator = </span><span class="s2">false;</span>
  <span class="s2">var </span><span class="s1">isAsync = </span><span class="s2">false;</span>
  <span class="s2">var </span><span class="s1">kind = </span><span class="s3">&quot;method&quot;</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">isStatic = </span><span class="s2">false;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;static&quot;</span><span class="s1">)) {</span>
    <span class="s0">// Parse static init block</span>
    <span class="s2">if </span><span class="s1">(ecmaVersion &gt;= </span><span class="s4">13 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.braceL)) {</span>
      <span class="s2">this</span><span class="s1">.parseClassStaticBlock(node)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">node</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassElementNameStart() || </span><span class="s2">this</span><span class="s1">.type === types$1.star) {</span>
      <span class="s1">isStatic = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">keyName = </span><span class="s3">&quot;static&quot;</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">node.static = isStatic</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!keyName &amp;&amp; ecmaVersion &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;async&quot;</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s2">this</span><span class="s1">.isClassElementNameStart() || </span><span class="s2">this</span><span class="s1">.type === types$1.star) &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
      <span class="s1">isAsync = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">keyName = </span><span class="s3">&quot;async&quot;</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!keyName &amp;&amp; (ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">|| !isAsync) &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.star)) {</span>
    <span class="s1">isGenerator = </span><span class="s2">true;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!keyName &amp;&amp; !isAsync &amp;&amp; !isGenerator) {</span>
    <span class="s2">var </span><span class="s1">lastValue = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;get&quot;</span><span class="s1">) || </span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;set&quot;</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isClassElementNameStart()) {</span>
        <span class="s1">kind = lastValue</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">keyName = lastValue</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Parse element name</span>
  <span class="s2">if </span><span class="s1">(keyName) {</span>
    <span class="s0">// 'async', 'get', 'set', or 'static' were not a keyword contextually.</span>
    <span class="s0">// The last token is any of those. Make it the element name.</span>
    <span class="s1">node.computed = </span><span class="s2">false;</span>
    <span class="s1">node.key = </span><span class="s2">this</span><span class="s1">.startNodeAt(</span><span class="s2">this</span><span class="s1">.lastTokStart</span><span class="s2">, this</span><span class="s1">.lastTokStartLoc)</span><span class="s2">;</span>
    <span class="s1">node.key.name = keyName</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.finishNode(node.key</span><span class="s2">, </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.parseClassElementName(node)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Parse element value</span>
  <span class="s2">if </span><span class="s1">(ecmaVersion &lt; </span><span class="s4">13 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.type === types$1.parenL || kind !== </span><span class="s3">&quot;method&quot; </span><span class="s1">|| isGenerator || isAsync) {</span>
    <span class="s2">var </span><span class="s1">isConstructor = !node.static &amp;&amp; checkKeyName(node</span><span class="s2">, </span><span class="s3">&quot;constructor&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">allowsDirectSuper = isConstructor &amp;&amp; constructorAllowsSuper</span><span class="s2">;</span>
    <span class="s0">// Couldn't move this check into the 'parseClassMethod' method for backward compatibility.</span>
    <span class="s2">if </span><span class="s1">(isConstructor &amp;&amp; kind !== </span><span class="s3">&quot;method&quot;</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(node.key.start</span><span class="s2">, </span><span class="s3">&quot;Constructor can't have get/set modifier&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.kind = isConstructor ? </span><span class="s3">&quot;constructor&quot; </span><span class="s1">: kind</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parseClassMethod(node</span><span class="s2">, </span><span class="s1">isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">allowsDirectSuper)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.parseClassField(node)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.isClassElementNameStart = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.type === types$1.name ||</span>
    <span class="s2">this</span><span class="s1">.type === types$1.privateId ||</span>
    <span class="s2">this</span><span class="s1">.type === types$1.num ||</span>
    <span class="s2">this</span><span class="s1">.type === types$1.string ||</span>
    <span class="s2">this</span><span class="s1">.type === types$1.bracketL ||</span>
    <span class="s2">this</span><span class="s1">.type.keyword</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassElementName = </span><span class="s2">function</span><span class="s1">(element) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.privateId) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.value === </span><span class="s3">&quot;constructor&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Classes can't have an element named '#constructor'&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">element.computed = </span><span class="s2">false;</span>
    <span class="s1">element.key = </span><span class="s2">this</span><span class="s1">.parsePrivateIdent()</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.parsePropertyName(element)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassMethod = </span><span class="s2">function</span><span class="s1">(method</span><span class="s2">, </span><span class="s1">isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">allowsDirectSuper) {</span>
  <span class="s0">// Check key and flags</span>
  <span class="s2">var </span><span class="s1">key = method.key</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(method.kind === </span><span class="s3">&quot;constructor&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(isGenerator) { </span><span class="s2">this</span><span class="s1">.raise(key.start</span><span class="s2">, </span><span class="s3">&quot;Constructor can't be a generator&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isAsync) { </span><span class="s2">this</span><span class="s1">.raise(key.start</span><span class="s2">, </span><span class="s3">&quot;Constructor can't be an async method&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(method.static &amp;&amp; checkKeyName(method</span><span class="s2">, </span><span class="s3">&quot;prototype&quot;</span><span class="s1">)) {</span>
    <span class="s2">this</span><span class="s1">.raise(key.start</span><span class="s2">, </span><span class="s3">&quot;Classes may not have a static property named prototype&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Parse value</span>
  <span class="s2">var </span><span class="s1">value = method.value = </span><span class="s2">this</span><span class="s1">.parseMethod(isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">allowsDirectSuper)</span><span class="s2">;</span>

  <span class="s0">// Check value</span>
  <span class="s2">if </span><span class="s1">(method.kind === </span><span class="s3">&quot;get&quot; </span><span class="s1">&amp;&amp; value.params.length !== </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(value.start</span><span class="s2">, </span><span class="s3">&quot;getter should have no params&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(method.kind === </span><span class="s3">&quot;set&quot; </span><span class="s1">&amp;&amp; value.params.length !== </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(value.start</span><span class="s2">, </span><span class="s3">&quot;setter should have exactly one param&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(method.kind === </span><span class="s3">&quot;set&quot; </span><span class="s1">&amp;&amp; value.params[</span><span class="s4">0</span><span class="s1">].type === </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(value.params[</span><span class="s4">0</span><span class="s1">].start</span><span class="s2">, </span><span class="s3">&quot;Setter cannot use rest params&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">return this</span><span class="s1">.finishNode(method</span><span class="s2">, </span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassField = </span><span class="s2">function</span><span class="s1">(field) {</span>
  <span class="s2">if </span><span class="s1">(checkKeyName(field</span><span class="s2">, </span><span class="s3">&quot;constructor&quot;</span><span class="s1">)) {</span>
    <span class="s2">this</span><span class="s1">.raise(field.key.start</span><span class="s2">, </span><span class="s3">&quot;Classes can't have a field named 'constructor'&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(field.static &amp;&amp; checkKeyName(field</span><span class="s2">, </span><span class="s3">&quot;prototype&quot;</span><span class="s1">)) {</span>
    <span class="s2">this</span><span class="s1">.raise(field.key.start</span><span class="s2">, </span><span class="s3">&quot;Classes can't have a static field named 'prototype'&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.eq)) {</span>
    <span class="s0">// To raise SyntaxError if 'arguments' exists in the initializer.</span>
    <span class="s2">var </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.currentThisScope()</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">inClassFieldInit = scope.inClassFieldInit</span><span class="s2">;</span>
    <span class="s1">scope.inClassFieldInit = </span><span class="s2">true;</span>
    <span class="s1">field.value = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
    <span class="s1">scope.inClassFieldInit = inClassFieldInit</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">field.value = </span><span class="s2">null;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>

  <span class="s2">return this</span><span class="s1">.finishNode(field</span><span class="s2">, </span><span class="s3">&quot;PropertyDefinition&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassStaticBlock = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s1">node.body = []</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">oldLabels = </span><span class="s2">this</span><span class="s1">.labels</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.braceR) {</span>
    <span class="s2">var </span><span class="s1">stmt = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">node.body.push(stmt)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.labels = oldLabels</span><span class="s2">;</span>

  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;StaticBlock&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassId = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isStatement) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.name) {</span>
    <span class="s1">node.id = </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isStatement)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkLValSimple(node.id</span><span class="s2">, </span><span class="s1">BIND_LEXICAL</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(isStatement === </span><span class="s2">true</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.id = </span><span class="s2">null;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseClassSuper = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s1">node.superClass = </span><span class="s2">this</span><span class="s1">.eat(types$1._extends) ? </span><span class="s2">this</span><span class="s1">.parseExprSubscripts(</span><span class="s2">null, false</span><span class="s1">) : </span><span class="s2">null;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.enterClassBody = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">element = {declared: Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">used: []}</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.privateNameStack.push(element)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">element.declared</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.exitClassBody = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">ref = </span><span class="s2">this</span><span class="s1">.privateNameStack.pop()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">declared = ref.declared</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">used = ref.used</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">len = </span><span class="s2">this</span><span class="s1">.privateNameStack.length</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">parent = len === </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.privateNameStack[len - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; used.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s2">var </span><span class="s1">id = used[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hasOwn(declared</span><span class="s2">, </span><span class="s1">id.name)) {</span>
      <span class="s2">if </span><span class="s1">(parent) {</span>
        <span class="s1">parent.used.push(id)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">.raiseRecoverable(id.start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Private field '#&quot; </span><span class="s1">+ (id.name) + </span><span class="s3">&quot;' must be declared in an enclosing class&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">isPrivateNameConflicted(privateNameMap</span><span class="s2">, </span><span class="s1">element) {</span>
  <span class="s2">var </span><span class="s1">name = element.key.name</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">curr = privateNameMap[name]</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">next = </span><span class="s3">&quot;true&quot;</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(element.type === </span><span class="s3">&quot;MethodDefinition&quot; </span><span class="s1">&amp;&amp; (element.kind === </span><span class="s3">&quot;get&quot; </span><span class="s1">|| element.kind === </span><span class="s3">&quot;set&quot;</span><span class="s1">)) {</span>
    <span class="s1">next = (element.static ? </span><span class="s3">&quot;s&quot; </span><span class="s1">: </span><span class="s3">&quot;i&quot;</span><span class="s1">) + element.kind</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// `class { get #a(){}; static set #a(_){} }` is also conflict.</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">curr === </span><span class="s3">&quot;iget&quot; </span><span class="s1">&amp;&amp; next === </span><span class="s3">&quot;iset&quot; </span><span class="s1">||</span>
    <span class="s1">curr === </span><span class="s3">&quot;iset&quot; </span><span class="s1">&amp;&amp; next === </span><span class="s3">&quot;iget&quot; </span><span class="s1">||</span>
    <span class="s1">curr === </span><span class="s3">&quot;sget&quot; </span><span class="s1">&amp;&amp; next === </span><span class="s3">&quot;sset&quot; </span><span class="s1">||</span>
    <span class="s1">curr === </span><span class="s3">&quot;sset&quot; </span><span class="s1">&amp;&amp; next === </span><span class="s3">&quot;sget&quot;</span>
  <span class="s1">) {</span>
    <span class="s1">privateNameMap[name] = </span><span class="s3">&quot;true&quot;</span><span class="s2">;</span>
    <span class="s2">return false</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!curr) {</span>
    <span class="s1">privateNameMap[name] = next</span><span class="s2">;</span>
    <span class="s2">return false</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">checkKeyName(node</span><span class="s2">, </span><span class="s1">name) {</span>
  <span class="s2">var </span><span class="s1">computed = node.computed</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">key = node.key</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">!computed &amp;&amp; (</span>
    <span class="s1">key.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; key.name === name ||</span>
    <span class="s1">key.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s1">&amp;&amp; key.value === name</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// Parses module export declaration.</span>

<span class="s1">pp$8.parseExport = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">exports) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s0">// export * from '...'</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.star)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s1">)) {</span>
        <span class="s1">node.exported = </span><span class="s2">this</span><span class="s1">.parseModuleExportName()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s1">node.exported</span><span class="s2">, this</span><span class="s1">.lastTokStart)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">node.exported = </span><span class="s2">null;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.string) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1._default)) { </span><span class="s0">// export default ...</span>
    <span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s3">&quot;default&quot;</span><span class="s2">, this</span><span class="s1">.lastTokStart)</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">isAsync</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._function || (isAsync = </span><span class="s2">this</span><span class="s1">.isAsyncFunction())) {</span>
      <span class="s2">var </span><span class="s1">fNode = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isAsync) { </span><span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseFunction(fNode</span><span class="s2">, </span><span class="s1">FUNC_STATEMENT$1 | FUNC_NULLABLE_ID$1</span><span class="s2">, false, </span><span class="s1">isAsync)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1._class) {</span>
      <span class="s2">var </span><span class="s1">cNode = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
      <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseClass(cNode</span><span class="s2">, </span><span class="s3">&quot;nullableID&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s0">// export var|const|let|function|class ...</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldParseExportStatement()) {</span>
    <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.declaration.type === </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkVariableExport(exports</span><span class="s2">, </span><span class="s1">node.declaration.declarations)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s1">node.declaration.id</span><span class="s2">, </span><span class="s1">node.declaration.id.start)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.specifiers = []</span><span class="s2">;</span>
    <span class="s1">node.source = </span><span class="s2">null;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{ </span><span class="s0">// export { x, y as z } [from '...']</span>
    <span class="s1">node.declaration = </span><span class="s2">null;</span>
    <span class="s1">node.specifiers = </span><span class="s2">this</span><span class="s1">.parseExportSpecifiers(exports)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.string) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.specifiers</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">// check for keywords used as local names</span>
        <span class="s2">var </span><span class="s1">spec = list[i]</span><span class="s2">;</span>

        <span class="s2">this</span><span class="s1">.checkUnreserved(spec.local)</span><span class="s2">;</span>
        <span class="s0">// check if export is defined</span>
        <span class="s2">this</span><span class="s1">.checkLocalExport(spec.local)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(spec.local.type === </span><span class="s3">&quot;Literal&quot;</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(spec.local.start</span><span class="s2">, </span><span class="s3">&quot;A string literal cannot be used as an exported binding without `from`.&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">node.source = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.checkExport = </span><span class="s2">function</span><span class="s1">(exports</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">pos) {</span>
  <span class="s2">if </span><span class="s1">(!exports) { </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">name !== </span><span class="s3">&quot;string&quot;</span><span class="s1">)</span>
    <span class="s1">{ name = name.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">? name.name : name.value</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(hasOwn(exports</span><span class="s2">, </span><span class="s1">name))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(pos</span><span class="s2">, </span><span class="s3">&quot;Duplicate export '&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;'&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">exports[name] = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.checkPatternExport = </span><span class="s2">function</span><span class="s1">(exports</span><span class="s2">, </span><span class="s1">pat) {</span>
  <span class="s2">var </span><span class="s1">type = pat.type</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(type === </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s1">pat</span><span class="s2">, </span><span class="s1">pat.start)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = pat.properties</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
      <span class="s1">{</span>
        <span class="s2">var </span><span class="s1">prop = list[i]</span><span class="s2">;</span>

        <span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">prop)</span><span class="s2">;</span>
      <span class="s1">} }</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i$1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list$1 = pat.elements</span><span class="s2">; </span><span class="s1">i$1 &lt; list$1.length</span><span class="s2">; </span><span class="s1">i$1 += </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">elt = list$1[i$1]</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(elt) { </span><span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">elt)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">} }</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;Property&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">pat.value)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">pat.left)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">pat.argument)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">pat.expression)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.checkVariableExport = </span><span class="s2">function</span><span class="s1">(exports</span><span class="s2">, </span><span class="s1">decls) {</span>
  <span class="s2">if </span><span class="s1">(!exports) { </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = decls</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">decl = list[i]</span><span class="s2">;</span>

    <span class="s2">this</span><span class="s1">.checkPatternExport(exports</span><span class="s2">, </span><span class="s1">decl.id)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.shouldParseExportStatement = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return this</span><span class="s1">.type.keyword === </span><span class="s3">&quot;var&quot; </span><span class="s1">||</span>
    <span class="s2">this</span><span class="s1">.type.keyword === </span><span class="s3">&quot;const&quot; </span><span class="s1">||</span>
    <span class="s2">this</span><span class="s1">.type.keyword === </span><span class="s3">&quot;class&quot; </span><span class="s1">||</span>
    <span class="s2">this</span><span class="s1">.type.keyword === </span><span class="s3">&quot;function&quot; </span><span class="s1">||</span>
    <span class="s2">this</span><span class="s1">.isLet() ||</span>
    <span class="s2">this</span><span class="s1">.isAsyncFunction()</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses a comma-separated list of module exports.</span>

<span class="s1">pp$8.parseExportSpecifiers = </span><span class="s2">function</span><span class="s1">(exports) {</span>
  <span class="s2">var </span><span class="s1">nodes = []</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true;</span>
  <span class="s0">// export { x, y as z } [from '...']</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.braceL)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.braceR)) {</span>
    <span class="s2">if </span><span class="s1">(!first) {</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.afterTrailingComma(types$1.braceR)) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ first = </span><span class="s2">false; </span><span class="s1">}</span>

    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s1">node.local = </span><span class="s2">this</span><span class="s1">.parseModuleExportName()</span><span class="s2">;</span>
    <span class="s1">node.exported = </span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s1">) ? </span><span class="s2">this</span><span class="s1">.parseModuleExportName() : node.local</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.checkExport(</span>
      <span class="s1">exports</span><span class="s2">,</span>
      <span class="s1">node.exported</span><span class="s2">,</span>
      <span class="s1">node.exported.start</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">nodes.push(</span><span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">nodes</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses import declaration.</span>

<span class="s1">pp$8.parseImport = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s0">// import '...'</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.string) {</span>
    <span class="s1">node.specifiers = empty$1</span><span class="s2">;</span>
    <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">node.specifiers = </span><span class="s2">this</span><span class="s1">.parseImportSpecifiers()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.type === types$1.string ? </span><span class="s2">this</span><span class="s1">.parseExprAtom() : </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses a comma-separated list of module imports.</span>

<span class="s1">pp$8.parseImportSpecifiers = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">nodes = []</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.name) {</span>
    <span class="s0">// import defaultObj, { x, y as z } from '...'</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s1">node.local = </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.checkLValSimple(node.local</span><span class="s2">, </span><span class="s1">BIND_LEXICAL)</span><span class="s2">;</span>
    <span class="s1">nodes.push(</span><span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.comma)) { </span><span class="s2">return </span><span class="s1">nodes }</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.star) {</span>
    <span class="s2">var </span><span class="s1">node$1 = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">&quot;as&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">node$1.local = </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.checkLValSimple(node$1.local</span><span class="s2">, </span><span class="s1">BIND_LEXICAL)</span><span class="s2">;</span>
    <span class="s1">nodes.push(</span><span class="s2">this</span><span class="s1">.finishNode(node$1</span><span class="s2">, </span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">nodes</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.braceL)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.braceR)) {</span>
    <span class="s2">if </span><span class="s1">(!first) {</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.afterTrailingComma(types$1.braceR)) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ first = </span><span class="s2">false; </span><span class="s1">}</span>

    <span class="s2">var </span><span class="s1">node$2 = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s1">node$2.imported = </span><span class="s2">this</span><span class="s1">.parseModuleExportName()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s1">)) {</span>
      <span class="s1">node$2.local = </span><span class="s2">this</span><span class="s1">.parseIdent()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.checkUnreserved(node$2.imported)</span><span class="s2">;</span>
      <span class="s1">node$2.local = node$2.imported</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.checkLValSimple(node$2.local</span><span class="s2">, </span><span class="s1">BIND_LEXICAL)</span><span class="s2">;</span>
    <span class="s1">nodes.push(</span><span class="s2">this</span><span class="s1">.finishNode(node$2</span><span class="s2">, </span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">nodes</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$8.parseModuleExportName = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">13 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.string) {</span>
    <span class="s2">var </span><span class="s1">stringLiteral = </span><span class="s2">this</span><span class="s1">.parseLiteral(</span><span class="s2">this</span><span class="s1">.value)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(loneSurrogate.test(stringLiteral.value)) {</span>
      <span class="s2">this</span><span class="s1">.raise(stringLiteral.start</span><span class="s2">, </span><span class="s3">&quot;An export name cannot include a lone surrogate.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">stringLiteral</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Set `ExpressionStatement#directive` property for directive prologues.</span>
<span class="s1">pp$8.adaptDirectivePrologue = </span><span class="s2">function</span><span class="s1">(statements) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; statements.length &amp;&amp; </span><span class="s2">this</span><span class="s1">.isDirectiveCandidate(statements[i])</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s1">statements[i].directive = statements[i].expression.raw.slice(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$8.isDirectiveCandidate = </span><span class="s2">function</span><span class="s1">(statement) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">5 </span><span class="s1">&amp;&amp;</span>
    <span class="s1">statement.type === </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">statement.expression.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s2">typeof </span><span class="s1">statement.expression.value === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s0">// Reject parenthesized strings.</span>
    <span class="s1">(</span><span class="s2">this</span><span class="s1">.input[statement.start] === </span><span class="s3">&quot;</span><span class="s2">\&quot;</span><span class="s3">&quot; </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.input[statement.start] === </span><span class="s3">&quot;'&quot;</span><span class="s1">)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$7 = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// Convert existing expression atom to assignable pattern</span>
<span class="s0">// if possible.</span>

<span class="s1">pp$7.toAssignable = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isBinding</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; node) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
    <span class="s2">case </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inAsync &amp;&amp; node.name === </span><span class="s3">&quot;await&quot;</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'await' as identifier inside an async function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">:</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s1">:</span>
      <span class="s1">node.type = </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors) { </span><span class="s2">this</span><span class="s1">.checkPatternErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.properties</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">prop = list[i]</span><span class="s2">;</span>

      <span class="s2">this</span><span class="s1">.toAssignable(prop</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">;</span>
        <span class="s0">// Early error:</span>
        <span class="s0">//   AssignmentRestProperty[Yield, Await] :</span>
        <span class="s0">//     `...` DestructuringAssignmentTarget[Yield, Await]</span>
        <span class="s0">//</span>
        <span class="s0">//   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.</span>
        <span class="s2">if </span><span class="s1">(</span>
          <span class="s1">prop.type === </span><span class="s3">&quot;RestElement&quot; </span><span class="s1">&amp;&amp;</span>
          <span class="s1">(prop.argument.type === </span><span class="s3">&quot;ArrayPattern&quot; </span><span class="s1">|| prop.argument.type === </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s1">)</span>
        <span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.raise(prop.argument.start</span><span class="s2">, </span><span class="s3">&quot;Unexpected token&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;Property&quot;</span><span class="s1">:</span>
      <span class="s0">// AssignmentProperty has type === &quot;Property&quot;</span>
      <span class="s2">if </span><span class="s1">(node.kind !== </span><span class="s3">&quot;init&quot;</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(node.key.start</span><span class="s2">, </span><span class="s3">&quot;Object pattern can't contain getter or setter&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.toAssignable(node.value</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s1">:</span>
      <span class="s1">node.type = </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors) { </span><span class="s2">this</span><span class="s1">.checkPatternErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.toAssignableList(node.elements</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;SpreadElement&quot;</span><span class="s1">:</span>
      <span class="s1">node.type = </span><span class="s3">&quot;RestElement&quot;</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.toAssignable(node.argument</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(node.argument.type === </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(node.argument.start</span><span class="s2">, </span><span class="s3">&quot;Rest elements cannot have a default value&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(node.operator !== </span><span class="s3">&quot;=&quot;</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(node.left.end</span><span class="s2">, </span><span class="s3">&quot;Only '=' operator can be used for specifying default value.&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">node.type = </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s2">;</span>
      <span class="s2">delete </span><span class="s1">node.operator</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.toAssignable(node.left</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s1">:</span>
      <span class="s2">this</span><span class="s1">.toAssignable(node.expression</span><span class="s2">, </span><span class="s1">isBinding</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;ChainExpression&quot;</span><span class="s1">:</span>
      <span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;Optional chaining cannot appear in left-hand side&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(!isBinding) { </span><span class="s2">break </span><span class="s1">}</span>

    <span class="s2">default</span><span class="s1">:</span>
      <span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s3">&quot;Assigning to rvalue&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(refDestructuringErrors) { </span><span class="s2">this</span><span class="s1">.checkPatternErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Convert list of expression atoms to binding list.</span>

<span class="s1">pp$7.toAssignableList = </span><span class="s2">function</span><span class="s1">(exprList</span><span class="s2">, </span><span class="s1">isBinding) {</span>
  <span class="s2">var </span><span class="s1">end = exprList.length</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; end</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">var </span><span class="s1">elt = exprList[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(elt) { </span><span class="s2">this</span><span class="s1">.toAssignable(elt</span><span class="s2">, </span><span class="s1">isBinding)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(end) {</span>
    <span class="s2">var </span><span class="s1">last = exprList[end - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion === </span><span class="s4">6 </span><span class="s1">&amp;&amp; isBinding &amp;&amp; last &amp;&amp; last.type === </span><span class="s3">&quot;RestElement&quot; </span><span class="s1">&amp;&amp; last.argument.type !== </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected(last.argument.start)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">exprList</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses spread element.</span>

<span class="s1">pp$7.parseSpread = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;SpreadElement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$7.parseRestBinding = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>

  <span class="s0">// RestElement inside of a function parameter must be an identifier</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion === </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.name)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseBindingAtom()</span><span class="s2">;</span>

  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses lvalue (assignable) atom.</span>

<span class="s1">pp$7.parseBindingAtom = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type) {</span>
    <span class="s2">case </span><span class="s1">types$1.bracketL:</span>
      <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s1">node.elements = </span><span class="s2">this</span><span class="s1">.parseBindingList(types$1.bracketR</span><span class="s2">, true, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s1">)</span>

    <span class="s2">case </span><span class="s1">types$1.braceL:</span>
      <span class="s2">return this</span><span class="s1">.parseObj(</span><span class="s2">true</span><span class="s1">)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.parseIdent()</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$7.parseBindingList = </span><span class="s2">function</span><span class="s1">(close</span><span class="s2">, </span><span class="s1">allowEmpty</span><span class="s2">, </span><span class="s1">allowTrailingComma) {</span>
  <span class="s2">var </span><span class="s1">elts = []</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true;</span>
  <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(close)) {</span>
    <span class="s2">if </span><span class="s1">(first) { first = </span><span class="s2">false; </span><span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{ </span><span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(allowEmpty &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.comma) {</span>
      <span class="s1">elts.push(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(allowTrailingComma &amp;&amp; </span><span class="s2">this</span><span class="s1">.afterTrailingComma(close)) {</span>
      <span class="s2">break</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.ellipsis) {</span>
      <span class="s2">var </span><span class="s1">rest = </span><span class="s2">this</span><span class="s1">.parseRestBinding()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.parseBindingListItem(rest)</span><span class="s2">;</span>
      <span class="s1">elts.push(rest)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.comma) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Comma is not permitted after the rest element&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.expect(close)</span><span class="s2">;</span>
      <span class="s2">break</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.startLoc)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.parseBindingListItem(elem)</span><span class="s2">;</span>
      <span class="s1">elts.push(elem)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">elts</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$7.parseBindingListItem = </span><span class="s2">function</span><span class="s1">(param) {</span>
  <span class="s2">return </span><span class="s1">param</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses assignment pattern around given atom if possible.</span>

<span class="s1">pp$7.parseMaybeDefault = </span><span class="s2">function</span><span class="s1">(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">left) {</span>
  <span class="s1">left = left || </span><span class="s2">this</span><span class="s1">.parseBindingAtom()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">6 </span><span class="s1">|| !</span><span class="s2">this</span><span class="s1">.eat(types$1.eq)) { </span><span class="s2">return </span><span class="s1">left }</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
  <span class="s1">node.left = left</span><span class="s2">;</span>
  <span class="s1">node.right = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The following three functions all verify that a node is an lvalue —</span>
<span class="s0">// something that can be bound, or assigned to. In order to do so, they perform</span>
<span class="s0">// a variety of checks:</span>
<span class="s0">//</span>
<span class="s0">// - Check that none of the bound/assigned-to identifiers are reserved words.</span>
<span class="s0">// - Record name declarations for bindings in the appropriate scope.</span>
<span class="s0">// - Check duplicate argument names, if checkClashes is set.</span>
<span class="s0">//</span>
<span class="s0">// If a complex binding pattern is encountered (e.g., object and array</span>
<span class="s0">// destructuring), the entire pattern is recursively checked.</span>
<span class="s0">//</span>
<span class="s0">// There are three versions of checkLVal*() appropriate for different</span>
<span class="s0">// circumstances:</span>
<span class="s0">//</span>
<span class="s0">// - checkLValSimple() shall be used if the syntactic construct supports</span>
<span class="s0">//   nothing other than identifiers and member expressions. Parenthesized</span>
<span class="s0">//   expressions are also correctly handled. This is generally appropriate for</span>
<span class="s0">//   constructs for which the spec says</span>
<span class="s0">//</span>
<span class="s0">//   &gt; It is a Syntax Error if AssignmentTargetType of [the production] is not</span>
<span class="s0">//   &gt; simple.</span>
<span class="s0">//</span>
<span class="s0">//   It is also appropriate for checking if an identifier is valid and not</span>
<span class="s0">//   defined elsewhere, like import declarations or function/class identifiers.</span>
<span class="s0">//</span>
<span class="s0">//   Examples where this is used include:</span>
<span class="s0">//     a += …;</span>
<span class="s0">//     import a from '…';</span>
<span class="s0">//   where a is the node to be checked.</span>
<span class="s0">//</span>
<span class="s0">// - checkLValPattern() shall be used if the syntactic construct supports</span>
<span class="s0">//   anything checkLValSimple() supports, as well as object and array</span>
<span class="s0">//   destructuring patterns. This is generally appropriate for constructs for</span>
<span class="s0">//   which the spec says</span>
<span class="s0">//</span>
<span class="s0">//   &gt; It is a Syntax Error if [the production] is neither an ObjectLiteral nor</span>
<span class="s0">//   &gt; an ArrayLiteral and AssignmentTargetType of [the production] is not</span>
<span class="s0">//   &gt; simple.</span>
<span class="s0">//</span>
<span class="s0">//   Examples where this is used include:</span>
<span class="s0">//     (a = …);</span>
<span class="s0">//     const a = …;</span>
<span class="s0">//     try { … } catch (a) { … }</span>
<span class="s0">//   where a is the node to be checked.</span>
<span class="s0">//</span>
<span class="s0">// - checkLValInnerPattern() shall be used if the syntactic construct supports</span>
<span class="s0">//   anything checkLValPattern() supports, as well as default assignment</span>
<span class="s0">//   patterns, rest elements, and other constructs that may appear within an</span>
<span class="s0">//   object or array destructuring pattern.</span>
<span class="s0">//</span>
<span class="s0">//   As a special case, function parameters also use checkLValInnerPattern(),</span>
<span class="s0">//   as they also support defaults and rest constructs.</span>
<span class="s0">//</span>
<span class="s0">// These functions deliberately support both assignment and binding constructs,</span>
<span class="s0">// as the logic for both is exceedingly similar. If the node is the target of</span>
<span class="s0">// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it</span>
<span class="s0">// should be set to the appropriate BIND_* constant, like BIND_VAR or</span>
<span class="s0">// BIND_LEXICAL.</span>
<span class="s0">//</span>
<span class="s0">// If the function is called with a non-BIND_NONE bindingType, then</span>
<span class="s0">// additionally a checkClashes object may be specified to allow checking for</span>
<span class="s0">// duplicate argument names. checkClashes is ignored if the provided construct</span>
<span class="s0">// is an assignment (i.e., bindingType is BIND_NONE).</span>

<span class="s1">pp$7.checkLValSimple = </span><span class="s2">function</span><span class="s1">(expr</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes) {</span>
  <span class="s2">if </span><span class="s1">( bindingType === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) bindingType = BIND_NONE</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">isBind = bindingType !== BIND_NONE</span><span class="s2">;</span>

  <span class="s2">switch </span><span class="s1">(expr.type) {</span>
  <span class="s2">case </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict &amp;&amp; </span><span class="s2">this</span><span class="s1">.reservedWordsStrictBind.test(expr.name))</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s1">(isBind ? </span><span class="s3">&quot;Binding &quot; </span><span class="s1">: </span><span class="s3">&quot;Assigning to &quot;</span><span class="s1">) + expr.name + </span><span class="s3">&quot; in strict mode&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBind) {</span>
      <span class="s2">if </span><span class="s1">(bindingType === BIND_LEXICAL &amp;&amp; expr.name === </span><span class="s3">&quot;let&quot;</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s3">&quot;let is disallowed as a lexically bound name&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(checkClashes) {</span>
        <span class="s2">if </span><span class="s1">(hasOwn(checkClashes</span><span class="s2">, </span><span class="s1">expr.name))</span>
          <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s3">&quot;Argument name clash&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">checkClashes[expr.name] = </span><span class="s2">true;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(bindingType !== BIND_OUTSIDE) { </span><span class="s2">this</span><span class="s1">.declareName(expr.name</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">expr.start)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;ChainExpression&quot;</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s3">&quot;Optional chaining cannot appear in left-hand side&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(isBind) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s3">&quot;Binding member expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(isBind) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(expr.start</span><span class="s2">, </span><span class="s3">&quot;Binding parenthesized expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.checkLValSimple(expr.expression</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span>

  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.raise(expr.start</span><span class="s2">, </span><span class="s1">(isBind ? </span><span class="s3">&quot;Binding&quot; </span><span class="s1">: </span><span class="s3">&quot;Assigning to&quot;</span><span class="s1">) + </span><span class="s3">&quot; rvalue&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$7.checkLValPattern = </span><span class="s2">function</span><span class="s1">(expr</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes) {</span>
  <span class="s2">if </span><span class="s1">( bindingType === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) bindingType = BIND_NONE</span><span class="s2">;</span>

  <span class="s2">switch </span><span class="s1">(expr.type) {</span>
  <span class="s2">case </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = expr.properties</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">prop = list[i]</span><span class="s2">;</span>

    <span class="s2">this</span><span class="s1">.checkLValInnerPattern(prop</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i$1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list$1 = expr.elements</span><span class="s2">; </span><span class="s1">i$1 &lt; list$1.length</span><span class="s2">; </span><span class="s1">i$1 += </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">elem = list$1[i$1]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(elem) { </span><span class="s2">this</span><span class="s1">.checkLValInnerPattern(elem</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">break</span>

  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.checkLValSimple(expr</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$7.checkLValInnerPattern = </span><span class="s2">function</span><span class="s1">(expr</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes) {</span>
  <span class="s2">if </span><span class="s1">( bindingType === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) bindingType = BIND_NONE</span><span class="s2">;</span>

  <span class="s2">switch </span><span class="s1">(expr.type) {</span>
  <span class="s2">case </span><span class="s3">&quot;Property&quot;</span><span class="s1">:</span>
    <span class="s0">// AssignmentProperty has type === &quot;Property&quot;</span>
    <span class="s2">this</span><span class="s1">.checkLValInnerPattern(expr.value</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;AssignmentPattern&quot;</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.checkLValPattern(expr.left</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
    <span class="s2">break</span>

  <span class="s2">case </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.checkLValPattern(expr.argument</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
    <span class="s2">break</span>

  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.checkLValPattern(expr</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">checkClashes)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The algorithm used to determine whether a regexp can appear at a</span>

<span class="s2">var </span><span class="s1">TokContext = </span><span class="s2">function </span><span class="s1">TokContext(token</span><span class="s2">, </span><span class="s1">isExpr</span><span class="s2">, </span><span class="s1">preserveSpace</span><span class="s2">, </span><span class="s1">override</span><span class="s2">, </span><span class="s1">generator) {</span>
  <span class="s2">this</span><span class="s1">.token = token</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.isExpr = !!isExpr</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.preserveSpace = !!preserveSpace</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.override = override</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.generator = !!generator</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">types = {</span>
  <span class="s1">b_stat: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;{&quot;</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">b_expr: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;{&quot;</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">b_tmpl: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;${&quot;</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">p_stat: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;(&quot;</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">p_expr: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;(&quot;</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">q_tmpl: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;`&quot;</span><span class="s2">, true, true, function </span><span class="s1">(p) { </span><span class="s2">return </span><span class="s1">p.tryReadTemplateToken()</span><span class="s2">; </span><span class="s1">})</span><span class="s2">,</span>
  <span class="s1">f_stat: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;function&quot;</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">f_expr: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;function&quot;</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">f_expr_gen: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;function&quot;</span><span class="s2">, true, false, null, true</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">f_gen: </span><span class="s2">new </span><span class="s1">TokContext(</span><span class="s3">&quot;function&quot;</span><span class="s2">, false, false, null, true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$6 = Parser.prototype</span><span class="s2">;</span>

<span class="s1">pp$6.initialContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">[types.b_stat]</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$6.curContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return this</span><span class="s1">.context[</span><span class="s2">this</span><span class="s1">.context.length - </span><span class="s4">1</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$6.braceIsBlock = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">var </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">.curContext()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(parent === types.f_expr || parent === types.f_stat)</span>
    <span class="s1">{ </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1.colon &amp;&amp; (parent === types.b_stat || parent === types.b_expr))</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">!parent.isExpr }</span>

  <span class="s0">// The check for `tt.name &amp;&amp; exprAllowed` detects whether we are</span>
  <span class="s0">// after a `yield` or `of` construct. See the `updateContext` for</span>
  <span class="s0">// `tt.name`.</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1._return || prevType === types$1.name &amp;&amp; </span><span class="s2">this</span><span class="s1">.exprAllowed)</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.start)) }</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)</span>
    <span class="s1">{ </span><span class="s2">return true </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1.braceL)</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">parent === types.b_stat }</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)</span>
    <span class="s1">{ </span><span class="s2">return false </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.exprAllowed</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$6.inGeneratorContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.context.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i--) {</span>
    <span class="s2">var </span><span class="s1">context = </span><span class="s2">this</span><span class="s1">.context[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(context.token === </span><span class="s3">&quot;function&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">return </span><span class="s1">context.generator }</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$6.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">var </span><span class="s1">update</span><span class="s2">, </span><span class="s1">type = </span><span class="s2">this</span><span class="s1">.type</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(type.keyword &amp;&amp; prevType === types$1.dot)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">false; </span><span class="s1">}</span>
  <span class="s2">else if </span><span class="s1">(update = type.updateContext)</span>
    <span class="s1">{ update.call(</span><span class="s2">this, </span><span class="s1">prevType)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.exprAllowed = type.beforeExpr</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Used to handle egde cases when token context could not be inferred correctly during tokenization phase</span>

<span class="s1">pp$6.overrideContext = </span><span class="s2">function</span><span class="s1">(tokenCtx) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.curContext() !== tokenCtx) {</span>
    <span class="s2">this</span><span class="s1">.context[</span><span class="s2">this</span><span class="s1">.context.length - </span><span class="s4">1</span><span class="s1">] = tokenCtx</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Token-specific context update code</span>

<span class="s1">types$1.parenR.updateContext = types$1.braceR.updateContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>
    <span class="s2">return</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">out = </span><span class="s2">this</span><span class="s1">.context.pop()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(out === types.b_stat &amp;&amp; </span><span class="s2">this</span><span class="s1">.curContext().token === </span><span class="s3">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">out = </span><span class="s2">this</span><span class="s1">.context.pop()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = !out.isExpr</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.braceL.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">this</span><span class="s1">.context.push(</span><span class="s2">this</span><span class="s1">.braceIsBlock(prevType) ? types.b_stat : types.b_expr)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.dollarBraceL.updateContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.context.push(types.b_tmpl)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.parenL.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">var </span><span class="s1">statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.context.push(statementParens ? types.p_stat : types.p_expr)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.incDec.updateContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s0">// tokExprAllowed stays unchanged</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1._function.updateContext = types$1._class.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">if </span><span class="s1">(prevType.beforeExpr &amp;&amp; prevType !== types$1._else &amp;&amp;</span>
      <span class="s1">!(prevType === types$1.semi &amp;&amp; </span><span class="s2">this</span><span class="s1">.curContext() !== types.p_stat) &amp;&amp;</span>
      <span class="s1">!(prevType === types$1._return &amp;&amp; lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.start))) &amp;&amp;</span>
      <span class="s1">!((prevType === types$1.colon || prevType === types$1.braceL) &amp;&amp; </span><span class="s2">this</span><span class="s1">.curContext() === types.b_stat))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context.push(types.f_expr)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context.push(types.f_stat)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.backQuote.updateContext = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.curContext() === types.q_tmpl)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context.pop()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context.push(types.q_tmpl)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.star.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">if </span><span class="s1">(prevType === types$1._function) {</span>
    <span class="s2">var </span><span class="s1">index = </span><span class="s2">this</span><span class="s1">.context.length - </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.context[index] === types.f_expr)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context[index] = types.f_expr_gen</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.context[index] = types.f_gen</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">types$1.name.updateContext = </span><span class="s2">function</span><span class="s1">(prevType) {</span>
  <span class="s2">var </span><span class="s1">allowed = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; prevType !== types$1.dot) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.value === </span><span class="s3">&quot;of&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.exprAllowed ||</span>
        <span class="s2">this</span><span class="s1">.value === </span><span class="s3">&quot;yield&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.inGeneratorContext())</span>
      <span class="s1">{ allowed = </span><span class="s2">true; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exprAllowed = allowed</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// A recursive descent parser operates by defining functions for all</span>

<span class="s2">var </span><span class="s1">pp$5 = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// Check if property name clashes with already added.</span>
<span class="s0">// Object/class getters and setters are not allowed to clash —</span>
<span class="s0">// either with each other or with an init property — and in</span>
<span class="s0">// strict mode, init properties are also not allowed to be repeated.</span>

<span class="s1">pp$5.checkPropClash = </span><span class="s2">function</span><span class="s1">(prop</span><span class="s2">, </span><span class="s1">propHash</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; prop.type === </span><span class="s3">&quot;SpreadElement&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; (prop.computed || prop.method || prop.shorthand))</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">key = prop.key</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">name</span><span class="s2">;</span>
  <span class="s2">switch </span><span class="s1">(key.type) {</span>
  <span class="s2">case </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">: name = key.name</span><span class="s2">; break</span>
  <span class="s2">case </span><span class="s3">&quot;Literal&quot;</span><span class="s1">: name = String(key.value)</span><span class="s2">; break</span>
  <span class="s2">default</span><span class="s1">: </span><span class="s2">return</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">kind = prop.kind</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(name === </span><span class="s3">&quot;__proto__&quot; </span><span class="s1">&amp;&amp; kind === </span><span class="s3">&quot;init&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(propHash.proto) {</span>
        <span class="s2">if </span><span class="s1">(refDestructuringErrors) {</span>
          <span class="s2">if </span><span class="s1">(refDestructuringErrors.doubleProto &lt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">refDestructuringErrors.doubleProto = key.start</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.raiseRecoverable(key.start</span><span class="s2">, </span><span class="s3">&quot;Redefinition of __proto__ property&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">propHash.proto = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">return</span>
  <span class="s1">}</span>
  <span class="s1">name = </span><span class="s3">&quot;$&quot; </span><span class="s1">+ name</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">other = propHash[name]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(other) {</span>
    <span class="s2">var </span><span class="s1">redefinition</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s3">&quot;init&quot;</span><span class="s1">) {</span>
      <span class="s1">redefinition = </span><span class="s2">this</span><span class="s1">.strict &amp;&amp; other.init || other.get || other.set</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">redefinition = other.init || other[kind]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(redefinition)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(key.start</span><span class="s2">, </span><span class="s3">&quot;Redefinition of property&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">other = propHash[name] = {</span>
      <span class="s1">init: </span><span class="s2">false,</span>
      <span class="s1">get: </span><span class="s2">false,</span>
      <span class="s1">set: </span><span class="s2">false</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">other[kind] = </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// ### Expression parsing</span>

<span class="s0">// These nest, from the most general expression type at the top to</span>
<span class="s0">// 'atomic', nondivisible expression types at the bottom. Most of</span>
<span class="s0">// the functions will simply let the function(s) below them parse,</span>
<span class="s0">// and, *if* the syntactic construct they handle is present, wrap</span>
<span class="s0">// the AST node that the inner parser gave them in another node.</span>

<span class="s0">// Parse a full expression. The optional arguments are used to</span>
<span class="s0">// forbid the `in` operator (in for loops initalization expressions)</span>
<span class="s0">// and provide reference for storing '=' operator inside shorthand</span>
<span class="s0">// property assignment in contexts where both object expression</span>
<span class="s0">// and object pattern might appear (so it's possible to raise</span>
<span class="s0">// delayed syntax error at correct position).</span>

<span class="s1">pp$5.parseExpression = </span><span class="s2">function</span><span class="s1">(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.comma) {</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node.expressions = [expr]</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.comma)) { node.expressions.push(</span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors))</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">expr</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse an assignment expression. This includes applications of</span>
<span class="s0">// operators like `+=`.</span>

<span class="s1">pp$5.parseMaybeAssign = </span><span class="s2">function</span><span class="s1">(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors</span><span class="s2">, </span><span class="s1">afterLeftParse) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;yield&quot;</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inGenerator) { </span><span class="s2">return this</span><span class="s1">.parseYield(forInit) }</span>
    <span class="s0">// The tokenizer will assume an expression is allowed after</span>
    <span class="s0">// `yield`, but this isn't that kind of yield</span>
    <span class="s2">else </span><span class="s1">{ </span><span class="s2">this</span><span class="s1">.exprAllowed = </span><span class="s2">false; </span><span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ownDestructuringErrors = </span><span class="s2">false, </span><span class="s1">oldParenAssign = -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">oldTrailingComma = -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">oldDoubleProto = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(refDestructuringErrors) {</span>
    <span class="s1">oldParenAssign = refDestructuringErrors.parenthesizedAssign</span><span class="s2">;</span>
    <span class="s1">oldTrailingComma = refDestructuringErrors.trailingComma</span><span class="s2">;</span>
    <span class="s1">oldDoubleProto = refDestructuringErrors.doubleProto</span><span class="s2">;</span>
    <span class="s1">refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">refDestructuringErrors = </span><span class="s2">new </span><span class="s1">DestructuringErrors</span><span class="s2">;</span>
    <span class="s1">ownDestructuringErrors = </span><span class="s2">true;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.parenL || </span><span class="s2">this</span><span class="s1">.type === types$1.name) {</span>
    <span class="s2">this</span><span class="s1">.potentialArrowAt = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.potentialArrowInForAwait = forInit === </span><span class="s3">&quot;await&quot;</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">left = </span><span class="s2">this</span><span class="s1">.parseMaybeConditional(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(afterLeftParse) { left = afterLeftParse.call(</span><span class="s2">this, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type.isAssign) {</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node.operator = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.eq)</span>
      <span class="s1">{ left = </span><span class="s2">this</span><span class="s1">.toAssignable(left</span><span class="s2">, false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!ownDestructuringErrors) {</span>
      <span class="s1">refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(refDestructuringErrors.shorthandAssign &gt;= left.start)</span>
      <span class="s1">{ refDestructuringErrors.shorthandAssign = -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// reset because shorthand default was used correctly</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.eq)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkLValPattern(left)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkLValSimple(left)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.left = left</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s1">node.right = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(oldDoubleProto &gt; -</span><span class="s4">1</span><span class="s1">) { refDestructuringErrors.doubleProto = oldDoubleProto</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(ownDestructuringErrors) { </span><span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(oldParenAssign &gt; -</span><span class="s4">1</span><span class="s1">) { refDestructuringErrors.parenthesizedAssign = oldParenAssign</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(oldTrailingComma &gt; -</span><span class="s4">1</span><span class="s1">) { refDestructuringErrors.trailingComma = oldTrailingComma</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">left</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse a ternary conditional (`?:`) operator.</span>

<span class="s1">pp$5.parseMaybeConditional = </span><span class="s2">function</span><span class="s1">(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseExprOps(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors)) { </span><span class="s2">return </span><span class="s1">expr }</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.question)) {</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node.test = expr</span><span class="s2">;</span>
    <span class="s1">node.consequent = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.expect(types$1.colon)</span><span class="s2">;</span>
    <span class="s1">node.alternate = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit)</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">expr</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Start the precedence parser.</span>

<span class="s1">pp$5.parseExprOps = </span><span class="s2">function</span><span class="s1">(forInit</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(refDestructuringErrors</span><span class="s2">, false, false, </span><span class="s1">forInit)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors)) { </span><span class="s2">return </span><span class="s1">expr }</span>
  <span class="s2">return </span><span class="s1">expr.start === startPos &amp;&amp; expr.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot; </span><span class="s1">? expr : </span><span class="s2">this</span><span class="s1">.parseExprOp(expr</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">forInit)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse binary operators with the operator precedence parsing</span>
<span class="s0">// algorithm. `left` is the left-hand side of the operator.</span>
<span class="s0">// `minPrec` provides context that allows the function to stop and</span>
<span class="s0">// defer further parser to one of its callers when it encounters an</span>
<span class="s0">// operator that has a lower precedence than the set it is parsing.</span>

<span class="s1">pp$5.parseExprOp = </span><span class="s2">function</span><span class="s1">(left</span><span class="s2">, </span><span class="s1">leftStartPos</span><span class="s2">, </span><span class="s1">leftStartLoc</span><span class="s2">, </span><span class="s1">minPrec</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">prec = </span><span class="s2">this</span><span class="s1">.type.binop</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(prec != </span><span class="s2">null </span><span class="s1">&amp;&amp; (!forInit || </span><span class="s2">this</span><span class="s1">.type !== types$1._in)) {</span>
    <span class="s2">if </span><span class="s1">(prec &gt; minPrec) {</span>
      <span class="s2">var </span><span class="s1">logical = </span><span class="s2">this</span><span class="s1">.type === types$1.logicalOR || </span><span class="s2">this</span><span class="s1">.type === types$1.logicalAND</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">coalesce = </span><span class="s2">this</span><span class="s1">.type === types$1.coalesce</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(coalesce) {</span>
        <span class="s0">// Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.</span>
        <span class="s0">// In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.</span>
        <span class="s1">prec = types$1.logicalAND.binop</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">op = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">right = </span><span class="s2">this</span><span class="s1">.parseExprOp(</span><span class="s2">this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null, false, false, </span><span class="s1">forInit)</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">prec</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.buildBinary(leftStartPos</span><span class="s2">, </span><span class="s1">leftStartLoc</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">logical || coalesce)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">((logical &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.coalesce) || (coalesce &amp;&amp; (</span><span class="s2">this</span><span class="s1">.type === types$1.logicalOR || </span><span class="s2">this</span><span class="s1">.type === types$1.logicalAND))) {</span>
        <span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.parseExprOp(node</span><span class="s2">, </span><span class="s1">leftStartPos</span><span class="s2">, </span><span class="s1">leftStartLoc</span><span class="s2">, </span><span class="s1">minPrec</span><span class="s2">, </span><span class="s1">forInit)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">left</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.buildBinary = </span><span class="s2">function</span><span class="s1">(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">logical) {</span>
  <span class="s2">if </span><span class="s1">(right.type === </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(right.start</span><span class="s2">, </span><span class="s3">&quot;Private identifier can only be left side of binary expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
  <span class="s1">node.left = left</span><span class="s2">;</span>
  <span class="s1">node.operator = op</span><span class="s2">;</span>
  <span class="s1">node.right = right</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">logical ? </span><span class="s3">&quot;LogicalExpression&quot; </span><span class="s1">: </span><span class="s3">&quot;BinaryExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse unary operators, both prefix and postfix.</span>

<span class="s1">pp$5.parseMaybeUnary = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors</span><span class="s2">, </span><span class="s1">sawUnary</span><span class="s2">, </span><span class="s1">incDec</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isContextual(</span><span class="s3">&quot;await&quot;</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.canAwait) {</span>
    <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseAwait(forInit)</span><span class="s2">;</span>
    <span class="s1">sawUnary = </span><span class="s2">true;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type.prefix) {</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">update = </span><span class="s2">this</span><span class="s1">.type === types$1.incDec</span><span class="s2">;</span>
    <span class="s1">node.operator = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s1">node.prefix = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null, true, </span><span class="s1">update</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(update) { </span><span class="s2">this</span><span class="s1">.checkLValSimple(node.argument)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict &amp;&amp; node.operator === </span><span class="s3">&quot;delete&quot; </span><span class="s1">&amp;&amp;</span>
             <span class="s1">node.argument.type === </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;Deleting local variable in strict mode&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(node.operator === </span><span class="s3">&quot;delete&quot; </span><span class="s1">&amp;&amp; isPrivateFieldAccess(node.argument))</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;Private fields can not be deleted&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{ sawUnary = </span><span class="s2">true; </span><span class="s1">}</span>
    <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">update ? </span><span class="s3">&quot;UpdateExpression&quot; </span><span class="s1">: </span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!sawUnary &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.privateId) {</span>
    <span class="s2">if </span><span class="s1">(forInit || </span><span class="s2">this</span><span class="s1">.privateNameStack.length === </span><span class="s4">0</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parsePrivateIdent()</span><span class="s2">;</span>
    <span class="s0">// only could be private fields in 'in', such as #x in obj</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1._in) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseExprSubscripts(refDestructuringErrors</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors)) { </span><span class="s2">return </span><span class="s1">expr }</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type.postfix &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
      <span class="s2">var </span><span class="s1">node$1 = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
      <span class="s1">node$1.operator = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
      <span class="s1">node$1.prefix = </span><span class="s2">false;</span>
      <span class="s1">node$1.argument = expr</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.checkLValSimple(expr)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s1">expr = </span><span class="s2">this</span><span class="s1">.finishNode(node$1</span><span class="s2">, </span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!incDec &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.starstar)) {</span>
    <span class="s2">if </span><span class="s1">(sawUnary)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">this</span><span class="s1">.lastTokStart)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else</span>
      <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.buildBinary(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">, this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null, false, false, </span><span class="s1">forInit)</span><span class="s2">, </span><span class="s3">&quot;**&quot;</span><span class="s2">, false</span><span class="s1">) }</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">expr</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">isPrivateFieldAccess(node) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">node.type === </span><span class="s3">&quot;MemberExpression&quot; </span><span class="s1">&amp;&amp; node.property.type === </span><span class="s3">&quot;PrivateIdentifier&quot; </span><span class="s1">||</span>
    <span class="s1">node.type === </span><span class="s3">&quot;ChainExpression&quot; </span><span class="s1">&amp;&amp; isPrivateFieldAccess(node.expression)</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// Parse call, dot, and `[]`-subscript expressions.</span>

<span class="s1">pp$5.parseExprSubscripts = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseExprAtom(refDestructuringErrors</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(expr.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokStart</span><span class="s2">, this</span><span class="s1">.lastTokEnd) !== </span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">return </span><span class="s1">expr }</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.parseSubscripts(expr</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, false, </span><span class="s1">forInit)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(refDestructuringErrors &amp;&amp; result.type === </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(refDestructuringErrors.trailingComma &gt;= result.start) { refDestructuringErrors.trailingComma = -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseSubscripts = </span><span class="s2">function</span><span class="s1">(base</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">noCalls</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">maybeAsyncArrow = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; base.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; base.name === </span><span class="s3">&quot;async&quot; </span><span class="s1">&amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.lastTokEnd === base.end &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() &amp;&amp; base.end - base.start === </span><span class="s4">5 </span><span class="s1">&amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.potentialArrowAt === base.start</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">optionalChained = </span><span class="s2">false;</span>

  <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">element = </span><span class="s2">this</span><span class="s1">.parseSubscript(base</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">noCalls</span><span class="s2">, </span><span class="s1">maybeAsyncArrow</span><span class="s2">, </span><span class="s1">optionalChained</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(element.optional) { optionalChained = </span><span class="s2">true; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(element === base || element.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(optionalChained) {</span>
        <span class="s2">var </span><span class="s1">chainNode = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
        <span class="s1">chainNode.expression = element</span><span class="s2">;</span>
        <span class="s1">element = </span><span class="s2">this</span><span class="s1">.finishNode(chainNode</span><span class="s2">, </span><span class="s3">&quot;ChainExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">element</span>
    <span class="s1">}</span>

    <span class="s1">base = element</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseSubscript = </span><span class="s2">function</span><span class="s1">(base</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">noCalls</span><span class="s2">, </span><span class="s1">maybeAsyncArrow</span><span class="s2">, </span><span class="s1">optionalChained</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">optionalSupported = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">optional = optionalSupported &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.questionDot)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(noCalls &amp;&amp; optional) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.lastTokStart</span><span class="s2">, </span><span class="s3">&quot;Optional chaining cannot appear in the callee of new expressions&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">computed = </span><span class="s2">this</span><span class="s1">.eat(types$1.bracketL)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(computed || (optional &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.parenL &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.backQuote) || </span><span class="s2">this</span><span class="s1">.eat(types$1.dot)) {</span>
    <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node.object = base</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(computed) {</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.bracketR)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.privateId &amp;&amp; base.type !== </span><span class="s3">&quot;Super&quot;</span><span class="s1">) {</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parsePrivateIdent()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">this</span><span class="s1">.options.allowReserved !== </span><span class="s3">&quot;never&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">node.computed = !!computed</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(optionalSupported) {</span>
      <span class="s1">node.optional = optional</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">base = </span><span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!noCalls &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.parenL)) {</span>
    <span class="s2">var </span><span class="s1">refDestructuringErrors = </span><span class="s2">new </span><span class="s1">DestructuringErrors</span><span class="s2">, </span><span class="s1">oldYieldPos = </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s1">oldAwaitPos = </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s1">oldAwaitIdentPos = </span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitIdentPos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">exprList = </span><span class="s2">this</span><span class="s1">.parseExprList(types$1.parenR</span><span class="s2">, this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s2">, false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(maybeAsyncArrow &amp;&amp; !optional &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.arrow)) {</span>
      <span class="s2">this</span><span class="s1">.checkPatternErrors(refDestructuringErrors</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.checkYieldAwaitInDefaultParams()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.awaitIdentPos &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'await' as identifier inside an async function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.awaitIdentPos = oldAwaitIdentPos</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.parseArrowExpression(</span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">, </span><span class="s1">exprList</span><span class="s2">, true, </span><span class="s1">forInit)</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos || </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos || </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitIdentPos = oldAwaitIdentPos || </span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">node$1 = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node$1.callee = base</span><span class="s2">;</span>
    <span class="s1">node$1.arguments = exprList</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(optionalSupported) {</span>
      <span class="s1">node$1.optional = optional</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">base = </span><span class="s2">this</span><span class="s1">.finishNode(node$1</span><span class="s2">, </span><span class="s3">&quot;CallExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.backQuote) {</span>
    <span class="s2">if </span><span class="s1">(optional || optionalChained) {</span>
      <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Optional chaining cannot appear in the tag of tagged template expressions&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">node$2 = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">node$2.tag = base</span><span class="s2">;</span>
    <span class="s1">node$2.quasi = </span><span class="s2">this</span><span class="s1">.parseTemplate({isTagged: </span><span class="s2">true</span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">base = </span><span class="s2">this</span><span class="s1">.finishNode(node$2</span><span class="s2">, </span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">base</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse an atomic expression — either a single token that is an</span>
<span class="s0">// expression, an expression started by a keyword like `function` or</span>
<span class="s0">// `new`, or an expression wrapped in punctuation like `()`, `[]`,</span>
<span class="s0">// or `{}`.</span>

<span class="s1">pp$5.parseExprAtom = </span><span class="s2">function</span><span class="s1">(refDestructuringErrors</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s0">// If a division operator appears in an expression position, the</span>
  <span class="s0">// tokenizer got confused, and we force it to read a regexp instead.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.slash) { </span><span class="s2">this</span><span class="s1">.readRegexp()</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">node</span><span class="s2">, </span><span class="s1">canBeArrow = </span><span class="s2">this</span><span class="s1">.potentialArrowAt === </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
  <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type) {</span>
  <span class="s2">case </span><span class="s1">types$1._super:</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.allowSuper)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;'super' keyword outside a method&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.parenL &amp;&amp; !</span><span class="s2">this</span><span class="s1">.allowDirectSuper)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s3">&quot;super() call outside constructor of a subclass&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s0">// The `super` keyword can appear at below:</span>
    <span class="s0">// SuperProperty:</span>
    <span class="s0">//     super [ Expression ]</span>
    <span class="s0">//     super . IdentifierName</span>
    <span class="s0">// SuperCall:</span>
    <span class="s0">//     super ( Arguments )</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.dot &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.bracketL &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.parenL)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;Super&quot;</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1._this:</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ThisExpression&quot;</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1.name:</span>
    <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">, </span><span class="s1">containsEsc = </span><span class="s2">this</span><span class="s1">.containsEsc</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">id = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; !containsEsc &amp;&amp; id.name === </span><span class="s3">&quot;async&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1._function)) {</span>
      <span class="s2">this</span><span class="s1">.overrideContext(types.f_expr)</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.parseFunction(</span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, false, true, </span><span class="s1">forInit)</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(canBeArrow &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon()) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.arrow))</span>
        <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.parseArrowExpression(</span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">, </span><span class="s1">[id]</span><span class="s2">, false, </span><span class="s1">forInit) }</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; id.name === </span><span class="s3">&quot;async&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.name &amp;&amp; !containsEsc &amp;&amp;</span>
          <span class="s1">(!</span><span class="s2">this</span><span class="s1">.potentialArrowInForAwait || </span><span class="s2">this</span><span class="s1">.value !== </span><span class="s3">&quot;of&quot; </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.containsEsc)) {</span>
        <span class="s1">id = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() || !</span><span class="s2">this</span><span class="s1">.eat(types$1.arrow))</span>
          <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.parseArrowExpression(</span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">, </span><span class="s1">[id]</span><span class="s2">, true, </span><span class="s1">forInit)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">id</span>

  <span class="s2">case </span><span class="s1">types$1.regexp:</span>
    <span class="s2">var </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.parseLiteral(value.value)</span><span class="s2">;</span>
    <span class="s1">node.regex = {pattern: value.pattern</span><span class="s2">, </span><span class="s1">flags: value.flags}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">node</span>

  <span class="s2">case </span><span class="s1">types$1.num: </span><span class="s2">case </span><span class="s1">types$1.string:</span>
    <span class="s2">return this</span><span class="s1">.parseLiteral(</span><span class="s2">this</span><span class="s1">.value)</span>

  <span class="s2">case </span><span class="s1">types$1._null: </span><span class="s2">case </span><span class="s1">types$1._true: </span><span class="s2">case </span><span class="s1">types$1._false:</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.type === types$1._null ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.type === types$1._true</span><span class="s2">;</span>
    <span class="s1">node.raw = </span><span class="s2">this</span><span class="s1">.type.keyword</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;Literal&quot;</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1.parenL:</span>
    <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">expr = </span><span class="s2">this</span><span class="s1">.parseParenAndDistinguishExpression(canBeArrow</span><span class="s2">, </span><span class="s1">forInit)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(refDestructuringErrors) {</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors.parenthesizedAssign &lt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.isSimpleAssignTarget(expr))</span>
        <span class="s1">{ refDestructuringErrors.parenthesizedAssign = start</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors.parenthesizedBind &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">{ refDestructuringErrors.parenthesizedBind = start</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expr</span>

  <span class="s2">case </span><span class="s1">types$1.bracketL:</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s1">node.elements = </span><span class="s2">this</span><span class="s1">.parseExprList(types$1.bracketR</span><span class="s2">, true, true, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1.braceL:</span>
    <span class="s2">this</span><span class="s1">.overrideContext(types.b_expr)</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.parseObj(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors)</span>

  <span class="s2">case </span><span class="s1">types$1._function:</span>
    <span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.parseFunction(node</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1._class:</span>
    <span class="s2">return this</span><span class="s1">.parseClass(</span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, false</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s1">types$1._new:</span>
    <span class="s2">return this</span><span class="s1">.parseNew()</span>

  <span class="s2">case </span><span class="s1">types$1.backQuote:</span>
    <span class="s2">return this</span><span class="s1">.parseTemplate()</span>

  <span class="s2">case </span><span class="s1">types$1._import:</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s1">) {</span>
      <span class="s2">return this</span><span class="s1">.parseExprImport()</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return this</span><span class="s1">.unexpected()</span>
    <span class="s1">}</span>

  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseExprImport = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>

  <span class="s0">// Consume `import` as an identifier for `import.meta`.</span>
  <span class="s0">// Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.containsEsc) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Escape sequence in keyword import&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">meta = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type) {</span>
  <span class="s2">case </span><span class="s1">types$1.parenL:</span>
    <span class="s2">return this</span><span class="s1">.parseDynamicImport(node)</span>
  <span class="s2">case </span><span class="s1">types$1.dot:</span>
    <span class="s1">node.meta = meta</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.parseImportMeta(node)</span>
  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseDynamicImport = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s0">// skip `(`</span>

  <span class="s0">// Parse node.source.</span>
  <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>

  <span class="s0">// Verify ending.</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.parenR)) {</span>
    <span class="s2">var </span><span class="s1">errorPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.comma) &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.parenR)) {</span>
      <span class="s2">this</span><span class="s1">.raiseRecoverable(errorPos</span><span class="s2">, </span><span class="s3">&quot;Trailing comma is not allowed in import()&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.unexpected(errorPos)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseImportMeta = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s0">// skip `.`</span>

  <span class="s2">var </span><span class="s1">containsEsc = </span><span class="s2">this</span><span class="s1">.containsEsc</span><span class="s2">;</span>
  <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(node.property.name !== </span><span class="s3">&quot;meta&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.property.start</span><span class="s2">, </span><span class="s3">&quot;The only valid meta property for import is 'import.meta'&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(containsEsc)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;'import.meta' must not contain escaped characters&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.sourceType !== </span><span class="s3">&quot;module&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.allowImportExportEverywhere)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'import.meta' outside a module&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;MetaProperty&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseLiteral = </span><span class="s2">function</span><span class="s1">(value) {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s1">node.value = value</span><span class="s2">;</span>
  <span class="s1">node.raw = </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(node.raw.charCodeAt(node.raw.length - </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">110</span><span class="s1">) { node.bigint = node.raw.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">).replace(</span><span class="s4">/_/g</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;Literal&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseParenExpression = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenL)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">.parseExpression()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.expect(types$1.parenR)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">val</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseParenAndDistinguishExpression = </span><span class="s2">function</span><span class="s1">(canBeArrow</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">allowTrailingComma = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>

    <span class="s2">var </span><span class="s1">innerStartPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">innerStartLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">exprList = []</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true, </span><span class="s1">lastIsComma = </span><span class="s2">false;</span>
    <span class="s2">var </span><span class="s1">refDestructuringErrors = </span><span class="s2">new </span><span class="s1">DestructuringErrors</span><span class="s2">, </span><span class="s1">oldYieldPos = </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s1">oldAwaitPos = </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s1">spreadStart</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s0">// Do not save awaitIdentPos to allow checking awaits nested in parameters</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.parenR) {</span>
      <span class="s1">first ? first = </span><span class="s2">false </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(allowTrailingComma &amp;&amp; </span><span class="s2">this</span><span class="s1">.afterTrailingComma(types$1.parenR</span><span class="s2">, true</span><span class="s1">)) {</span>
        <span class="s1">lastIsComma = </span><span class="s2">true;</span>
        <span class="s2">break</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.ellipsis) {</span>
        <span class="s1">spreadStart = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
        <span class="s1">exprList.push(</span><span class="s2">this</span><span class="s1">.parseParenItem(</span><span class="s2">this</span><span class="s1">.parseRestBinding()))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.comma) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Comma is not permitted after the rest element&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s2">break</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">exprList.push(</span><span class="s2">this</span><span class="s1">.parseMaybeAssign(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors</span><span class="s2">, this</span><span class="s1">.parseParenItem))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">innerEndPos = </span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, </span><span class="s1">innerEndLoc = </span><span class="s2">this</span><span class="s1">.lastTokEndLoc</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.expect(types$1.parenR)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(canBeArrow &amp;&amp; !</span><span class="s2">this</span><span class="s1">.canInsertSemicolon() &amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.arrow)) {</span>
      <span class="s2">this</span><span class="s1">.checkPatternErrors(refDestructuringErrors</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.checkYieldAwaitInDefaultParams()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.parseParenArrowList(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">exprList</span><span class="s2">, </span><span class="s1">forInit)</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!exprList.length || lastIsComma) { </span><span class="s2">this</span><span class="s1">.unexpected(</span><span class="s2">this</span><span class="s1">.lastTokStart)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(spreadStart) { </span><span class="s2">this</span><span class="s1">.unexpected(spreadStart)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.checkExpressionErrors(refDestructuringErrors</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos || </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos || </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(exprList.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">val = </span><span class="s2">this</span><span class="s1">.startNodeAt(innerStartPos</span><span class="s2">, </span><span class="s1">innerStartLoc)</span><span class="s2">;</span>
      <span class="s1">val.expressions = exprList</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.finishNodeAt(val</span><span class="s2">, </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s2">, </span><span class="s1">innerEndPos</span><span class="s2">, </span><span class="s1">innerEndLoc)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">val = exprList[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">val = </span><span class="s2">this</span><span class="s1">.parseParenExpression()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.preserveParens) {</span>
    <span class="s2">var </span><span class="s1">par = </span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">;</span>
    <span class="s1">par.expression = val</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishNode(par</span><span class="s2">, </span><span class="s3">&quot;ParenthesizedExpression&quot;</span><span class="s1">)</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">val</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseParenItem = </span><span class="s2">function</span><span class="s1">(item) {</span>
  <span class="s2">return </span><span class="s1">item</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseParenArrowList = </span><span class="s2">function</span><span class="s1">(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">exprList</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">return this</span><span class="s1">.parseArrowExpression(</span><span class="s2">this</span><span class="s1">.startNodeAt(startPos</span><span class="s2">, </span><span class="s1">startLoc)</span><span class="s2">, </span><span class="s1">exprList</span><span class="s2">, false, </span><span class="s1">forInit)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// New's precedence is slightly tricky. It must allow its argument to</span>
<span class="s0">// be a `[]` or dot subscript expression, but not a call — at least,</span>
<span class="s0">// not without wrapping it in parentheses. Thus, it uses the noCalls</span>
<span class="s0">// argument to parseSubscripts to prevent it from consuming the</span>
<span class="s0">// argument list.</span>

<span class="s2">var </span><span class="s1">empty = []</span><span class="s2">;</span>

<span class="s1">pp$5.parseNew = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.containsEsc) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Escape sequence in keyword new&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">meta = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.dot)) {</span>
    <span class="s1">node.meta = meta</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">containsEsc = </span><span class="s2">this</span><span class="s1">.containsEsc</span><span class="s2">;</span>
    <span class="s1">node.property = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.property.name !== </span><span class="s3">&quot;target&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.property.start</span><span class="s2">, </span><span class="s3">&quot;The only valid meta property for new is 'new.target'&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(containsEsc)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;'new.target' must not contain escaped characters&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.allowNewDotTarget)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;'new.target' can only be used in functions and class static block&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;MetaProperty&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">, </span><span class="s1">isImport = </span><span class="s2">this</span><span class="s1">.type === types$1._import</span><span class="s2">;</span>
  <span class="s1">node.callee = </span><span class="s2">this</span><span class="s1">.parseSubscripts(</span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isImport &amp;&amp; node.callee.type === </span><span class="s3">&quot;ImportExpression&quot;</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.raise(startPos</span><span class="s2">, </span><span class="s3">&quot;Cannot use new with import()&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.parenL)) { node.arguments = </span><span class="s2">this</span><span class="s1">.parseExprList(types$1.parenR</span><span class="s2">, this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">else </span><span class="s1">{ node.arguments = empty</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;NewExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse template expression.</span>

<span class="s1">pp$5.parseTemplateElement = </span><span class="s2">function</span><span class="s1">(ref) {</span>
  <span class="s2">var </span><span class="s1">isTagged = ref.isTagged</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.invalidTemplate) {</span>
    <span class="s2">if </span><span class="s1">(!isTagged) {</span>
      <span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Bad escape sequence in untagged template literal&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">elem.value = {</span>
      <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">,</span>
      <span class="s1">cooked: </span><span class="s2">null</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">elem.value = {</span>
      <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.end).replace(</span><span class="s4">/\r\n?/g</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">cooked: </span><span class="s2">this</span><span class="s1">.value</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">elem.tail = </span><span class="s2">this</span><span class="s1">.type === types$1.backQuote</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(elem</span><span class="s2">, </span><span class="s3">&quot;TemplateElement&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseTemplate = </span><span class="s2">function</span><span class="s1">(ref) {</span>
  <span class="s2">if </span><span class="s1">( ref === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) ref = {}</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">isTagged = ref.isTagged</span><span class="s2">; if </span><span class="s1">( isTagged === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) isTagged = </span><span class="s2">false;</span>

  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.expressions = []</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">curElt = </span><span class="s2">this</span><span class="s1">.parseTemplateElement({isTagged: isTagged})</span><span class="s2">;</span>
  <span class="s1">node.quasis = [curElt]</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(!curElt.tail) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.eof) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Unterminated template literal&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.expect(types$1.dollarBraceL)</span><span class="s2">;</span>
    <span class="s1">node.expressions.push(</span><span class="s2">this</span><span class="s1">.parseExpression())</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.expect(types$1.braceR)</span><span class="s2">;</span>
    <span class="s1">node.quasis.push(curElt = </span><span class="s2">this</span><span class="s1">.parseTemplateElement({isTagged: isTagged}))</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.isAsyncProp = </span><span class="s2">function</span><span class="s1">(prop) {</span>
  <span class="s2">return </span><span class="s1">!prop.computed &amp;&amp; prop.key.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; prop.key.name === </span><span class="s3">&quot;async&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.name || </span><span class="s2">this</span><span class="s1">.type === types$1.num || </span><span class="s2">this</span><span class="s1">.type === types$1.string || </span><span class="s2">this</span><span class="s1">.type === types$1.bracketL || </span><span class="s2">this</span><span class="s1">.type.keyword || (</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.star)) &amp;&amp;</span>
    <span class="s1">!lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.start))</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse an object literal or binding pattern.</span>

<span class="s1">pp$5.parseObj = </span><span class="s2">function</span><span class="s1">(isPattern</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true, </span><span class="s1">propHash = {}</span><span class="s2">;</span>
  <span class="s1">node.properties = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(types$1.braceR)) {</span>
    <span class="s2">if </span><span class="s1">(!first) {</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">5 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.afterTrailingComma(types$1.braceR)) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ first = </span><span class="s2">false; </span><span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prop = </span><span class="s2">this</span><span class="s1">.parseProperty(isPattern</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isPattern) { </span><span class="s2">this</span><span class="s1">.checkPropClash(prop</span><span class="s2">, </span><span class="s1">propHash</span><span class="s2">, </span><span class="s1">refDestructuringErrors)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.properties.push(prop)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s1">isPattern ? </span><span class="s3">&quot;ObjectPattern&quot; </span><span class="s1">: </span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseProperty = </span><span class="s2">function</span><span class="s1">(isPattern</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">prop = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.ellipsis)) {</span>
    <span class="s2">if </span><span class="s1">(isPattern) {</span>
      <span class="s1">prop.argument = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.comma) {</span>
        <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Comma is not permitted after the rest element&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.finishNode(prop</span><span class="s2">, </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s0">// Parse argument.</span>
    <span class="s1">prop.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s0">// To disallow trailing comma via `this.toAssignable()`.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.comma &amp;&amp; refDestructuringErrors &amp;&amp; refDestructuringErrors.trailingComma &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">refDestructuringErrors.trailingComma = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Finish</span>
    <span class="s2">return this</span><span class="s1">.finishNode(prop</span><span class="s2">, </span><span class="s3">&quot;SpreadElement&quot;</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s1">prop.method = </span><span class="s2">false;</span>
    <span class="s1">prop.shorthand = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(isPattern || refDestructuringErrors) {</span>
      <span class="s1">startPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
      <span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isPattern)</span>
      <span class="s1">{ isGenerator = </span><span class="s2">this</span><span class="s1">.eat(types$1.star)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">containsEsc = </span><span class="s2">this</span><span class="s1">.containsEsc</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parsePropertyName(prop)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!isPattern &amp;&amp; !containsEsc &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8 </span><span class="s1">&amp;&amp; !isGenerator &amp;&amp; </span><span class="s2">this</span><span class="s1">.isAsyncProp(prop)) {</span>
    <span class="s1">isAsync = </span><span class="s2">true;</span>
    <span class="s1">isGenerator = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.eat(types$1.star)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parsePropertyName(prop)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">isAsync = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.parsePropertyValue(prop</span><span class="s2">, </span><span class="s1">isPattern</span><span class="s2">, </span><span class="s1">isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">refDestructuringErrors</span><span class="s2">, </span><span class="s1">containsEsc)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(prop</span><span class="s2">, </span><span class="s3">&quot;Property&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parsePropertyValue = </span><span class="s2">function</span><span class="s1">(prop</span><span class="s2">, </span><span class="s1">isPattern</span><span class="s2">, </span><span class="s1">isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, </span><span class="s1">refDestructuringErrors</span><span class="s2">, </span><span class="s1">containsEsc) {</span>
  <span class="s2">if </span><span class="s1">((isGenerator || isAsync) &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.colon)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.colon)) {</span>
    <span class="s1">prop.value = isPattern ? </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.startLoc) : </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s1">prop.kind = </span><span class="s3">&quot;init&quot;</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.parenL) {</span>
    <span class="s2">if </span><span class="s1">(isPattern) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">prop.kind = </span><span class="s3">&quot;init&quot;</span><span class="s2">;</span>
    <span class="s1">prop.method = </span><span class="s2">true;</span>
    <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMethod(isGenerator</span><span class="s2">, </span><span class="s1">isAsync)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isPattern &amp;&amp; !containsEsc &amp;&amp;</span>
             <span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">5 </span><span class="s1">&amp;&amp; !prop.computed &amp;&amp; prop.key.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s1">&amp;&amp;</span>
             <span class="s1">(prop.key.name === </span><span class="s3">&quot;get&quot; </span><span class="s1">|| prop.key.name === </span><span class="s3">&quot;set&quot;</span><span class="s1">) &amp;&amp;</span>
             <span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== types$1.comma &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.braceR &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.eq)) {</span>
    <span class="s2">if </span><span class="s1">(isGenerator || isAsync) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">prop.kind = prop.key.name</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parsePropertyName(prop)</span><span class="s2">;</span>
    <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMethod(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">var </span><span class="s1">paramCount = prop.kind === </span><span class="s3">&quot;get&quot; </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prop.value.params.length !== paramCount) {</span>
      <span class="s2">var </span><span class="s1">start = prop.value.start</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(prop.kind === </span><span class="s3">&quot;get&quot;</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;getter should have no params&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">else</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;setter should have exactly one param&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(prop.kind === </span><span class="s3">&quot;set&quot; </span><span class="s1">&amp;&amp; prop.value.params[</span><span class="s4">0</span><span class="s1">].type === </span><span class="s3">&quot;RestElement&quot;</span><span class="s1">)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(prop.value.params[</span><span class="s4">0</span><span class="s1">].start</span><span class="s2">, </span><span class="s3">&quot;Setter cannot use rest params&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; !prop.computed &amp;&amp; prop.key.type === </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(isGenerator || isAsync) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.checkUnreserved(prop.key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prop.key.name === </span><span class="s3">&quot;await&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.awaitIdentPos)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.awaitIdentPos = startPos</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">prop.kind = </span><span class="s3">&quot;init&quot;</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isPattern) {</span>
      <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, this</span><span class="s1">.copyNode(prop.key))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.eq &amp;&amp; refDestructuringErrors) {</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors.shorthandAssign &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">{ refDestructuringErrors.shorthandAssign = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.parseMaybeDefault(startPos</span><span class="s2">, </span><span class="s1">startLoc</span><span class="s2">, this</span><span class="s1">.copyNode(prop.key))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">prop.value = </span><span class="s2">this</span><span class="s1">.copyNode(prop.key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">prop.shorthand = </span><span class="s2">true;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{ </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parsePropertyName = </span><span class="s2">function</span><span class="s1">(prop) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(types$1.bracketL)) {</span>
      <span class="s1">prop.computed = </span><span class="s2">true;</span>
      <span class="s1">prop.key = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.bracketR)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">prop.key</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">prop.computed = </span><span class="s2">false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">prop.key = </span><span class="s2">this</span><span class="s1">.type === types$1.num || </span><span class="s2">this</span><span class="s1">.type === types$1.string ? </span><span class="s2">this</span><span class="s1">.parseExprAtom() : </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">this</span><span class="s1">.options.allowReserved !== </span><span class="s3">&quot;never&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Initialize empty function node.</span>

<span class="s1">pp$5.initFunction = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s1">node.id = </span><span class="s2">null;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) { node.generator = node.expression = </span><span class="s2">false; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">) { node.async = </span><span class="s2">false; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse object or class method.</span>

<span class="s1">pp$5.parseMethod = </span><span class="s2">function</span><span class="s1">(isGenerator</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">allowDirectSuper) {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">, </span><span class="s1">oldYieldPos = </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s1">oldAwaitPos = </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s1">oldAwaitIdentPos = </span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.initFunction(node)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">{ node.generator = isGenerator</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">{ node.async = !!isAsync</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.enterScope(functionFlags(isAsync</span><span class="s2">, </span><span class="s1">node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : </span><span class="s4">0</span><span class="s1">))</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.expect(types$1.parenL)</span><span class="s2">;</span>
  <span class="s1">node.params = </span><span class="s2">this</span><span class="s1">.parseBindingList(types$1.parenR</span><span class="s2">, false, this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.checkYieldAwaitInDefaultParams()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parseFunctionBody(node</span><span class="s2">, false, true, false</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = oldAwaitIdentPos</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse arrow function expression with given parameters.</span>

<span class="s1">pp$5.parseArrowExpression = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">isAsync</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">oldYieldPos = </span><span class="s2">this</span><span class="s1">.yieldPos</span><span class="s2">, </span><span class="s1">oldAwaitPos = </span><span class="s2">this</span><span class="s1">.awaitPos</span><span class="s2">, </span><span class="s1">oldAwaitIdentPos = </span><span class="s2">this</span><span class="s1">.awaitIdentPos</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.enterScope(functionFlags(isAsync</span><span class="s2">, false</span><span class="s1">) | SCOPE_ARROW)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.initFunction(node)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">8</span><span class="s1">) { node.async = !!isAsync</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = </span><span class="s4">0</span><span class="s2">;</span>

  <span class="s1">node.params = </span><span class="s2">this</span><span class="s1">.toAssignableList(params</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.parseFunctionBody(node</span><span class="s2">, true, false, </span><span class="s1">forInit)</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.yieldPos = oldYieldPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitPos = oldAwaitPos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.awaitIdentPos = oldAwaitIdentPos</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse function body and check parameters.</span>

<span class="s1">pp$5.parseFunctionBody = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">isArrowFunction</span><span class="s2">, </span><span class="s1">isMethod</span><span class="s2">, </span><span class="s1">forInit) {</span>
  <span class="s2">var </span><span class="s1">isExpression = isArrowFunction &amp;&amp; </span><span class="s2">this</span><span class="s1">.type !== types$1.braceL</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">oldStrict = </span><span class="s2">this</span><span class="s1">.strict</span><span class="s2">, </span><span class="s1">useStrict = </span><span class="s2">false;</span>

  <span class="s2">if </span><span class="s1">(isExpression) {</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit)</span><span class="s2">;</span>
    <span class="s1">node.expression = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.checkParams(node</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">var </span><span class="s1">nonSimple = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">7 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.isSimpleParamList(node.params)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!oldStrict || nonSimple) {</span>
      <span class="s1">useStrict = </span><span class="s2">this</span><span class="s1">.strictDirective(</span><span class="s2">this</span><span class="s1">.end)</span><span class="s2">;</span>
      <span class="s0">// If this is a strict mode function, verify that argument names</span>
      <span class="s0">// are not repeated, and it does not try to bind the words `eval`</span>
      <span class="s0">// or `arguments`.</span>
      <span class="s2">if </span><span class="s1">(useStrict &amp;&amp; nonSimple)</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(node.start</span><span class="s2">, </span><span class="s3">&quot;Illegal 'use strict' directive in function with non-simple parameter list&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// Start a new scope with regard to labels and the `inFunction`</span>
    <span class="s0">// flag (restore them to their old value afterwards).</span>
    <span class="s2">var </span><span class="s1">oldLabels = </span><span class="s2">this</span><span class="s1">.labels</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.labels = []</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(useStrict) { </span><span class="s2">this</span><span class="s1">.strict = </span><span class="s2">true; </span><span class="s1">}</span>

    <span class="s0">// Add the params to varDeclaredNames to ensure that an error is thrown</span>
    <span class="s0">// if a let/const declaration in the function clashes with one of the params.</span>
    <span class="s2">this</span><span class="s1">.checkParams(node</span><span class="s2">, </span><span class="s1">!oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; !isMethod &amp;&amp; </span><span class="s2">this</span><span class="s1">.isSimpleParamList(node.params))</span><span class="s2">;</span>
    <span class="s0">// Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict &amp;&amp; node.id) { </span><span class="s2">this</span><span class="s1">.checkLValSimple(node.id</span><span class="s2">, </span><span class="s1">BIND_OUTSIDE)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">node.body = </span><span class="s2">this</span><span class="s1">.parseBlock(</span><span class="s2">false, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">useStrict &amp;&amp; !oldStrict)</span><span class="s2">;</span>
    <span class="s1">node.expression = </span><span class="s2">false;</span>
    <span class="s2">this</span><span class="s1">.adaptDirectivePrologue(node.body.body)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.labels = oldLabels</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.exitScope()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.isSimpleParamList = </span><span class="s2">function</span><span class="s1">(params) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = params</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">param = list[i]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(param.type !== </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">) { </span><span class="s2">return false</span>
  <span class="s1">} }</span>
  <span class="s2">return true</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Checks function params for various disallowed patterns such as using &quot;eval&quot;</span>
<span class="s0">// or &quot;arguments&quot; and duplicate parameters.</span>

<span class="s1">pp$5.checkParams = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">allowDuplicates) {</span>
  <span class="s2">var </span><span class="s1">nameHash = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.params</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">{</span>
    <span class="s2">var </span><span class="s1">param = list[i]</span><span class="s2">;</span>

    <span class="s2">this</span><span class="s1">.checkLValInnerPattern(param</span><span class="s2">, </span><span class="s1">BIND_VAR</span><span class="s2">, </span><span class="s1">allowDuplicates ? </span><span class="s2">null </span><span class="s1">: nameHash)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses a comma-separated list of expressions, and returns them as</span>
<span class="s0">// an array. `close` is the token type that ends the list, and</span>
<span class="s0">// `allowEmpty` can be turned on to allow subsequent commas with</span>
<span class="s0">// nothing in between them to be parsed as `null` (which is needed</span>
<span class="s0">// for array literals).</span>

<span class="s1">pp$5.parseExprList = </span><span class="s2">function</span><span class="s1">(close</span><span class="s2">, </span><span class="s1">allowTrailingComma</span><span class="s2">, </span><span class="s1">allowEmpty</span><span class="s2">, </span><span class="s1">refDestructuringErrors) {</span>
  <span class="s2">var </span><span class="s1">elts = []</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true;</span>
  <span class="s2">while </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eat(close)) {</span>
    <span class="s2">if </span><span class="s1">(!first) {</span>
      <span class="s2">this</span><span class="s1">.expect(types$1.comma)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(allowTrailingComma &amp;&amp; </span><span class="s2">this</span><span class="s1">.afterTrailingComma(close)) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ first = </span><span class="s2">false; </span><span class="s1">}</span>

    <span class="s2">var </span><span class="s1">elt = (</span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(allowEmpty &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.comma)</span>
      <span class="s1">{ elt = </span><span class="s2">null; </span><span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.ellipsis) {</span>
      <span class="s1">elt = </span><span class="s2">this</span><span class="s1">.parseSpread(refDestructuringErrors)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(refDestructuringErrors &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === types$1.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">{ refDestructuringErrors.trailingComma = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">elt = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(</span><span class="s2">false, </span><span class="s1">refDestructuringErrors)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">elts.push(elt)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">elts</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.checkUnreserved = </span><span class="s2">function</span><span class="s1">(ref) {</span>
  <span class="s2">var </span><span class="s1">start = ref.start</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">end = ref.end</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">name = ref.name</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inGenerator &amp;&amp; name === </span><span class="s3">&quot;yield&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'yield' as identifier inside a generator&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inAsync &amp;&amp; name === </span><span class="s3">&quot;await&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'await' as identifier inside an async function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentThisScope().inClassFieldInit &amp;&amp; name === </span><span class="s3">&quot;arguments&quot;</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;Cannot use 'arguments' in class field initializer&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inClassStaticBlock &amp;&amp; (name === </span><span class="s3">&quot;arguments&quot; </span><span class="s1">|| name === </span><span class="s3">&quot;await&quot;</span><span class="s1">))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Cannot use &quot; </span><span class="s1">+ name + </span><span class="s3">&quot; in class static initialization block&quot;</span><span class="s1">))</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.keywords.test(name))</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Unexpected keyword '&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;'&quot;</span><span class="s1">))</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">6 </span><span class="s1">&amp;&amp;</span>
    <span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, </span><span class="s1">end).indexOf(</span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">re = </span><span class="s2">this</span><span class="s1">.strict ? </span><span class="s2">this</span><span class="s1">.reservedWordsStrict : </span><span class="s2">this</span><span class="s1">.reservedWords</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(re.test(name)) {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.inAsync &amp;&amp; name === </span><span class="s3">&quot;await&quot;</span><span class="s1">)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s3">&quot;Cannot use keyword 'await' outside an async function&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.raiseRecoverable(start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;The keyword '&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;' is reserved&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parse the next token as an identifier. If `liberal` is true (used</span>
<span class="s0">// when parsing properties), it will also convert keywords into</span>
<span class="s0">// identifiers.</span>

<span class="s1">pp$5.parseIdent = </span><span class="s2">function</span><span class="s1">(liberal) {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.name) {</span>
    <span class="s1">node.name = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type.keyword) {</span>
    <span class="s1">node.name = </span><span class="s2">this</span><span class="s1">.type.keyword</span><span class="s2">;</span>

    <span class="s0">// To fix https://github.com/acornjs/acorn/issues/575</span>
    <span class="s0">// `class` and `function` keywords push new context into this.context.</span>
    <span class="s0">// But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.</span>
    <span class="s0">// If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword</span>
    <span class="s2">if </span><span class="s1">((node.name === </span><span class="s3">&quot;class&quot; </span><span class="s1">|| node.name === </span><span class="s3">&quot;function&quot;</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(</span><span class="s2">this</span><span class="s1">.lastTokEnd !== </span><span class="s2">this</span><span class="s1">.lastTokStart + </span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.lastTokStart) !== </span><span class="s4">46</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.context.pop()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next(!!liberal)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;Identifier&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!liberal) {</span>
    <span class="s2">this</span><span class="s1">.checkUnreserved(node)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.name === </span><span class="s3">&quot;await&quot; </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.awaitIdentPos)</span>
      <span class="s1">{ </span><span class="s2">this</span><span class="s1">.awaitIdentPos = node.start</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parsePrivateIdent = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.privateId) {</span>
    <span class="s1">node.name = </span><span class="s2">this</span><span class="s1">.value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s1">)</span><span class="s2">;</span>

  <span class="s0">// For validating existence</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.privateNameStack.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.raise(node.start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Private field '#&quot; </span><span class="s1">+ (node.name) + </span><span class="s3">&quot;' must be declared in an enclosing class&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.privateNameStack[</span><span class="s2">this</span><span class="s1">.privateNameStack.length - </span><span class="s4">1</span><span class="s1">].used.push(node)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Parses yield expression inside generator.</span>

<span class="s1">pp$5.parseYield = </span><span class="s2">function</span><span class="s1">(forInit) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.yieldPos) { </span><span class="s2">this</span><span class="s1">.yieldPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === types$1.semi || </span><span class="s2">this</span><span class="s1">.canInsertSemicolon() || (</span><span class="s2">this</span><span class="s1">.type !== types$1.star &amp;&amp; !</span><span class="s2">this</span><span class="s1">.type.startsExpr)) {</span>
    <span class="s1">node.delegate = </span><span class="s2">false;</span>
    <span class="s1">node.argument = </span><span class="s2">null;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">node.delegate = </span><span class="s2">this</span><span class="s1">.eat(types$1.star)</span><span class="s2">;</span>
    <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign(forInit)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;YieldExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$5.parseAwait = </span><span class="s2">function</span><span class="s1">(forInit) {</span>
  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.awaitPos) { </span><span class="s2">this</span><span class="s1">.awaitPos = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s1">node.argument = </span><span class="s2">this</span><span class="s1">.parseMaybeUnary(</span><span class="s2">null, true, false, </span><span class="s1">forInit)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$4 = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// This function is used to raise exceptions on parse errors. It</span>
<span class="s0">// takes an offset integer (into the current `input`) to indicate</span>
<span class="s0">// the location of the error, attaches the position to the end</span>
<span class="s0">// of the error message, and then raises a `SyntaxError` with that</span>
<span class="s0">// message.</span>

<span class="s1">pp$4.raise = </span><span class="s2">function</span><span class="s1">(pos</span><span class="s2">, </span><span class="s1">message) {</span>
  <span class="s2">var </span><span class="s1">loc = getLineInfo(</span><span class="s2">this</span><span class="s1">.input</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">;</span>
  <span class="s1">message += </span><span class="s3">&quot; (&quot; </span><span class="s1">+ loc.line + </span><span class="s3">&quot;:&quot; </span><span class="s1">+ loc.column + </span><span class="s3">&quot;)&quot;</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">SyntaxError(message)</span><span class="s2">;</span>
  <span class="s1">err.pos = pos</span><span class="s2">; </span><span class="s1">err.loc = loc</span><span class="s2">; </span><span class="s1">err.raisedAt = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">throw </span><span class="s1">err</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$4.raiseRecoverable = pp$4.raise</span><span class="s2">;</span>

<span class="s1">pp$4.curPosition = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) {</span>
    <span class="s2">return new </span><span class="s1">Position(</span><span class="s2">this</span><span class="s1">.curLine</span><span class="s2">, this</span><span class="s1">.pos - </span><span class="s2">this</span><span class="s1">.lineStart)</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">pp$3 = Parser.prototype</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">Scope = </span><span class="s2">function </span><span class="s1">Scope(flags) {</span>
  <span class="s2">this</span><span class="s1">.flags = flags</span><span class="s2">;</span>
  <span class="s0">// A list of var-declared names in the current lexical scope</span>
  <span class="s2">this</span><span class="s1">.var = []</span><span class="s2">;</span>
  <span class="s0">// A list of lexically-declared names in the current lexical scope</span>
  <span class="s2">this</span><span class="s1">.lexical = []</span><span class="s2">;</span>
  <span class="s0">// A list of lexically-declared FunctionDeclaration names in the current lexical scope</span>
  <span class="s2">this</span><span class="s1">.functions = []</span><span class="s2">;</span>
  <span class="s0">// A switch to disallow the identifier reference 'arguments'</span>
  <span class="s2">this</span><span class="s1">.inClassFieldInit = </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.</span>

<span class="s1">pp$3.enterScope = </span><span class="s2">function</span><span class="s1">(flags) {</span>
  <span class="s2">this</span><span class="s1">.scopeStack.push(</span><span class="s2">new </span><span class="s1">Scope(flags))</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$3.exitScope = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.scopeStack.pop()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The spec says:</span>
<span class="s0">// &gt; At the top level of a function, or script, function declarations are</span>
<span class="s0">// &gt; treated like var declarations rather than like lexical declarations.</span>
<span class="s1">pp$3.treatFunctionsAsVarInScope = </span><span class="s2">function</span><span class="s1">(scope) {</span>
  <span class="s2">return </span><span class="s1">(scope.flags &amp; SCOPE_FUNCTION) || !</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$3.declareName = </span><span class="s2">function</span><span class="s1">(name</span><span class="s2">, </span><span class="s1">bindingType</span><span class="s2">, </span><span class="s1">pos) {</span>
  <span class="s2">var </span><span class="s1">redeclared = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(bindingType === BIND_LEXICAL) {</span>
    <span class="s2">var </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.currentScope()</span><span class="s2">;</span>
    <span class="s1">redeclared = scope.lexical.indexOf(name) &gt; -</span><span class="s4">1 </span><span class="s1">|| scope.functions.indexOf(name) &gt; -</span><span class="s4">1 </span><span class="s1">|| scope.var.indexOf(name) &gt; -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">scope.lexical.push(name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP))</span>
      <span class="s1">{ </span><span class="s2">delete this</span><span class="s1">.undefinedExports[name]</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(bindingType === BIND_SIMPLE_CATCH) {</span>
    <span class="s2">var </span><span class="s1">scope$1 = </span><span class="s2">this</span><span class="s1">.currentScope()</span><span class="s2">;</span>
    <span class="s1">scope$1.lexical.push(name)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(bindingType === BIND_FUNCTION) {</span>
    <span class="s2">var </span><span class="s1">scope$2 = </span><span class="s2">this</span><span class="s1">.currentScope()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.treatFunctionsAsVar)</span>
      <span class="s1">{ redeclared = scope$2.lexical.indexOf(name) &gt; -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">else</span>
      <span class="s1">{ redeclared = scope$2.lexical.indexOf(name) &gt; -</span><span class="s4">1 </span><span class="s1">|| scope$2.var.indexOf(name) &gt; -</span><span class="s4">1</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s1">scope$2.functions.push(name)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.scopeStack.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">--i) {</span>
      <span class="s2">var </span><span class="s1">scope$3 = </span><span class="s2">this</span><span class="s1">.scopeStack[i]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(scope$3.lexical.indexOf(name) &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; !((scope$3.flags &amp; SCOPE_SIMPLE_CATCH) &amp;&amp; scope$3.lexical[</span><span class="s4">0</span><span class="s1">] === name) ||</span>
          <span class="s1">!</span><span class="s2">this</span><span class="s1">.treatFunctionsAsVarInScope(scope$3) &amp;&amp; scope$3.functions.indexOf(name) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">redeclared = </span><span class="s2">true;</span>
        <span class="s2">break</span>
      <span class="s1">}</span>
      <span class="s1">scope$3.var.push(name)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; (scope$3.flags &amp; SCOPE_TOP))</span>
        <span class="s1">{ </span><span class="s2">delete this</span><span class="s1">.undefinedExports[name]</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(scope$3.flags &amp; SCOPE_VAR) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(redeclared) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(pos</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Identifier '&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;' has already been declared&quot;</span><span class="s1">))</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$3.checkLocalExport = </span><span class="s2">function</span><span class="s1">(id) {</span>
  <span class="s0">// scope.functions must be empty as Module code is always strict.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeStack[</span><span class="s4">0</span><span class="s1">].lexical.indexOf(id.name) === -</span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.scopeStack[</span><span class="s4">0</span><span class="s1">].var.indexOf(id.name) === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.undefinedExports[id.name] = id</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$3.currentScope = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return this</span><span class="s1">.scopeStack[</span><span class="s2">this</span><span class="s1">.scopeStack.length - </span><span class="s4">1</span><span class="s1">]</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$3.currentVarScope = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.scopeStack.length - </span><span class="s4">1</span><span class="s2">;; </span><span class="s1">i--) {</span>
    <span class="s2">var </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.scopeStack[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(scope.flags &amp; SCOPE_VAR) { </span><span class="s2">return </span><span class="s1">scope }</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.</span>
<span class="s1">pp$3.currentThisScope = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.scopeStack.length - </span><span class="s4">1</span><span class="s2">;; </span><span class="s1">i--) {</span>
    <span class="s2">var </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.scopeStack[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(scope.flags &amp; SCOPE_VAR &amp;&amp; !(scope.flags &amp; SCOPE_ARROW)) { </span><span class="s2">return </span><span class="s1">scope }</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">Node = </span><span class="s2">function </span><span class="s1">Node(parser</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">loc) {</span>
  <span class="s2">this</span><span class="s1">.type = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.start = pos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.end = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(parser.options.locations)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.loc = </span><span class="s2">new </span><span class="s1">SourceLocation(parser</span><span class="s2">, </span><span class="s1">loc)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(parser.options.directSourceFile)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.sourceFile = parser.options.directSourceFile</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(parser.options.ranges)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.range = [pos</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Start an AST node, attaching a start offset.</span>

<span class="s2">var </span><span class="s1">pp$2 = Parser.prototype</span><span class="s2">;</span>

<span class="s1">pp$2.startNode = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">return new </span><span class="s1">Node(</span><span class="s2">this, this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.startLoc)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$2.startNodeAt = </span><span class="s2">function</span><span class="s1">(pos</span><span class="s2">, </span><span class="s1">loc) {</span>
  <span class="s2">return new </span><span class="s1">Node(</span><span class="s2">this, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">loc)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Finish an AST node, adding `type` and `end` properties.</span>

<span class="s2">function </span><span class="s1">finishNodeAt(node</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">loc) {</span>
  <span class="s1">node.type = type</span><span class="s2">;</span>
  <span class="s1">node.end = pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations)</span>
    <span class="s1">{ node.loc.end = loc</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ranges)</span>
    <span class="s1">{ node.range[</span><span class="s4">1</span><span class="s1">] = pos</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">node</span>
<span class="s1">}</span>

<span class="s1">pp$2.finishNode = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">return </span><span class="s1">finishNodeAt.call(</span><span class="s2">this, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.lastTokEndLoc)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Finish node at given position</span>

<span class="s1">pp$2.finishNodeAt = </span><span class="s2">function</span><span class="s1">(node</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">loc) {</span>
  <span class="s2">return </span><span class="s1">finishNodeAt.call(</span><span class="s2">this, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">loc)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp$2.copyNode = </span><span class="s2">function</span><span class="s1">(node) {</span>
  <span class="s2">var </span><span class="s1">newNode = </span><span class="s2">new </span><span class="s1">Node(</span><span class="s2">this, </span><span class="s1">node.start</span><span class="s2">, this</span><span class="s1">.startLoc)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">prop </span><span class="s2">in </span><span class="s1">node) { newNode[prop] = node[prop]</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">newNode</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// This file contains Unicode properties extracted from the ECMAScript specification.</span>
<span class="s0">// The lists are extracted like so:</span>
<span class="s0">// $$('#table-binary-unicode-properties &gt; figure &gt; table &gt; tbody &gt; tr &gt; td:nth-child(1) code').map(el =&gt; el.innerText)</span>

<span class="s0">// #table-binary-unicode-properties</span>
<span class="s2">var </span><span class="s1">ecma9BinaryProperties = </span><span class="s3">&quot;ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma10BinaryProperties = ecma9BinaryProperties + </span><span class="s3">&quot; Extended_Pictographic&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma11BinaryProperties = ecma10BinaryProperties</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma12BinaryProperties = ecma11BinaryProperties + </span><span class="s3">&quot; EBase EComp EMod EPres ExtPict&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma13BinaryProperties = ecma12BinaryProperties</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma14BinaryProperties = ecma13BinaryProperties</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">unicodeBinaryProperties = {</span>
  <span class="s4">9</span><span class="s1">: ecma9BinaryProperties</span><span class="s2">,</span>
  <span class="s4">10</span><span class="s1">: ecma10BinaryProperties</span><span class="s2">,</span>
  <span class="s4">11</span><span class="s1">: ecma11BinaryProperties</span><span class="s2">,</span>
  <span class="s4">12</span><span class="s1">: ecma12BinaryProperties</span><span class="s2">,</span>
  <span class="s4">13</span><span class="s1">: ecma13BinaryProperties</span><span class="s2">,</span>
  <span class="s4">14</span><span class="s1">: ecma14BinaryProperties</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// #table-unicode-general-category-values</span>
<span class="s2">var </span><span class="s1">unicodeGeneralCategoryValues = </span><span class="s3">&quot;Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu&quot;</span><span class="s2">;</span>

<span class="s0">// #table-unicode-script-values</span>
<span class="s2">var </span><span class="s1">ecma9ScriptValues = </span><span class="s3">&quot;Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma10ScriptValues = ecma9ScriptValues + </span><span class="s3">&quot; Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma11ScriptValues = ecma10ScriptValues + </span><span class="s3">&quot; Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma12ScriptValues = ecma11ScriptValues + </span><span class="s3">&quot; Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma13ScriptValues = ecma12ScriptValues + </span><span class="s3">&quot; Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ecma14ScriptValues = ecma13ScriptValues + </span><span class="s3">&quot; Kawi Nag_Mundari Nagm&quot;</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">unicodeScriptValues = {</span>
  <span class="s4">9</span><span class="s1">: ecma9ScriptValues</span><span class="s2">,</span>
  <span class="s4">10</span><span class="s1">: ecma10ScriptValues</span><span class="s2">,</span>
  <span class="s4">11</span><span class="s1">: ecma11ScriptValues</span><span class="s2">,</span>
  <span class="s4">12</span><span class="s1">: ecma12ScriptValues</span><span class="s2">,</span>
  <span class="s4">13</span><span class="s1">: ecma13ScriptValues</span><span class="s2">,</span>
  <span class="s4">14</span><span class="s1">: ecma14ScriptValues</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">data = {}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">buildUnicodeData(ecmaVersion) {</span>
  <span class="s2">var </span><span class="s1">d = data[ecmaVersion] = {</span>
    <span class="s1">binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + </span><span class="s3">&quot; &quot; </span><span class="s1">+ unicodeGeneralCategoryValues)</span><span class="s2">,</span>
    <span class="s1">nonBinary: {</span>
      <span class="s1">General_Category: wordsRegexp(unicodeGeneralCategoryValues)</span><span class="s2">,</span>
      <span class="s1">Script: wordsRegexp(unicodeScriptValues[ecmaVersion])</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">d.nonBinary.Script_Extensions = d.nonBinary.Script</span><span class="s2">;</span>

  <span class="s1">d.nonBinary.gc = d.nonBinary.General_Category</span><span class="s2">;</span>
  <span class="s1">d.nonBinary.sc = d.nonBinary.Script</span><span class="s2">;</span>
  <span class="s1">d.nonBinary.scx = d.nonBinary.Script_Extensions</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = [</span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">13</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
  <span class="s2">var </span><span class="s1">ecmaVersion = list[i]</span><span class="s2">;</span>

  <span class="s1">buildUnicodeData(ecmaVersion)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">pp$1 = Parser.prototype</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">RegExpValidationState = </span><span class="s2">function </span><span class="s1">RegExpValidationState(parser) {</span>
  <span class="s2">this</span><span class="s1">.parser = parser</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.validFlags = </span><span class="s3">&quot;gim&quot; </span><span class="s1">+ (parser.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">? </span><span class="s3">&quot;uy&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">) + (parser.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">? </span><span class="s3">&quot;s&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">) + (parser.options.ecmaVersion &gt;= </span><span class="s4">13 </span><span class="s1">? </span><span class="s3">&quot;d&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.unicodeProperties = data[parser.options.ecmaVersion &gt;= </span><span class="s4">14 </span><span class="s1">? </span><span class="s4">14 </span><span class="s1">: parser.options.ecmaVersion]</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.source = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.flags = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.start = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.switchU = </span><span class="s2">false;</span>
  <span class="s2">this</span><span class="s1">.switchN = </span><span class="s2">false;</span>
  <span class="s2">this</span><span class="s1">.pos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastAssertionIsQuantifiable = </span><span class="s2">false;</span>
  <span class="s2">this</span><span class="s1">.numCapturingParens = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.maxBackReference = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.groupNames = []</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.backReferenceNames = []</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.reset = </span><span class="s2">function </span><span class="s1">reset (start</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">flags) {</span>
  <span class="s2">var </span><span class="s1">unicode = flags.indexOf(</span><span class="s3">&quot;u&quot;</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.start = start | </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.source = pattern + </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.flags = flags</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.switchU = unicode &amp;&amp; </span><span class="s2">this</span><span class="s1">.parser.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.switchN = unicode &amp;&amp; </span><span class="s2">this</span><span class="s1">.parser.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.raise = </span><span class="s2">function </span><span class="s1">raise (message) {</span>
  <span class="s2">this</span><span class="s1">.parser.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;Invalid regular expression: /&quot; </span><span class="s1">+ (</span><span class="s2">this</span><span class="s1">.source) + </span><span class="s3">&quot;/: &quot; </span><span class="s1">+ message))</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// If u flag is given, this returns the code point at the index (it combines a surrogate pair).</span>
<span class="s0">// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).</span>
<span class="s1">RegExpValidationState.prototype.at = </span><span class="s2">function </span><span class="s1">at (i</span><span class="s2">, </span><span class="s1">forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">var </span><span class="s1">s = </span><span class="s2">this</span><span class="s1">.source</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">l = s.length</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(i &gt;= l) {</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">c = s.charCodeAt(i)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!(forceU || </span><span class="s2">this</span><span class="s1">.switchU) || c &lt;= </span><span class="s4">0xD7FF </span><span class="s1">|| c &gt;= </span><span class="s4">0xE000 </span><span class="s1">|| i + </span><span class="s4">1 </span><span class="s1">&gt;= l) {</span>
    <span class="s2">return </span><span class="s1">c</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">next = s.charCodeAt(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">next &gt;= </span><span class="s4">0xDC00 </span><span class="s1">&amp;&amp; next &lt;= </span><span class="s4">0xDFFF </span><span class="s1">? (c &lt;&lt; </span><span class="s4">10</span><span class="s1">) + next - </span><span class="s4">0x35FDC00 </span><span class="s1">: c</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.nextIndex = </span><span class="s2">function </span><span class="s1">nextIndex (i</span><span class="s2">, </span><span class="s1">forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">var </span><span class="s1">s = </span><span class="s2">this</span><span class="s1">.source</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">l = s.length</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(i &gt;= l) {</span>
    <span class="s2">return </span><span class="s1">l</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">c = s.charCodeAt(i)</span><span class="s2">, </span><span class="s1">next</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!(forceU || </span><span class="s2">this</span><span class="s1">.switchU) || c &lt;= </span><span class="s4">0xD7FF </span><span class="s1">|| c &gt;= </span><span class="s4">0xE000 </span><span class="s1">|| i + </span><span class="s4">1 </span><span class="s1">&gt;= l ||</span>
      <span class="s1">(next = s.charCodeAt(i + </span><span class="s4">1</span><span class="s1">)) &lt; </span><span class="s4">0xDC00 </span><span class="s1">|| next &gt; </span><span class="s4">0xDFFF</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">i + </span><span class="s4">1</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">i + </span><span class="s4">2</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.current = </span><span class="s2">function </span><span class="s1">current (forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">return this</span><span class="s1">.at(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">forceU)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.lookahead = </span><span class="s2">function </span><span class="s1">lookahead (forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">return this</span><span class="s1">.at(</span><span class="s2">this</span><span class="s1">.nextIndex(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">forceU)</span><span class="s2">, </span><span class="s1">forceU)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.advance = </span><span class="s2">function </span><span class="s1">advance (forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">this</span><span class="s1">.pos = </span><span class="s2">this</span><span class="s1">.nextIndex(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">forceU)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">RegExpValidationState.prototype.eat = </span><span class="s2">function </span><span class="s1">eat (ch</span><span class="s2">, </span><span class="s1">forceU) {</span>
    <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.current(forceU) === ch) {</span>
    <span class="s2">this</span><span class="s1">.advance(forceU)</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Validate the flags part of a given RegExpLiteral.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExpValidationState} state The state to validate RegExp.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>
<span class="s1">pp$1.validateRegExpFlags = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">validFlags = state.validFlags</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">flags = state.flags</span><span class="s2">;</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; flags.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">var </span><span class="s1">flag = flags.charAt(i)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(validFlags.indexOf(flag) === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(state.start</span><span class="s2">, </span><span class="s3">&quot;Invalid regular expression flag&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(flags.indexOf(flag</span><span class="s2">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.raise(state.start</span><span class="s2">, </span><span class="s3">&quot;Duplicate regular expression flag&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">/**</span>
 <span class="s5">* Validate the pattern part of a given RegExpLiteral.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExpValidationState} state The state to validate RegExp.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
 <span class="s5">*/</span>
<span class="s1">pp$1.validateRegExpPattern = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">this</span><span class="s1">.regexp_pattern(state)</span><span class="s2">;</span>

  <span class="s0">// The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of</span>
  <span class="s0">// parsing contains a |GroupName|, reparse with the goal symbol</span>
  <span class="s0">// |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*</span>
  <span class="s0">// exception if _P_ did not conform to the grammar, if any elements of _P_</span>
  <span class="s0">// were not matched by the parse, or if any Early Error conditions exist.</span>
  <span class="s2">if </span><span class="s1">(!state.switchN &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp; state.groupNames.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">state.switchN = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.regexp_pattern(state)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern</span>
<span class="s1">pp$1.regexp_pattern = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s1">state.pos = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s1">state.lastAssertionIsQuantifiable = </span><span class="s2">false;</span>
  <span class="s1">state.numCapturingParens = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.maxBackReference = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.groupNames.length = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.backReferenceNames.length = </span><span class="s4">0</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.regexp_disjunction(state)</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(state.pos !== state.source.length) {</span>
    <span class="s0">// Make the same messages as V8.</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x29 </span><span class="s0">/* ) */</span><span class="s1">)) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Unmatched ')'&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5D </span><span class="s0">/* ] */</span><span class="s1">) || state.eat(</span><span class="s4">0x7D </span><span class="s0">/* } */</span><span class="s1">)) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Lone quantifier brackets&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(state.maxBackReference &gt; state.numCapturingParens) {</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = state.backReferenceNames</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">name = list[i]</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(state.groupNames.indexOf(name) === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid named capture referenced&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction</span>
<span class="s1">pp$1.regexp_disjunction = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">this</span><span class="s1">.regexp_alternative(state)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(state.eat(</span><span class="s4">0x7C </span><span class="s0">/* | */</span><span class="s1">)) {</span>
    <span class="s2">this</span><span class="s1">.regexp_alternative(state)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Make the same message as V8.</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatQuantifier(state</span><span class="s2">, true</span><span class="s1">)) {</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Nothing to repeat&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x7B </span><span class="s0">/* { */</span><span class="s1">)) {</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Lone quantifier brackets&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative</span>
<span class="s1">pp$1.regexp_alternative = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">while </span><span class="s1">(state.pos &lt; state.source.length &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatTerm(state))</span>
    <span class="s1">{ }</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term</span>
<span class="s1">pp$1.regexp_eatTerm = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatAssertion(state)) {</span>
    <span class="s0">// Handle `QuantifiableAssertion Quantifier` alternative.</span>
    <span class="s0">// `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion</span>
    <span class="s0">// is a QuantifiableAssertion.</span>
    <span class="s2">if </span><span class="s1">(state.lastAssertionIsQuantifiable &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatQuantifier(state)) {</span>
      <span class="s0">// Make the same message as V8.</span>
      <span class="s2">if </span><span class="s1">(state.switchU) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Invalid quantifier&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.switchU ? </span><span class="s2">this</span><span class="s1">.regexp_eatAtom(state) : </span><span class="s2">this</span><span class="s1">.regexp_eatExtendedAtom(state)) {</span>
    <span class="s2">this</span><span class="s1">.regexp_eatQuantifier(state)</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion</span>
<span class="s1">pp$1.regexp_eatAssertion = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s1">state.lastAssertionIsQuantifiable = </span><span class="s2">false;</span>

  <span class="s0">// ^, $</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5E </span><span class="s0">/* ^ */</span><span class="s1">) || state.eat(</span><span class="s4">0x24 </span><span class="s0">/* $ */</span><span class="s1">)) {</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s0">// \b \B</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5C </span><span class="s0">/* \ */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x42 </span><span class="s0">/* B */</span><span class="s1">) || state.eat(</span><span class="s4">0x62 </span><span class="s0">/* b */</span><span class="s1">)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">// Lookahead / Lookbehind</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x28 </span><span class="s0">/* ( */</span><span class="s1">) &amp;&amp; state.eat(</span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">)) {</span>
    <span class="s2">var </span><span class="s1">lookbehind = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
      <span class="s1">lookbehind = state.eat(</span><span class="s4">0x3C </span><span class="s0">/* &lt; */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x3D </span><span class="s0">/* = */</span><span class="s1">) || state.eat(</span><span class="s4">0x21 </span><span class="s0">/* ! */</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.regexp_disjunction(state)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!state.eat(</span><span class="s4">0x29 </span><span class="s0">/* ) */</span><span class="s1">)) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Unterminated group&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">state.lastAssertionIsQuantifiable = !lookbehind</span><span class="s2">;</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier</span>
<span class="s1">pp$1.regexp_eatQuantifier = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">noError) {</span>
  <span class="s2">if </span><span class="s1">( noError === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) noError = </span><span class="s2">false;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatQuantifierPrefix(state</span><span class="s2">, </span><span class="s1">noError)) {</span>
    <span class="s1">state.eat(</span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix</span>
<span class="s1">pp$1.regexp_eatQuantifierPrefix = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">noError) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">state.eat(</span><span class="s4">0x2A </span><span class="s0">/* * */</span><span class="s1">) ||</span>
    <span class="s1">state.eat(</span><span class="s4">0x2B </span><span class="s0">/* + */</span><span class="s1">) ||</span>
    <span class="s1">state.eat(</span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatBracedQuantifier(state</span><span class="s2">, </span><span class="s1">noError)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatBracedQuantifier = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">noError) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x7B </span><span class="s0">/* { */</span><span class="s1">)) {</span>
    <span class="s2">var </span><span class="s1">min = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">max = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatDecimalDigits(state)) {</span>
      <span class="s1">min = state.lastIntValue</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x2C </span><span class="s0">/* , */</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatDecimalDigits(state)) {</span>
        <span class="s1">max = state.lastIntValue</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x7D </span><span class="s0">/* } */</span><span class="s1">)) {</span>
        <span class="s0">// SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term</span>
        <span class="s2">if </span><span class="s1">(max !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; max &lt; min &amp;&amp; !noError) {</span>
          <span class="s1">state.raise(</span><span class="s3">&quot;numbers out of order in {} quantifier&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.switchU &amp;&amp; !noError) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Incomplete quantifier&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom</span>
<span class="s1">pp$1.regexp_eatAtom = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.regexp_eatPatternCharacters(state) ||</span>
    <span class="s1">state.eat(</span><span class="s4">0x2E </span><span class="s0">/* . */</span><span class="s1">) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatReverseSolidusAtomEscape(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterClass(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatUncapturingGroup(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCapturingGroup(state)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatReverseSolidusAtomEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5C </span><span class="s0">/* \ */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatAtomEscape(state)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatUncapturingGroup = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x28 </span><span class="s0">/* ( */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">) &amp;&amp; state.eat(</span><span class="s4">0x3A </span><span class="s0">/* : */</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.regexp_disjunction(state)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x29 </span><span class="s0">/* ) */</span><span class="s1">)) {</span>
        <span class="s2">return true</span>
      <span class="s1">}</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Unterminated group&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatCapturingGroup = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x28 </span><span class="s0">/* ( */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.regexp_groupSpecifier(state)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.current() === </span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid group&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">.regexp_disjunction(state)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x29 </span><span class="s0">/* ) */</span><span class="s1">)) {</span>
      <span class="s1">state.numCapturingParens += </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Unterminated group&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom</span>
<span class="s1">pp$1.regexp_eatExtendedAtom = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">state.eat(</span><span class="s4">0x2E </span><span class="s0">/* . */</span><span class="s1">) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatReverseSolidusAtomEscape(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterClass(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatUncapturingGroup(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCapturingGroup(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatInvalidBracedQuantifier(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatExtendedPatternCharacter(state)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier</span>
<span class="s1">pp$1.regexp_eatInvalidBracedQuantifier = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatBracedQuantifier(state</span><span class="s2">, true</span><span class="s1">)) {</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Nothing to repeat&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter</span>
<span class="s1">pp$1.regexp_eatSyntaxCharacter = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isSyntaxCharacter(ch)) {</span>
    <span class="s1">state.lastIntValue = ch</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isSyntaxCharacter(ch) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">ch === </span><span class="s4">0x24 </span><span class="s0">/* $ */ </span><span class="s1">||</span>
    <span class="s1">ch &gt;= </span><span class="s4">0x28 </span><span class="s0">/* ( */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x2B </span><span class="s0">/* + */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x2E </span><span class="s0">/* . */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x3F </span><span class="s0">/* ? */ </span><span class="s1">||</span>
    <span class="s1">ch &gt;= </span><span class="s4">0x5B </span><span class="s0">/* [ */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x5E </span><span class="s0">/* ^ */ </span><span class="s1">||</span>
    <span class="s1">ch &gt;= </span><span class="s4">0x7B </span><span class="s0">/* { */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x7D </span><span class="s0">/* } */</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter</span>
<span class="s0">// But eat eager.</span>
<span class="s1">pp$1.regexp_eatPatternCharacters = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">((ch = state.current()) !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; !isSyntaxCharacter(ch)) {</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.pos !== start</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter</span>
<span class="s1">pp$1.regexp_eatExtendedPatternCharacter = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">ch !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x24 </span><span class="s0">/* $ */ </span><span class="s1">&amp;&amp;</span>
    <span class="s1">!(ch &gt;= </span><span class="s4">0x28 </span><span class="s0">/* ( */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x2B </span><span class="s0">/* + */</span><span class="s1">) &amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x2E </span><span class="s0">/* . */ </span><span class="s1">&amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x3F </span><span class="s0">/* ? */ </span><span class="s1">&amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x5B </span><span class="s0">/* [ */ </span><span class="s1">&amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x5E </span><span class="s0">/* ^ */ </span><span class="s1">&amp;&amp;</span>
    <span class="s1">ch !== </span><span class="s4">0x7C </span><span class="s0">/* | */</span>
  <span class="s1">) {</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// GroupSpecifier ::</span>
<span class="s0">//   [empty]</span>
<span class="s0">//   `?` GroupName</span>
<span class="s1">pp$1.regexp_groupSpecifier = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x3F </span><span class="s0">/* ? */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatGroupName(state)) {</span>
      <span class="s2">if </span><span class="s1">(state.groupNames.indexOf(state.lastStringValue) !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Duplicate capture group name&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">state.groupNames.push(state.lastStringValue)</span><span class="s2">;</span>
      <span class="s2">return</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid group&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// GroupName ::</span>
<span class="s0">//   `&lt;` RegExpIdentifierName `&gt;`</span>
<span class="s0">// Note: this updates `state.lastStringValue` property with the eaten name.</span>
<span class="s1">pp$1.regexp_eatGroupName = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s1">state.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x3C </span><span class="s0">/* &lt; */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatRegExpIdentifierName(state) &amp;&amp; state.eat(</span><span class="s4">0x3E </span><span class="s0">/* &gt; */</span><span class="s1">)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid capture group name&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// RegExpIdentifierName ::</span>
<span class="s0">//   RegExpIdentifierStart</span>
<span class="s0">//   RegExpIdentifierName RegExpIdentifierPart</span>
<span class="s0">// Note: this updates `state.lastStringValue` property with the eaten name.</span>
<span class="s1">pp$1.regexp_eatRegExpIdentifierName = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s1">state.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatRegExpIdentifierStart(state)) {</span>
    <span class="s1">state.lastStringValue += codePointToString(state.lastIntValue)</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatRegExpIdentifierPart(state)) {</span>
      <span class="s1">state.lastStringValue += codePointToString(state.lastIntValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// RegExpIdentifierStart ::</span>
<span class="s0">//   UnicodeIDStart</span>
<span class="s0">//   `$`</span>
<span class="s0">//   `_`</span>
<span class="s0">//   `\` RegExpUnicodeEscapeSequence[+U]</span>
<span class="s1">pp$1.regexp_eatRegExpIdentifierStart = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">forceU = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = state.current(forceU)</span><span class="s2">;</span>
  <span class="s1">state.advance(forceU)</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x5C </span><span class="s0">/* \ */ </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatRegExpUnicodeEscapeSequence(state</span><span class="s2">, </span><span class="s1">forceU)) {</span>
    <span class="s1">ch = state.lastIntValue</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isRegExpIdentifierStart(ch)) {</span>
    <span class="s1">state.lastIntValue = ch</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isRegExpIdentifierStart(ch) {</span>
  <span class="s2">return </span><span class="s1">isIdentifierStart(ch</span><span class="s2">, true</span><span class="s1">) || ch === </span><span class="s4">0x24 </span><span class="s0">/* $ */ </span><span class="s1">|| ch === </span><span class="s4">0x5F </span><span class="s0">/* _ */</span>
<span class="s1">}</span>

<span class="s0">// RegExpIdentifierPart ::</span>
<span class="s0">//   UnicodeIDContinue</span>
<span class="s0">//   `$`</span>
<span class="s0">//   `_`</span>
<span class="s0">//   `\` RegExpUnicodeEscapeSequence[+U]</span>
<span class="s0">//   &lt;ZWNJ&gt;</span>
<span class="s0">//   &lt;ZWJ&gt;</span>
<span class="s1">pp$1.regexp_eatRegExpIdentifierPart = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">forceU = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = state.current(forceU)</span><span class="s2">;</span>
  <span class="s1">state.advance(forceU)</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x5C </span><span class="s0">/* \ */ </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatRegExpUnicodeEscapeSequence(state</span><span class="s2">, </span><span class="s1">forceU)) {</span>
    <span class="s1">ch = state.lastIntValue</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isRegExpIdentifierPart(ch)) {</span>
    <span class="s1">state.lastIntValue = ch</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isRegExpIdentifierPart(ch) {</span>
  <span class="s2">return </span><span class="s1">isIdentifierChar(ch</span><span class="s2">, true</span><span class="s1">) || ch === </span><span class="s4">0x24 </span><span class="s0">/* $ */ </span><span class="s1">|| ch === </span><span class="s4">0x5F </span><span class="s0">/* _ */ </span><span class="s1">|| ch === </span><span class="s4">0x200C </span><span class="s0">/* &lt;ZWNJ&gt; */ </span><span class="s1">|| ch === </span><span class="s4">0x200D </span><span class="s0">/* &lt;ZWJ&gt; */</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape</span>
<span class="s1">pp$1.regexp_eatAtomEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.regexp_eatBackReference(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterClassEscape(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterEscape(state) ||</span>
    <span class="s1">(state.switchN &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatKGroupName(state))</span>
  <span class="s1">) {</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(state.switchU) {</span>
    <span class="s0">// Make the same message as V8.</span>
    <span class="s2">if </span><span class="s1">(state.current() === </span><span class="s4">0x63 </span><span class="s0">/* c */</span><span class="s1">) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid unicode escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatBackReference = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatDecimalEscape(state)) {</span>
    <span class="s2">var </span><span class="s1">n = state.lastIntValue</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(state.switchU) {</span>
      <span class="s0">// For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape</span>
      <span class="s2">if </span><span class="s1">(n &gt; state.maxBackReference) {</span>
        <span class="s1">state.maxBackReference = n</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(n &lt;= state.numCapturingParens) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatKGroupName = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x6B </span><span class="s0">/* k */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatGroupName(state)) {</span>
      <span class="s1">state.backReferenceNames.push(state.lastStringValue)</span><span class="s2">;</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid named reference&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape</span>
<span class="s1">pp$1.regexp_eatCharacterEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.regexp_eatControlEscape(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCControlLetter(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatZero(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatHexEscapeSequence(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatRegExpUnicodeEscapeSequence(state</span><span class="s2">, false</span><span class="s1">) ||</span>
    <span class="s1">(!state.switchU &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatLegacyOctalEscapeSequence(state)) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatIdentityEscape(state)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatCControlLetter = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x63 </span><span class="s0">/* c */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatControlLetter(state)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_eatZero = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.current() === </span><span class="s4">0x30 </span><span class="s0">/* 0 */ </span><span class="s1">&amp;&amp; !isDecimalDigit(state.lookahead())) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape</span>
<span class="s1">pp$1.regexp_eatControlEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x74 </span><span class="s0">/* t */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x09</span><span class="s2">; </span><span class="s0">/* \t */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x6E </span><span class="s0">/* n */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x0A</span><span class="s2">; </span><span class="s0">/* \n */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x76 </span><span class="s0">/* v */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x0B</span><span class="s2">; </span><span class="s0">/* \v */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x66 </span><span class="s0">/* f */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x0C</span><span class="s2">; </span><span class="s0">/* \f */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0x72 </span><span class="s0">/* r */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x0D</span><span class="s2">; </span><span class="s0">/* \r */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter</span>
<span class="s1">pp$1.regexp_eatControlLetter = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isControlLetter(ch)) {</span>
    <span class="s1">state.lastIntValue = ch % </span><span class="s4">0x20</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isControlLetter(ch) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">(ch &gt;= </span><span class="s4">0x41 </span><span class="s0">/* A */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x5A </span><span class="s0">/* Z */</span><span class="s1">) ||</span>
    <span class="s1">(ch &gt;= </span><span class="s4">0x61 </span><span class="s0">/* a */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x7A </span><span class="s0">/* z */</span><span class="s1">)</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence</span>
<span class="s1">pp$1.regexp_eatRegExpUnicodeEscapeSequence = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">forceU) {</span>
  <span class="s2">if </span><span class="s1">( forceU === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">) forceU = </span><span class="s2">false;</span>

  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">switchU = forceU || state.switchU</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x75 </span><span class="s0">/* u */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatFixedHexDigits(state</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)) {</span>
      <span class="s2">var </span><span class="s1">lead = state.lastIntValue</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(switchU &amp;&amp; lead &gt;= </span><span class="s4">0xD800 </span><span class="s1">&amp;&amp; lead &lt;= </span><span class="s4">0xDBFF</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">leadSurrogateEnd = state.pos</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5C </span><span class="s0">/* \ */</span><span class="s1">) &amp;&amp; state.eat(</span><span class="s4">0x75 </span><span class="s0">/* u */</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatFixedHexDigits(state</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)) {</span>
          <span class="s2">var </span><span class="s1">trail = state.lastIntValue</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(trail &gt;= </span><span class="s4">0xDC00 </span><span class="s1">&amp;&amp; trail &lt;= </span><span class="s4">0xDFFF</span><span class="s1">) {</span>
            <span class="s1">state.lastIntValue = (lead - </span><span class="s4">0xD800</span><span class="s1">) * </span><span class="s4">0x400 </span><span class="s1">+ (trail - </span><span class="s4">0xDC00</span><span class="s1">) + </span><span class="s4">0x10000</span><span class="s2">;</span>
            <span class="s2">return true</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">state.pos = leadSurrogateEnd</span><span class="s2">;</span>
        <span class="s1">state.lastIntValue = lead</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">switchU &amp;&amp;</span>
      <span class="s1">state.eat(</span><span class="s4">0x7B </span><span class="s0">/* { */</span><span class="s1">) &amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.regexp_eatHexDigits(state) &amp;&amp;</span>
      <span class="s1">state.eat(</span><span class="s4">0x7D </span><span class="s0">/* } */</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">isValidUnicode(state.lastIntValue)</span>
    <span class="s1">) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(switchU) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid unicode escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isValidUnicode(ch) {</span>
  <span class="s2">return </span><span class="s1">ch &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x10FFFF</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape</span>
<span class="s1">pp$1.regexp_eatIdentityEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.switchU) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatSyntaxCharacter(state)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x2F </span><span class="s0">/* / */</span><span class="s1">)) {</span>
      <span class="s1">state.lastIntValue = </span><span class="s4">0x2F</span><span class="s2">; </span><span class="s0">/* / */</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">return false</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0x63 </span><span class="s0">/* c */ </span><span class="s1">&amp;&amp; (!state.switchN || ch !== </span><span class="s4">0x6B </span><span class="s0">/* k */</span><span class="s1">)) {</span>
    <span class="s1">state.lastIntValue = ch</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape</span>
<span class="s1">pp$1.regexp_eatDecimalEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ch &gt;= </span><span class="s4">0x31 </span><span class="s0">/* 1 */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x39 </span><span class="s0">/* 9 */</span><span class="s1">) {</span>
    <span class="s2">do </span><span class="s1">{</span>
      <span class="s1">state.lastIntValue = </span><span class="s4">10 </span><span class="s1">* state.lastIntValue + (ch - </span><span class="s4">0x30 </span><span class="s0">/* 0 */</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">((ch = state.current()) &gt;= </span><span class="s4">0x30 </span><span class="s0">/* 0 */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x39 </span><span class="s0">/* 9 */</span><span class="s1">)</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape</span>
<span class="s1">pp$1.regexp_eatCharacterClassEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(isCharacterClassEscape(ch)) {</span>
    <span class="s1">state.lastIntValue = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(</span>
    <span class="s1">state.switchU &amp;&amp;</span>
    <span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9 </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(ch === </span><span class="s4">0x50 </span><span class="s0">/* P */ </span><span class="s1">|| ch === </span><span class="s4">0x70 </span><span class="s0">/* p */</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s1">state.lastIntValue = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s1">state.eat(</span><span class="s4">0x7B </span><span class="s0">/* { */</span><span class="s1">) &amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.regexp_eatUnicodePropertyValueExpression(state) &amp;&amp;</span>
      <span class="s1">state.eat(</span><span class="s4">0x7D </span><span class="s0">/* } */</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Invalid property name&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isCharacterClassEscape(ch) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">ch === </span><span class="s4">0x64 </span><span class="s0">/* d */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x44 </span><span class="s0">/* D */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x73 </span><span class="s0">/* s */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x53 </span><span class="s0">/* S */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x77 </span><span class="s0">/* w */ </span><span class="s1">||</span>
    <span class="s1">ch === </span><span class="s4">0x57 </span><span class="s0">/* W */</span>
  <span class="s1">)</span>
<span class="s1">}</span>

<span class="s0">// UnicodePropertyValueExpression ::</span>
<span class="s0">//   UnicodePropertyName `=` UnicodePropertyValue</span>
<span class="s0">//   LoneUnicodePropertyNameOrValue</span>
<span class="s1">pp$1.regexp_eatUnicodePropertyValueExpression = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>

  <span class="s0">// UnicodePropertyName `=` UnicodePropertyValue</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(</span><span class="s4">0x3D </span><span class="s0">/* = */</span><span class="s1">)) {</span>
    <span class="s2">var </span><span class="s1">name = state.lastStringValue</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatUnicodePropertyValue(state)) {</span>
      <span class="s2">var </span><span class="s1">value = state.lastStringValue</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.regexp_validateUnicodePropertyNameAndValue(state</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">state.pos = start</span><span class="s2">;</span>

  <span class="s0">// LoneUnicodePropertyNameOrValue</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatLoneUnicodePropertyNameOrValue(state)) {</span>
    <span class="s2">var </span><span class="s1">nameOrValue = state.lastStringValue</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.regexp_validateUnicodePropertyNameOrValue(state</span><span class="s2">, </span><span class="s1">nameOrValue)</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_validateUnicodePropertyNameAndValue = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s2">if </span><span class="s1">(!hasOwn(state.unicodeProperties.nonBinary</span><span class="s2">, </span><span class="s1">name))</span>
    <span class="s1">{ state.raise(</span><span class="s3">&quot;Invalid property name&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!state.unicodeProperties.nonBinary[name].test(value))</span>
    <span class="s1">{ state.raise(</span><span class="s3">&quot;Invalid property value&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">pp$1.regexp_validateUnicodePropertyNameOrValue = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">nameOrValue) {</span>
  <span class="s2">if </span><span class="s1">(!state.unicodeProperties.binary.test(nameOrValue))</span>
    <span class="s1">{ state.raise(</span><span class="s3">&quot;Invalid property name&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// UnicodePropertyName ::</span>
<span class="s0">//   UnicodePropertyNameCharacters</span>
<span class="s1">pp$1.regexp_eatUnicodePropertyName = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(isUnicodePropertyNameCharacter(ch = state.current())) {</span>
    <span class="s1">state.lastStringValue += codePointToString(ch)</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.lastStringValue !== </span><span class="s3">&quot;&quot;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isUnicodePropertyNameCharacter(ch) {</span>
  <span class="s2">return </span><span class="s1">isControlLetter(ch) || ch === </span><span class="s4">0x5F </span><span class="s0">/* _ */</span>
<span class="s1">}</span>

<span class="s0">// UnicodePropertyValue ::</span>
<span class="s0">//   UnicodePropertyValueCharacters</span>
<span class="s1">pp$1.regexp_eatUnicodePropertyValue = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastStringValue = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(isUnicodePropertyValueCharacter(ch = state.current())) {</span>
    <span class="s1">state.lastStringValue += codePointToString(ch)</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.lastStringValue !== </span><span class="s3">&quot;&quot;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isUnicodePropertyValueCharacter(ch) {</span>
  <span class="s2">return </span><span class="s1">isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)</span>
<span class="s1">}</span>

<span class="s0">// LoneUnicodePropertyNameOrValue ::</span>
<span class="s0">//   UnicodePropertyValueCharacters</span>
<span class="s1">pp$1.regexp_eatLoneUnicodePropertyNameOrValue = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">return this</span><span class="s1">.regexp_eatUnicodePropertyValue(state)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass</span>
<span class="s1">pp$1.regexp_eatCharacterClass = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5B </span><span class="s0">/* [ */</span><span class="s1">)) {</span>
    <span class="s1">state.eat(</span><span class="s4">0x5E </span><span class="s0">/* ^ */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.regexp_classRanges(state)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5D </span><span class="s0">/* ] */</span><span class="s1">)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s0">// Unreachable since it threw &quot;unterminated regular expression&quot; error before.</span>
    <span class="s1">state.raise(</span><span class="s3">&quot;Unterminated character class&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges</span>
<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges</span>
<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash</span>
<span class="s1">pp$1.regexp_classRanges = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatClassAtom(state)) {</span>
    <span class="s2">var </span><span class="s1">left = state.lastIntValue</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x2D </span><span class="s0">/* - */</span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatClassAtom(state)) {</span>
      <span class="s2">var </span><span class="s1">right = state.lastIntValue</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(state.switchU &amp;&amp; (left === -</span><span class="s4">1 </span><span class="s1">|| right === -</span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Invalid character class&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(left !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; right !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; left &gt; right) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Range out of order in character class&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom</span>
<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash</span>
<span class="s1">pp$1.regexp_eatClassAtom = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x5C </span><span class="s0">/* \ */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatClassEscape(state)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.switchU) {</span>
      <span class="s0">// Make the same message as V8.</span>
      <span class="s2">var </span><span class="s1">ch$1 = state.current()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(ch$1 === </span><span class="s4">0x63 </span><span class="s0">/* c */ </span><span class="s1">|| isOctalDigit(ch$1)) {</span>
        <span class="s1">state.raise(</span><span class="s3">&quot;Invalid class escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0x5D </span><span class="s0">/* ] */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = ch</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape</span>
<span class="s1">pp$1.regexp_eatClassEscape = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x62 </span><span class="s0">/* b */</span><span class="s1">)) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x08</span><span class="s2">; </span><span class="s0">/* &lt;BS&gt; */</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.switchU &amp;&amp; state.eat(</span><span class="s4">0x2D </span><span class="s0">/* - */</span><span class="s1">)) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">0x2D</span><span class="s2">; </span><span class="s0">/* - */</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!state.switchU &amp;&amp; state.eat(</span><span class="s4">0x63 </span><span class="s0">/* c */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatClassControlLetter(state)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">(</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterClassEscape(state) ||</span>
    <span class="s2">this</span><span class="s1">.regexp_eatCharacterEscape(state)</span>
  <span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter</span>
<span class="s1">pp$1.regexp_eatClassControlLetter = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isDecimalDigit(ch) || ch === </span><span class="s4">0x5F </span><span class="s0">/* _ */</span><span class="s1">) {</span>
    <span class="s1">state.lastIntValue = ch % </span><span class="s4">0x20</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence</span>
<span class="s1">pp$1.regexp_eatHexEscapeSequence = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(state.eat(</span><span class="s4">0x78 </span><span class="s0">/* x */</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatFixedHexDigits(state</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)) {</span>
      <span class="s2">return true</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(state.switchU) {</span>
      <span class="s1">state.raise(</span><span class="s3">&quot;Invalid escape&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">state.pos = start</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits</span>
<span class="s1">pp$1.regexp_eatDecimalDigits = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(isDecimalDigit(ch = state.current())) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">10 </span><span class="s1">* state.lastIntValue + (ch - </span><span class="s4">0x30 </span><span class="s0">/* 0 */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.pos !== start</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isDecimalDigit(ch) {</span>
  <span class="s2">return </span><span class="s1">ch &gt;= </span><span class="s4">0x30 </span><span class="s0">/* 0 */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x39 </span><span class="s0">/* 9 */</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits</span>
<span class="s1">pp$1.regexp_eatHexDigits = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(isHexDigit(ch = state.current())) {</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">16 </span><span class="s1">* state.lastIntValue + hexToInt(ch)</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.pos !== start</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isHexDigit(ch) {</span>
  <span class="s2">return </span><span class="s1">(</span>
    <span class="s1">(ch &gt;= </span><span class="s4">0x30 </span><span class="s0">/* 0 */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x39 </span><span class="s0">/* 9 */</span><span class="s1">) ||</span>
    <span class="s1">(ch &gt;= </span><span class="s4">0x41 </span><span class="s0">/* A */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x46 </span><span class="s0">/* F */</span><span class="s1">) ||</span>
    <span class="s1">(ch &gt;= </span><span class="s4">0x61 </span><span class="s0">/* a */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x66 </span><span class="s0">/* f */</span><span class="s1">)</span>
  <span class="s1">)</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hexToInt(ch) {</span>
  <span class="s2">if </span><span class="s1">(ch &gt;= </span><span class="s4">0x41 </span><span class="s0">/* A */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x46 </span><span class="s0">/* F */</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s4">10 </span><span class="s1">+ (ch - </span><span class="s4">0x41 </span><span class="s0">/* A */</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(ch &gt;= </span><span class="s4">0x61 </span><span class="s0">/* a */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x66 </span><span class="s0">/* f */</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s4">10 </span><span class="s1">+ (ch - </span><span class="s4">0x61 </span><span class="s0">/* a */</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ch - </span><span class="s4">0x30 </span><span class="s0">/* 0 */</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence</span>
<span class="s0">// Allows only 0-377(octal) i.e. 0-255(decimal).</span>
<span class="s1">pp$1.regexp_eatLegacyOctalEscapeSequence = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatOctalDigit(state)) {</span>
    <span class="s2">var </span><span class="s1">n1 = state.lastIntValue</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.regexp_eatOctalDigit(state)) {</span>
      <span class="s2">var </span><span class="s1">n2 = state.lastIntValue</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(n1 &lt;= </span><span class="s4">3 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.regexp_eatOctalDigit(state)) {</span>
        <span class="s1">state.lastIntValue = n1 * </span><span class="s4">64 </span><span class="s1">+ n2 * </span><span class="s4">8 </span><span class="s1">+ state.lastIntValue</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.lastIntValue = n1 * </span><span class="s4">8 </span><span class="s1">+ n2</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">state.lastIntValue = n1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit</span>
<span class="s1">pp$1.regexp_eatOctalDigit = </span><span class="s2">function</span><span class="s1">(state) {</span>
  <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isOctalDigit(ch)) {</span>
    <span class="s1">state.lastIntValue = ch - </span><span class="s4">0x30</span><span class="s2">; </span><span class="s0">/* 0 */</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
    <span class="s2">return true</span>
  <span class="s1">}</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">return false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isOctalDigit(ch) {</span>
  <span class="s2">return </span><span class="s1">ch &gt;= </span><span class="s4">0x30 </span><span class="s0">/* 0 */ </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">0x37 </span><span class="s0">/* 7 */</span>
<span class="s1">}</span>

<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits</span>
<span class="s0">// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit</span>
<span class="s0">// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence</span>
<span class="s1">pp$1.regexp_eatFixedHexDigits = </span><span class="s2">function</span><span class="s1">(state</span><span class="s2">, </span><span class="s1">length) {</span>
  <span class="s2">var </span><span class="s1">start = state.pos</span><span class="s2">;</span>
  <span class="s1">state.lastIntValue = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s2">var </span><span class="s1">ch = state.current()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isHexDigit(ch)) {</span>
      <span class="s1">state.pos = start</span><span class="s2">;</span>
      <span class="s2">return false</span>
    <span class="s1">}</span>
    <span class="s1">state.lastIntValue = </span><span class="s4">16 </span><span class="s1">* state.lastIntValue + hexToInt(ch)</span><span class="s2">;</span>
    <span class="s1">state.advance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return true</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Object type used to represent tokens. Note that normally, tokens</span>
<span class="s0">// simply exist as properties on the parser object. This is only</span>
<span class="s0">// used for the onToken callback and the external tokenizer.</span>

<span class="s2">var </span><span class="s1">Token = </span><span class="s2">function </span><span class="s1">Token(p) {</span>
  <span class="s2">this</span><span class="s1">.type = p.type</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.value = p.value</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.start = p.start</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.end = p.end</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(p.options.locations)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.loc = </span><span class="s2">new </span><span class="s1">SourceLocation(p</span><span class="s2">, </span><span class="s1">p.startLoc</span><span class="s2">, </span><span class="s1">p.endLoc)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(p.options.ranges)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.range = [p.start</span><span class="s2">, </span><span class="s1">p.end]</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// ## Tokenizer</span>

<span class="s2">var </span><span class="s1">pp = Parser.prototype</span><span class="s2">;</span>

<span class="s0">// Move to the next token</span>

<span class="s1">pp.next = </span><span class="s2">function</span><span class="s1">(ignoreEscapeSequenceInKeyword) {</span>
  <span class="s2">if </span><span class="s1">(!ignoreEscapeSequenceInKeyword &amp;&amp; </span><span class="s2">this</span><span class="s1">.type.keyword &amp;&amp; </span><span class="s2">this</span><span class="s1">.containsEsc)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Escape sequence in keyword &quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.type.keyword)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.onToken)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.options.onToken(</span><span class="s2">new </span><span class="s1">Token(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.lastTokEnd = </span><span class="s2">this</span><span class="s1">.end</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastTokStart = </span><span class="s2">this</span><span class="s1">.start</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastTokEndLoc = </span><span class="s2">this</span><span class="s1">.endLoc</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.lastTokStartLoc = </span><span class="s2">this</span><span class="s1">.startLoc</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.nextToken()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.getToken = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
  <span class="s2">return new </span><span class="s1">Token(</span><span class="s2">this</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// If we're in an ES6 environment, make parsers iterable</span>
<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Symbol !== </span><span class="s3">&quot;undefined&quot;</span><span class="s1">)</span>
  <span class="s1">{ pp[Symbol.iterator] = </span><span class="s2">function</span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">this$1$1 = </span><span class="s2">this;</span>

    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">next: </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s2">var </span><span class="s1">token = this$1$1.getToken()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
          <span class="s1">done: token.type === types$1.eof</span><span class="s2">,</span>
          <span class="s1">value: token</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">; </span><span class="s1">}</span>

<span class="s0">// Toggle strict mode. Re-reads the next number or string to please</span>
<span class="s0">// pedantic tests (`&quot;use strict&quot;; 010;` should fail).</span>

<span class="s0">// Read a single token, updating the parser object's token-related</span>
<span class="s0">// properties.</span>

<span class="s1">pp.nextToken = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">curContext = </span><span class="s2">this</span><span class="s1">.curContext()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!curContext || !curContext.preserveSpace) { </span><span class="s2">this</span><span class="s1">.skipSpace()</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) { </span><span class="s2">this</span><span class="s1">.startLoc = </span><span class="s2">this</span><span class="s1">.curPosition()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &gt;= </span><span class="s2">this</span><span class="s1">.input.length) { </span><span class="s2">return this</span><span class="s1">.finishToken(types$1.eof) }</span>

  <span class="s2">if </span><span class="s1">(curContext.override) { </span><span class="s2">return </span><span class="s1">curContext.override(</span><span class="s2">this</span><span class="s1">) }</span>
  <span class="s2">else </span><span class="s1">{ </span><span class="s2">this</span><span class="s1">.readToken(</span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos())</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken = </span><span class="s2">function</span><span class="s1">(code) {</span>
  <span class="s0">// Identifier or keyword. '\uXXXX' sequences are allowed in</span>
  <span class="s0">// identifiers, so '\' also dispatches to that.</span>
  <span class="s2">if </span><span class="s1">(isIdentifierStart(code</span><span class="s2">, this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) || code === </span><span class="s4">92 </span><span class="s0">/* '\' */</span><span class="s1">)</span>
    <span class="s1">{ </span><span class="s2">return this</span><span class="s1">.readWord() }</span>

  <span class="s2">return this</span><span class="s1">.getTokenFromCode(code)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.fullCharCodeAtPos = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">code = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(code &lt;= </span><span class="s4">0xd7ff </span><span class="s1">|| code &gt;= </span><span class="s4">0xdc00</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">code }</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">next &lt;= </span><span class="s4">0xdbff </span><span class="s1">|| next &gt;= </span><span class="s4">0xe000 </span><span class="s1">? code : (code &lt;&lt; </span><span class="s4">10</span><span class="s1">) + next - </span><span class="s4">0x35fdc00</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.skipBlockComment = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.options.onComment &amp;&amp; </span><span class="s2">this</span><span class="s1">.curPosition()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">end = </span><span class="s2">this</span><span class="s1">.input.indexOf(</span><span class="s3">&quot;*/&quot;</span><span class="s2">, this</span><span class="s1">.pos += </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(end === -</span><span class="s4">1</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos - </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;Unterminated comment&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.pos = end + </span><span class="s4">2</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">nextBreak = (</span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pos = start</span><span class="s2">; </span><span class="s1">(nextBreak = nextLineBreak(</span><span class="s2">this</span><span class="s1">.input</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, this</span><span class="s1">.pos)) &gt; -</span><span class="s4">1</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.curLine</span><span class="s2">;</span>
      <span class="s1">pos = </span><span class="s2">this</span><span class="s1">.lineStart = nextBreak</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.onComment)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.options.onComment(</span><span class="s2">true, this</span><span class="s1">.input.slice(start + </span><span class="s4">2</span><span class="s2">, </span><span class="s1">end)</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, this</span><span class="s1">.pos</span><span class="s2">,</span>
                           <span class="s1">startLoc</span><span class="s2">, this</span><span class="s1">.curPosition())</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.skipLineComment = </span><span class="s2">function</span><span class="s1">(startSkip) {</span>
  <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">startLoc = </span><span class="s2">this</span><span class="s1">.options.onComment &amp;&amp; </span><span class="s2">this</span><span class="s1">.curPosition()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos += startSkip)</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &lt; </span><span class="s2">this</span><span class="s1">.input.length &amp;&amp; !isNewLine(ch)) {</span>
    <span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(++</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.onComment)</span>
    <span class="s1">{ </span><span class="s2">this</span><span class="s1">.options.onComment(</span><span class="s2">false, this</span><span class="s1">.input.slice(start + startSkip</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, this</span><span class="s1">.pos</span><span class="s2">,</span>
                           <span class="s1">startLoc</span><span class="s2">, this</span><span class="s1">.curPosition())</span><span class="s2">; </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Called at the start of the parse and after every token. Skips</span>
<span class="s0">// whitespace and comments, and.</span>

<span class="s1">pp.skipSpace = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s1">loop: </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &lt; </span><span class="s2">this</span><span class="s1">.input.length) {</span>
    <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(ch) {</span>
    <span class="s2">case </span><span class="s4">32</span><span class="s1">: </span><span class="s2">case </span><span class="s4">160</span><span class="s1">: </span><span class="s0">// ' '</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">break</span>
    <span class="s2">case </span><span class="s4">13</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">10</span><span class="s1">) {</span>
        <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s2">case </span><span class="s4">10</span><span class="s1">: </span><span class="s2">case </span><span class="s4">8232</span><span class="s1">: </span><span class="s2">case </span><span class="s4">8233</span><span class="s1">:</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) {</span>
        <span class="s1">++</span><span class="s2">this</span><span class="s1">.curLine</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.lineStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">break</span>
    <span class="s2">case </span><span class="s4">47</span><span class="s1">: </span><span class="s0">// '/'</span>
      <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)) {</span>
      <span class="s2">case </span><span class="s4">42</span><span class="s1">: </span><span class="s0">// '*'</span>
        <span class="s2">this</span><span class="s1">.skipBlockComment()</span><span class="s2">;</span>
        <span class="s2">break</span>
      <span class="s2">case </span><span class="s4">47</span><span class="s1">:</span>
        <span class="s2">this</span><span class="s1">.skipLineComment(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">break</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">break </span><span class="s1">loop</span>
      <span class="s1">}</span>
      <span class="s2">break</span>
    <span class="s2">default</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(ch &gt; </span><span class="s4">8 </span><span class="s1">&amp;&amp; ch &lt; </span><span class="s4">14 </span><span class="s1">|| ch &gt;= </span><span class="s4">5760 </span><span class="s1">&amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {</span>
        <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">break </span><span class="s1">loop</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Called at the end of every token. Sets `end`, `val`, and</span>
<span class="s0">// maintains `context` and `exprAllowed`, and skips the space after</span>
<span class="s0">// the token, so that the next one's `start` will point at the</span>
<span class="s0">// right position.</span>

<span class="s1">pp.finishToken = </span><span class="s2">function</span><span class="s1">(type</span><span class="s2">, </span><span class="s1">val) {</span>
  <span class="s2">this</span><span class="s1">.end = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) { </span><span class="s2">this</span><span class="s1">.endLoc = </span><span class="s2">this</span><span class="s1">.curPosition()</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">prevType = </span><span class="s2">this</span><span class="s1">.type</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.type = type</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.value = val</span><span class="s2">;</span>

  <span class="s2">this</span><span class="s1">.updateContext(prevType)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// ### Token reading</span>

<span class="s0">// This is the function that is called to fetch the next token. It</span>
<span class="s0">// is somewhat obscure, because it works in character codes rather</span>
<span class="s0">// than characters, and because operator parsing has been inlined</span>
<span class="s0">// into it.</span>
<span class="s0">//</span>
<span class="s0">// All in the name of speed.</span>
<span class="s0">//</span>
<span class="s1">pp.readToken_dot = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next &gt;= </span><span class="s4">48 </span><span class="s1">&amp;&amp; next &lt;= </span><span class="s4">57</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.readNumber(</span><span class="s2">true</span><span class="s1">) }</span>
  <span class="s2">var </span><span class="s1">next2 = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6 </span><span class="s1">&amp;&amp; next === </span><span class="s4">46 </span><span class="s1">&amp;&amp; next2 === </span><span class="s4">46</span><span class="s1">) { </span><span class="s0">// 46 = dot '.'</span>
    <span class="s2">this</span><span class="s1">.pos += </span><span class="s4">3</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishToken(types$1.ellipsis)</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishToken(types$1.dot)</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_slash = </span><span class="s2">function</span><span class="s1">() { </span><span class="s0">// '/'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.exprAllowed) { ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.readRegexp() }</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) }</span>
  <span class="s2">return this</span><span class="s1">.finishOp(types$1.slash</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_mult_modulo_exp = </span><span class="s2">function</span><span class="s1">(code) { </span><span class="s0">// '%*'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">size = </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">tokentype = code === </span><span class="s4">42 </span><span class="s1">? types$1.star : types$1.modulo</span><span class="s2">;</span>

  <span class="s0">// exponentiation operator ** and **=</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">7 </span><span class="s1">&amp;&amp; code === </span><span class="s4">42 </span><span class="s1">&amp;&amp; next === </span><span class="s4">42</span><span class="s1">) {</span>
    <span class="s1">++size</span><span class="s2">;</span>
    <span class="s1">tokentype = types$1.starstar</span><span class="s2">;</span>
    <span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s1">size + </span><span class="s4">1</span><span class="s1">) }</span>
  <span class="s2">return this</span><span class="s1">.finishOp(tokentype</span><span class="s2">, </span><span class="s1">size)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_pipe_amp = </span><span class="s2">function</span><span class="s1">(code) { </span><span class="s0">// '|&amp;'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next === code) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">12</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">next2 = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(next2 === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">3</span><span class="s1">) }</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishOp(code === </span><span class="s4">124 </span><span class="s1">? types$1.logicalOR : types$1.logicalAND</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) }</span>
  <span class="s2">return this</span><span class="s1">.finishOp(code === </span><span class="s4">124 </span><span class="s1">? types$1.bitwiseOR : types$1.bitwiseAND</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_caret = </span><span class="s2">function</span><span class="s1">() { </span><span class="s0">// '^'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) }</span>
  <span class="s2">return this</span><span class="s1">.finishOp(types$1.bitwiseXOR</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_plus_min = </span><span class="s2">function</span><span class="s1">(code) { </span><span class="s0">// '+-'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next === code) {</span>
    <span class="s2">if </span><span class="s1">(next === </span><span class="s4">45 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">62 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(</span><span class="s2">this</span><span class="s1">.lastTokEnd === </span><span class="s4">0 </span><span class="s1">|| lineBreak.test(</span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.lastTokEnd</span><span class="s2">, this</span><span class="s1">.pos)))) {</span>
      <span class="s0">// A `--&gt;` line comment</span>
      <span class="s2">this</span><span class="s1">.skipLineComment(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.skipSpace()</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.nextToken()</span>
    <span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishOp(types$1.incDec</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) }</span>
  <span class="s2">return this</span><span class="s1">.finishOp(types$1.plusMin</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_lt_gt = </span><span class="s2">function</span><span class="s1">(code) { </span><span class="s0">// '&lt;&gt;'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">size = </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next === code) {</span>
    <span class="s1">size = code === </span><span class="s4">62 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">62 </span><span class="s1">? </span><span class="s4">3 </span><span class="s1">: </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + size) === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s1">size + </span><span class="s4">1</span><span class="s1">) }</span>
    <span class="s2">return this</span><span class="s1">.finishOp(types$1.bitShift</span><span class="s2">, </span><span class="s1">size)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">33 </span><span class="s1">&amp;&amp; code === </span><span class="s4">60 </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.inModule &amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">45 </span><span class="s1">&amp;&amp;</span>
      <span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">3</span><span class="s1">) === </span><span class="s4">45</span><span class="s1">) {</span>
    <span class="s0">// `&lt;!--`, an XML-style comment that should be interpreted as a line comment</span>
    <span class="s2">this</span><span class="s1">.skipLineComment(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.skipSpace()</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.nextToken()</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { size = </span><span class="s4">2</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishOp(types$1.relational</span><span class="s2">, </span><span class="s1">size)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_eq_excl = </span><span class="s2">function</span><span class="s1">(code) { </span><span class="s0">// '=!'</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.equality</span><span class="s2">, this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">61 </span><span class="s1">? </span><span class="s4">3 </span><span class="s1">: </span><span class="s4">2</span><span class="s1">) }</span>
  <span class="s2">if </span><span class="s1">(code === </span><span class="s4">61 </span><span class="s1">&amp;&amp; next === </span><span class="s4">62 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) { </span><span class="s0">// '=&gt;'</span>
    <span class="s2">this</span><span class="s1">.pos += </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishToken(types$1.arrow)</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishOp(code === </span><span class="s4">61 </span><span class="s1">? types$1.eq : types$1.prefix</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_question = </span><span class="s2">function</span><span class="s1">() { </span><span class="s0">// '?'</span>
  <span class="s2">var </span><span class="s1">ecmaVersion = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ecmaVersion &gt;= </span><span class="s4">11</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(next === </span><span class="s4">46</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">next2 = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(next2 &lt; </span><span class="s4">48 </span><span class="s1">|| next2 &gt; </span><span class="s4">57</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.questionDot</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) }</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(next === </span><span class="s4">63</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(ecmaVersion &gt;= </span><span class="s4">12</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">next2$1 = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(next2$1 === </span><span class="s4">61</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.finishOp(types$1.assign</span><span class="s2">, </span><span class="s4">3</span><span class="s1">) }</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.finishOp(types$1.coalesce</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishOp(types$1.question</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readToken_numberSign = </span><span class="s2">function</span><span class="s1">() { </span><span class="s0">// '#'</span>
  <span class="s2">var </span><span class="s1">ecmaVersion = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">code = </span><span class="s4">35</span><span class="s2">; </span><span class="s0">// '#'</span>
  <span class="s2">if </span><span class="s1">(ecmaVersion &gt;= </span><span class="s4">13</span><span class="s1">) {</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">code = </span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isIdentifierStart(code</span><span class="s2">, true</span><span class="s1">) || code === </span><span class="s4">92 </span><span class="s0">/* '\' */</span><span class="s1">) {</span>
      <span class="s2">return this</span><span class="s1">.finishToken(types$1.privateId</span><span class="s2">, this</span><span class="s1">.readWord1())</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Unexpected character '&quot; </span><span class="s1">+ codePointToString(code) + </span><span class="s3">&quot;'&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.getTokenFromCode = </span><span class="s2">function</span><span class="s1">(code) {</span>
  <span class="s2">switch </span><span class="s1">(code) {</span>
  <span class="s0">// The interpretation of a dot depends on whether it is followed</span>
  <span class="s0">// by a digit or another two dots.</span>
  <span class="s2">case </span><span class="s4">46</span><span class="s1">: </span><span class="s0">// '.'</span>
    <span class="s2">return this</span><span class="s1">.readToken_dot()</span>

  <span class="s0">// Punctuation tokens.</span>
  <span class="s2">case </span><span class="s4">40</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.parenL)</span>
  <span class="s2">case </span><span class="s4">41</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.parenR)</span>
  <span class="s2">case </span><span class="s4">59</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.semi)</span>
  <span class="s2">case </span><span class="s4">44</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.comma)</span>
  <span class="s2">case </span><span class="s4">91</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.bracketL)</span>
  <span class="s2">case </span><span class="s4">93</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.bracketR)</span>
  <span class="s2">case </span><span class="s4">123</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.braceL)</span>
  <span class="s2">case </span><span class="s4">125</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.braceR)</span>
  <span class="s2">case </span><span class="s4">58</span><span class="s1">: ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; return this</span><span class="s1">.finishToken(types$1.colon)</span>

  <span class="s2">case </span><span class="s4">96</span><span class="s1">: </span><span class="s0">// '`'</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">6</span><span class="s1">) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">.finishToken(types$1.backQuote)</span>

  <span class="s2">case </span><span class="s4">48</span><span class="s1">: </span><span class="s0">// '0'</span>
    <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(next === </span><span class="s4">120 </span><span class="s1">|| next === </span><span class="s4">88</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.readRadixNumber(</span><span class="s4">16</span><span class="s1">) } </span><span class="s0">// '0x', '0X' - hex number</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(next === </span><span class="s4">111 </span><span class="s1">|| next === </span><span class="s4">79</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.readRadixNumber(</span><span class="s4">8</span><span class="s1">) } </span><span class="s0">// '0o', '0O' - octal number</span>
      <span class="s2">if </span><span class="s1">(next === </span><span class="s4">98 </span><span class="s1">|| next === </span><span class="s4">66</span><span class="s1">) { </span><span class="s2">return this</span><span class="s1">.readRadixNumber(</span><span class="s4">2</span><span class="s1">) } </span><span class="s0">// '0b', '0B' - binary number</span>
    <span class="s1">}</span>

  <span class="s0">// Anything else beginning with a digit is an integer, octal</span>
  <span class="s0">// number, or float.</span>
  <span class="s2">case </span><span class="s4">49</span><span class="s1">: </span><span class="s2">case </span><span class="s4">50</span><span class="s1">: </span><span class="s2">case </span><span class="s4">51</span><span class="s1">: </span><span class="s2">case </span><span class="s4">52</span><span class="s1">: </span><span class="s2">case </span><span class="s4">53</span><span class="s1">: </span><span class="s2">case </span><span class="s4">54</span><span class="s1">: </span><span class="s2">case </span><span class="s4">55</span><span class="s1">: </span><span class="s2">case </span><span class="s4">56</span><span class="s1">: </span><span class="s2">case </span><span class="s4">57</span><span class="s1">: </span><span class="s0">// 1-9</span>
    <span class="s2">return this</span><span class="s1">.readNumber(</span><span class="s2">false</span><span class="s1">)</span>

  <span class="s0">// Quotes produce strings.</span>
  <span class="s2">case </span><span class="s4">34</span><span class="s1">: </span><span class="s2">case </span><span class="s4">39</span><span class="s1">: </span><span class="s0">// '&quot;', &quot;'&quot;</span>
    <span class="s2">return this</span><span class="s1">.readString(code)</span>

  <span class="s0">// Operators are parsed inline in tiny state machines. '=' (61) is</span>
  <span class="s0">// often referred to. `finishOp` simply skips the amount of</span>
  <span class="s0">// characters it is given as second argument, and returns a token</span>
  <span class="s0">// of the type given by its first argument.</span>
  <span class="s2">case </span><span class="s4">47</span><span class="s1">: </span><span class="s0">// '/'</span>
    <span class="s2">return this</span><span class="s1">.readToken_slash()</span>

  <span class="s2">case </span><span class="s4">37</span><span class="s1">: </span><span class="s2">case </span><span class="s4">42</span><span class="s1">: </span><span class="s0">// '%*'</span>
    <span class="s2">return this</span><span class="s1">.readToken_mult_modulo_exp(code)</span>

  <span class="s2">case </span><span class="s4">124</span><span class="s1">: </span><span class="s2">case </span><span class="s4">38</span><span class="s1">: </span><span class="s0">// '|&amp;'</span>
    <span class="s2">return this</span><span class="s1">.readToken_pipe_amp(code)</span>

  <span class="s2">case </span><span class="s4">94</span><span class="s1">: </span><span class="s0">// '^'</span>
    <span class="s2">return this</span><span class="s1">.readToken_caret()</span>

  <span class="s2">case </span><span class="s4">43</span><span class="s1">: </span><span class="s2">case </span><span class="s4">45</span><span class="s1">: </span><span class="s0">// '+-'</span>
    <span class="s2">return this</span><span class="s1">.readToken_plus_min(code)</span>

  <span class="s2">case </span><span class="s4">60</span><span class="s1">: </span><span class="s2">case </span><span class="s4">62</span><span class="s1">: </span><span class="s0">// '&lt;&gt;'</span>
    <span class="s2">return this</span><span class="s1">.readToken_lt_gt(code)</span>

  <span class="s2">case </span><span class="s4">61</span><span class="s1">: </span><span class="s2">case </span><span class="s4">33</span><span class="s1">: </span><span class="s0">// '=!'</span>
    <span class="s2">return this</span><span class="s1">.readToken_eq_excl(code)</span>

  <span class="s2">case </span><span class="s4">63</span><span class="s1">: </span><span class="s0">// '?'</span>
    <span class="s2">return this</span><span class="s1">.readToken_question()</span>

  <span class="s2">case </span><span class="s4">126</span><span class="s1">: </span><span class="s0">// '~'</span>
    <span class="s2">return this</span><span class="s1">.finishOp(types$1.prefix</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

  <span class="s2">case </span><span class="s4">35</span><span class="s1">: </span><span class="s0">// '#'</span>
    <span class="s2">return this</span><span class="s1">.readToken_numberSign()</span>
  <span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Unexpected character '&quot; </span><span class="s1">+ codePointToString(code) + </span><span class="s3">&quot;'&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.finishOp = </span><span class="s2">function</span><span class="s1">(type</span><span class="s2">, </span><span class="s1">size) {</span>
  <span class="s2">var </span><span class="s1">str = </span><span class="s2">this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, this</span><span class="s1">.pos + size)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.pos += size</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishToken(type</span><span class="s2">, </span><span class="s1">str)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readRegexp = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">escaped</span><span class="s2">, </span><span class="s1">inClass</span><span class="s2">, </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &gt;= </span><span class="s2">this</span><span class="s1">.input.length) { </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s3">&quot;Unterminated regular expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(lineBreak.test(ch)) { </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s3">&quot;Unterminated regular expression&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!escaped) {</span>
      <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">&quot;[&quot;</span><span class="s1">) { inClass = </span><span class="s2">true; </span><span class="s1">}</span>
      <span class="s2">else if </span><span class="s1">(ch === </span><span class="s3">&quot;]&quot; </span><span class="s1">&amp;&amp; inClass) { inClass = </span><span class="s2">false; </span><span class="s1">}</span>
      <span class="s2">else if </span><span class="s1">(ch === </span><span class="s3">&quot;/&quot; </span><span class="s1">&amp;&amp; !inClass) { </span><span class="s2">break </span><span class="s1">}</span>
      <span class="s1">escaped = ch === </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{ escaped = </span><span class="s2">false; </span><span class="s1">}</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">var </span><span class="s1">pattern = </span><span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">flagsStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">flags = </span><span class="s2">this</span><span class="s1">.readWord1()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.containsEsc) { </span><span class="s2">this</span><span class="s1">.unexpected(flagsStart)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s0">// Validate pattern</span>
  <span class="s2">var </span><span class="s1">state = </span><span class="s2">this</span><span class="s1">.regexpState || (</span><span class="s2">this</span><span class="s1">.regexpState = </span><span class="s2">new </span><span class="s1">RegExpValidationState(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">state.reset(start</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">flags)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.validateRegExpFlags(state)</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.validateRegExpPattern(state)</span><span class="s2">;</span>

  <span class="s0">// Create Literal#value property value.</span>
  <span class="s2">var </span><span class="s1">value = </span><span class="s2">null;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">value = </span><span class="s2">new </span><span class="s1">RegExp(pattern</span><span class="s2">, </span><span class="s1">flags)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
    <span class="s0">// ESTree requires null if it failed to instantiate RegExp object.</span>
    <span class="s0">// https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral</span>
  <span class="s1">}</span>

  <span class="s2">return this</span><span class="s1">.finishToken(types$1.regexp</span><span class="s2">, </span><span class="s1">{pattern: pattern</span><span class="s2">, </span><span class="s1">flags: flags</span><span class="s2">, </span><span class="s1">value: value})</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Read an integer in the given radix. Return null if zero digits</span>
<span class="s0">// were read, the integer value otherwise. When `len` is given, this</span>
<span class="s0">// will return `null` unless the integer has exactly `len` digits.</span>

<span class="s1">pp.readInt = </span><span class="s2">function</span><span class="s1">(radix</span><span class="s2">, </span><span class="s1">len</span><span class="s2">, </span><span class="s1">maybeLegacyOctalNumericLiteral) {</span>
  <span class="s0">// `len` is used for character escape sequences. In that case, disallow separators.</span>
  <span class="s2">var </span><span class="s1">allowSeparators = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">12 </span><span class="s1">&amp;&amp; len === undefined</span><span class="s2">;</span>

  <span class="s0">// `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)</span>
  <span class="s0">// and isn't fraction part nor exponent part. In that case, if the first digit</span>
  <span class="s0">// is zero then disallow separators.</span>
  <span class="s2">var </span><span class="s1">isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral &amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos) === </span><span class="s4">48</span><span class="s2">;</span>

  <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s1">total = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">lastCode = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">e = len == </span><span class="s2">null </span><span class="s1">? Infinity : len</span><span class="s2">; </span><span class="s1">i &lt; e</span><span class="s2">; </span><span class="s1">++i</span><span class="s2">, </span><span class="s1">++</span><span class="s2">this</span><span class="s1">.pos) {</span>
    <span class="s2">var </span><span class="s1">code = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">, </span><span class="s1">val = (</span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(allowSeparators &amp;&amp; code === </span><span class="s4">95</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isLegacyOctalNumericLiteral) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Numeric separator is not allowed in legacy octal numeric literals&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(lastCode === </span><span class="s4">95</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Numeric separator must be exactly one underscore&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(i === </span><span class="s4">0</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Numeric separator is not allowed at the first of digits&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">lastCode = code</span><span class="s2">;</span>
      <span class="s2">continue</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(code &gt;= </span><span class="s4">97</span><span class="s1">) { val = code - </span><span class="s4">97 </span><span class="s1">+ </span><span class="s4">10</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// a</span>
    <span class="s2">else if </span><span class="s1">(code &gt;= </span><span class="s4">65</span><span class="s1">) { val = code - </span><span class="s4">65 </span><span class="s1">+ </span><span class="s4">10</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// A</span>
    <span class="s2">else if </span><span class="s1">(code &gt;= </span><span class="s4">48 </span><span class="s1">&amp;&amp; code &lt;= </span><span class="s4">57</span><span class="s1">) { val = code - </span><span class="s4">48</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// 0-9</span>
    <span class="s2">else </span><span class="s1">{ val = Infinity</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(val &gt;= radix) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s1">lastCode = code</span><span class="s2">;</span>
    <span class="s1">total = total * radix + val</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(allowSeparators &amp;&amp; lastCode === </span><span class="s4">95</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raiseRecoverable(</span><span class="s2">this</span><span class="s1">.pos - </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;Numeric separator is not allowed at the last of digits&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos === start || len != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.pos - start !== len) { </span><span class="s2">return null </span><span class="s1">}</span>

  <span class="s2">return </span><span class="s1">total</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">stringToNumber(str</span><span class="s2">, </span><span class="s1">isLegacyOctalNumericLiteral) {</span>
  <span class="s2">if </span><span class="s1">(isLegacyOctalNumericLiteral) {</span>
    <span class="s2">return </span><span class="s1">parseInt(str</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
  <span class="s1">}</span>

  <span class="s0">// `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.</span>
  <span class="s2">return </span><span class="s1">parseFloat(str.replace(</span><span class="s4">/_/g</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">stringToBigInt(str) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">BigInt !== </span><span class="s3">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s2">return null</span>
  <span class="s1">}</span>

  <span class="s0">// `BigInt(value)` throws syntax error if the string contains numeric separators.</span>
  <span class="s2">return </span><span class="s1">BigInt(str.replace(</span><span class="s4">/_/g</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
<span class="s1">}</span>

<span class="s1">pp.readRadixNumber = </span><span class="s2">function</span><span class="s1">(radix) {</span>
  <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">this</span><span class="s1">.pos += </span><span class="s4">2</span><span class="s2">; </span><span class="s0">// 0x</span>
  <span class="s2">var </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">.readInt(radix)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(val == </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start + </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;Expected number in radix &quot; </span><span class="s1">+ radix)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos) === </span><span class="s4">110</span><span class="s1">) {</span>
    <span class="s1">val = stringToBigInt(</span><span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, this</span><span class="s1">.pos))</span><span class="s2">;</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isIdentifierStart(</span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos())) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Identifier directly after number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishToken(types$1.num</span><span class="s2">, </span><span class="s1">val)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Read an integer, octal integer, or floating-point number.</span>

<span class="s1">pp.readNumber = </span><span class="s2">function</span><span class="s1">(startsWithDot) {</span>
  <span class="s2">var </span><span class="s1">start = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!startsWithDot &amp;&amp; </span><span class="s2">this</span><span class="s1">.readInt(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true</span><span class="s1">) === </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s3">&quot;Invalid number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">octal = </span><span class="s2">this</span><span class="s1">.pos - start &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(start) === </span><span class="s4">48</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(octal &amp;&amp; </span><span class="s2">this</span><span class="s1">.strict) { </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s3">&quot;Invalid number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">var </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!octal &amp;&amp; !startsWithDot &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11 </span><span class="s1">&amp;&amp; next === </span><span class="s4">110</span><span class="s1">) {</span>
    <span class="s2">var </span><span class="s1">val$1 = stringToBigInt(</span><span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, this</span><span class="s1">.pos))</span><span class="s2">;</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isIdentifierStart(</span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos())) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Identifier directly after number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return this</span><span class="s1">.finishToken(types$1.num</span><span class="s2">, </span><span class="s1">val$1)</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(octal &amp;&amp; </span><span class="s4">/[89]/</span><span class="s1">.test(</span><span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, this</span><span class="s1">.pos))) { octal = </span><span class="s2">false; </span><span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(next === </span><span class="s4">46 </span><span class="s1">&amp;&amp; !octal) { </span><span class="s0">// '.'</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.readInt(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">((next === </span><span class="s4">69 </span><span class="s1">|| next === </span><span class="s4">101</span><span class="s1">) &amp;&amp; !octal) { </span><span class="s0">// 'eE'</span>
    <span class="s1">next = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(++</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(next === </span><span class="s4">43 </span><span class="s1">|| next === </span><span class="s4">45</span><span class="s1">) { ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// '+-'</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.readInt(</span><span class="s4">10</span><span class="s1">) === </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(start</span><span class="s2">, </span><span class="s3">&quot;Invalid number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isIdentifierStart(</span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos())) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Identifier directly after number&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>

  <span class="s2">var </span><span class="s1">val = stringToNumber(</span><span class="s2">this</span><span class="s1">.input.slice(start</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">, </span><span class="s1">octal)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishToken(types$1.num</span><span class="s2">, </span><span class="s1">val)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Read a string value, interpreting backslash-escapes.</span>

<span class="s1">pp.readCodePoint = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">, </span><span class="s1">code</span><span class="s2">;</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">123</span><span class="s1">) { </span><span class="s0">// '{'</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">6</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">codePos = ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">code = </span><span class="s2">this</span><span class="s1">.readHexChar(</span><span class="s2">this</span><span class="s1">.input.indexOf(</span><span class="s3">&quot;}&quot;</span><span class="s2">, this</span><span class="s1">.pos) - </span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(code &gt; </span><span class="s4">0x10FFFF</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.invalidStringToken(codePos</span><span class="s2">, </span><span class="s3">&quot;Code point out of bounds&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">code = </span><span class="s2">this</span><span class="s1">.readHexChar(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">code</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readString = </span><span class="s2">function</span><span class="s1">(quote) {</span>
  <span class="s2">var </span><span class="s1">out = </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">chunkStart = ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &gt;= </span><span class="s2">this</span><span class="s1">.input.length) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unterminated string constant&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ch === quote) { </span><span class="s2">break </span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">92</span><span class="s1">) { </span><span class="s0">// '\'</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.readEscapedChar(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0x2028 </span><span class="s1">|| ch === </span><span class="s4">0x2029</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &lt; </span><span class="s4">10</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unterminated string constant&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) {</span>
        <span class="s2">this</span><span class="s1">.curLine++</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.lineStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(isNewLine(ch)) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unterminated string constant&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">out += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos++)</span><span class="s2">;</span>
  <span class="s2">return this</span><span class="s1">.finishToken(types$1.string</span><span class="s2">, </span><span class="s1">out)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Reads template string tokens.</span>

<span class="s2">var </span><span class="s1">INVALID_TEMPLATE_ESCAPE_ERROR = {}</span><span class="s2">;</span>

<span class="s1">pp.tryReadTemplateToken = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.inTemplateElement = </span><span class="s2">true;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.readTmplToken()</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">if </span><span class="s1">(err === INVALID_TEMPLATE_ESCAPE_ERROR) {</span>
      <span class="s2">this</span><span class="s1">.readInvalidTemplateToken()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw </span><span class="s1">err</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">this</span><span class="s1">.inTemplateElement = </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.invalidStringToken = </span><span class="s2">function</span><span class="s1">(position</span><span class="s2">, </span><span class="s1">message) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.inTemplateElement &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
    <span class="s2">throw </span><span class="s1">INVALID_TEMPLATE_ESCAPE_ERROR</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">this</span><span class="s1">.raise(position</span><span class="s2">, </span><span class="s1">message)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s1">pp.readTmplToken = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">out = </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">;;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &gt;= </span><span class="s2">this</span><span class="s1">.input.length) { </span><span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unterminated template&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">96 </span><span class="s1">|| ch === </span><span class="s4">36 </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">123</span><span class="s1">) { </span><span class="s0">// '`', '${'</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos === </span><span class="s2">this</span><span class="s1">.start &amp;&amp; (</span><span class="s2">this</span><span class="s1">.type === types$1.template || </span><span class="s2">this</span><span class="s1">.type === types$1.invalidTemplate)) {</span>
        <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">36</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.pos += </span><span class="s4">2</span><span class="s2">;</span>
          <span class="s2">return this</span><span class="s1">.finishToken(types$1.dollarBraceL)</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
          <span class="s2">return this</span><span class="s1">.finishToken(types$1.backQuote)</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.finishToken(types$1.template</span><span class="s2">, </span><span class="s1">out)</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">92</span><span class="s1">) { </span><span class="s0">// '\'</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.readEscapedChar(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isNewLine(ch)) {</span>
      <span class="s1">out += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">switch </span><span class="s1">(ch) {</span>
      <span class="s2">case </span><span class="s4">13</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos) === </span><span class="s4">10</span><span class="s1">) { ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s2">case </span><span class="s4">10</span><span class="s1">:</span>
        <span class="s1">out += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
        <span class="s2">break</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s1">out += String.fromCharCode(ch)</span><span class="s2">;</span>
        <span class="s2">break</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) {</span>
        <span class="s1">++</span><span class="s2">this</span><span class="s1">.curLine</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.lineStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Reads a template token to search for the end, without validating any escape sequences</span>
<span class="s1">pp.readInvalidTemplateToken = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">; this</span><span class="s1">.pos &lt; </span><span class="s2">this</span><span class="s1">.input.length</span><span class="s2">; this</span><span class="s1">.pos++) {</span>
    <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input[</span><span class="s2">this</span><span class="s1">.pos]) {</span>
    <span class="s2">case </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">:</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">break</span>

    <span class="s2">case </span><span class="s3">&quot;$&quot;</span><span class="s1">:</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input[</span><span class="s2">this</span><span class="s1">.pos + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">&quot;{&quot;</span><span class="s1">) {</span>
        <span class="s2">break</span>
      <span class="s1">}</span>

    <span class="s0">// falls through</span>
    <span class="s2">case </span><span class="s3">&quot;`&quot;</span><span class="s1">:</span>
      <span class="s2">return this</span><span class="s1">.finishToken(types$1.invalidTemplate</span><span class="s2">, this</span><span class="s1">.input.slice(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, this</span><span class="s1">.pos))</span>

    <span class="s0">// no default</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.start</span><span class="s2">, </span><span class="s3">&quot;Unterminated template&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Used to read escaped characters</span>

<span class="s1">pp.readEscapedChar = </span><span class="s2">function</span><span class="s1">(inTemplate) {</span>
  <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(++</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
  <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">switch </span><span class="s1">(ch) {</span>
  <span class="s2">case </span><span class="s4">110</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s0">// 'n' -&gt; '\n'</span>
  <span class="s2">case </span><span class="s4">114</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot; </span><span class="s0">// 'r' -&gt; '\r'</span>
  <span class="s2">case </span><span class="s4">120</span><span class="s1">: </span><span class="s2">return </span><span class="s1">String.fromCharCode(</span><span class="s2">this</span><span class="s1">.readHexChar(</span><span class="s4">2</span><span class="s1">)) </span><span class="s0">// 'x'</span>
  <span class="s2">case </span><span class="s4">117</span><span class="s1">: </span><span class="s2">return </span><span class="s1">codePointToString(</span><span class="s2">this</span><span class="s1">.readCodePoint()) </span><span class="s0">// 'u'</span>
  <span class="s2">case </span><span class="s4">116</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot; </span><span class="s0">// 't' -&gt; '\t'</span>
  <span class="s2">case </span><span class="s4">98</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\b</span><span class="s3">&quot; </span><span class="s0">// 'b' -&gt; '\b'</span>
  <span class="s2">case </span><span class="s4">118</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\u000b</span><span class="s3">&quot; </span><span class="s0">// 'v' -&gt; '\u000b'</span>
  <span class="s2">case </span><span class="s4">102</span><span class="s1">: </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\f</span><span class="s3">&quot; </span><span class="s0">// 'f' -&gt; '\f'</span>
  <span class="s2">case </span><span class="s4">13</span><span class="s1">: </span><span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos) === </span><span class="s4">10</span><span class="s1">) { ++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; </span><span class="s1">} </span><span class="s0">// '\r\n'</span>
  <span class="s2">case </span><span class="s4">10</span><span class="s1">: </span><span class="s0">// ' \n'</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.locations) { </span><span class="s2">this</span><span class="s1">.lineStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">; </span><span class="s1">++</span><span class="s2">this</span><span class="s1">.curLine</span><span class="s2">; </span><span class="s1">}</span>
    <span class="s2">return </span><span class="s3">&quot;&quot;</span>
  <span class="s2">case </span><span class="s4">56</span><span class="s1">:</span>
  <span class="s2">case </span><span class="s4">57</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.strict) {</span>
      <span class="s2">this</span><span class="s1">.invalidStringToken(</span>
        <span class="s2">this</span><span class="s1">.pos - </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s3">&quot;Invalid escape sequence&quot;</span>
      <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(inTemplate) {</span>
      <span class="s2">var </span><span class="s1">codePos = </span><span class="s2">this</span><span class="s1">.pos - </span><span class="s4">1</span><span class="s2">;</span>

      <span class="s2">this</span><span class="s1">.invalidStringToken(</span>
        <span class="s1">codePos</span><span class="s2">,</span>
        <span class="s3">&quot;Invalid escape sequence in template string&quot;</span>
      <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s2">default</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">(ch &gt;= </span><span class="s4">48 </span><span class="s1">&amp;&amp; ch &lt;= </span><span class="s4">55</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">octalStr = </span><span class="s2">this</span><span class="s1">.input.substr(</span><span class="s2">this</span><span class="s1">.pos - </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">).match(</span><span class="s4">/^[0-7]+/</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">octal = parseInt(octalStr</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(octal &gt; </span><span class="s4">255</span><span class="s1">) {</span>
        <span class="s1">octalStr = octalStr.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">octal = parseInt(octalStr</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.pos += octalStr.length - </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s1">ch = </span><span class="s2">this</span><span class="s1">.input.charCodeAt(</span><span class="s2">this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">((octalStr !== </span><span class="s3">&quot;0&quot; </span><span class="s1">|| ch === </span><span class="s4">56 </span><span class="s1">|| ch === </span><span class="s4">57</span><span class="s1">) &amp;&amp; (</span><span class="s2">this</span><span class="s1">.strict || inTemplate)) {</span>
        <span class="s2">this</span><span class="s1">.invalidStringToken(</span>
          <span class="s2">this</span><span class="s1">.pos - </span><span class="s4">1 </span><span class="s1">- octalStr.length</span><span class="s2">,</span>
          <span class="s1">inTemplate</span>
            <span class="s1">? </span><span class="s3">&quot;Octal literal in template string&quot;</span>
            <span class="s1">: </span><span class="s3">&quot;Octal literal in strict mode&quot;</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">String.fromCharCode(octal)</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isNewLine(ch)) {</span>
      <span class="s0">// Unicode new line characters after \ get removed from output in both</span>
      <span class="s0">// template literals and strings</span>
      <span class="s2">return </span><span class="s3">&quot;&quot;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">String.fromCharCode(ch)</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Used to read character escape sequences ('\x', '\u', '\U').</span>

<span class="s1">pp.readHexChar = </span><span class="s2">function</span><span class="s1">(len) {</span>
  <span class="s2">var </span><span class="s1">codePos = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">n = </span><span class="s2">this</span><span class="s1">.readInt(</span><span class="s4">16</span><span class="s2">, </span><span class="s1">len)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(n === </span><span class="s2">null</span><span class="s1">) { </span><span class="s2">this</span><span class="s1">.invalidStringToken(codePos</span><span class="s2">, </span><span class="s3">&quot;Bad character escape sequence&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
  <span class="s2">return </span><span class="s1">n</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Read an identifier, and return it as a string. Sets `this.containsEsc`</span>
<span class="s0">// to whether the word contained a '\u' escape.</span>
<span class="s0">//</span>
<span class="s0">// Incrementally adds only escaped chars, adding other chunks as-is</span>
<span class="s0">// as a micro-optimization.</span>

<span class="s1">pp.readWord1 = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">this</span><span class="s1">.containsEsc = </span><span class="s2">false;</span>
  <span class="s2">var </span><span class="s1">word = </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">first = </span><span class="s2">true, </span><span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">astral = </span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">6</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pos &lt; </span><span class="s2">this</span><span class="s1">.input.length) {</span>
    <span class="s2">var </span><span class="s1">ch = </span><span class="s2">this</span><span class="s1">.fullCharCodeAtPos()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isIdentifierChar(ch</span><span class="s2">, </span><span class="s1">astral)) {</span>
      <span class="s2">this</span><span class="s1">.pos += ch &lt;= </span><span class="s4">0xffff </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">92</span><span class="s1">) { </span><span class="s0">// &quot;\&quot;</span>
      <span class="s2">this</span><span class="s1">.containsEsc = </span><span class="s2">true;</span>
      <span class="s1">word += </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">escStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.input.charCodeAt(++</span><span class="s2">this</span><span class="s1">.pos) !== </span><span class="s4">117</span><span class="s1">) </span><span class="s0">// &quot;u&quot;</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.invalidStringToken(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Expecting Unicode escape sequence </span><span class="s2">\\</span><span class="s3">uXXXX&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">++</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
      <span class="s2">var </span><span class="s1">esc = </span><span class="s2">this</span><span class="s1">.readCodePoint()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!(first ? isIdentifierStart : isIdentifierChar)(esc</span><span class="s2">, </span><span class="s1">astral))</span>
        <span class="s1">{ </span><span class="s2">this</span><span class="s1">.invalidStringToken(escStart</span><span class="s2">, </span><span class="s3">&quot;Invalid Unicode escape&quot;</span><span class="s1">)</span><span class="s2">; </span><span class="s1">}</span>
      <span class="s1">word += codePointToString(esc)</span><span class="s2">;</span>
      <span class="s1">chunkStart = </span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">break</span>
    <span class="s1">}</span>
    <span class="s1">first = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">word + </span><span class="s2">this</span><span class="s1">.input.slice(chunkStart</span><span class="s2">, this</span><span class="s1">.pos)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Read an identifier or keyword token. Will check for reserved</span>
<span class="s0">// words when necessary.</span>

<span class="s1">pp.readWord = </span><span class="s2">function</span><span class="s1">() {</span>
  <span class="s2">var </span><span class="s1">word = </span><span class="s2">this</span><span class="s1">.readWord1()</span><span class="s2">;</span>
  <span class="s2">var </span><span class="s1">type = types$1.name</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.keywords.test(word)) {</span>
    <span class="s1">type = keywords[word]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this</span><span class="s1">.finishToken(type</span><span class="s2">, </span><span class="s1">word)</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// Acorn is a tiny, fast JavaScript parser written in JavaScript.</span>

<span class="s2">var </span><span class="s1">version = </span><span class="s3">&quot;8.8.2&quot;</span><span class="s2">;</span>

<span class="s1">Parser.acorn = {</span>
  <span class="s1">Parser: Parser</span><span class="s2">,</span>
  <span class="s1">version: version</span><span class="s2">,</span>
  <span class="s1">defaultOptions: defaultOptions</span><span class="s2">,</span>
  <span class="s1">Position: Position</span><span class="s2">,</span>
  <span class="s1">SourceLocation: SourceLocation</span><span class="s2">,</span>
  <span class="s1">getLineInfo: getLineInfo</span><span class="s2">,</span>
  <span class="s1">Node: Node</span><span class="s2">,</span>
  <span class="s1">TokenType: TokenType</span><span class="s2">,</span>
  <span class="s1">tokTypes: types$1</span><span class="s2">,</span>
  <span class="s1">keywordTypes: keywords</span><span class="s2">,</span>
  <span class="s1">TokContext: TokContext</span><span class="s2">,</span>
  <span class="s1">tokContexts: types</span><span class="s2">,</span>
  <span class="s1">isIdentifierChar: isIdentifierChar</span><span class="s2">,</span>
  <span class="s1">isIdentifierStart: isIdentifierStart</span><span class="s2">,</span>
  <span class="s1">Token: Token</span><span class="s2">,</span>
  <span class="s1">isNewLine: isNewLine</span><span class="s2">,</span>
  <span class="s1">lineBreak: lineBreak</span><span class="s2">,</span>
  <span class="s1">lineBreakG: lineBreakG</span><span class="s2">,</span>
  <span class="s1">nonASCIIwhitespace: nonASCIIwhitespace</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// The main exported interface (under `self.acorn` when in the</span>
<span class="s0">// browser) is a `parse` function that takes a code string and</span>
<span class="s0">// returns an abstract syntax tree as specified by [Mozilla parser</span>
<span class="s0">// API][api].</span>
<span class="s0">//</span>
<span class="s0">// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API</span>

<span class="s2">function </span><span class="s1">parse(input</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">Parser.parse(input</span><span class="s2">, </span><span class="s1">options)</span>
<span class="s1">}</span>

<span class="s0">// This function tries to parse a single expression at a given</span>
<span class="s0">// offset in a string. Useful for parsing mixed-language formats</span>
<span class="s0">// that embed JavaScript expressions.</span>

<span class="s2">function </span><span class="s1">parseExpressionAt(input</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">Parser.parseExpressionAt(input</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">options)</span>
<span class="s1">}</span>

<span class="s0">// Acorn is organized as a tokenizer and a recursive-descent parser.</span>
<span class="s0">// The `tokenizer` export provides an interface to the tokenizer.</span>

<span class="s2">function </span><span class="s1">tokenizer(input</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">Parser.tokenizer(input</span><span class="s2">, </span><span class="s1">options)</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">_acorn = </span><span class="s0">/*#__PURE__*/</span><span class="s1">Object.defineProperty({</span>
  <span class="s1">__proto__: </span><span class="s2">null,</span>
  <span class="s1">Node</span><span class="s2">,</span>
  <span class="s1">Parser</span><span class="s2">,</span>
  <span class="s1">Position</span><span class="s2">,</span>
  <span class="s1">SourceLocation</span><span class="s2">,</span>
  <span class="s1">TokContext</span><span class="s2">,</span>
  <span class="s1">Token</span><span class="s2">,</span>
  <span class="s1">TokenType</span><span class="s2">,</span>
  <span class="s1">defaultOptions</span><span class="s2">,</span>
  <span class="s1">getLineInfo</span><span class="s2">,</span>
  <span class="s1">isIdentifierChar</span><span class="s2">,</span>
  <span class="s1">isIdentifierStart</span><span class="s2">,</span>
  <span class="s1">isNewLine</span><span class="s2">,</span>
  <span class="s1">keywordTypes: keywords</span><span class="s2">,</span>
  <span class="s1">lineBreak</span><span class="s2">,</span>
  <span class="s1">lineBreakG</span><span class="s2">,</span>
  <span class="s1">nonASCIIwhitespace</span><span class="s2">,</span>
  <span class="s1">parse</span><span class="s2">,</span>
  <span class="s1">parseExpressionAt</span><span class="s2">,</span>
  <span class="s1">tokContexts: types</span><span class="s2">,</span>
  <span class="s1">tokTypes: types$1</span><span class="s2">,</span>
  <span class="s1">tokenizer</span><span class="s2">,</span>
  <span class="s1">version</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">Symbol.toStringTag</span><span class="s2">, </span><span class="s1">{ value: </span><span class="s3">'Module' </span><span class="s1">})</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">flru (max) {</span>
	<span class="s2">var </span><span class="s1">num</span><span class="s2">, </span><span class="s1">curr</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">;</span>
	<span class="s2">var </span><span class="s1">limit = max || </span><span class="s4">1</span><span class="s2">;</span>

	<span class="s2">function </span><span class="s1">keep(key</span><span class="s2">, </span><span class="s1">value) {</span>
		<span class="s2">if </span><span class="s1">(++num &gt; limit) {</span>
			<span class="s1">prev = curr</span><span class="s2">;</span>
			<span class="s1">reset(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
			<span class="s1">++num</span><span class="s2">;</span>
		<span class="s1">}</span>
		<span class="s1">curr[key] = value</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s2">function </span><span class="s1">reset(isPartial) {</span>
		<span class="s1">num = </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s1">curr = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
		<span class="s1">isPartial || (prev=Object.create(</span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
	<span class="s1">}</span>

	<span class="s1">reset()</span><span class="s2">;</span>

	<span class="s2">return </span><span class="s1">{</span>
		<span class="s1">clear: reset</span><span class="s2">,</span>
		<span class="s1">has: </span><span class="s2">function </span><span class="s1">(key) {</span>
			<span class="s2">return </span><span class="s1">curr[key] !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">|| prev[key] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
		<span class="s1">}</span><span class="s2">,</span>
		<span class="s1">get: </span><span class="s2">function </span><span class="s1">(key) {</span>
			<span class="s2">var </span><span class="s1">val = curr[key]</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">(val !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">val</span><span class="s2">;</span>
			<span class="s2">if </span><span class="s1">((val=prev[key]) !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">keep(key</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">;</span>
				<span class="s2">return </span><span class="s1">val</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span><span class="s2">,</span>
		<span class="s1">set: </span><span class="s2">function </span><span class="s1">(key</span><span class="s2">, </span><span class="s1">value) {</span>
			<span class="s2">if </span><span class="s1">(curr[key] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
				<span class="s1">curr[key] = value</span><span class="s2">;</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">keep(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolveIdViaPlugins(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">moduleLoaderResolveId</span><span class="s2">, </span><span class="s1">skip</span><span class="s2">, </span><span class="s1">customOptions</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions) {</span>
    <span class="s2">let </span><span class="s1">skipped = </span><span class="s2">null;</span>
    <span class="s2">let </span><span class="s1">replaceContext = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(skip) {</span>
        <span class="s1">skipped = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">skippedCall of skip) {</span>
            <span class="s2">if </span><span class="s1">(source === skippedCall.source &amp;&amp; importer === skippedCall.importer) {</span>
                <span class="s1">skipped.add(skippedCall.plugin)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">replaceContext = (pluginContext</span><span class="s2">, </span><span class="s1">plugin) =&gt; ({</span>
            <span class="s1">...pluginContext</span><span class="s2">,</span>
            <span class="s1">resolve: (source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">{ assertions</span><span class="s2">, </span><span class="s1">custom</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">skipSelf } = BLANK) =&gt; moduleLoaderResolveId(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">custom</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions || EMPTY_OBJECT</span><span class="s2">, </span><span class="s1">skipSelf ? [...skip</span><span class="s2">, </span><span class="s1">{ importer</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">source }] : skip)</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">pluginDriver.hookFirstAndGetPlugin(</span><span class="s3">'resolveId'</span><span class="s2">, </span><span class="s1">[source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">{ assertions</span><span class="s2">, </span><span class="s1">custom: customOptions</span><span class="s2">, </span><span class="s1">isEntry }]</span><span class="s2">, </span><span class="s1">replaceContext</span><span class="s2">, </span><span class="s1">skipped)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">resolveId(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">preserveSymlinks</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">moduleLoaderResolveId</span><span class="s2">, </span><span class="s1">skip</span><span class="s2">, </span><span class="s1">customOptions</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions) {</span>
    <span class="s2">const </span><span class="s1">pluginResult = </span><span class="s2">await </span><span class="s1">resolveIdViaPlugins(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">moduleLoaderResolveId</span><span class="s2">, </span><span class="s1">skip</span><span class="s2">, </span><span class="s1">customOptions</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pluginResult != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[resolveIdResult</span><span class="s2">, </span><span class="s1">plugin] = pluginResult</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolveIdResult === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; !resolveIdResult.resolvedBy) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">...resolveIdResult</span><span class="s2">,</span>
                <span class="s1">resolvedBy: plugin.name</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolveIdResult === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">id: resolveIdResult</span><span class="s2">,</span>
                <span class="s1">resolvedBy: plugin.name</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">resolveIdResult</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// external modules (non-entry modules that start with neither '.' or '/')</span>
    <span class="s0">// are skipped at this stage.</span>
    <span class="s2">if </span><span class="s1">(importer !== undefined &amp;&amp; !isAbsolute(source) &amp;&amp; source[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s2">return null;</span>
    <span class="s0">// `resolve` processes paths from right to left, prepending them until an</span>
    <span class="s0">// absolute path is created. Absolute importees therefore shortcircuit the</span>
    <span class="s0">// resolve call and require no special handing on our part.</span>
    <span class="s0">// See https://nodejs.org/api/path.html#path_path_resolve_paths</span>
    <span class="s2">return </span><span class="s1">addJsExtensionIfNecessary(importer ? resolve(dirname(importer)</span><span class="s2">, </span><span class="s1">source) : resolve(source)</span><span class="s2">, </span><span class="s1">preserveSymlinks)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">addJsExtensionIfNecessary(file</span><span class="s2">, </span><span class="s1">preserveSymlinks) {</span>
    <span class="s2">return </span><span class="s1">((</span><span class="s2">await </span><span class="s1">findFile(file</span><span class="s2">, </span><span class="s1">preserveSymlinks)) ??</span>
        <span class="s1">(</span><span class="s2">await </span><span class="s1">findFile(file + </span><span class="s3">'.mjs'</span><span class="s2">, </span><span class="s1">preserveSymlinks)) ??</span>
        <span class="s1">(</span><span class="s2">await </span><span class="s1">findFile(file + </span><span class="s3">'.js'</span><span class="s2">, </span><span class="s1">preserveSymlinks)))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">findFile(file</span><span class="s2">, </span><span class="s1">preserveSymlinks) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">stats = </span><span class="s2">await </span><span class="s1">lstat(file)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!preserveSymlinks &amp;&amp; stats.isSymbolicLink())</span>
            <span class="s2">return await </span><span class="s1">findFile(</span><span class="s2">await </span><span class="s1">realpath(file)</span><span class="s2">, </span><span class="s1">preserveSymlinks)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((preserveSymlinks &amp;&amp; stats.isSymbolicLink()) || stats.isFile()) {</span>
            <span class="s0">// check case</span>
            <span class="s2">const </span><span class="s1">name = basename(file)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">files = </span><span class="s2">await </span><span class="s1">readdir(dirname(file))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(files.includes(name))</span>
                <span class="s2">return </span><span class="s1">file</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">{</span>
        <span class="s0">// suppress</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">ANONYMOUS_PLUGIN_PREFIX = </span><span class="s3">'at position '</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ANONYMOUS_OUTPUT_PLUGIN_PREFIX = </span><span class="s3">'at output position '</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">createPluginCache(cache) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">delete</span><span class="s1">(id) {</span>
            <span class="s2">return delete </span><span class="s1">cache[id]</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get(id) {</span>
            <span class="s2">const </span><span class="s1">item = cache[id]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!item)</span>
                <span class="s2">return;</span>
            <span class="s1">item[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">item[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has(id) {</span>
            <span class="s2">const </span><span class="s1">item = cache[id]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!item)</span>
                <span class="s2">return false;</span>
            <span class="s1">item[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">set(id</span><span class="s2">, </span><span class="s1">value) {</span>
            <span class="s1">cache[id] = [</span><span class="s4">0</span><span class="s2">, </span><span class="s1">value]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTrackedPluginCache(pluginCache</span><span class="s2">, </span><span class="s1">onUse) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">delete</span><span class="s1">(id) {</span>
            <span class="s1">onUse()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">pluginCache.delete(id)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get(id) {</span>
            <span class="s1">onUse()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">pluginCache.get(id)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has(id) {</span>
            <span class="s1">onUse()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">pluginCache.has(id)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">set(id</span><span class="s2">, </span><span class="s1">value) {</span>
            <span class="s1">onUse()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">pluginCache.set(id</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">NO_CACHE = {</span>
    <span class="s2">delete</span><span class="s1">() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">get() {</span>
        <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has() {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">set() { }</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">uncacheablePluginError(pluginName) {</span>
    <span class="s2">if </span><span class="s1">(pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||</span>
        <span class="s1">pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {</span>
        <span class="s2">return </span><span class="s1">error(errorAnonymousPluginCache())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">error(errorDuplicatePluginName(pluginName))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCacheForUncacheablePlugin(pluginName) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s2">delete</span><span class="s1">() {</span>
            <span class="s2">return </span><span class="s1">uncacheablePluginError(pluginName)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get() {</span>
            <span class="s2">return </span><span class="s1">uncacheablePluginError(pluginName)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has() {</span>
            <span class="s2">return </span><span class="s1">uncacheablePluginError(pluginName)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">set() {</span>
            <span class="s2">return </span><span class="s1">uncacheablePluginError(pluginName)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">transform(source</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">pluginDriver</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">const </span><span class="s1">id = module.id</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">sourcemapChain = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">originalSourcemap = source.map === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: decodedSourcemap(source.map)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">originalCode = source.code</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">ast = source.ast</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">transformDependencies = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">emittedFiles = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">customTransformCache = </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">useCustomTransformCache = () =&gt; (customTransformCache = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">pluginName = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">currentSource = source.code</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">transformReducer(previousCode</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">plugin) {</span>
        <span class="s2">let </span><span class="s1">code</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">map</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">result === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s1">code = result</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(result &amp;&amp; </span><span class="s2">typeof </span><span class="s1">result === </span><span class="s3">'object'</span><span class="s1">) {</span>
            <span class="s1">module.updateOptions(result)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(result.code == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(result.map || result.ast) {</span>
                    <span class="s1">warn(errorNoTransformMapOrAstWithoutCode(plugin.name))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">previousCode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">({ code</span><span class="s2">, </span><span class="s1">map</span><span class="s2">, </span><span class="s1">ast } = result)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">previousCode</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// strict null check allows 'null' maps to not be pushed to the chain,</span>
        <span class="s0">// while 'undefined' gets the missing map warning</span>
        <span class="s2">if </span><span class="s1">(map !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">sourcemapChain.push(decodedSourcemap(</span><span class="s2">typeof </span><span class="s1">map === </span><span class="s3">'string' </span><span class="s1">? JSON.parse(map) : map) || {</span>
                <span class="s1">missing: </span><span class="s2">true,</span>
                <span class="s1">plugin: plugin.name</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">code</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">code</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">code = </span><span class="s2">await </span><span class="s1">pluginDriver.hookReduceArg0(</span><span class="s3">'transform'</span><span class="s2">, </span><span class="s1">[currentSource</span><span class="s2">, </span><span class="s1">id]</span><span class="s2">, </span><span class="s1">transformReducer</span><span class="s2">, </span><span class="s1">(pluginContext</span><span class="s2">, </span><span class="s1">plugin) =&gt; {</span>
            <span class="s1">pluginName = plugin.name</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">...pluginContext</span><span class="s2">,</span>
                <span class="s1">addWatchFile(id) {</span>
                    <span class="s1">transformDependencies.push(id)</span><span class="s2">;</span>
                    <span class="s1">pluginContext.addWatchFile(id)</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">cache: customTransformCache</span>
                    <span class="s1">? pluginContext.cache</span>
                    <span class="s1">: getTrackedPluginCache(pluginContext.cache</span><span class="s2">, </span><span class="s1">useCustomTransformCache)</span><span class="s2">,</span>
                <span class="s1">emitFile(emittedFile) {</span>
                    <span class="s1">emittedFiles.push(emittedFile)</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">pluginDriver.emitFile(emittedFile)</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">error(error_</span><span class="s2">, </span><span class="s1">pos) {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">error_ === </span><span class="s3">'string'</span><span class="s1">)</span>
                        <span class="s1">error_ = { message: error_ }</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(pos)</span>
                        <span class="s1">augmentCodeLocation(error_</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">currentSource</span><span class="s2">, </span><span class="s1">id)</span><span class="s2">;</span>
                    <span class="s1">error_.id = id</span><span class="s2">;</span>
                    <span class="s1">error_.hook = </span><span class="s3">'transform'</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">pluginContext.error(error_)</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">getCombinedSourcemap() {</span>
                    <span class="s2">const </span><span class="s1">combinedMap = collapseSourcemap(id</span><span class="s2">, </span><span class="s1">originalCode</span><span class="s2">, </span><span class="s1">originalSourcemap</span><span class="s2">, </span><span class="s1">sourcemapChain</span><span class="s2">, </span><span class="s1">warn)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(!combinedMap) {</span>
                        <span class="s2">const </span><span class="s1">magicString = </span><span class="s2">new </span><span class="s1">MagicString(originalCode)</span><span class="s2">;</span>
                        <span class="s2">return </span><span class="s1">magicString.generateMap({ hires: </span><span class="s2">true, </span><span class="s1">includeContent: </span><span class="s2">true, </span><span class="s1">source: id })</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(originalSourcemap !== combinedMap) {</span>
                        <span class="s1">originalSourcemap = combinedMap</span><span class="s2">;</span>
                        <span class="s1">sourcemapChain.length = </span><span class="s4">0</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return new </span><span class="s1">SourceMap({</span>
                        <span class="s1">...combinedMap</span><span class="s2">,</span>
                        <span class="s1">file: </span><span class="s2">null,</span>
                        <span class="s1">sourcesContent: combinedMap.sourcesContent</span>
                    <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">setAssetSource() {</span>
                    <span class="s2">return this</span><span class="s1">.error(errorInvalidSetAssetSourceCall())</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">warn(warning</span><span class="s2">, </span><span class="s1">pos) {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">warning === </span><span class="s3">'string'</span><span class="s1">)</span>
                        <span class="s1">warning = { message: warning }</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(pos)</span>
                        <span class="s1">augmentCodeLocation(warning</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">currentSource</span><span class="s2">, </span><span class="s1">id)</span><span class="s2">;</span>
                    <span class="s1">warning.id = id</span><span class="s2">;</span>
                    <span class="s1">warning.hook = </span><span class="s3">'transform'</span><span class="s2">;</span>
                    <span class="s1">pluginContext.warn(warning)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(error_) {</span>
        <span class="s2">return </span><span class="s1">error(errorPluginError(error_</span><span class="s2">, </span><span class="s1">pluginName</span><span class="s2">, </span><span class="s1">{ hook: </span><span class="s3">'transform'</span><span class="s2">, </span><span class="s1">id }))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!customTransformCache &amp;&amp; </span><span class="s0">// files emitted by a transform hook need to be emitted again if the hook is skipped</span>
        <span class="s1">emittedFiles.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">module.transformFiles = emittedFiles</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">ast</span><span class="s2">,</span>
        <span class="s1">code</span><span class="s2">,</span>
        <span class="s1">customTransformCache</span><span class="s2">,</span>
        <span class="s1">originalCode</span><span class="s2">,</span>
        <span class="s1">originalSourcemap</span><span class="s2">,</span>
        <span class="s1">sourcemapChain</span><span class="s2">,</span>
        <span class="s1">transformDependencies</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">RESOLVE_DEPENDENCIES = </span><span class="s3">'resolveDependencies'</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ModuleLoader {</span>
    <span class="s1">constructor(graph</span><span class="s2">, </span><span class="s1">modulesById</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">pluginDriver) {</span>
        <span class="s2">this</span><span class="s1">.graph = graph</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modulesById = modulesById</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginDriver = pluginDriver</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.implicitEntryModules = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.indexedEntryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.latestLoadModulesPromise = Promise.resolve()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.moduleLoadPromises = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modulesWithLoadedDependencies = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nextChunkNamePriority = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nextEntryModuleIndex = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.resolveId = async (source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">customOptions</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">, </span><span class="s1">skip = </span><span class="s2">null</span><span class="s1">) =&gt; </span><span class="s2">this</span><span class="s1">.getResolvedIdWithDefaults(</span><span class="s2">this</span><span class="s1">.getNormalizedResolvedIdWithoutDefaults(</span><span class="s2">this</span><span class="s1">.options.external(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, false</span><span class="s1">)</span>
            <span class="s1">? </span><span class="s2">false</span>
            <span class="s1">: </span><span class="s2">await </span><span class="s1">resolveId(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, this</span><span class="s1">.options.preserveSymlinks</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.resolveId</span><span class="s2">, </span><span class="s1">skip</span><span class="s2">, </span><span class="s1">customOptions</span><span class="s2">, typeof </span><span class="s1">isEntry === </span><span class="s3">'boolean' </span><span class="s1">? isEntry : !importer</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">source)</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.hasModuleSideEffects = options.treeshake</span>
            <span class="s1">? options.treeshake.moduleSideEffects</span>
            <span class="s1">: () =&gt; </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">async addAdditionalModules(unresolvedModules) {</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.extendLoadModulesPromise(Promise.all(unresolvedModules.map(id =&gt; </span><span class="s2">this</span><span class="s1">.loadEntryModule(id</span><span class="s2">, false, </span><span class="s1">undefined</span><span class="s2">, null</span><span class="s1">))))</span><span class="s2">;</span>
        <span class="s2">await this</span><span class="s1">.awaitLoadModulesPromise()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async addEntryModules(unresolvedEntryModules</span><span class="s2">, </span><span class="s1">isUserDefined) {</span>
        <span class="s2">const </span><span class="s1">firstEntryModuleIndex = </span><span class="s2">this</span><span class="s1">.nextEntryModuleIndex</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nextEntryModuleIndex += unresolvedEntryModules.length</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">firstChunkNamePriority = </span><span class="s2">this</span><span class="s1">.nextChunkNamePriority</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.nextChunkNamePriority += unresolvedEntryModules.length</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">newEntryModules = </span><span class="s2">await this</span><span class="s1">.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id</span><span class="s2">, </span><span class="s1">importer }) =&gt; </span><span class="s2">this</span><span class="s1">.loadEntryModule(id</span><span class="s2">, true, </span><span class="s1">importer</span><span class="s2">, null</span><span class="s1">))).then(entryModules =&gt; {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">entryModule] of entryModules.entries()) {</span>
                <span class="s1">entryModule.isUserDefinedEntryPoint =</span>
                    <span class="s1">entryModule.isUserDefinedEntryPoint || isUserDefined</span><span class="s2">;</span>
                <span class="s1">addChunkNamesToModule(entryModule</span><span class="s2">, </span><span class="s1">unresolvedEntryModules[index]</span><span class="s2">, </span><span class="s1">isUserDefined</span><span class="s2">, </span><span class="s1">firstChunkNamePriority + index)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">existingIndexedModule = </span><span class="s2">this</span><span class="s1">.indexedEntryModules.find(indexedModule =&gt; indexedModule.module === entryModule)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(existingIndexedModule) {</span>
                    <span class="s1">existingIndexedModule.index = Math.min(existingIndexedModule.index</span><span class="s2">, </span><span class="s1">firstEntryModuleIndex + index)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.indexedEntryModules.push({</span>
                        <span class="s1">index: firstEntryModuleIndex + index</span><span class="s2">,</span>
                        <span class="s1">module: entryModule</span>
                    <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.indexedEntryModules.sort(({ index: indexA }</span><span class="s2">, </span><span class="s1">{ index: indexB }) =&gt; indexA &gt; indexB ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">entryModules</span><span class="s2">;</span>
        <span class="s1">}))</span><span class="s2">;</span>
        <span class="s2">await this</span><span class="s1">.awaitLoadModulesPromise()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">entryModules: </span><span class="s2">this</span><span class="s1">.indexedEntryModules.map(({ module }) =&gt; module)</span><span class="s2">,</span>
            <span class="s1">implicitEntryModules: [...</span><span class="s2">this</span><span class="s1">.implicitEntryModules]</span><span class="s2">,</span>
            <span class="s1">newEntryModules</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async emitChunk({ fileName</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">implicitlyLoadedAfterOneOf</span><span class="s2">, </span><span class="s1">preserveSignature }) {</span>
        <span class="s2">const </span><span class="s1">unresolvedModule = {</span>
            <span class="s1">fileName: fileName || </span><span class="s2">null,</span>
            <span class="s1">id</span><span class="s2">,</span>
            <span class="s1">importer</span><span class="s2">,</span>
            <span class="s1">name: name || </span><span class="s2">null</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">module = implicitlyLoadedAfterOneOf</span>
            <span class="s1">? </span><span class="s2">await this</span><span class="s1">.addEntryWithImplicitDependants(unresolvedModule</span><span class="s2">, </span><span class="s1">implicitlyLoadedAfterOneOf)</span>
            <span class="s1">: (</span><span class="s2">await this</span><span class="s1">.addEntryModules([unresolvedModule]</span><span class="s2">, false</span><span class="s1">)).newEntryModules[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(preserveSignature != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">module.preserveSignature = preserveSignature</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">module</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async preloadModule(resolvedId) {</span>
        <span class="s2">const </span><span class="s1">module = </span><span class="s2">await this</span><span class="s1">.fetchModule(</span><span class="s2">this</span><span class="s1">.getResolvedIdWithDefaults(resolvedId</span><span class="s2">, </span><span class="s1">EMPTY_OBJECT)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, false, </span><span class="s1">resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">module.info</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addEntryWithImplicitDependants(unresolvedModule</span><span class="s2">, </span><span class="s1">implicitlyLoadedAfter) {</span>
        <span class="s2">const </span><span class="s1">chunkNamePriority = </span><span class="s2">this</span><span class="s1">.nextChunkNamePriority++</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.extendLoadModulesPromise(</span><span class="s2">this</span><span class="s1">.loadEntryModule(unresolvedModule.id</span><span class="s2">, false, </span><span class="s1">unresolvedModule.importer</span><span class="s2">, null</span><span class="s1">).then(async (entryModule) =&gt; {</span>
            <span class="s1">addChunkNamesToModule(entryModule</span><span class="s2">, </span><span class="s1">unresolvedModule</span><span class="s2">, false, </span><span class="s1">chunkNamePriority)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!entryModule.info.isEntry) {</span>
                <span class="s2">this</span><span class="s1">.implicitEntryModules.add(entryModule)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">implicitlyLoadedAfterModules = </span><span class="s2">await </span><span class="s1">Promise.all(implicitlyLoadedAfter.map(id =&gt; </span><span class="s2">this</span><span class="s1">.loadEntryModule(id</span><span class="s2">, false, </span><span class="s1">unresolvedModule.importer</span><span class="s2">, </span><span class="s1">entryModule.id)))</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of implicitlyLoadedAfterModules) {</span>
                    <span class="s1">entryModule.implicitlyLoadedAfter.add(module)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependant of entryModule.implicitlyLoadedAfter) {</span>
                    <span class="s1">dependant.implicitlyLoadedBefore.add(entryModule)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">entryModule</span><span class="s2">;</span>
        <span class="s1">}))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async addModuleSource(id</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">module) {</span>
        <span class="s2">let </span><span class="s1">source</span><span class="s2">;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">source = </span><span class="s2">await this</span><span class="s1">.graph.fileOperationQueue.run(async () =&gt; (</span><span class="s2">await this</span><span class="s1">.pluginDriver.hookFirst(</span><span class="s3">'load'</span><span class="s2">, </span><span class="s1">[id])) ?? (</span><span class="s2">await </span><span class="s1">readFile(id</span><span class="s2">, </span><span class="s3">'utf8'</span><span class="s1">)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(error_) {</span>
            <span class="s2">let </span><span class="s1">message = </span><span class="s3">`Could not load </span><span class="s1">${id}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(importer)</span>
                <span class="s1">message += </span><span class="s3">` (imported by </span><span class="s1">${relativeId(importer)}</span><span class="s3">)`</span><span class="s2">;</span>
            <span class="s1">message += </span><span class="s3">`: </span><span class="s1">${error_.message}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">error_.message = message</span><span class="s2">;</span>
            <span class="s2">throw </span><span class="s1">error_</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">sourceDescription = </span><span class="s2">typeof </span><span class="s1">source === </span><span class="s3">'string'</span>
            <span class="s1">? { code: source }</span>
            <span class="s1">: source != </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">source === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">source.code === </span><span class="s3">'string'</span>
                <span class="s1">? source</span>
                <span class="s1">: error(errorBadLoader(id))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">cachedModule = </span><span class="s2">this</span><span class="s1">.graph.cachedModules.get(id)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cachedModule &amp;&amp;</span>
            <span class="s1">!cachedModule.customTransformCache &amp;&amp;</span>
            <span class="s1">cachedModule.originalCode === sourceDescription.code &amp;&amp;</span>
            <span class="s1">!(</span><span class="s2">await this</span><span class="s1">.pluginDriver.hookFirst(</span><span class="s3">'shouldTransformCachedModule'</span><span class="s2">, </span><span class="s1">[</span>
                <span class="s1">{</span>
                    <span class="s1">ast: cachedModule.ast</span><span class="s2">,</span>
                    <span class="s1">code: cachedModule.code</span><span class="s2">,</span>
                    <span class="s1">id: cachedModule.id</span><span class="s2">,</span>
                    <span class="s1">meta: cachedModule.meta</span><span class="s2">,</span>
                    <span class="s1">moduleSideEffects: cachedModule.moduleSideEffects</span><span class="s2">,</span>
                    <span class="s1">resolvedSources: cachedModule.resolvedIds</span><span class="s2">,</span>
                    <span class="s1">syntheticNamedExports: cachedModule.syntheticNamedExports</span>
                <span class="s1">}</span>
            <span class="s1">]))) {</span>
            <span class="s2">if </span><span class="s1">(cachedModule.transformFiles) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">emittedFile of cachedModule.transformFiles)</span>
                    <span class="s2">this</span><span class="s1">.pluginDriver.emitFile(emittedFile)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">module.setSource(cachedModule)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">module.updateOptions(sourceDescription)</span><span class="s2">;</span>
            <span class="s1">module.setSource(</span><span class="s2">await </span><span class="s1">transform(sourceDescription</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.options.onwarn))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async awaitLoadModulesPromise() {</span>
        <span class="s2">let </span><span class="s1">startingPromise</span><span class="s2">;</span>
        <span class="s2">do </span><span class="s1">{</span>
            <span class="s1">startingPromise = </span><span class="s2">this</span><span class="s1">.latestLoadModulesPromise</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">startingPromise</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(startingPromise !== </span><span class="s2">this</span><span class="s1">.latestLoadModulesPromise)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">extendLoadModulesPromise(loadNewModulesPromise) {</span>
        <span class="s2">this</span><span class="s1">.latestLoadModulesPromise = Promise.all([</span>
            <span class="s1">loadNewModulesPromise</span><span class="s2">,</span>
            <span class="s2">this</span><span class="s1">.latestLoadModulesPromise</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.latestLoadModulesPromise.catch(() =&gt; {</span>
            <span class="s0">/* Avoid unhandled Promise rejections */</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">loadNewModulesPromise</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async fetchDynamicDependencies(module</span><span class="s2">, </span><span class="s1">resolveDynamicImportPromises) {</span>
        <span class="s2">const </span><span class="s1">dependencies = </span><span class="s2">await </span><span class="s1">Promise.all(resolveDynamicImportPromises.map(resolveDynamicImportPromise =&gt; resolveDynamicImportPromise.then(async ([dynamicImport</span><span class="s2">, </span><span class="s1">resolvedId]) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(resolvedId === </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">return null;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolvedId === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s1">dynamicImport.resolution = resolvedId</span><span class="s2">;</span>
                <span class="s2">return null;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">(dynamicImport.resolution = </span><span class="s2">await this</span><span class="s1">.fetchResolvedDependency(relativeId(resolvedId.id)</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">resolvedId))</span><span class="s2">;</span>
        <span class="s1">})))</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of dependencies) {</span>
            <span class="s2">if </span><span class="s1">(dependency) {</span>
                <span class="s1">module.dynamicDependencies.add(dependency)</span><span class="s2">;</span>
                <span class="s1">dependency.dynamicImporters.push(module.id)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// If this is a preload, then this method always waits for the dependencies of</span>
    <span class="s0">// the module to be resolved.</span>
    <span class="s0">// Otherwise, if the module does not exist, it waits for the module and all</span>
    <span class="s0">// its dependencies to be loaded.</span>
    <span class="s0">// Otherwise, it returns immediately.</span>
    <span class="s1">async fetchModule({ assertions</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">meta</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">syntheticNamedExports }</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">isPreload) {</span>
        <span class="s2">const </span><span class="s1">existingModule = </span><span class="s2">this</span><span class="s1">.modulesById.get(id)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(existingModule </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
            <span class="s2">if </span><span class="s1">(importer &amp;&amp; doAssertionsDiffer(assertions</span><span class="s2">, </span><span class="s1">existingModule.info.assertions)) {</span>
                <span class="s2">this</span><span class="s1">.options.onwarn(errorInconsistentImportAssertions(existingModule.info.assertions</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">await this</span><span class="s1">.handleExistingModule(existingModule</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">isPreload)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">existingModule</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">module = </span><span class="s2">new </span><span class="s1">Module(</span><span class="s2">this</span><span class="s1">.graph</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, this</span><span class="s1">.options</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">syntheticNamedExports</span><span class="s2">, </span><span class="s1">meta</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modulesById.set(id</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.graph.watchFiles[id] = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">loadPromise = </span><span class="s2">this</span><span class="s1">.addModuleSource(id</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">module).then(() =&gt; [</span>
            <span class="s2">this</span><span class="s1">.getResolveStaticDependencyPromises(module)</span><span class="s2">,</span>
            <span class="s2">this</span><span class="s1">.getResolveDynamicImportPromises(module)</span><span class="s2">,</span>
            <span class="s1">loadAndResolveDependenciesPromise</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() =&gt; </span><span class="s2">this</span><span class="s1">.pluginDriver.hookParallel(</span><span class="s3">'moduleParsed'</span><span class="s2">, </span><span class="s1">[module.info]))</span><span class="s2">;</span>
        <span class="s1">loadAndResolveDependenciesPromise.catch(() =&gt; {</span>
            <span class="s0">/* avoid unhandled promise rejections */</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.moduleLoadPromises.set(module</span><span class="s2">, </span><span class="s1">loadPromise)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">resolveDependencyPromises = </span><span class="s2">await </span><span class="s1">loadPromise</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isPreload) {</span>
            <span class="s2">await this</span><span class="s1">.fetchModuleDependencies(module</span><span class="s2">, </span><span class="s1">...resolveDependencyPromises)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isPreload === RESOLVE_DEPENDENCIES) {</span>
            <span class="s2">await </span><span class="s1">loadAndResolveDependenciesPromise</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">module</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async fetchModuleDependencies(module</span><span class="s2">, </span><span class="s1">resolveStaticDependencyPromises</span><span class="s2">, </span><span class="s1">resolveDynamicDependencyPromises</span><span class="s2">, </span><span class="s1">loadAndResolveDependenciesPromise) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.modulesWithLoadedDependencies.has(module)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.modulesWithLoadedDependencies.add(module)</span><span class="s2">;</span>
        <span class="s2">await </span><span class="s1">Promise.all([</span>
            <span class="s2">this</span><span class="s1">.fetchStaticDependencies(module</span><span class="s2">, </span><span class="s1">resolveStaticDependencyPromises)</span><span class="s2">,</span>
            <span class="s2">this</span><span class="s1">.fetchDynamicDependencies(module</span><span class="s2">, </span><span class="s1">resolveDynamicDependencyPromises)</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">module.linkImports()</span><span class="s2">;</span>
        <span class="s0">// To handle errors when resolving dependencies or in moduleParsed</span>
        <span class="s2">await </span><span class="s1">loadAndResolveDependenciesPromise</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">fetchResolvedDependency(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">resolvedId) {</span>
        <span class="s2">if </span><span class="s1">(resolvedId.external) {</span>
            <span class="s2">const </span><span class="s1">{ assertions</span><span class="s2">, </span><span class="s1">external</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">meta } = resolvedId</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">externalModule = </span><span class="s2">this</span><span class="s1">.modulesById.get(id)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!externalModule) {</span>
                <span class="s1">externalModule = </span><span class="s2">new </span><span class="s1">ExternalModule(</span><span class="s2">this</span><span class="s1">.options</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">moduleSideEffects</span><span class="s2">, </span><span class="s1">meta</span><span class="s2">, </span><span class="s1">external !== </span><span class="s3">'absolute' </span><span class="s1">&amp;&amp; isAbsolute(id)</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.modulesById.set(id</span><span class="s2">, </span><span class="s1">externalModule)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!(externalModule </span><span class="s2">instanceof </span><span class="s1">ExternalModule)) {</span>
                <span class="s2">return </span><span class="s1">error(errorInternalIdCannotBeExternal(source</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(doAssertionsDiffer(externalModule.info.assertions</span><span class="s2">, </span><span class="s1">assertions)) {</span>
                <span class="s2">this</span><span class="s1">.options.onwarn(errorInconsistentImportAssertions(externalModule.info.assertions</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">Promise.resolve(externalModule)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.fetchModule(resolvedId</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, false, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async fetchStaticDependencies(module</span><span class="s2">, </span><span class="s1">resolveStaticDependencyPromises) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of </span><span class="s2">await </span><span class="s1">Promise.all(resolveStaticDependencyPromises.map(resolveStaticDependencyPromise =&gt; resolveStaticDependencyPromise.then(([source</span><span class="s2">, </span><span class="s1">resolvedId]) =&gt; </span><span class="s2">this</span><span class="s1">.fetchResolvedDependency(source</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">resolvedId))))) {</span>
            <span class="s1">module.dependencies.add(dependency)</span><span class="s2">;</span>
            <span class="s1">dependency.importers.push(module.id)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.treeshake || module.info.moduleSideEffects === </span><span class="s3">'no-treeshake'</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependency of module.dependencies) {</span>
                <span class="s2">if </span><span class="s1">(dependency </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                    <span class="s1">dependency.importedFromNotTreeshaken = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getNormalizedResolvedIdWithoutDefaults(resolveIdResult</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">source) {</span>
        <span class="s2">const </span><span class="s1">{ makeAbsoluteExternalsRelative } = </span><span class="s2">this</span><span class="s1">.options</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(resolveIdResult) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolveIdResult === </span><span class="s3">'object'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">external = resolveIdResult.external || </span><span class="s2">this</span><span class="s1">.options.external(resolveIdResult.id</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">...resolveIdResult</span><span class="s2">,</span>
                    <span class="s1">external: external &amp;&amp;</span>
                        <span class="s1">(external === </span><span class="s3">'relative' </span><span class="s1">||</span>
                            <span class="s1">!isAbsolute(resolveIdResult.id) ||</span>
                            <span class="s1">(external === </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">isNotAbsoluteExternal(resolveIdResult.id</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">makeAbsoluteExternalsRelative)) ||</span>
                            <span class="s3">'absolute'</span><span class="s1">)</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">external = </span><span class="s2">this</span><span class="s1">.options.external(resolveIdResult</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">external: external &amp;&amp;</span>
                    <span class="s1">(isNotAbsoluteExternal(resolveIdResult</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">makeAbsoluteExternalsRelative) ||</span>
                        <span class="s3">'absolute'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id: external &amp;&amp; makeAbsoluteExternalsRelative</span>
                    <span class="s1">? normalizeRelativeExternalId(resolveIdResult</span><span class="s2">, </span><span class="s1">importer)</span>
                    <span class="s1">: resolveIdResult</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">id = makeAbsoluteExternalsRelative</span>
            <span class="s1">? normalizeRelativeExternalId(source</span><span class="s2">, </span><span class="s1">importer)</span>
            <span class="s1">: source</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(resolveIdResult !== </span><span class="s2">false </span><span class="s1">&amp;&amp; !</span><span class="s2">this</span><span class="s1">.options.external(id</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, true</span><span class="s1">)) {</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">external: isNotAbsoluteExternal(id</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">makeAbsoluteExternalsRelative) || </span><span class="s3">'absolute'</span><span class="s2">,</span>
            <span class="s1">id</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getResolveDynamicImportPromises(module) {</span>
        <span class="s2">return </span><span class="s1">module.dynamicImports.map(async (dynamicImport) =&gt; {</span>
            <span class="s2">const </span><span class="s1">resolvedId = </span><span class="s2">await this</span><span class="s1">.resolveDynamicImport(module</span><span class="s2">, typeof </span><span class="s1">dynamicImport.argument === </span><span class="s3">'string'</span>
                <span class="s1">? dynamicImport.argument</span>
                <span class="s1">: dynamicImport.argument.esTreeNode</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">getAssertionsFromImportExpression(dynamicImport.node))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(resolvedId &amp;&amp; </span><span class="s2">typeof </span><span class="s1">resolvedId === </span><span class="s3">'object'</span><span class="s1">) {</span>
                <span class="s1">dynamicImport.id = resolvedId.id</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">[dynamicImport</span><span class="s2">, </span><span class="s1">resolvedId]</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getResolveStaticDependencyPromises(module) {</span>
        <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
        <span class="s2">return </span><span class="s1">Array.from(module.sourcesWithAssertions</span><span class="s2">, </span><span class="s1">async ([source</span><span class="s2">, </span><span class="s1">assertions]) =&gt; [</span>
            <span class="s1">source</span><span class="s2">,</span>
            <span class="s1">(module.resolvedIds[source] =</span>
                <span class="s1">module.resolvedIds[source] ||</span>
                    <span class="s2">this</span><span class="s1">.handleInvalidResolvedId(</span><span class="s2">await this</span><span class="s1">.resolveId(source</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">EMPTY_OBJECT</span><span class="s2">, false, </span><span class="s1">assertions)</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">assertions))</span>
        <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getResolvedIdWithDefaults(resolvedId</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">if </span><span class="s1">(!resolvedId) {</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">external = resolvedId.external || </span><span class="s2">false;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">assertions: resolvedId.assertions || assertions</span><span class="s2">,</span>
            <span class="s1">external</span><span class="s2">,</span>
            <span class="s1">id: resolvedId.id</span><span class="s2">,</span>
            <span class="s1">meta: resolvedId.meta || {}</span><span class="s2">,</span>
            <span class="s1">moduleSideEffects: resolvedId.moduleSideEffects ?? </span><span class="s2">this</span><span class="s1">.hasModuleSideEffects(resolvedId.id</span><span class="s2">, </span><span class="s1">!!external)</span><span class="s2">,</span>
            <span class="s1">resolvedBy: resolvedId.resolvedBy ?? </span><span class="s3">'rollup'</span><span class="s2">,</span>
            <span class="s1">syntheticNamedExports: resolvedId.syntheticNamedExports ?? </span><span class="s2">false</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async handleExistingModule(module</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">isPreload) {</span>
        <span class="s2">const </span><span class="s1">loadPromise = </span><span class="s2">this</span><span class="s1">.moduleLoadPromises.get(module)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPreload) {</span>
            <span class="s2">return </span><span class="s1">isPreload === RESOLVE_DEPENDENCIES</span>
                <span class="s1">? waitForDependencyResolution(loadPromise)</span>
                <span class="s1">: loadPromise</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isEntry) {</span>
            <span class="s1">module.info.isEntry = </span><span class="s2">true;</span>
            <span class="s2">this</span><span class="s1">.implicitEntryModules.delete(module)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependant of module.implicitlyLoadedAfter) {</span>
                <span class="s1">dependant.implicitlyLoadedBefore.delete(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">module.implicitlyLoadedAfter.clear()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.fetchModuleDependencies(module</span><span class="s2">, </span><span class="s1">...(</span><span class="s2">await </span><span class="s1">loadPromise))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">handleInvalidResolvedId(resolvedId</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">if </span><span class="s1">(resolvedId === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(isRelative(source)) {</span>
                <span class="s2">return </span><span class="s1">error(errorUnresolvedImport(source</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.options.onwarn(errorUnresolvedImportTreatedAsExternal(source</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">assertions</span><span class="s2">,</span>
                <span class="s1">external: </span><span class="s2">true,</span>
                <span class="s1">id: source</span><span class="s2">,</span>
                <span class="s1">meta: {}</span><span class="s2">,</span>
                <span class="s1">moduleSideEffects: </span><span class="s2">this</span><span class="s1">.hasModuleSideEffects(source</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">resolvedBy: </span><span class="s3">'rollup'</span><span class="s2">,</span>
                <span class="s1">syntheticNamedExports: </span><span class="s2">false</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(resolvedId.external &amp;&amp; resolvedId.syntheticNamedExports) {</span>
            <span class="s2">this</span><span class="s1">.options.onwarn(errorExternalSyntheticExports(source</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">resolvedId</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async loadEntryModule(unresolvedId</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore) {</span>
        <span class="s2">const </span><span class="s1">resolveIdResult = </span><span class="s2">await </span><span class="s1">resolveId(unresolvedId</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, this</span><span class="s1">.options.preserveSymlinks</span><span class="s2">, this</span><span class="s1">.pluginDriver</span><span class="s2">, this</span><span class="s1">.resolveId</span><span class="s2">, null, </span><span class="s1">EMPTY_OBJECT</span><span class="s2">, true, </span><span class="s1">EMPTY_OBJECT)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(resolveIdResult == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">error(implicitlyLoadedBefore === </span><span class="s2">null</span>
                <span class="s1">? errorUnresolvedEntry(unresolvedId)</span>
                <span class="s1">: errorUnresolvedImplicitDependant(unresolvedId</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(resolveIdResult === </span><span class="s2">false </span><span class="s1">||</span>
            <span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolveIdResult === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; resolveIdResult.external)) {</span>
            <span class="s2">return </span><span class="s1">error(implicitlyLoadedBefore === </span><span class="s2">null</span>
                <span class="s1">? errorEntryCannotBeExternal(unresolvedId)</span>
                <span class="s1">: errorImplicitDependantCannotBeExternal(unresolvedId</span><span class="s2">, </span><span class="s1">implicitlyLoadedBefore))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.fetchModule(</span><span class="s2">this</span><span class="s1">.getResolvedIdWithDefaults(</span><span class="s2">typeof </span><span class="s1">resolveIdResult === </span><span class="s3">'object'</span>
            <span class="s1">? resolveIdResult</span>
            <span class="s1">: { id: resolveIdResult }</span><span class="s2">, </span><span class="s1">EMPTY_OBJECT)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async resolveDynamicImport(module</span><span class="s2">, </span><span class="s1">specifier</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">assertions) {</span>
        <span class="s2">const </span><span class="s1">resolution = </span><span class="s2">await this</span><span class="s1">.pluginDriver.hookFirst(</span><span class="s3">'resolveDynamicImport'</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">specifier</span><span class="s2">,</span>
            <span class="s1">importer</span><span class="s2">,</span>
            <span class="s1">{ assertions }</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">specifier !== </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">resolution === </span><span class="s3">'string'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">resolution</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!resolution) {</span>
                <span class="s2">return null;</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">.getResolvedIdWithDefaults(resolution</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(resolution == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">existingResolution = module.resolvedIds[specifier]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(existingResolution) {</span>
                <span class="s2">if </span><span class="s1">(doAssertionsDiffer(existingResolution.assertions</span><span class="s2">, </span><span class="s1">assertions)) {</span>
                    <span class="s2">this</span><span class="s1">.options.onwarn(errorInconsistentImportAssertions(existingResolution.assertions</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">, </span><span class="s1">specifier</span><span class="s2">, </span><span class="s1">importer))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">existingResolution</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">(module.resolvedIds[specifier] = </span><span class="s2">this</span><span class="s1">.handleInvalidResolvedId(</span><span class="s2">await this</span><span class="s1">.resolveId(specifier</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">EMPTY_OBJECT</span><span class="s2">, false, </span><span class="s1">assertions)</span><span class="s2">, </span><span class="s1">specifier</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">assertions))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.handleInvalidResolvedId(</span><span class="s2">this</span><span class="s1">.getResolvedIdWithDefaults(</span><span class="s2">this</span><span class="s1">.getNormalizedResolvedIdWithoutDefaults(resolution</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">specifier)</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">, </span><span class="s1">specifier</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">assertions)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeRelativeExternalId(source</span><span class="s2">, </span><span class="s1">importer) {</span>
    <span class="s2">return </span><span class="s1">isRelative(source)</span>
        <span class="s1">? importer</span>
            <span class="s1">? resolve(importer</span><span class="s2">, </span><span class="s3">'..'</span><span class="s2">, </span><span class="s1">source)</span>
            <span class="s1">: resolve(source)</span>
        <span class="s1">: source</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addChunkNamesToModule(module</span><span class="s2">, </span><span class="s1">{ fileName</span><span class="s2">, </span><span class="s1">name }</span><span class="s2">, </span><span class="s1">isUserDefined</span><span class="s2">, </span><span class="s1">priority) {</span>
    <span class="s2">if </span><span class="s1">(fileName !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">module.chunkFileNames.add(fileName)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(name !== </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s0">// Always keep chunkNames sorted by priority</span>
        <span class="s2">let </span><span class="s1">namePosition = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(module.chunkNames[namePosition]?.priority &lt; priority)</span>
            <span class="s1">namePosition++</span><span class="s2">;</span>
        <span class="s1">module.chunkNames.splice(namePosition</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">{ isUserDefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">priority })</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNotAbsoluteExternal(id</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">makeAbsoluteExternalsRelative) {</span>
    <span class="s2">return </span><span class="s1">(makeAbsoluteExternalsRelative === </span><span class="s2">true </span><span class="s1">||</span>
        <span class="s1">(makeAbsoluteExternalsRelative === </span><span class="s3">'ifRelativeSource' </span><span class="s1">&amp;&amp; isRelative(source)) ||</span>
        <span class="s1">!isAbsolute(id))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">waitForDependencyResolution(loadPromise) {</span>
    <span class="s2">const </span><span class="s1">[resolveStaticDependencyPromises</span><span class="s2">, </span><span class="s1">resolveDynamicImportPromises] = </span><span class="s2">await </span><span class="s1">loadPromise</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">Promise.all([...resolveStaticDependencyPromises</span><span class="s2">, </span><span class="s1">...resolveDynamicImportPromises])</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">GlobalScope </span><span class="s2">extends </span><span class="s1">Scope$1 {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.variables.set(</span><span class="s3">'undefined'</span><span class="s2">, new </span><span class="s1">UndefinedVariable())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">findVariable(name) {</span>
        <span class="s2">let </span><span class="s1">variable = </span><span class="s2">this</span><span class="s1">.variables.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!variable) {</span>
            <span class="s1">variable = </span><span class="s2">new </span><span class="s1">GlobalVariable(name)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.variables.set(name</span><span class="s2">, </span><span class="s1">variable)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">variable</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getSourceHash(source) {</span>
    <span class="s2">return </span><span class="s1">createHash().update(source).digest(</span><span class="s3">'hex'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generateAssetFileName(name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">bundle) {</span>
    <span class="s2">const </span><span class="s1">emittedName = outputOptions.sanitizeFileName(name || </span><span class="s3">'asset'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">makeUnique(renderNamePattern(</span><span class="s2">typeof </span><span class="s1">outputOptions.assetFileNames === </span><span class="s3">'function'</span>
        <span class="s1">? outputOptions.assetFileNames({ name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">type: </span><span class="s3">'asset' </span><span class="s1">})</span>
        <span class="s1">: outputOptions.assetFileNames</span><span class="s2">, </span><span class="s3">'output.assetFileNames'</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">ext: () =&gt; extname(emittedName).slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">extname: () =&gt; extname(emittedName)</span><span class="s2">,</span>
        <span class="s1">hash: size =&gt; sourceHash.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">Math.max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">size || defaultHashSize))</span><span class="s2">,</span>
        <span class="s1">name: () =&gt; emittedName.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">Math.max(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">emittedName.length - extname(emittedName).length))</span>
    <span class="s1">})</span><span class="s2">, </span><span class="s1">bundle)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reserveFileNameInBundle(fileName</span><span class="s2">, </span><span class="s1">{ bundle }</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">if </span><span class="s1">(bundle[lowercaseBundleKeys].has(fileName.toLowerCase())) {</span>
        <span class="s1">warn(errorFileNameConflict(fileName))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">bundle[fileName] = FILE_PLACEHOLDER</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasValidType(emittedFile) {</span>
    <span class="s2">return </span><span class="s1">Boolean(emittedFile &amp;&amp;</span>
        <span class="s1">(emittedFile.type === </span><span class="s3">'asset' </span><span class="s1">||</span>
            <span class="s1">emittedFile.type === </span><span class="s3">'chunk'</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasValidName(emittedFile) {</span>
    <span class="s2">const </span><span class="s1">validatedName = emittedFile.fileName || emittedFile.name</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">!validatedName || (</span><span class="s2">typeof </span><span class="s1">validatedName === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; !isPathFragment(validatedName))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getValidSource(source</span><span class="s2">, </span><span class="s1">emittedFile</span><span class="s2">, </span><span class="s1">fileReferenceId) {</span>
    <span class="s2">if </span><span class="s1">(!(</span><span class="s2">typeof </span><span class="s1">source === </span><span class="s3">'string' </span><span class="s1">|| source </span><span class="s2">instanceof </span><span class="s1">Uint8Array)) {</span>
        <span class="s2">const </span><span class="s1">assetName = emittedFile.fileName || emittedFile.name || fileReferenceId</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Could not set source for </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">assetName === </span><span class="s3">'string' </span><span class="s1">? </span><span class="s3">`asset &quot;</span><span class="s1">${assetName}</span><span class="s3">&quot;` </span><span class="s1">: </span><span class="s3">'unnamed asset'</span><span class="s1">}</span><span class="s3">, asset source needs to be a string, Uint8Array or Buffer.`</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">source</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAssetFileName(file</span><span class="s2">, </span><span class="s1">referenceId) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">file.fileName !== </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorAssetNotFinalisedForFileName(file.name || referenceId))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">file.fileName</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getChunkFileName(file</span><span class="s2">, </span><span class="s1">facadeChunkByModule) {</span>
    <span class="s2">if </span><span class="s1">(file.fileName) {</span>
        <span class="s2">return </span><span class="s1">file.fileName</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(facadeChunkByModule) {</span>
        <span class="s2">return </span><span class="s1">facadeChunkByModule.get(file.module).getFileName()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">error(errorChunkNotGeneratedForFileName(file.fileName || file.name))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">FileEmitter {</span>
    <span class="s1">constructor(graph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">baseFileEmitter) {</span>
        <span class="s2">this</span><span class="s1">.graph = graph</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.facadeChunkByModule = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.nextIdBase = </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.output = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">.outputFileEmitters = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.emitFile = (emittedFile) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!hasValidType(emittedFile)) {</span>
                <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Emitted files must be of type &quot;asset&quot; or &quot;chunk&quot;, received &quot;</span><span class="s1">${emittedFile &amp;&amp; emittedFile.type}</span><span class="s3">&quot;.`</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!hasValidName(emittedFile)) {</span>
                <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`The &quot;fileName&quot; or &quot;name&quot; properties of emitted files must be strings that are neither absolute nor relative paths, received &quot;</span><span class="s1">${emittedFile.fileName || emittedFile.name}</span><span class="s3">&quot;.`</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(emittedFile.type === </span><span class="s3">'chunk'</span><span class="s1">) {</span>
                <span class="s2">return this</span><span class="s1">.emitChunk(emittedFile)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">.emitAsset(emittedFile)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.finaliseAssets = () =&gt; {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[referenceId</span><span class="s2">, </span><span class="s1">emittedFile] of </span><span class="s2">this</span><span class="s1">.filesByReferenceId) {</span>
                <span class="s2">if </span><span class="s1">(emittedFile.type === </span><span class="s3">'asset' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">emittedFile.fileName !== </span><span class="s3">'string'</span><span class="s1">)</span>
                    <span class="s2">return </span><span class="s1">error(errorNoAssetSourceSet(emittedFile.name || referenceId))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.getFileName = (fileReferenceId) =&gt; {</span>
            <span class="s2">const </span><span class="s1">emittedFile = </span><span class="s2">this</span><span class="s1">.filesByReferenceId.get(fileReferenceId)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!emittedFile)</span>
                <span class="s2">return </span><span class="s1">error(errorFileReferenceIdNotFoundForFilename(fileReferenceId))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(emittedFile.type === </span><span class="s3">'chunk'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">getChunkFileName(emittedFile</span><span class="s2">, this</span><span class="s1">.facadeChunkByModule)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">getAssetFileName(emittedFile</span><span class="s2">, </span><span class="s1">fileReferenceId)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setAssetSource = (referenceId</span><span class="s2">, </span><span class="s1">requestedSource) =&gt; {</span>
            <span class="s2">const </span><span class="s1">consumedFile = </span><span class="s2">this</span><span class="s1">.filesByReferenceId.get(referenceId)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!consumedFile)</span>
                <span class="s2">return </span><span class="s1">error(errorAssetReferenceIdNotFoundForSetSource(referenceId))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(consumedFile.type !== </span><span class="s3">'asset'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Asset sources can only be set for emitted assets but &quot;</span><span class="s1">${referenceId}</span><span class="s3">&quot; is an emitted chunk.`</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(consumedFile.source !== undefined) {</span>
                <span class="s2">return </span><span class="s1">error(errorAssetSourceAlreadySet(consumedFile.name || referenceId))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">source = getValidSource(requestedSource</span><span class="s2">, </span><span class="s1">consumedFile</span><span class="s2">, </span><span class="s1">referenceId)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.output) {</span>
                <span class="s2">this</span><span class="s1">.finalizeAdditionalAsset(consumedFile</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, this</span><span class="s1">.output)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">consumedFile.source = source</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">emitter of </span><span class="s2">this</span><span class="s1">.outputFileEmitters) {</span>
                    <span class="s1">emitter.finalizeAdditionalAsset(consumedFile</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">emitter.output)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setChunkInformation = (facadeChunkByModule) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.facadeChunkByModule = facadeChunkByModule</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setOutputBundle = (bundle</span><span class="s2">, </span><span class="s1">outputOptions) =&gt; {</span>
            <span class="s2">const </span><span class="s1">output = (</span><span class="s2">this</span><span class="s1">.output = {</span>
                <span class="s1">bundle</span><span class="s2">,</span>
                <span class="s1">fileNamesBySource: </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">,</span>
                <span class="s1">outputOptions</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">emittedFile of </span><span class="s2">this</span><span class="s1">.filesByReferenceId.values()) {</span>
                <span class="s2">if </span><span class="s1">(emittedFile.fileName) {</span>
                    <span class="s1">reserveFileNameInBundle(emittedFile.fileName</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, this</span><span class="s1">.options.onwarn)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">consumedAssetsByHash = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">consumedFile of </span><span class="s2">this</span><span class="s1">.filesByReferenceId.values()) {</span>
                <span class="s2">if </span><span class="s1">(consumedFile.type === </span><span class="s3">'asset' </span><span class="s1">&amp;&amp; consumedFile.source !== undefined) {</span>
                    <span class="s2">if </span><span class="s1">(consumedFile.fileName) {</span>
                        <span class="s2">this</span><span class="s1">.finalizeAdditionalAsset(consumedFile</span><span class="s2">, </span><span class="s1">consumedFile.source</span><span class="s2">, </span><span class="s1">output)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">sourceHash = getSourceHash(consumedFile.source)</span><span class="s2">;</span>
                        <span class="s1">getOrCreate(consumedAssetsByHash</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">() =&gt; []).push(consumedFile)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[sourceHash</span><span class="s2">, </span><span class="s1">consumedFiles] of consumedAssetsByHash) {</span>
                <span class="s2">this</span><span class="s1">.finalizeAssetsWithSameSource(consumedFiles</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">output)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.filesByReferenceId = baseFileEmitter</span>
            <span class="s1">? </span><span class="s2">new </span><span class="s1">Map(baseFileEmitter.filesByReferenceId)</span>
            <span class="s1">: </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s1">baseFileEmitter?.addOutputFileEmitter(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">addOutputFileEmitter(outputFileEmitter) {</span>
        <span class="s2">this</span><span class="s1">.outputFileEmitters.push(outputFileEmitter)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">assignReferenceId(file</span><span class="s2">, </span><span class="s1">idBase) {</span>
        <span class="s2">let </span><span class="s1">referenceId = idBase</span><span class="s2">;</span>
        <span class="s2">do </span><span class="s1">{</span>
            <span class="s1">referenceId = createHash().update(referenceId).digest(</span><span class="s3">'hex'</span><span class="s1">).slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.filesByReferenceId.has(referenceId) ||</span>
            <span class="s2">this</span><span class="s1">.outputFileEmitters.some(({ filesByReferenceId }) =&gt; filesByReferenceId.has(referenceId)))</span><span class="s2">;</span>
        <span class="s1">file.referenceId = referenceId</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.filesByReferenceId.set(referenceId</span><span class="s2">, </span><span class="s1">file)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ filesByReferenceId } of </span><span class="s2">this</span><span class="s1">.outputFileEmitters) {</span>
            <span class="s1">filesByReferenceId.set(referenceId</span><span class="s2">, </span><span class="s1">file)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">referenceId</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">emitAsset(emittedAsset) {</span>
        <span class="s2">const </span><span class="s1">source = emittedAsset.source === undefined</span>
            <span class="s1">? undefined</span>
            <span class="s1">: getValidSource(emittedAsset.source</span><span class="s2">, </span><span class="s1">emittedAsset</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">consumedAsset = {</span>
            <span class="s1">fileName: emittedAsset.fileName</span><span class="s2">,</span>
            <span class="s1">name: emittedAsset.name</span><span class="s2">,</span>
            <span class="s1">needsCodeReference: !!emittedAsset.needsCodeReference</span><span class="s2">,</span>
            <span class="s1">referenceId: </span><span class="s3">''</span><span class="s2">,</span>
            <span class="s1">source</span><span class="s2">,</span>
            <span class="s1">type: </span><span class="s3">'asset'</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">referenceId = </span><span class="s2">this</span><span class="s1">.assignReferenceId(consumedAsset</span><span class="s2">, </span><span class="s1">emittedAsset.fileName || emittedAsset.name || String(</span><span class="s2">this</span><span class="s1">.nextIdBase++))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.output) {</span>
            <span class="s2">this</span><span class="s1">.emitAssetWithReferenceId(consumedAsset</span><span class="s2">, this</span><span class="s1">.output)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">fileEmitter of </span><span class="s2">this</span><span class="s1">.outputFileEmitters) {</span>
                <span class="s1">fileEmitter.emitAssetWithReferenceId(consumedAsset</span><span class="s2">, </span><span class="s1">fileEmitter.output)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">referenceId</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">emitAssetWithReferenceId(consumedAsset</span><span class="s2">, </span><span class="s1">output) {</span>
        <span class="s2">const </span><span class="s1">{ fileName</span><span class="s2">, </span><span class="s1">source } = consumedAsset</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(fileName) {</span>
            <span class="s1">reserveFileNameInBundle(fileName</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, this</span><span class="s1">.options.onwarn)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(source !== undefined) {</span>
            <span class="s2">this</span><span class="s1">.finalizeAdditionalAsset(consumedAsset</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">output)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">emitChunk(emittedChunk) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.graph.phase &gt; BuildPhase.LOAD_AND_PARSE) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidRollupPhaseForChunkEmission())</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">emittedChunk.id !== </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">error(errorFailedValidation(</span><span class="s3">`Emitted chunks need to have a valid string id, received &quot;</span><span class="s1">${emittedChunk.id}</span><span class="s3">&quot;`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">consumedChunk = {</span>
            <span class="s1">fileName: emittedChunk.fileName</span><span class="s2">,</span>
            <span class="s1">module: </span><span class="s2">null,</span>
            <span class="s1">name: emittedChunk.name || emittedChunk.id</span><span class="s2">,</span>
            <span class="s1">referenceId: </span><span class="s3">''</span><span class="s2">,</span>
            <span class="s1">type: </span><span class="s3">'chunk'</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.graph.moduleLoader</span>
            <span class="s1">.emitChunk(emittedChunk)</span>
            <span class="s1">.then(module =&gt; (consumedChunk.module = module))</span>
            <span class="s1">.catch(() =&gt; {</span>
            <span class="s0">// Avoid unhandled Promise rejection as the error will be thrown later</span>
            <span class="s0">// once module loading has finished</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.assignReferenceId(consumedChunk</span><span class="s2">, </span><span class="s1">emittedChunk.id)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">finalizeAdditionalAsset(consumedFile</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">{ bundle</span><span class="s2">, </span><span class="s1">fileNamesBySource</span><span class="s2">, </span><span class="s1">outputOptions }) {</span>
        <span class="s2">let </span><span class="s1">{ fileName</span><span class="s2">, </span><span class="s1">needsCodeReference</span><span class="s2">, </span><span class="s1">referenceId } = consumedFile</span><span class="s2">;</span>
        <span class="s0">// Deduplicate assets if an explicit fileName is not provided</span>
        <span class="s2">if </span><span class="s1">(!fileName) {</span>
            <span class="s2">const </span><span class="s1">sourceHash = getSourceHash(source)</span><span class="s2">;</span>
            <span class="s1">fileName = fileNamesBySource.get(sourceHash)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!fileName) {</span>
                <span class="s1">fileName = generateAssetFileName(consumedFile.name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">bundle)</span><span class="s2">;</span>
                <span class="s1">fileNamesBySource.set(sourceHash</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">// We must not modify the original assets to avoid interaction between outputs</span>
        <span class="s2">const </span><span class="s1">assetWithFileName = { ...consumedFile</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">, </span><span class="s1">source }</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.filesByReferenceId.set(referenceId</span><span class="s2">, </span><span class="s1">assetWithFileName)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">existingAsset = bundle[fileName]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(existingAsset?.type === </span><span class="s3">'asset'</span><span class="s1">) {</span>
            <span class="s1">existingAsset.needsCodeReference &amp;&amp; (existingAsset.needsCodeReference = needsCodeReference)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">bundle[fileName] = {</span>
                <span class="s1">fileName</span><span class="s2">,</span>
                <span class="s1">name: consumedFile.name</span><span class="s2">,</span>
                <span class="s1">needsCodeReference</span><span class="s2">,</span>
                <span class="s1">source</span><span class="s2">,</span>
                <span class="s1">type: </span><span class="s3">'asset'</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">finalizeAssetsWithSameSource(consumedFiles</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">{ bundle</span><span class="s2">, </span><span class="s1">fileNamesBySource</span><span class="s2">, </span><span class="s1">outputOptions }) {</span>
        <span class="s2">let </span><span class="s1">fileName = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">usedConsumedFile</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">needsCodeReference = </span><span class="s2">true;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">consumedFile of consumedFiles) {</span>
            <span class="s1">needsCodeReference &amp;&amp; (needsCodeReference = consumedFile.needsCodeReference)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">assetFileName = generateAssetFileName(consumedFile.name</span><span class="s2">, </span><span class="s1">consumedFile.source</span><span class="s2">, </span><span class="s1">sourceHash</span><span class="s2">, </span><span class="s1">outputOptions</span><span class="s2">, </span><span class="s1">bundle)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!fileName ||</span>
                <span class="s1">assetFileName.length &lt; fileName.length ||</span>
                <span class="s1">(assetFileName.length === fileName.length &amp;&amp; assetFileName &lt; fileName)) {</span>
                <span class="s1">fileName = assetFileName</span><span class="s2">;</span>
                <span class="s1">usedConsumedFile = consumedFile</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">fileNamesBySource.set(sourceHash</span><span class="s2">, </span><span class="s1">fileName)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">consumedFile of consumedFiles) {</span>
            <span class="s0">// We must not modify the original assets to avoid interaction between outputs</span>
            <span class="s2">const </span><span class="s1">assetWithFileName = { ...consumedFile</span><span class="s2">, </span><span class="s1">fileName }</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.filesByReferenceId.set(consumedFile.referenceId</span><span class="s2">, </span><span class="s1">assetWithFileName)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">bundle[fileName] = {</span>
            <span class="s1">fileName</span><span class="s2">,</span>
            <span class="s1">name: usedConsumedFile.name</span><span class="s2">,</span>
            <span class="s1">needsCodeReference</span><span class="s2">,</span>
            <span class="s1">source: usedConsumedFile.source</span><span class="s2">,</span>
            <span class="s1">type: </span><span class="s3">'asset'</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getPluginContext(plugin</span><span class="s2">, </span><span class="s1">pluginCache</span><span class="s2">, </span><span class="s1">graph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">fileEmitter</span><span class="s2">, </span><span class="s1">existingPluginNames) {</span>
    <span class="s2">let </span><span class="s1">cacheable = </span><span class="s2">true;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">plugin.cacheKey !== </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||</span>
            <span class="s1">plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) ||</span>
            <span class="s1">existingPluginNames.has(plugin.name)) {</span>
            <span class="s1">cacheable = </span><span class="s2">false;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">existingPluginNames.add(plugin.name)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">cacheInstance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!pluginCache) {</span>
        <span class="s1">cacheInstance = NO_CACHE</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(cacheable) {</span>
        <span class="s2">const </span><span class="s1">cacheKey = plugin.cacheKey || plugin.name</span><span class="s2">;</span>
        <span class="s1">cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(</span><span class="s2">null</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">cacheInstance = getCacheForUncacheablePlugin(plugin.name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">addWatchFile(id) {</span>
            <span class="s2">if </span><span class="s1">(graph.phase &gt;= BuildPhase.GENERATE) {</span>
                <span class="s2">return this</span><span class="s1">.error(errorInvalidRollupPhaseForAddWatchFile())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">graph.watchFiles[id] = </span><span class="s2">true;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">cache: cacheInstance</span><span class="s2">,</span>
        <span class="s1">emitFile: fileEmitter.emitFile.bind(fileEmitter)</span><span class="s2">,</span>
        <span class="s1">error(error_) {</span>
            <span class="s2">return </span><span class="s1">error(errorPluginError(error_</span><span class="s2">, </span><span class="s1">plugin.name))</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">getFileName: fileEmitter.getFileName</span><span class="s2">,</span>
        <span class="s1">getModuleIds: () =&gt; graph.modulesById.keys()</span><span class="s2">,</span>
        <span class="s1">getModuleInfo: graph.getModuleInfo</span><span class="s2">,</span>
        <span class="s1">getWatchFiles: () =&gt; Object.keys(graph.watchFiles)</span><span class="s2">,</span>
        <span class="s1">load(resolvedId) {</span>
            <span class="s2">return </span><span class="s1">graph.moduleLoader.preloadModule(resolvedId)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">meta: {</span>
            <span class="s1">rollupVersion: version$1</span><span class="s2">,</span>
            <span class="s1">watchMode: graph.watchMode</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get moduleIds() {</span>
            <span class="s2">function</span><span class="s1">* wrappedModuleIds() {</span>
                <span class="s0">// We are wrapping this in a generator to only show the message once we are actually iterating</span>
                <span class="s1">warnDeprecation(</span><span class="s3">`Accessing &quot;this.moduleIds&quot; on the plugin context by plugin </span><span class="s1">${plugin.name} </span><span class="s3">is deprecated. The &quot;this.getModuleIds&quot; plugin context function should be used instead.`</span><span class="s2">, </span><span class="s1">URL_THIS_GETMODULEIDS</span><span class="s2">, true, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">plugin.name)</span><span class="s2">;</span>
                <span class="s2">yield</span><span class="s1">* moduleIds</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">moduleIds = graph.modulesById.keys()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">wrappedModuleIds()</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">parse: graph.contextParse.bind(graph)</span><span class="s2">,</span>
        <span class="s1">resolve(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">{ assertions</span><span class="s2">, </span><span class="s1">custom</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">skipSelf } = BLANK) {</span>
            <span class="s2">return </span><span class="s1">graph.moduleLoader.resolveId(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">custom</span><span class="s2">, </span><span class="s1">isEntry</span><span class="s2">, </span><span class="s1">assertions || EMPTY_OBJECT</span><span class="s2">, </span><span class="s1">skipSelf ? [{ importer</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">source }] : </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">setAssetSource: fileEmitter.setAssetSource</span><span class="s2">,</span>
        <span class="s1">warn(warning) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">warning === </span><span class="s3">'string'</span><span class="s1">)</span>
                <span class="s1">warning = { message: warning }</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(warning.code)</span>
                <span class="s1">warning.pluginCode = warning.code</span><span class="s2">;</span>
            <span class="s1">warning.code = </span><span class="s3">'PLUGIN_WARNING'</span><span class="s2">;</span>
            <span class="s1">warning.plugin = plugin.name</span><span class="s2">;</span>
            <span class="s1">options.onwarn(warning)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">// This will make sure no input hook is omitted</span>
<span class="s2">const </span><span class="s1">inputHookNames = {</span>
    <span class="s1">buildEnd: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">buildStart: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">closeBundle: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">closeWatcher: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">load: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">moduleParsed: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">options: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">resolveDynamicImport: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">resolveId: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">shouldTransformCachedModule: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">transform: </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">watchChange: </span><span class="s4">1</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">inputHooks = Object.keys(inputHookNames)</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">PluginDriver {</span>
    <span class="s1">constructor(graph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">userPlugins</span><span class="s2">, </span><span class="s1">pluginCache</span><span class="s2">, </span><span class="s1">basePluginDriver) {</span>
        <span class="s2">this</span><span class="s1">.graph = graph</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginCache = pluginCache</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.sortedPlugins = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.unfulfilledActions = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.fileEmitter = </span><span class="s2">new </span><span class="s1">FileEmitter(graph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">basePluginDriver &amp;&amp; basePluginDriver.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.emitFile = </span><span class="s2">this</span><span class="s1">.fileEmitter.emitFile.bind(</span><span class="s2">this</span><span class="s1">.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.getFileName = </span><span class="s2">this</span><span class="s1">.fileEmitter.getFileName.bind(</span><span class="s2">this</span><span class="s1">.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.finaliseAssets = </span><span class="s2">this</span><span class="s1">.fileEmitter.finaliseAssets.bind(</span><span class="s2">this</span><span class="s1">.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setChunkInformation = </span><span class="s2">this</span><span class="s1">.fileEmitter.setChunkInformation.bind(</span><span class="s2">this</span><span class="s1">.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.setOutputBundle = </span><span class="s2">this</span><span class="s1">.fileEmitter.setOutputBundle.bind(</span><span class="s2">this</span><span class="s1">.fileEmitter)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.plugins = [...(basePluginDriver ? basePluginDriver.plugins : [])</span><span class="s2">, </span><span class="s1">...userPlugins]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">existingPluginNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pluginContexts = </span><span class="s2">new </span><span class="s1">Map(</span><span class="s2">this</span><span class="s1">.plugins.map(plugin =&gt; [</span>
            <span class="s1">plugin</span><span class="s2">,</span>
            <span class="s1">getPluginContext(plugin</span><span class="s2">, </span><span class="s1">pluginCache</span><span class="s2">, </span><span class="s1">graph</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, this</span><span class="s1">.fileEmitter</span><span class="s2">, </span><span class="s1">existingPluginNames)</span>
        <span class="s1">]))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(basePluginDriver) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of userPlugins) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">hook of inputHooks) {</span>
                    <span class="s2">if </span><span class="s1">(hook </span><span class="s2">in </span><span class="s1">plugin) {</span>
                        <span class="s1">options.onwarn(errorInputHookInOutputPlugin(plugin.name</span><span class="s2">, </span><span class="s1">hook))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">createOutputPluginDriver(plugins) {</span>
        <span class="s2">return new </span><span class="s1">PluginDriver(</span><span class="s2">this</span><span class="s1">.graph</span><span class="s2">, this</span><span class="s1">.options</span><span class="s2">, </span><span class="s1">plugins</span><span class="s2">, this</span><span class="s1">.pluginCache</span><span class="s2">, this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getUnfulfilledHookActions() {</span>
        <span class="s2">return this</span><span class="s1">.unfulfilledActions</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains, first non-null result stops and returns</span>
    <span class="s1">hookFirst(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext</span><span class="s2">, </span><span class="s1">skipped) {</span>
        <span class="s2">return this</span><span class="s1">.hookFirstAndGetPlugin(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext</span><span class="s2">, </span><span class="s1">skipped).then(result =&gt; result &amp;&amp; result[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains, first non-null result stops and returns result and last plugin</span>
    <span class="s1">async hookFirstAndGetPlugin(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext</span><span class="s2">, </span><span class="s1">skipped) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s2">if </span><span class="s1">(skipped?.has(plugin))</span>
                <span class="s2">continue;</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">await this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(result != </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">[result</span><span class="s2">, </span><span class="s1">plugin]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s0">// chains synchronously, first non-null result stops and returns</span>
    <span class="s1">hookFirstSync(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.runHookSync(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(result != </span><span class="s2">null</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s0">// parallel, ignores returns</span>
    <span class="s1">async hookParallel(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">const </span><span class="s1">parallelPromises = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s2">if </span><span class="s1">(plugin[hookName].sequential) {</span>
                <span class="s2">await </span><span class="s1">Promise.all(parallelPromises)</span><span class="s2">;</span>
                <span class="s1">parallelPromises.length = </span><span class="s4">0</span><span class="s2">;</span>
                <span class="s2">await this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parallelPromises.push(</span><span class="s2">this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">await </span><span class="s1">Promise.all(parallelPromises)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains, reduces returned value, handling the reduced value as the first hook argument</span>
    <span class="s1">hookReduceArg0(hookName</span><span class="s2">, </span><span class="s1">[argument0</span><span class="s2">, </span><span class="s1">...rest]</span><span class="s2">, </span><span class="s1">reduce</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">let </span><span class="s1">promise = Promise.resolve(argument0)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s1">promise = promise.then(argument0 =&gt; </span><span class="s2">this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">[argument0</span><span class="s2">, </span><span class="s1">...rest]</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext).then(result =&gt; reduce.call(</span><span class="s2">this</span><span class="s1">.pluginContexts.get(plugin)</span><span class="s2">, </span><span class="s1">argument0</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">plugin)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">promise</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains synchronously, reduces returned value, handling the reduced value as the first hook argument</span>
    <span class="s1">hookReduceArg0Sync(hookName</span><span class="s2">, </span><span class="s1">[argument0</span><span class="s2">, </span><span class="s1">...rest]</span><span class="s2">, </span><span class="s1">reduce</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s2">const </span><span class="s1">parameters = [argument0</span><span class="s2">, </span><span class="s1">...rest]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.runHookSync(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext)</span><span class="s2">;</span>
            <span class="s1">argument0 = reduce.call(</span><span class="s2">this</span><span class="s1">.pluginContexts.get(plugin)</span><span class="s2">, </span><span class="s1">argument0</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">argument0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains, reduces returned value to type string, handling the reduced value separately. permits hooks as values.</span>
    <span class="s1">async hookReduceValue(hookName</span><span class="s2">, </span><span class="s1">initialValue</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">reducer) {</span>
        <span class="s2">const </span><span class="s1">results = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">parallelResults = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName</span><span class="s2">, </span><span class="s1">validateAddonPluginHandler)) {</span>
            <span class="s2">if </span><span class="s1">(plugin[hookName].sequential) {</span>
                <span class="s1">results.push(...(</span><span class="s2">await </span><span class="s1">Promise.all(parallelResults)))</span><span class="s2">;</span>
                <span class="s1">parallelResults.length = </span><span class="s4">0</span><span class="s2">;</span>
                <span class="s1">results.push(</span><span class="s2">await this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">parallelResults.push(</span><span class="s2">this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">results.push(...(</span><span class="s2">await </span><span class="s1">Promise.all(parallelResults)))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">results.reduce(reducer</span><span class="s2">, await </span><span class="s1">initialValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains synchronously, reduces returned value to type T, handling the reduced value separately. permits hooks as values.</span>
    <span class="s1">hookReduceValueSync(hookName</span><span class="s2">, </span><span class="s1">initialValue</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">reduce</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">let </span><span class="s1">accumulator = initialValue</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.runHookSync(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext)</span><span class="s2">;</span>
            <span class="s1">accumulator = reduce.call(</span><span class="s2">this</span><span class="s1">.pluginContexts.get(plugin)</span><span class="s2">, </span><span class="s1">accumulator</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">accumulator</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// chains, ignores returns</span>
    <span class="s1">hookSeq(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">let </span><span class="s1">promise = Promise.resolve()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of </span><span class="s2">this</span><span class="s1">.getSortedPlugins(hookName)) {</span>
            <span class="s1">promise = promise.then(() =&gt; </span><span class="s2">this</span><span class="s1">.runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">promise.then(noReturn)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getSortedPlugins(hookName</span><span class="s2">, </span><span class="s1">validateHandler) {</span>
        <span class="s2">return </span><span class="s1">getOrCreate(</span><span class="s2">this</span><span class="s1">.sortedPlugins</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">() =&gt; getSortedValidatedPlugins(hookName</span><span class="s2">, this</span><span class="s1">.plugins</span><span class="s2">, </span><span class="s1">validateHandler))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Implementation signature</span>
    <span class="s1">runHook(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s0">// We always filter for plugins that support the hook before running it</span>
        <span class="s2">const </span><span class="s1">hook = plugin[hookName]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">typeof </span><span class="s1">hook === </span><span class="s3">'object' </span><span class="s1">? hook.handler : hook</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">context = </span><span class="s2">this</span><span class="s1">.pluginContexts.get(plugin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(replaceContext) {</span>
            <span class="s1">context = replaceContext(context</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">action = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">Promise.resolve()</span>
            <span class="s1">.then(() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">handler !== </span><span class="s3">'function'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">handler</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// eslint-disable-next-line @typescript-eslint/ban-types</span>
            <span class="s2">const </span><span class="s1">hookResult = handler.apply(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!hookResult?.then) {</span>
                <span class="s0">// short circuit for non-thenables and non-Promises</span>
                <span class="s2">return </span><span class="s1">hookResult</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">// Track pending hook actions to properly error out when</span>
            <span class="s0">// unfulfilled promises cause rollup to abruptly and confusingly</span>
            <span class="s0">// exit with a successful 0 return code but without producing any</span>
            <span class="s0">// output, errors or warnings.</span>
            <span class="s1">action = [plugin.name</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">parameters]</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.unfulfilledActions.add(action)</span><span class="s2">;</span>
            <span class="s0">// Although it would be more elegant to just return hookResult here</span>
            <span class="s0">// and put the .then() handler just above the .catch() handler below,</span>
            <span class="s0">// doing so would subtly change the defacto async event dispatch order</span>
            <span class="s0">// which at least one test and some plugins in the wild may depend on.</span>
            <span class="s2">return </span><span class="s1">Promise.resolve(hookResult).then(result =&gt; {</span>
                <span class="s0">// action was fulfilled</span>
                <span class="s2">this</span><span class="s1">.unfulfilledActions.delete(action)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">})</span>
            <span class="s1">.catch(error_ =&gt; {</span>
            <span class="s2">if </span><span class="s1">(action !== </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s0">// action considered to be fulfilled since error being handled</span>
                <span class="s2">this</span><span class="s1">.unfulfilledActions.delete(action)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">error(errorPluginError(error_</span><span class="s2">, </span><span class="s1">plugin.name</span><span class="s2">, </span><span class="s1">{ hook: hookName }))</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Run a sync plugin hook and return the result.</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">hookName Name of the plugin hook. Must be in `PluginHooks`.</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">args Arguments passed to the plugin hook.</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">plugin The acutal plugin</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">replaceContext When passed, the plugin context can be overridden.</span>
     <span class="s5">*/</span>
    <span class="s1">runHookSync(hookName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">, </span><span class="s1">plugin</span><span class="s2">, </span><span class="s1">replaceContext) {</span>
        <span class="s2">const </span><span class="s1">hook = plugin[hookName]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">typeof </span><span class="s1">hook === </span><span class="s3">'object' </span><span class="s1">? hook.handler : hook</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">context = </span><span class="s2">this</span><span class="s1">.pluginContexts.get(plugin)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(replaceContext) {</span>
            <span class="s1">context = replaceContext(context</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s0">// eslint-disable-next-line @typescript-eslint/ban-types</span>
            <span class="s2">return </span><span class="s1">handler.apply(context</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(error_) {</span>
            <span class="s2">return </span><span class="s1">error(errorPluginError(error_</span><span class="s2">, </span><span class="s1">plugin.name</span><span class="s2">, </span><span class="s1">{ hook: hookName }))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSortedValidatedPlugins(hookName</span><span class="s2">, </span><span class="s1">plugins</span><span class="s2">, </span><span class="s1">validateHandler = validateFunctionPluginHandler) {</span>
    <span class="s2">const </span><span class="s1">pre = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">normal = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">post = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">plugin of plugins) {</span>
        <span class="s2">const </span><span class="s1">hook = plugin[hookName]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hook) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">hook === </span><span class="s3">'object'</span><span class="s1">) {</span>
                <span class="s1">validateHandler(hook.handler</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hook.order === </span><span class="s3">'pre'</span><span class="s1">) {</span>
                    <span class="s1">pre.push(plugin)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(hook.order === </span><span class="s3">'post'</span><span class="s1">) {</span>
                    <span class="s1">post.push(plugin)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">validateHandler(hook</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">plugin)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">normal.push(plugin)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[...pre</span><span class="s2">, </span><span class="s1">...normal</span><span class="s2">, </span><span class="s1">...post]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateFunctionPluginHandler(handler</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">handler !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s1">error(errorInvalidFunctionPluginHook(hookName</span><span class="s2">, </span><span class="s1">plugin.name))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateAddonPluginHandler(handler</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">plugin) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">handler !== </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">handler !== </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidAddonPluginHook(hookName</span><span class="s2">, </span><span class="s1">plugin.name))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">noReturn() { }</span>

<span class="s2">class </span><span class="s1">Queue {</span>
    <span class="s1">constructor(maxParallel) {</span>
        <span class="s2">this</span><span class="s1">.maxParallel = maxParallel</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.queue = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.workerCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">run(task) {</span>
        <span class="s2">return new </span><span class="s1">Promise((resolve</span><span class="s2">, </span><span class="s1">reject) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.queue.push({ reject</span><span class="s2">, </span><span class="s1">resolve</span><span class="s2">, </span><span class="s1">task })</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.work()</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async work() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.workerCount &gt;= </span><span class="s2">this</span><span class="s1">.maxParallel)</span>
            <span class="s2">return;</span>
        <span class="s2">this</span><span class="s1">.workerCount++</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">entry</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">((entry = </span><span class="s2">this</span><span class="s1">.queue.shift())) {</span>
            <span class="s2">const </span><span class="s1">{ reject</span><span class="s2">, </span><span class="s1">resolve</span><span class="s2">, </span><span class="s1">task } = entry</span><span class="s2">;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">task()</span><span class="s2">;</span>
                <span class="s1">resolve(result)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">catch </span><span class="s1">(error) {</span>
                <span class="s1">reject(error)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.workerCount--</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">normalizeEntryModules(entryModules) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(entryModules)) {</span>
        <span class="s2">return </span><span class="s1">entryModules.map(id =&gt; ({</span>
            <span class="s1">fileName: </span><span class="s2">null,</span>
            <span class="s1">id</span><span class="s2">,</span>
            <span class="s1">implicitlyLoadedAfter: []</span><span class="s2">,</span>
            <span class="s1">importer: undefined</span><span class="s2">,</span>
            <span class="s1">name: </span><span class="s2">null</span>
        <span class="s1">}))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Object.entries(entryModules).map(([name</span><span class="s2">, </span><span class="s1">id]) =&gt; ({</span>
        <span class="s1">fileName: </span><span class="s2">null,</span>
        <span class="s1">id</span><span class="s2">,</span>
        <span class="s1">implicitlyLoadedAfter: []</span><span class="s2">,</span>
        <span class="s1">importer: undefined</span><span class="s2">,</span>
        <span class="s1">name</span>
    <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Graph {</span>
    <span class="s1">constructor(options</span><span class="s2">, </span><span class="s1">watcher) {</span>
        <span class="s2">this</span><span class="s1">.options = options</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.astLru = flru(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.cachedModules = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.deoptimizationTracker = </span><span class="s2">new </span><span class="s1">PathTracker()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.entryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modulesById = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.needsTreeshakingPass = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.phase = BuildPhase.LOAD_AND_PARSE</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.scope = </span><span class="s2">new </span><span class="s1">GlobalScope()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.watchFiles = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.watchMode = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">.externalModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.implicitEntryModules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.modules = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.getModuleInfo = (moduleId) =&gt; {</span>
            <span class="s2">const </span><span class="s1">foundModule = </span><span class="s2">this</span><span class="s1">.modulesById.get(moduleId)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!foundModule)</span>
                <span class="s2">return null;</span>
            <span class="s2">return </span><span class="s1">foundModule.info</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(options.cache !== </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(options.cache?.modules) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of options.cache.modules)</span>
                    <span class="s2">this</span><span class="s1">.cachedModules.set(module.id</span><span class="s2">, </span><span class="s1">module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.pluginCache = options.cache?.plugins || Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s0">// increment access counter</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name </span><span class="s2">in this</span><span class="s1">.pluginCache) {</span>
                <span class="s2">const </span><span class="s1">cache = </span><span class="s2">this</span><span class="s1">.pluginCache[name]</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">value of Object.values(cache))</span>
                    <span class="s1">value[</span><span class="s4">0</span><span class="s1">]++</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(watcher) {</span>
            <span class="s2">this</span><span class="s1">.watchMode = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">handleChange = (...parameters) =&gt; </span><span class="s2">this</span><span class="s1">.pluginDriver.hookParallel(</span><span class="s3">'watchChange'</span><span class="s2">, </span><span class="s1">parameters)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">handleClose = () =&gt; </span><span class="s2">this</span><span class="s1">.pluginDriver.hookParallel(</span><span class="s3">'closeWatcher'</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
            <span class="s1">watcher.onCurrentRun(</span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">handleChange)</span><span class="s2">;</span>
            <span class="s1">watcher.onCurrentRun(</span><span class="s3">'close'</span><span class="s2">, </span><span class="s1">handleClose)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.pluginDriver = </span><span class="s2">new </span><span class="s1">PluginDriver(</span><span class="s2">this, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">options.plugins</span><span class="s2">, this</span><span class="s1">.pluginCache)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.acornParser = Parser.extend(...options.acornInjectPlugins)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.moduleLoader = </span><span class="s2">new </span><span class="s1">ModuleLoader(</span><span class="s2">this, this</span><span class="s1">.modulesById</span><span class="s2">, this</span><span class="s1">.options</span><span class="s2">, this</span><span class="s1">.pluginDriver)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.fileOperationQueue = </span><span class="s2">new </span><span class="s1">Queue(options.maxParallelFileOps)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.pureFunctions = getPureFunctions(options)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async build() {</span>
        <span class="s1">timeStart(</span><span class="s3">'generate module graph'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">await this</span><span class="s1">.generateModuleGraph()</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'generate module graph'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">timeStart(</span><span class="s3">'sort and bind modules'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.phase = BuildPhase.ANALYSE</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.sortModules()</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'sort and bind modules'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">timeStart(</span><span class="s3">'mark included statements'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.includeStatements()</span><span class="s2">;</span>
        <span class="s1">timeEnd(</span><span class="s3">'mark included statements'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.phase = BuildPhase.GENERATE</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">contextParse(code</span><span class="s2">, </span><span class="s1">options = {}) {</span>
        <span class="s2">const </span><span class="s1">onCommentOrig = options.onComment</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">comments = []</span><span class="s2">;</span>
        <span class="s1">options.onComment =</span>
            <span class="s1">onCommentOrig &amp;&amp; </span><span class="s2">typeof </span><span class="s1">onCommentOrig == </span><span class="s3">'function'</span>
                <span class="s1">? (block</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">...parameters) =&gt; {</span>
                    <span class="s1">comments.push({ end</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">type: block ? </span><span class="s3">'Block' </span><span class="s1">: </span><span class="s3">'Line'</span><span class="s2">, </span><span class="s1">value: text })</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">onCommentOrig.call(options</span><span class="s2">, </span><span class="s1">block</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">...parameters)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">: comments</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">ast = </span><span class="s2">this</span><span class="s1">.acornParser.parse(code</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">...</span><span class="s2">this</span><span class="s1">.options.acorn</span><span class="s2">,</span>
            <span class="s1">...options</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">onCommentOrig == </span><span class="s3">'object'</span><span class="s1">) {</span>
            <span class="s1">onCommentOrig.push(...comments)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">options.onComment = onCommentOrig</span><span class="s2">;</span>
        <span class="s1">addAnnotations(comments</span><span class="s2">, </span><span class="s1">ast</span><span class="s2">, </span><span class="s1">code)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">ast</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getCache() {</span>
        <span class="s0">// handle plugin cache eviction</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name </span><span class="s2">in this</span><span class="s1">.pluginCache) {</span>
            <span class="s2">const </span><span class="s1">cache = </span><span class="s2">this</span><span class="s1">.pluginCache[name]</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">allDeleted = </span><span class="s2">true;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">value] of Object.entries(cache)) {</span>
                <span class="s2">if </span><span class="s1">(value[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s2">this</span><span class="s1">.options.experimentalCacheExpiry)</span>
                    <span class="s2">delete </span><span class="s1">cache[key]</span><span class="s2">;</span>
                <span class="s2">else</span>
                    <span class="s1">allDeleted = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(allDeleted)</span>
                <span class="s2">delete this</span><span class="s1">.pluginCache[name]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">modules: </span><span class="s2">this</span><span class="s1">.modules.map(module =&gt; module.toJSON())</span><span class="s2">,</span>
            <span class="s1">plugins: </span><span class="s2">this</span><span class="s1">.pluginCache</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">async generateModuleGraph() {</span>
        <span class="s1">({ entryModules: </span><span class="s2">this</span><span class="s1">.entryModules</span><span class="s2">, </span><span class="s1">implicitEntryModules: </span><span class="s2">this</span><span class="s1">.implicitEntryModules } =</span>
            <span class="s2">await this</span><span class="s1">.moduleLoader.addEntryModules(normalizeEntryModules(</span><span class="s2">this</span><span class="s1">.options.input)</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.entryModules.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'You must supply options.input to rollup'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.modulesById.values()) {</span>
            <span class="s2">if </span><span class="s1">(module </span><span class="s2">instanceof </span><span class="s1">Module) {</span>
                <span class="s2">this</span><span class="s1">.modules.push(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.externalModules.push(module)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">includeStatements() {</span>
        <span class="s2">const </span><span class="s1">entryModules = [...</span><span class="s2">this</span><span class="s1">.entryModules</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.implicitEntryModules]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of entryModules) {</span>
            <span class="s1">markModuleAndImpureDependenciesAsExecuted(module)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.treeshake) {</span>
            <span class="s2">let </span><span class="s1">treeshakingPass = </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">timeStart(</span><span class="s3">`treeshaking pass </span><span class="s1">${treeshakingPass}</span><span class="s3">`</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.needsTreeshakingPass = </span><span class="s2">false;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.modules) {</span>
                    <span class="s2">if </span><span class="s1">(module.isExecuted) {</span>
                        <span class="s2">if </span><span class="s1">(module.info.moduleSideEffects === </span><span class="s3">'no-treeshake'</span><span class="s1">) {</span>
                            <span class="s1">module.includeAllInBundle()</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">module.include()</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(treeshakingPass === </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s0">// We only include exports after the first pass to avoid issues with</span>
                    <span class="s0">// the TDZ detection logic</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of entryModules) {</span>
                        <span class="s2">if </span><span class="s1">(module.preserveSignature !== </span><span class="s2">false</span><span class="s1">) {</span>
                            <span class="s1">module.includeAllExports(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s2">this</span><span class="s1">.needsTreeshakingPass = </span><span class="s2">true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">timeEnd(</span><span class="s3">`treeshaking pass </span><span class="s1">${treeshakingPass++}</span><span class="s3">`</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.needsTreeshakingPass)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.modules)</span>
                <span class="s1">module.includeAllInBundle()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">externalModule of </span><span class="s2">this</span><span class="s1">.externalModules)</span>
            <span class="s1">externalModule.warnUnusedImports()</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.implicitEntryModules) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dependant of module.implicitlyLoadedAfter) {</span>
                <span class="s2">if </span><span class="s1">(!(dependant.info.isEntry || dependant.isIncluded())) {</span>
                    <span class="s1">error(errorImplicitDependantIsNotIncluded(dependant))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">sortModules() {</span>
        <span class="s2">const </span><span class="s1">{ orderedModules</span><span class="s2">, </span><span class="s1">cyclePaths } = analyseModuleExecution(</span><span class="s2">this</span><span class="s1">.entryModules)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">cyclePath of cyclePaths) {</span>
            <span class="s2">this</span><span class="s1">.options.onwarn(errorCircularDependency(cyclePath))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.modules = orderedModules</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.modules) {</span>
            <span class="s1">module.bindReferences()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.warnForMissingExports()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">warnForMissingExports() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">module of </span><span class="s2">this</span><span class="s1">.modules) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">importDescription of module.importDescriptions.values()) {</span>
                <span class="s2">if </span><span class="s1">(importDescription.name !== </span><span class="s3">'*' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!importDescription.module.getVariableForExportName(importDescription.name)[</span><span class="s4">0</span><span class="s1">]) {</span>
                    <span class="s1">module.warn(errorMissingExport(importDescription.name</span><span class="s2">, </span><span class="s1">module.id</span><span class="s2">, </span><span class="s1">importDescription.module.id)</span><span class="s2">, </span><span class="s1">importDescription.start)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">formatAction([pluginName</span><span class="s2">, </span><span class="s1">hookName</span><span class="s2">, </span><span class="s1">parameters]) {</span>
    <span class="s2">const </span><span class="s1">action = </span><span class="s3">`(</span><span class="s1">${pluginName}</span><span class="s3">) </span><span class="s1">${hookName}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">s = JSON.stringify</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(hookName) {</span>
        <span class="s2">case </span><span class="s3">'resolveId'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${action} ${s(parameters[</span><span class="s4">0</span><span class="s1">])} ${s(parameters[</span><span class="s4">1</span><span class="s1">])}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'load'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${action} ${s(parameters[</span><span class="s4">0</span><span class="s1">])}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'transform'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${action} ${s(parameters[</span><span class="s4">1</span><span class="s1">])}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'shouldTransformCachedModule'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${action} ${s(parameters[</span><span class="s4">0</span><span class="s1">].id)}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'moduleParsed'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">`</span><span class="s1">${action} ${s(parameters[</span><span class="s4">0</span><span class="s1">].id)}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">action</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">// We do not directly listen on process to avoid max listeners warnings for</span>
<span class="s0">// complicated build processes</span>
<span class="s2">const </span><span class="s1">beforeExitEvent = </span><span class="s3">'beforeExit'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">beforeExitEmitter = </span><span class="s2">new </span><span class="s1">EventEmitter()</span><span class="s2">;</span>
<span class="s1">beforeExitEmitter.setMaxListeners(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">process$1.on(beforeExitEvent</span><span class="s2">, </span><span class="s1">() =&gt; beforeExitEmitter.emit(beforeExitEvent))</span><span class="s2">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">catchUnfinishedHookActions(pluginDriver</span><span class="s2">, </span><span class="s1">callback) {</span>
    <span class="s2">let </span><span class="s1">handleEmptyEventLoop</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">emptyEventLoopPromise = </span><span class="s2">new </span><span class="s1">Promise((_</span><span class="s2">, </span><span class="s1">reject) =&gt; {</span>
        <span class="s1">handleEmptyEventLoop = () =&gt; {</span>
            <span class="s2">const </span><span class="s1">unfulfilledActions = pluginDriver.getUnfulfilledHookActions()</span><span class="s2">;</span>
            <span class="s1">reject(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s1">[...unfulfilledActions].map(formatAction).join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)))</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">beforeExitEmitter.once(beforeExitEvent</span><span class="s2">, </span><span class="s1">handleEmptyEventLoop)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">Promise.race([callback()</span><span class="s2">, </span><span class="s1">emptyEventLoopPromise])</span><span class="s2">;</span>
    <span class="s1">beforeExitEmitter.off(beforeExitEvent</span><span class="s2">, </span><span class="s1">handleEmptyEventLoop)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">leftCurlyBrace = </span><span class="s3">&quot;{&quot;</span><span class="s1">.charCodeAt(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">space = </span><span class="s3">&quot; &quot;</span><span class="s1">.charCodeAt(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">keyword = </span><span class="s3">&quot;assert&quot;</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">FUNC_STATEMENT = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">FUNC_NULLABLE_ID = </span><span class="s4">4</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">importAssertions(Parser) {</span>
  <span class="s0">// Use supplied version acorn version if present, to avoid</span>
  <span class="s0">// reference mismatches due to different acorn versions. This</span>
  <span class="s0">// allows this plugin to be used with Rollup which supplies</span>
  <span class="s0">// its own internal version of acorn and thereby sidesteps</span>
  <span class="s0">// the package manager.</span>
  <span class="s2">const </span><span class="s1">acorn = Parser.acorn || _acorn</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ tokTypes: tt</span><span class="s2">, </span><span class="s1">TokenType } = acorn</span><span class="s2">;</span>

  <span class="s2">return class extends </span><span class="s1">Parser {</span>
    <span class="s1">constructor(...args) {</span>
      <span class="s2">super</span><span class="s1">(...args)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.assertToken = </span><span class="s2">new </span><span class="s1">TokenType(keyword)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">_codeAt(i) {</span>
      <span class="s2">return this</span><span class="s1">.input.charCodeAt(i)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">_eat(t) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== t) {</span>
        <span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">readToken(code) {</span>
      <span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">; </span><span class="s1">i &lt; keyword.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._codeAt(</span><span class="s2">this</span><span class="s1">.pos + i) !== keyword.charCodeAt(i)) {</span>
          <span class="s2">return super</span><span class="s1">.readToken(code)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// ensure that the keyword is at the correct location</span>
      <span class="s0">// ie `assert{...` or `assert {...`</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">;; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._codeAt(</span><span class="s2">this</span><span class="s1">.pos + i) === leftCurlyBrace) {</span>
          <span class="s0">// Found '{'</span>
          <span class="s2">break;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._codeAt(</span><span class="s2">this</span><span class="s1">.pos + i) === space) {</span>
          <span class="s0">// white space is allowed between `assert` and `{`, so continue.</span>
          <span class="s2">continue;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return super</span><span class="s1">.readToken(code)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// If we're inside a dynamic import expression we'll parse</span>
      <span class="s0">// the `assert` keyword as a standard object property name</span>
      <span class="s0">// ie `import(&quot;&quot;./foo.json&quot;, { assert: { type: &quot;json&quot; } })`</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type.label === </span><span class="s3">&quot;{&quot;</span><span class="s1">) {</span>
        <span class="s2">return super</span><span class="s1">.readToken(code)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.pos += keyword.length</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.finishToken(</span><span class="s2">this</span><span class="s1">.assertToken)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">parseDynamicImport(node) {</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s0">// skip `(`</span>

      <span class="s0">// Parse node.source.</span>
      <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(tt.comma)) {</span>
        <span class="s2">const </span><span class="s1">obj = </span><span class="s2">this</span><span class="s1">.parseObj(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">node.arguments = [obj]</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._eat(tt.parenR)</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportExpression&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">// ported from acorn/src/statement.js pp.parseExport</span>
    <span class="s1">parseExport(node</span><span class="s2">, </span><span class="s1">exports) {</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s0">// export * from '...'</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(tt.star)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.ecmaVersion &gt;= </span><span class="s4">11</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;as&quot;</span><span class="s1">)) {</span>
            <span class="s1">node.exported = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s1">node.exported.name</span><span class="s2">, this</span><span class="s1">.lastTokStart)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node.exported = </span><span class="s2">null;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== tt.string) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === </span><span class="s2">this</span><span class="s1">.assertToken) {</span>
          <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">assertions = </span><span class="s2">this</span><span class="s1">.parseImportAssertions()</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(assertions) {</span>
            <span class="s1">node.assertions = assertions</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s1">)</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(tt._default)) { </span><span class="s0">// export default ...</span>
        <span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s3">&quot;default&quot;</span><span class="s2">, this</span><span class="s1">.lastTokStart)</span><span class="s2">;</span>
        <span class="s2">var </span><span class="s1">isAsync</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tt._function || (isAsync = </span><span class="s2">this</span><span class="s1">.isAsyncFunction())) {</span>
          <span class="s2">var </span><span class="s1">fNode = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
          <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isAsync) { </span><span class="s2">this</span><span class="s1">.next()</span><span class="s2">; </span><span class="s1">}</span>
          <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseFunction(fNode</span><span class="s2">, </span><span class="s1">FUNC_STATEMENT | FUNC_NULLABLE_ID</span><span class="s2">, false, </span><span class="s1">isAsync)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tt._class) {</span>
          <span class="s2">var </span><span class="s1">cNode = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>
          <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseClass(cNode</span><span class="s2">, </span><span class="s3">&quot;nullableID&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseMaybeAssign()</span><span class="s2">;</span>
          <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">)</span>
      <span class="s1">}</span>
      <span class="s0">// export var|const|let|function|class ...</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shouldParseExportStatement()) {</span>
        <span class="s1">node.declaration = </span><span class="s2">this</span><span class="s1">.parseStatement(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(node.declaration.type === </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s1">)</span>
          <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkVariableExport(exports</span><span class="s2">, </span><span class="s1">node.declaration.declarations)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s2">else</span>
          <span class="s1">{ </span><span class="s2">this</span><span class="s1">.checkExport(exports</span><span class="s2">, </span><span class="s1">node.declaration.id.name</span><span class="s2">, </span><span class="s1">node.declaration.id.start)</span><span class="s2">; </span><span class="s1">}</span>
        <span class="s1">node.specifiers = []</span><span class="s2">;</span>
        <span class="s1">node.source = </span><span class="s2">null;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{ </span><span class="s0">// export { x, y as z } [from '...']</span>
        <span class="s1">node.declaration = </span><span class="s2">null;</span>
        <span class="s1">node.specifiers = </span><span class="s2">this</span><span class="s1">.parseExportSpecifiers(exports)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eatContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== tt.string) { </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">; </span><span class="s1">}</span>
          <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>

          <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === </span><span class="s2">this</span><span class="s1">.assertToken) {</span>
            <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">assertions = </span><span class="s2">this</span><span class="s1">.parseImportAssertions()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(assertions) {</span>
              <span class="s1">node.assertions = assertions</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">list = node.specifiers</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i += </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">// check for keywords used as local names</span>
            <span class="s2">var </span><span class="s1">spec = list[i]</span><span class="s2">;</span>

            <span class="s2">this</span><span class="s1">.checkUnreserved(spec.local)</span><span class="s2">;</span>
            <span class="s0">// check if export is defined</span>
            <span class="s2">this</span><span class="s1">.checkLocalExport(spec.local)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">node.source = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s1">parseImport(node) {</span>
      <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
      <span class="s0">// import '...'</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tt.string) {</span>
        <span class="s1">node.specifiers = []</span><span class="s2">;</span>
        <span class="s1">node.source = </span><span class="s2">this</span><span class="s1">.parseExprAtom()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">node.specifiers = </span><span class="s2">this</span><span class="s1">.parseImportSpecifiers()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.expectContextual(</span><span class="s3">&quot;from&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">node.source =</span>
          <span class="s2">this</span><span class="s1">.type === tt.string ? </span><span class="s2">this</span><span class="s1">.parseExprAtom() : </span><span class="s2">this</span><span class="s1">.unexpected()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === </span><span class="s2">this</span><span class="s1">.assertToken) {</span>
        <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">assertions = </span><span class="s2">this</span><span class="s1">.parseImportAssertions()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(assertions) {</span>
          <span class="s1">node.assertions = assertions</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.semicolon()</span><span class="s2">;</span>
      <span class="s2">return this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportDeclaration&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">parseImportAssertions() {</span>
      <span class="s2">this</span><span class="s1">._eat(tt.braceL)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">attrs = </span><span class="s2">this</span><span class="s1">.parseAssertEntries()</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">._eat(tt.braceR)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">attrs</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">parseAssertEntries() {</span>
      <span class="s2">const </span><span class="s1">attrs = []</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">attrNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>

      <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tt.braceR) {</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.startNode()</span><span class="s2">;</span>

        <span class="s0">// parse AssertionKey : IdentifierName, StringLiteral</span>
        <span class="s2">let </span><span class="s1">assertionKeyNode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type === tt.string) {</span>
          <span class="s1">assertionKeyNode = </span><span class="s2">this</span><span class="s1">.parseLiteral(</span><span class="s2">this</span><span class="s1">.value)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">assertionKeyNode = </span><span class="s2">this</span><span class="s1">.parseIdent(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.next()</span><span class="s2">;</span>
        <span class="s1">node.key = assertionKeyNode</span><span class="s2">;</span>

        <span class="s0">// check if we already have an entry for an attribute</span>
        <span class="s0">// if a duplicate entry is found, throw an error</span>
        <span class="s0">// for now this logic will come into play only when someone declares `type` twice</span>
        <span class="s2">if </span><span class="s1">(attrNames.has(node.key.name)) {</span>
          <span class="s2">this</span><span class="s1">.raise(</span><span class="s2">this</span><span class="s1">.pos</span><span class="s2">, </span><span class="s3">&quot;Duplicated key in assertions&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">attrNames.add(node.key.name)</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type !== tt.string) {</span>
          <span class="s2">this</span><span class="s1">.raise(</span>
            <span class="s2">this</span><span class="s1">.pos</span><span class="s2">,</span>
            <span class="s3">&quot;Only string is supported as an assertion value&quot;</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">node.value = </span><span class="s2">this</span><span class="s1">.parseLiteral(</span><span class="s2">this</span><span class="s1">.value)</span><span class="s2">;</span>

        <span class="s1">attrs.push(</span><span class="s2">this</span><span class="s1">.finishNode(node</span><span class="s2">, </span><span class="s3">&quot;ImportAttribute&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.eat(tt.comma))</span><span class="s2">;</span>

      <span class="s2">return </span><span class="s1">attrs</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">ensureArray(items) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(items)) {</span>
        <span class="s2">return </span><span class="s1">items.filter(Boolean)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(items) {</span>
        <span class="s2">return </span><span class="s1">[items]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">asyncFlatten(array) {</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">array = (</span><span class="s2">await </span><span class="s1">Promise.all(array)).flat(Infinity)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">while </span><span class="s1">(array.some((v) =&gt; v?.then))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">array</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">defaultOnWarn = warning =&gt; console.warn(warning.message || warning)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">warnUnknownOptions(passedOptions</span><span class="s2">, </span><span class="s1">validOptions</span><span class="s2">, </span><span class="s1">optionType</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">ignoredKeys = </span><span class="s4">/$./</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">validOptionSet = </span><span class="s2">new </span><span class="s1">Set(validOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">unknownOptions = Object.keys(passedOptions).filter(key =&gt; !(validOptionSet.has(key) || ignoredKeys.test(key)))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(unknownOptions.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">warn(errorUnknownOption(optionType</span><span class="s2">, </span><span class="s1">unknownOptions</span><span class="s2">, </span><span class="s1">[...validOptionSet].sort()))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">treeshakePresets = {</span>
    <span class="s1">recommended: {</span>
        <span class="s1">annotations: </span><span class="s2">true,</span>
        <span class="s1">correctVarValueBeforeDeclaration: </span><span class="s2">false,</span>
        <span class="s1">manualPureFunctions: EMPTY_ARRAY</span><span class="s2">,</span>
        <span class="s1">moduleSideEffects: () =&gt; </span><span class="s2">true,</span>
        <span class="s1">propertyReadSideEffects: </span><span class="s2">true,</span>
        <span class="s1">tryCatchDeoptimization: </span><span class="s2">true,</span>
        <span class="s1">unknownGlobalSideEffects: </span><span class="s2">false</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">safest: {</span>
        <span class="s1">annotations: </span><span class="s2">true,</span>
        <span class="s1">correctVarValueBeforeDeclaration: </span><span class="s2">true,</span>
        <span class="s1">manualPureFunctions: EMPTY_ARRAY</span><span class="s2">,</span>
        <span class="s1">moduleSideEffects: () =&gt; </span><span class="s2">true,</span>
        <span class="s1">propertyReadSideEffects: </span><span class="s2">true,</span>
        <span class="s1">tryCatchDeoptimization: </span><span class="s2">true,</span>
        <span class="s1">unknownGlobalSideEffects: </span><span class="s2">true</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">smallest: {</span>
        <span class="s1">annotations: </span><span class="s2">true,</span>
        <span class="s1">correctVarValueBeforeDeclaration: </span><span class="s2">false,</span>
        <span class="s1">manualPureFunctions: EMPTY_ARRAY</span><span class="s2">,</span>
        <span class="s1">moduleSideEffects: () =&gt; </span><span class="s2">false,</span>
        <span class="s1">propertyReadSideEffects: </span><span class="s2">false,</span>
        <span class="s1">tryCatchDeoptimization: </span><span class="s2">false,</span>
        <span class="s1">unknownGlobalSideEffects: </span><span class="s2">false</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">generatedCodePresets = {</span>
    <span class="s1">es2015: {</span>
        <span class="s1">arrowFunctions: </span><span class="s2">true,</span>
        <span class="s1">constBindings: </span><span class="s2">true,</span>
        <span class="s1">objectShorthand: </span><span class="s2">true,</span>
        <span class="s1">reservedNamesAsProps: </span><span class="s2">true,</span>
        <span class="s1">symbols: </span><span class="s2">true</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">es5: {</span>
        <span class="s1">arrowFunctions: </span><span class="s2">false,</span>
        <span class="s1">constBindings: </span><span class="s2">false,</span>
        <span class="s1">objectShorthand: </span><span class="s2">false,</span>
        <span class="s1">reservedNamesAsProps: </span><span class="s2">true,</span>
        <span class="s1">symbols: </span><span class="s2">false</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">objectifyOption = (value) =&gt; value &amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'object' </span><span class="s1">? value : {}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">objectifyOptionWithPresets = (presets</span><span class="s2">, </span><span class="s1">optionName</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">additionalValues) =&gt; (value) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">preset = presets[value]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(preset) {</span>
            <span class="s2">return </span><span class="s1">preset</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">error(errorInvalidOption(optionName</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s3">`valid values are </span><span class="s1">${additionalValues}${printQuotedStringList(Object.keys(presets))}</span><span class="s3">. You can also supply an object for more fine-grained control`</span><span class="s2">, </span><span class="s1">value))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">objectifyOption(value)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getOptionWithPreset = (value</span><span class="s2">, </span><span class="s1">presets</span><span class="s2">, </span><span class="s1">optionName</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">additionalValues) =&gt; {</span>
    <span class="s2">const </span><span class="s1">presetName = value?.preset</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(presetName) {</span>
        <span class="s2">const </span><span class="s1">preset = presets[presetName]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(preset) {</span>
            <span class="s2">return </span><span class="s1">{ ...preset</span><span class="s2">, </span><span class="s1">...value }</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">error(errorInvalidOption(</span><span class="s3">`</span><span class="s1">${optionName}</span><span class="s3">.preset`</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s3">`valid values are </span><span class="s1">${printQuotedStringList(Object.keys(presets))}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">presetName))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">objectifyOptionWithPresets(presets</span><span class="s2">, </span><span class="s1">optionName</span><span class="s2">, </span><span class="s1">urlSnippet</span><span class="s2">, </span><span class="s1">additionalValues)(value)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizePluginOption = async (plugins) =&gt; (</span><span class="s2">await </span><span class="s1">asyncFlatten([plugins])).filter(Boolean)</span><span class="s2">;</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">normalizeInputOptions(config) {</span>
    <span class="s0">// These are options that may trigger special warnings or behaviour later</span>
    <span class="s0">// if the user did not select an explicit value</span>
    <span class="s2">const </span><span class="s1">unsetOptions = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">context = config.context ?? </span><span class="s3">'undefined'</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">onwarn = getOnwarn(config)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">strictDeprecations = config.strictDeprecations || </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">maxParallelFileOps = getmaxParallelFileOps(config</span><span class="s2">, </span><span class="s1">onwarn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">options = {</span>
        <span class="s1">acorn: getAcorn(config)</span><span class="s2">,</span>
        <span class="s1">acornInjectPlugins: getAcornInjectPlugins(config)</span><span class="s2">,</span>
        <span class="s1">cache: getCache(config)</span><span class="s2">,</span>
        <span class="s1">context</span><span class="s2">,</span>
        <span class="s1">experimentalCacheExpiry: config.experimentalCacheExpiry ?? </span><span class="s4">10</span><span class="s2">,</span>
        <span class="s1">experimentalLogSideEffects: config.experimentalLogSideEffects || </span><span class="s2">false,</span>
        <span class="s1">external: getIdMatcher(config.external)</span><span class="s2">,</span>
        <span class="s1">inlineDynamicImports: getInlineDynamicImports$1(config</span><span class="s2">, </span><span class="s1">onwarn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">,</span>
        <span class="s1">input: getInput(config)</span><span class="s2">,</span>
        <span class="s1">makeAbsoluteExternalsRelative: config.makeAbsoluteExternalsRelative ?? </span><span class="s3">'ifRelativeSource'</span><span class="s2">,</span>
        <span class="s1">manualChunks: getManualChunks$1(config</span><span class="s2">, </span><span class="s1">onwarn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">,</span>
        <span class="s1">maxParallelFileOps</span><span class="s2">,</span>
        <span class="s1">maxParallelFileReads: maxParallelFileOps</span><span class="s2">,</span>
        <span class="s1">moduleContext: getModuleContext(config</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">,</span>
        <span class="s1">onwarn</span><span class="s2">,</span>
        <span class="s1">perf: config.perf || </span><span class="s2">false,</span>
        <span class="s1">plugins: </span><span class="s2">await </span><span class="s1">normalizePluginOption(config.plugins)</span><span class="s2">,</span>
        <span class="s1">preserveEntrySignatures: config.preserveEntrySignatures ?? </span><span class="s3">'exports-only'</span><span class="s2">,</span>
        <span class="s1">preserveModules: getPreserveModules$1(config</span><span class="s2">, </span><span class="s1">onwarn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">,</span>
        <span class="s1">preserveSymlinks: config.preserveSymlinks || </span><span class="s2">false,</span>
        <span class="s1">shimMissingExports: config.shimMissingExports || </span><span class="s2">false,</span>
        <span class="s1">strictDeprecations</span><span class="s2">,</span>
        <span class="s1">treeshake: getTreeshake(config)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">warnUnknownOptions(config</span><span class="s2">, </span><span class="s1">[...Object.keys(options)</span><span class="s2">, </span><span class="s3">'watch'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'input options'</span><span class="s2">, </span><span class="s1">options.onwarn</span><span class="s2">, </span><span class="s4">/^(output)$/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ options</span><span class="s2">, </span><span class="s1">unsetOptions }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getOnwarn = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ onwarn } = config</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">onwarn</span>
        <span class="s1">? warning =&gt; {</span>
            <span class="s1">warning.toString = () =&gt; {</span>
                <span class="s2">let </span><span class="s1">warningString = </span><span class="s3">''</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(warning.plugin)</span>
                    <span class="s1">warningString += </span><span class="s3">`(</span><span class="s1">${warning.plugin} </span><span class="s3">plugin) `</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(warning.loc)</span>
                    <span class="s1">warningString += </span><span class="s3">`</span><span class="s1">${relativeId(warning.loc.file)} </span><span class="s3">(</span><span class="s1">${warning.loc.line}</span><span class="s3">:</span><span class="s1">${warning.loc.column}</span><span class="s3">) `</span><span class="s2">;</span>
                <span class="s1">warningString += warning.message</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">warningString</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">onwarn(warning</span><span class="s2">, </span><span class="s1">defaultOnWarn)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">: defaultOnWarn</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getAcorn = (config) =&gt; ({</span>
    <span class="s1">ecmaVersion: </span><span class="s3">'latest'</span><span class="s2">,</span>
    <span class="s1">sourceType: </span><span class="s3">'module'</span><span class="s2">,</span>
    <span class="s1">...config.acorn</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getAcornInjectPlugins = (config) =&gt; [</span>
    <span class="s1">importAssertions</span><span class="s2">,</span>
    <span class="s1">...ensureArray(config.acornInjectPlugins)</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getCache = (config) =&gt; config.cache === </span><span class="s2">true </span><span class="s0">// `true` is the default</span>
    <span class="s1">? undefined</span>
    <span class="s1">: config.cache?.cache || config.cache</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getIdMatcher = (option) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(option === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">() =&gt; </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">option === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(id</span><span class="s2">, </span><span class="s1">...parameters) =&gt; (!id.startsWith(</span><span class="s3">'</span><span class="s2">\0</span><span class="s3">'</span><span class="s1">) &amp;&amp; option(id</span><span class="s2">, </span><span class="s1">...parameters)) || </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(option) {</span>
        <span class="s2">const </span><span class="s1">ids = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">matchers = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">value of ensureArray(option)) {</span>
            <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">RegExp) {</span>
                <span class="s1">matchers.push(value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">ids.add(value)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(id</span><span class="s2">, </span><span class="s1">..._arguments) =&gt; ids.has(id) || matchers.some(matcher =&gt; matcher.test(id))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">() =&gt; </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getInlineDynamicImports$1 = (config</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configInlineDynamicImports = config.inlineDynamicImports</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configInlineDynamicImports) {</span>
        <span class="s1">warnDeprecationWithOptions(</span><span class="s3">'The &quot;inlineDynamicImports&quot; option is deprecated. Use the &quot;output.inlineDynamicImports&quot; option instead.'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_INLINEDYNAMICIMPORTS</span><span class="s2">, true, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configInlineDynamicImports</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getInput = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configInput = config.input</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">configInput == </span><span class="s2">null </span><span class="s1">? [] : </span><span class="s2">typeof </span><span class="s1">configInput === </span><span class="s3">'string' </span><span class="s1">? [configInput] : configInput</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getManualChunks$1 = (config</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configManualChunks = config.manualChunks</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configManualChunks) {</span>
        <span class="s1">warnDeprecationWithOptions(</span><span class="s3">'The &quot;manualChunks&quot; option is deprecated. Use the &quot;output.manualChunks&quot; option instead.'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_MANUALCHUNKS</span><span class="s2">, true, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configManualChunks</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getmaxParallelFileOps = (config</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations) =&gt; {</span>
    <span class="s2">const </span><span class="s1">maxParallelFileReads = config.maxParallelFileReads</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">maxParallelFileReads === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s1">warnDeprecationWithOptions(</span><span class="s3">'The &quot;maxParallelFileReads&quot; option is deprecated. Use the &quot;maxParallelFileOps&quot; option instead.'</span><span class="s2">, </span><span class="s1">URL_MAXPARALLELFILEOPS</span><span class="s2">, true, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">maxParallelFileOps = config.maxParallelFileOps ?? maxParallelFileReads</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">maxParallelFileOps === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(maxParallelFileOps &lt;= </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">Infinity</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">maxParallelFileOps</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">20</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getModuleContext = (config</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configModuleContext = config.moduleContext</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">configModuleContext === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">id =&gt; configModuleContext(id) ?? context</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(configModuleContext) {</span>
        <span class="s2">const </span><span class="s1">contextByModuleId = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">moduleContext] of Object.entries(configModuleContext)) {</span>
            <span class="s1">contextByModuleId[resolve(key)] = moduleContext</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">id =&gt; contextByModuleId[id] ?? context</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">() =&gt; context</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getPreserveModules$1 = (config</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configPreserveModules = config.preserveModules</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configPreserveModules) {</span>
        <span class="s1">warnDeprecationWithOptions(</span><span class="s3">'The &quot;preserveModules&quot; option is deprecated. Use the &quot;output.preserveModules&quot; option instead.'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_PRESERVEMODULES</span><span class="s2">, true, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">strictDeprecations)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configPreserveModules</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getTreeshake = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configTreeshake = config.treeshake</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configTreeshake === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">configWithPreset = getOptionWithPreset(config.treeshake</span><span class="s2">, </span><span class="s1">treeshakePresets</span><span class="s2">, </span><span class="s3">'treeshake'</span><span class="s2">, </span><span class="s1">URL_TREESHAKE</span><span class="s2">, </span><span class="s3">'false, true, '</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">annotations: configWithPreset.annotations !== </span><span class="s2">false,</span>
        <span class="s1">correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === </span><span class="s2">true,</span>
        <span class="s1">manualPureFunctions: configWithPreset.manualPureFunctions ?? EMPTY_ARRAY</span><span class="s2">,</span>
        <span class="s1">moduleSideEffects: getHasModuleSideEffects(configWithPreset.moduleSideEffects)</span><span class="s2">,</span>
        <span class="s1">propertyReadSideEffects: configWithPreset.propertyReadSideEffects === </span><span class="s3">'always'</span>
            <span class="s1">? </span><span class="s3">'always'</span>
            <span class="s1">: configWithPreset.propertyReadSideEffects !== </span><span class="s2">false,</span>
        <span class="s1">tryCatchDeoptimization: configWithPreset.tryCatchDeoptimization !== </span><span class="s2">false,</span>
        <span class="s1">unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== </span><span class="s2">false</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getHasModuleSideEffects = (moduleSideEffectsOption) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">moduleSideEffectsOption === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">() =&gt; moduleSideEffectsOption</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(moduleSideEffectsOption === </span><span class="s3">'no-external'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(_id</span><span class="s2">, </span><span class="s1">external) =&gt; !external</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">moduleSideEffectsOption === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">(id</span><span class="s2">, </span><span class="s1">external) =&gt; id.startsWith(</span><span class="s3">'</span><span class="s2">\0</span><span class="s3">'</span><span class="s1">) ? </span><span class="s2">true </span><span class="s1">: moduleSideEffectsOption(id</span><span class="s2">, </span><span class="s1">external) !== </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(moduleSideEffectsOption)) {</span>
        <span class="s2">const </span><span class="s1">ids = </span><span class="s2">new </span><span class="s1">Set(moduleSideEffectsOption)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">id =&gt; ids.has(id)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(moduleSideEffectsOption) {</span>
        <span class="s1">error(errorInvalidOption(</span><span class="s3">'treeshake.moduleSideEffects'</span><span class="s2">, </span><span class="s1">URL_TREESHAKE_MODULESIDEEFFECTS</span><span class="s2">, </span><span class="s3">'please use one of false, &quot;no-external&quot;, a function or an array'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">() =&gt; </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// https://datatracker.ietf.org/doc/html/rfc2396</span>
<span class="s0">// eslint-disable-next-line no-control-regex</span>
<span class="s2">const </span><span class="s1">INVALID_CHAR_REGEX = </span><span class="s4">/[\u0000-\u001F&quot;#$&amp;*+,:;&lt;=&gt;?[\]^`{|}\u007F]/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">DRIVE_LETTER_REGEX = </span><span class="s4">/^[a-z]:/i</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">sanitizeFileName(name) {</span>
    <span class="s2">const </span><span class="s1">match = DRIVE_LETTER_REGEX.exec(name)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">driveLetter = match ? match[</span><span class="s4">0</span><span class="s1">] : </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s0">// A `:` is only allowed as part of a windows drive letter (ex: C:\foo)</span>
    <span class="s0">// Otherwise, avoid them because they can refer to NTFS alternate data streams.</span>
    <span class="s2">return </span><span class="s1">driveLetter + name.slice(driveLetter.length).replace(INVALID_CHAR_REGEX</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s2">function </span><span class="s1">normalizeOutputOptions(config</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions) {</span>
    <span class="s0">// These are options that may trigger special warnings or behaviour later</span>
    <span class="s0">// if the user did not select an explicit value</span>
    <span class="s2">const </span><span class="s1">unsetOptions = </span><span class="s2">new </span><span class="s1">Set(unsetInputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">compact = config.compact || </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">format = getFormat(config)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">inlineDynamicImports = getInlineDynamicImports(config</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">preserveModules = getPreserveModules(config</span><span class="s2">, </span><span class="s1">inlineDynamicImports</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">file = getFile(config</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">preferConst = getPreferConst(config</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">generatedCode = getGeneratedCode(config</span><span class="s2">, </span><span class="s1">preferConst)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">outputOptions = {</span>
        <span class="s1">amd: getAmd(config)</span><span class="s2">,</span>
        <span class="s1">assetFileNames: config.assetFileNames ?? </span><span class="s3">'assets/[name]-[hash][extname]'</span><span class="s2">,</span>
        <span class="s1">banner: getAddon(config</span><span class="s2">, </span><span class="s3">'banner'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">chunkFileNames: config.chunkFileNames ?? </span><span class="s3">'[name]-[hash].js'</span><span class="s2">,</span>
        <span class="s1">compact</span><span class="s2">,</span>
        <span class="s1">dir: getDir(config</span><span class="s2">, </span><span class="s1">file)</span><span class="s2">,</span>
        <span class="s1">dynamicImportFunction: getDynamicImportFunction(config</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">format)</span><span class="s2">,</span>
        <span class="s1">dynamicImportInCjs: config.dynamicImportInCjs ?? </span><span class="s2">true,</span>
        <span class="s1">entryFileNames: getEntryFileNames(config</span><span class="s2">, </span><span class="s1">unsetOptions)</span><span class="s2">,</span>
        <span class="s1">esModule: config.esModule ?? </span><span class="s3">'if-default-prop'</span><span class="s2">,</span>
        <span class="s1">experimentalDeepDynamicChunkOptimization: getExperimentalDeepDynamicChunkOptimization(config</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">,</span>
        <span class="s1">experimentalMinChunkSize: config.experimentalMinChunkSize || </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">exports: getExports(config</span><span class="s2">, </span><span class="s1">unsetOptions)</span><span class="s2">,</span>
        <span class="s1">extend: config.extend || </span><span class="s2">false,</span>
        <span class="s1">externalImportAssertions: config.externalImportAssertions ?? </span><span class="s2">true,</span>
        <span class="s1">externalLiveBindings: config.externalLiveBindings ?? </span><span class="s2">true,</span>
        <span class="s1">file</span><span class="s2">,</span>
        <span class="s1">footer: getAddon(config</span><span class="s2">, </span><span class="s3">'footer'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">format</span><span class="s2">,</span>
        <span class="s1">freeze: config.freeze ?? </span><span class="s2">true,</span>
        <span class="s1">generatedCode</span><span class="s2">,</span>
        <span class="s1">globals: config.globals || {}</span><span class="s2">,</span>
        <span class="s1">hoistTransitiveImports: config.hoistTransitiveImports ?? </span><span class="s2">true,</span>
        <span class="s1">indent: getIndent(config</span><span class="s2">, </span><span class="s1">compact)</span><span class="s2">,</span>
        <span class="s1">inlineDynamicImports</span><span class="s2">,</span>
        <span class="s1">interop: getInterop(config)</span><span class="s2">,</span>
        <span class="s1">intro: getAddon(config</span><span class="s2">, </span><span class="s3">'intro'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">manualChunks: getManualChunks(config</span><span class="s2">, </span><span class="s1">inlineDynamicImports</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">,</span>
        <span class="s1">minifyInternalExports: getMinifyInternalExports(config</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">compact)</span><span class="s2">,</span>
        <span class="s1">name: config.name</span><span class="s2">,</span>
        <span class="s1">namespaceToStringTag: getNamespaceToStringTag(config</span><span class="s2">, </span><span class="s1">generatedCode</span><span class="s2">, </span><span class="s1">inputOptions)</span><span class="s2">,</span>
        <span class="s1">noConflict: config.noConflict || </span><span class="s2">false,</span>
        <span class="s1">outro: getAddon(config</span><span class="s2">, </span><span class="s3">'outro'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">paths: config.paths || {}</span><span class="s2">,</span>
        <span class="s1">plugins: </span><span class="s2">await </span><span class="s1">normalizePluginOption(config.plugins)</span><span class="s2">,</span>
        <span class="s1">preferConst</span><span class="s2">,</span>
        <span class="s1">preserveModules</span><span class="s2">,</span>
        <span class="s1">preserveModulesRoot: getPreserveModulesRoot(config)</span><span class="s2">,</span>
        <span class="s1">sanitizeFileName: </span><span class="s2">typeof </span><span class="s1">config.sanitizeFileName === </span><span class="s3">'function'</span>
            <span class="s1">? config.sanitizeFileName</span>
            <span class="s1">: config.sanitizeFileName === </span><span class="s2">false</span>
                <span class="s1">? id =&gt; id</span>
                <span class="s1">: sanitizeFileName</span><span class="s2">,</span>
        <span class="s1">sourcemap: config.sourcemap || </span><span class="s2">false,</span>
        <span class="s1">sourcemapBaseUrl: getSourcemapBaseUrl(config)</span><span class="s2">,</span>
        <span class="s1">sourcemapExcludeSources: config.sourcemapExcludeSources || </span><span class="s2">false,</span>
        <span class="s1">sourcemapFile: config.sourcemapFile</span><span class="s2">,</span>
        <span class="s1">sourcemapIgnoreList: </span><span class="s2">typeof </span><span class="s1">config.sourcemapIgnoreList === </span><span class="s3">'function'</span>
            <span class="s1">? config.sourcemapIgnoreList</span>
            <span class="s1">: config.sourcemapIgnoreList === </span><span class="s2">false</span>
                <span class="s1">? () =&gt; </span><span class="s2">false</span>
                <span class="s1">: relativeSourcePath =&gt; relativeSourcePath.includes(</span><span class="s3">'node_modules'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapPathTransform: config.sourcemapPathTransform</span><span class="s2">,</span>
        <span class="s1">strict: config.strict ?? </span><span class="s2">true,</span>
        <span class="s1">systemNullSetters: config.systemNullSetters ?? </span><span class="s2">true,</span>
        <span class="s1">validate: config.validate || </span><span class="s2">false</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">warnUnknownOptions(config</span><span class="s2">, </span><span class="s1">Object.keys(outputOptions)</span><span class="s2">, </span><span class="s3">'output options'</span><span class="s2">, </span><span class="s1">inputOptions.onwarn)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ options: outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getFile = (config</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ file } = config</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">file === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(preserveModules) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.file'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_DIR</span><span class="s2">, </span><span class="s3">'you must set &quot;output.dir&quot; instead of &quot;output.file&quot; when using the &quot;output.preserveModules&quot; option'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!Array.isArray(inputOptions.input))</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.file'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_DIR</span><span class="s2">, </span><span class="s3">'you must set &quot;output.dir&quot; instead of &quot;output.file&quot; when providing named inputs'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">file</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getFormat = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configFormat = config.format</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(configFormat) {</span>
        <span class="s2">case </span><span class="s1">undefined:</span>
        <span class="s2">case </span><span class="s3">'es'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'esm'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'module'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">'es'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'cjs'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'commonjs'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">'cjs'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'system'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'systemjs'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s3">'system'</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s3">'amd'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'iife'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'umd'</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">configFormat</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">: {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.format'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_FORMAT</span><span class="s2">, </span><span class="s3">`Valid values are &quot;amd&quot;, &quot;cjs&quot;, &quot;system&quot;, &quot;es&quot;, &quot;iife&quot; or &quot;umd&quot;`</span><span class="s2">, </span><span class="s1">configFormat))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getInlineDynamicImports = (config</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">inlineDynamicImports = (config.inlineDynamicImports ?? inputOptions.inlineDynamicImports) || </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">{ input } = inputOptions</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(inlineDynamicImports &amp;&amp; (Array.isArray(input) ? input : Object.keys(input)).length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.inlineDynamicImports'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_INLINEDYNAMICIMPORTS</span><span class="s2">, </span><span class="s3">'multiple inputs are not supported when &quot;output.inlineDynamicImports&quot; is true'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">inlineDynamicImports</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getPreserveModules = (config</span><span class="s2">, </span><span class="s1">inlineDynamicImports</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">preserveModules = (config.preserveModules ?? inputOptions.preserveModules) || </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(preserveModules) {</span>
        <span class="s2">if </span><span class="s1">(inlineDynamicImports) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.inlineDynamicImports'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_INLINEDYNAMICIMPORTS</span><span class="s2">, </span><span class="s3">`this option is not supported for &quot;output.preserveModules&quot;`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(inputOptions.preserveEntrySignatures === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'preserveEntrySignatures'</span><span class="s2">, </span><span class="s1">URL_PRESERVEENTRYSIGNATURES</span><span class="s2">, </span><span class="s3">'setting this option to false is not supported for &quot;output.preserveModules&quot;'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">preserveModules</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getPreferConst = (config</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configPreferConst = config.preferConst</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configPreferConst != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">warnDeprecation(</span><span class="s3">`The &quot;output.preferConst&quot; option is deprecated. Use the &quot;output.generatedCode.constBindings&quot; option instead.`</span><span class="s2">, </span><span class="s1">URL_OUTPUT_GENERATEDCODE_CONSTBINDINGS</span><span class="s2">, true, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">!!configPreferConst</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getPreserveModulesRoot = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ preserveModulesRoot } = config</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(preserveModulesRoot === </span><span class="s2">null </span><span class="s1">|| preserveModulesRoot === undefined) {</span>
        <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolve(preserveModulesRoot)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getAmd = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">mergedOption = {</span>
        <span class="s1">autoId: </span><span class="s2">false,</span>
        <span class="s1">basePath: </span><span class="s3">''</span><span class="s2">,</span>
        <span class="s1">define: </span><span class="s3">'define'</span><span class="s2">,</span>
        <span class="s1">forceJsExtensionForImports: </span><span class="s2">false,</span>
        <span class="s1">...config.amd</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">((mergedOption.autoId || mergedOption.basePath) &amp;&amp; mergedOption.id) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.amd.id'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_AMD_ID</span><span class="s2">, </span><span class="s3">'this option cannot be used together with &quot;output.amd.autoId&quot;/&quot;output.amd.basePath&quot;'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mergedOption.basePath &amp;&amp; !mergedOption.autoId) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.amd.basePath'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_AMD_BASEPATH</span><span class="s2">, </span><span class="s3">'this option only works with &quot;output.amd.autoId&quot;'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mergedOption.autoId</span>
        <span class="s1">? {</span>
            <span class="s1">autoId: </span><span class="s2">true,</span>
            <span class="s1">basePath: mergedOption.basePath</span><span class="s2">,</span>
            <span class="s1">define: mergedOption.define</span><span class="s2">,</span>
            <span class="s1">forceJsExtensionForImports: mergedOption.forceJsExtensionForImports</span>
        <span class="s1">}</span>
        <span class="s1">: {</span>
            <span class="s1">autoId: </span><span class="s2">false,</span>
            <span class="s1">define: mergedOption.define</span><span class="s2">,</span>
            <span class="s1">forceJsExtensionForImports: mergedOption.forceJsExtensionForImports</span><span class="s2">,</span>
            <span class="s1">id: mergedOption.id</span>
        <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getAddon = (config</span><span class="s2">, </span><span class="s1">name) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configAddon = config[name]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">configAddon === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">configAddon</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">() =&gt; configAddon || </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">// eslint-disable-next-line unicorn/prevent-abbreviations</span>
<span class="s2">const </span><span class="s1">getDir = (config</span><span class="s2">, </span><span class="s1">file) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ dir } = config</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">dir === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">file === </span><span class="s3">'string'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.dir'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_DIR</span><span class="s2">, </span><span class="s3">'you must set either &quot;output.file&quot; for a single-file build or &quot;output.dir&quot; when generating multiple chunks'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">dir</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getDynamicImportFunction = (config</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">format) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configDynamicImportFunction = config.dynamicImportFunction</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configDynamicImportFunction) {</span>
        <span class="s1">warnDeprecation(</span><span class="s3">`The &quot;output.dynamicImportFunction&quot; option is deprecated. Use the &quot;renderDynamicImport&quot; plugin hook instead.`</span><span class="s2">, </span><span class="s1">URL_RENDERDYNAMICIMPORT</span><span class="s2">, true, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(format !== </span><span class="s3">'es'</span><span class="s1">) {</span>
            <span class="s1">inputOptions.onwarn(errorInvalidOption(</span><span class="s3">'output.dynamicImportFunction'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_DYNAMICIMPORTFUNCTION</span><span class="s2">, </span><span class="s3">'this option is ignored for formats other than &quot;es&quot;'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configDynamicImportFunction</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getEntryFileNames = (config</span><span class="s2">, </span><span class="s1">unsetOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configEntryFileNames = config.entryFileNames</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configEntryFileNames == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">unsetOptions.add(</span><span class="s3">'entryFileNames'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configEntryFileNames ?? </span><span class="s3">'[name].js'</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getExperimentalDeepDynamicChunkOptimization(config</span><span class="s2">, </span><span class="s1">inputOptions) {</span>
    <span class="s2">const </span><span class="s1">configExperimentalDeepDynamicChunkOptimization = config.experimentalDeepDynamicChunkOptimization</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configExperimentalDeepDynamicChunkOptimization != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">warnDeprecation(</span><span class="s3">`The &quot;output.experimentalDeepDynamicChunkOptimization&quot; option is deprecated as Rollup always runs the full chunking algorithm now. The option should be removed.`</span><span class="s2">, </span><span class="s1">URL_OUTPUT_EXPERIMENTALDEEPCHUNKOPTIMIZATION</span><span class="s2">, true, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configExperimentalDeepDynamicChunkOptimization || </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExports(config</span><span class="s2">, </span><span class="s1">unsetOptions) {</span>
    <span class="s2">const </span><span class="s1">configExports = config.exports</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configExports == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">unsetOptions.add(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(![</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'named'</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'auto'</span><span class="s1">].includes(configExports)) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidExportOptionValue(configExports))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configExports || </span><span class="s3">'auto'</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getGeneratedCode = (config</span><span class="s2">, </span><span class="s1">preferConst) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configWithPreset = getOptionWithPreset(config.generatedCode</span><span class="s2">, </span><span class="s1">generatedCodePresets</span><span class="s2">, </span><span class="s3">'output.generatedCode'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_GENERATEDCODE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">arrowFunctions: configWithPreset.arrowFunctions === </span><span class="s2">true,</span>
        <span class="s1">constBindings: configWithPreset.constBindings === </span><span class="s2">true </span><span class="s1">|| preferConst</span><span class="s2">,</span>
        <span class="s1">objectShorthand: configWithPreset.objectShorthand === </span><span class="s2">true,</span>
        <span class="s1">reservedNamesAsProps: configWithPreset.reservedNamesAsProps !== </span><span class="s2">false,</span>
        <span class="s1">symbols: configWithPreset.symbols === </span><span class="s2">true</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getIndent = (config</span><span class="s2">, </span><span class="s1">compact) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(compact) {</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">configIndent = config.indent</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">configIndent === </span><span class="s2">false </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: configIndent ?? </span><span class="s2">true;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ALLOWED_INTEROP_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s3">'compat'</span><span class="s2">,</span>
    <span class="s3">'auto'</span><span class="s2">,</span>
    <span class="s3">'esModule'</span><span class="s2">,</span>
    <span class="s3">'default'</span><span class="s2">,</span>
    <span class="s3">'defaultOnly'</span>
<span class="s1">])</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getInterop = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configInterop = config.interop</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">configInterop === </span><span class="s3">'function'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">interopPerId = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">defaultInterop = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">id =&gt; id === </span><span class="s2">null</span>
            <span class="s1">? defaultInterop || validateInterop((defaultInterop = configInterop(id)))</span>
            <span class="s1">: id </span><span class="s2">in </span><span class="s1">interopPerId</span>
                <span class="s1">? interopPerId[id]</span>
                <span class="s1">: validateInterop((interopPerId[id] = configInterop(id)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configInterop === undefined ? () =&gt; </span><span class="s3">'default' </span><span class="s1">: () =&gt; validateInterop(configInterop)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">validateInterop = (interop) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!ALLOWED_INTEROP_TYPES.has(interop)) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.interop'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_INTEROP</span><span class="s2">, </span>
        <span class="s0">// eslint-disable-next-line unicorn/prefer-spread</span>
        <span class="s3">`use one of </span><span class="s1">${Array.from(ALLOWED_INTEROP_TYPES</span><span class="s2">, </span><span class="s1">value =&gt; JSON.stringify(value)).join(</span><span class="s3">', '</span><span class="s1">)}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">interop))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">interop</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getManualChunks = (config</span><span class="s2">, </span><span class="s1">inlineDynamicImports</span><span class="s2">, </span><span class="s1">preserveModules</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configManualChunks = config.manualChunks || inputOptions.manualChunks</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configManualChunks) {</span>
        <span class="s2">if </span><span class="s1">(inlineDynamicImports) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.manualChunks'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_MANUALCHUNKS</span><span class="s2">, </span><span class="s3">'this option is not supported for &quot;output.inlineDynamicImports&quot;'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(preserveModules) {</span>
            <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.manualChunks'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_MANUALCHUNKS</span><span class="s2">, </span><span class="s3">'this option is not supported for &quot;output.preserveModules&quot;'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configManualChunks || {}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getMinifyInternalExports = (config</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">compact) =&gt; config.minifyInternalExports ?? (compact || format === </span><span class="s3">'es' </span><span class="s1">|| format === </span><span class="s3">'system'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getNamespaceToStringTag = (config</span><span class="s2">, </span><span class="s1">generatedCode</span><span class="s2">, </span><span class="s1">inputOptions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configNamespaceToStringTag = config.namespaceToStringTag</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(configNamespaceToStringTag != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">warnDeprecation(</span><span class="s3">`The &quot;output.namespaceToStringTag&quot; option is deprecated. Use the &quot;output.generatedCode.symbols&quot; option instead.`</span><span class="s2">, </span><span class="s1">URL_OUTPUT_GENERATEDCODE_SYMBOLS</span><span class="s2">, true, </span><span class="s1">inputOptions)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">configNamespaceToStringTag</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">generatedCode.symbols || </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getSourcemapBaseUrl = (config) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ sourcemapBaseUrl } = config</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(sourcemapBaseUrl) {</span>
        <span class="s2">if </span><span class="s1">(isValidUrl(sourcemapBaseUrl)) {</span>
            <span class="s2">return </span><span class="s1">sourcemapBaseUrl</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'output.sourcemapBaseUrl'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_SOURCEMAPBASEURL</span><span class="s2">, </span><span class="s3">`must be a valid URL, received </span><span class="s1">${JSON.stringify(sourcemapBaseUrl)}</span><span class="s3">`</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">rollup(rawInputOptions) {</span>
    <span class="s2">return </span><span class="s1">rollupInternal(rawInputOptions</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">rollupInternal(rawInputOptions</span><span class="s2">, </span><span class="s1">watcher) {</span>
    <span class="s2">const </span><span class="s1">{ options: inputOptions</span><span class="s2">, </span><span class="s1">unsetOptions: unsetInputOptions } = </span><span class="s2">await </span><span class="s1">getInputOptions(rawInputOptions</span><span class="s2">, </span><span class="s1">watcher !== </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">initialiseTimers(inputOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">graph = </span><span class="s2">new </span><span class="s1">Graph(inputOptions</span><span class="s2">, </span><span class="s1">watcher)</span><span class="s2">;</span>
    <span class="s0">// remove the cache object from the memory after graph creation (cache is not used anymore)</span>
    <span class="s2">const </span><span class="s1">useCache = rawInputOptions.cache !== </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(rawInputOptions.cache) {</span>
        <span class="s1">inputOptions.cache = undefined</span><span class="s2">;</span>
        <span class="s1">rawInputOptions.cache = undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">timeStart(</span><span class="s3">'BUILD'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">await </span><span class="s1">catchUnfinishedHookActions(graph.pluginDriver</span><span class="s2">, </span><span class="s1">async () =&gt; {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">timeStart(</span><span class="s3">'initialize'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">graph.pluginDriver.hookParallel(</span><span class="s3">'buildStart'</span><span class="s2">, </span><span class="s1">[inputOptions])</span><span class="s2">;</span>
            <span class="s1">timeEnd(</span><span class="s3">'initialize'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">graph.build()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(error_) {</span>
            <span class="s2">const </span><span class="s1">watchFiles = Object.keys(graph.watchFiles)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(watchFiles.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">error_.watchFiles = watchFiles</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">await </span><span class="s1">graph.pluginDriver.hookParallel(</span><span class="s3">'buildEnd'</span><span class="s2">, </span><span class="s1">[error_])</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">graph.pluginDriver.hookParallel(</span><span class="s3">'closeBundle'</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
            <span class="s2">throw </span><span class="s1">error_</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">await </span><span class="s1">graph.pluginDriver.hookParallel(</span><span class="s3">'buildEnd'</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">timeEnd(</span><span class="s3">'BUILD'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = {</span>
        <span class="s1">cache: useCache ? graph.getCache() : undefined</span><span class="s2">,</span>
        <span class="s1">async close() {</span>
            <span class="s2">if </span><span class="s1">(result.closed)</span>
                <span class="s2">return;</span>
            <span class="s1">result.closed = </span><span class="s2">true;</span>
            <span class="s2">await </span><span class="s1">graph.pluginDriver.hookParallel(</span><span class="s3">'closeBundle'</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">closed: </span><span class="s2">false,</span>
        <span class="s1">async generate(rawOutputOptions) {</span>
            <span class="s2">if </span><span class="s1">(result.closed)</span>
                <span class="s2">return </span><span class="s1">error(errorAlreadyClosed())</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">handleGenerateWrite(</span><span class="s2">false, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions</span><span class="s2">, </span><span class="s1">rawOutputOptions</span><span class="s2">, </span><span class="s1">graph)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">watchFiles: Object.keys(graph.watchFiles)</span><span class="s2">,</span>
        <span class="s1">async write(rawOutputOptions) {</span>
            <span class="s2">if </span><span class="s1">(result.closed)</span>
                <span class="s2">return </span><span class="s1">error(errorAlreadyClosed())</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">handleGenerateWrite(</span><span class="s2">true, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions</span><span class="s2">, </span><span class="s1">rawOutputOptions</span><span class="s2">, </span><span class="s1">graph)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(inputOptions.perf)</span>
        <span class="s1">result.getTimings = getTimings</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getInputOptions(rawInputOptions</span><span class="s2">, </span><span class="s1">watchMode) {</span>
    <span class="s2">if </span><span class="s1">(!rawInputOptions) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'You must supply an options object to rollup'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">rawPlugins = getSortedValidatedPlugins(</span><span class="s3">'options'</span><span class="s2">, await </span><span class="s1">normalizePluginOption(rawInputOptions.plugins))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ options</span><span class="s2">, </span><span class="s1">unsetOptions } = </span><span class="s2">await </span><span class="s1">normalizeInputOptions(</span><span class="s2">await </span><span class="s1">rawPlugins.reduce(applyOptionHook(watchMode)</span><span class="s2">, </span><span class="s1">Promise.resolve(rawInputOptions)))</span><span class="s2">;</span>
    <span class="s1">normalizePlugins(options.plugins</span><span class="s2">, </span><span class="s1">ANONYMOUS_PLUGIN_PREFIX)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ options</span><span class="s2">, </span><span class="s1">unsetOptions }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">applyOptionHook(watchMode) {</span>
    <span class="s2">return </span><span class="s1">async (inputOptions</span><span class="s2">, </span><span class="s1">plugin) =&gt; {</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s3">'handler' </span><span class="s2">in </span><span class="s1">plugin.options ? plugin.options.handler : plugin.options</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">((</span><span class="s2">await </span><span class="s1">handler.call({ meta: { rollupVersion: version$1</span><span class="s2">, </span><span class="s1">watchMode } }</span><span class="s2">, await </span><span class="s1">inputOptions)) ||</span>
            <span class="s1">inputOptions)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizePlugins(plugins</span><span class="s2">, </span><span class="s1">anonymousPrefix) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[index</span><span class="s2">, </span><span class="s1">plugin] of plugins.entries()) {</span>
        <span class="s2">if </span><span class="s1">(!plugin.name) {</span>
            <span class="s1">plugin.name = </span><span class="s3">`</span><span class="s1">${anonymousPrefix}${index + </span><span class="s4">1</span><span class="s1">}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleGenerateWrite(isWrite</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions</span><span class="s2">, </span><span class="s1">rawOutputOptions</span><span class="s2">, </span><span class="s1">graph) {</span>
    <span class="s2">const </span><span class="s1">{ options: outputOptions</span><span class="s2">, </span><span class="s1">outputPluginDriver</span><span class="s2">, </span><span class="s1">unsetOptions } = </span><span class="s2">await </span><span class="s1">getOutputOptionsAndPluginDriver(rawOutputOptions</span><span class="s2">, </span><span class="s1">graph.pluginDriver</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">catchUnfinishedHookActions(outputPluginDriver</span><span class="s2">, </span><span class="s1">async () =&gt; {</span>
        <span class="s2">const </span><span class="s1">bundle = </span><span class="s2">new </span><span class="s1">Bundle(outputOptions</span><span class="s2">, </span><span class="s1">unsetOptions</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">outputPluginDriver</span><span class="s2">, </span><span class="s1">graph)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">generated = </span><span class="s2">await </span><span class="s1">bundle.generate(isWrite)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isWrite) {</span>
            <span class="s1">timeStart(</span><span class="s3">'WRITE'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!outputOptions.dir &amp;&amp; !outputOptions.file) {</span>
                <span class="s2">return </span><span class="s1">error(errorMissingFileOrDirOption())</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">await </span><span class="s1">Promise.all(Object.values(generated).map(chunk =&gt; graph.fileOperationQueue.run(() =&gt; writeOutputFile(chunk</span><span class="s2">, </span><span class="s1">outputOptions))))</span><span class="s2">;</span>
            <span class="s2">await </span><span class="s1">outputPluginDriver.hookParallel(</span><span class="s3">'writeBundle'</span><span class="s2">, </span><span class="s1">[outputOptions</span><span class="s2">, </span><span class="s1">generated])</span><span class="s2">;</span>
            <span class="s1">timeEnd(</span><span class="s3">'WRITE'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">createOutput(generated)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">getOutputOptionsAndPluginDriver(rawOutputOptions</span><span class="s2">, </span><span class="s1">inputPluginDriver</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions) {</span>
    <span class="s2">if </span><span class="s1">(!rawOutputOptions) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'You must supply an options object'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">rawPlugins = </span><span class="s2">await </span><span class="s1">normalizePluginOption(rawOutputOptions.plugins)</span><span class="s2">;</span>
    <span class="s1">normalizePlugins(rawPlugins</span><span class="s2">, </span><span class="s1">ANONYMOUS_OUTPUT_PLUGIN_PREFIX)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">...(</span><span class="s2">await </span><span class="s1">getOutputOptions(inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions</span><span class="s2">, </span><span class="s1">rawOutputOptions</span><span class="s2">, </span><span class="s1">outputPluginDriver))</span><span class="s2">,</span>
        <span class="s1">outputPluginDriver</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getOutputOptions(inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions</span><span class="s2">, </span><span class="s1">rawOutputOptions</span><span class="s2">, </span><span class="s1">outputPluginDriver) {</span>
    <span class="s2">return </span><span class="s1">normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync(</span><span class="s3">'outputOptions'</span><span class="s2">, </span><span class="s1">[rawOutputOptions]</span><span class="s2">, </span><span class="s1">(outputOptions</span><span class="s2">, </span><span class="s1">result) =&gt; result || outputOptions</span><span class="s2">, </span><span class="s1">pluginContext =&gt; {</span>
        <span class="s2">const </span><span class="s1">emitError = () =&gt; pluginContext.error(errorCannotEmitFromOptionsHook())</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...pluginContext</span><span class="s2">,</span>
            <span class="s1">emitFile: emitError</span><span class="s2">,</span>
            <span class="s1">setAssetSource: emitError</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">, </span><span class="s1">inputOptions</span><span class="s2">, </span><span class="s1">unsetInputOptions)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createOutput(outputBundle) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">output: Object.values(outputBundle).filter(outputFile =&gt; Object.keys(outputFile).length &gt; </span><span class="s4">0</span><span class="s1">).sort((outputFileA</span><span class="s2">, </span><span class="s1">outputFileB) =&gt; getSortingFileType(outputFileA) - getSortingFileType(outputFileB))</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">SortingFileType</span><span class="s2">;</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(SortingFileType) {</span>
    <span class="s1">SortingFileType[SortingFileType[</span><span class="s3">&quot;ENTRY_CHUNK&quot;</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">] = </span><span class="s3">&quot;ENTRY_CHUNK&quot;</span><span class="s2">;</span>
    <span class="s1">SortingFileType[SortingFileType[</span><span class="s3">&quot;SECONDARY_CHUNK&quot;</span><span class="s1">] = </span><span class="s4">1</span><span class="s1">] = </span><span class="s3">&quot;SECONDARY_CHUNK&quot;</span><span class="s2">;</span>
    <span class="s1">SortingFileType[SortingFileType[</span><span class="s3">&quot;ASSET&quot;</span><span class="s1">] = </span><span class="s4">2</span><span class="s1">] = </span><span class="s3">&quot;ASSET&quot;</span><span class="s2">;</span>
<span class="s1">})(SortingFileType || (SortingFileType = {}))</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getSortingFileType(file) {</span>
    <span class="s2">if </span><span class="s1">(file.type === </span><span class="s3">'asset'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">SortingFileType.ASSET</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(file.isEntry) {</span>
        <span class="s2">return </span><span class="s1">SortingFileType.ENTRY_CHUNK</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">SortingFileType.SECONDARY_CHUNK</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">writeOutputFile(outputFile</span><span class="s2">, </span><span class="s1">outputOptions) {</span>
    <span class="s2">const </span><span class="s1">fileName = resolve(outputOptions.dir || dirname(outputOptions.file)</span><span class="s2">, </span><span class="s1">outputFile.fileName)</span><span class="s2">;</span>
    <span class="s0">// 'recursive: true' does not throw if the folder structure, or parts of it, already exist</span>
    <span class="s2">await </span><span class="s1">mkdir(dirname(fileName)</span><span class="s2">, </span><span class="s1">{ recursive: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">writeFile(fileName</span><span class="s2">, </span><span class="s1">outputFile.type === </span><span class="s3">'asset' </span><span class="s1">? outputFile.source : outputFile.code)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* Auxiliary function for defining rollup configuration</span>
 <span class="s5">* Mainly to facilitate IDE code prompts, after all, export default does not prompt, even if you add @type annotations, it is not accurate</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">options</span>
 <span class="s5">*/</span>
<span class="s2">function </span><span class="s1">defineConfig(options) {</span>
    <span class="s2">return </span><span class="s1">options</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">{</span>
  <span class="s1">env = {}</span><span class="s2">,</span>
  <span class="s1">argv = []</span><span class="s2">,</span>
  <span class="s1">platform = </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
<span class="s1">} = </span><span class="s2">typeof </span><span class="s1">process === </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? {} : process</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isDisabled = </span><span class="s3">&quot;NO_COLOR&quot; </span><span class="s2">in </span><span class="s1">env || argv.includes(</span><span class="s3">&quot;--no-color&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isForced = </span><span class="s3">&quot;FORCE_COLOR&quot; </span><span class="s2">in </span><span class="s1">env || argv.includes(</span><span class="s3">&quot;--color&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isWindows = platform === </span><span class="s3">&quot;win32&quot;</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isDumbTerminal = env.TERM === </span><span class="s3">&quot;dumb&quot;</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isCompatibleTerminal =</span>
  <span class="s1">tty &amp;&amp; tty.isatty &amp;&amp; tty.isatty(</span><span class="s4">1</span><span class="s1">) &amp;&amp; env.TERM &amp;&amp; !isDumbTerminal</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isCI =</span>
  <span class="s3">&quot;CI&quot; </span><span class="s2">in </span><span class="s1">env &amp;&amp;</span>
  <span class="s1">(</span><span class="s3">&quot;GITHUB_ACTIONS&quot; </span><span class="s2">in </span><span class="s1">env || </span><span class="s3">&quot;GITLAB_CI&quot; </span><span class="s2">in </span><span class="s1">env || </span><span class="s3">&quot;CIRCLECI&quot; </span><span class="s2">in </span><span class="s1">env)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isColorSupported =</span>
  <span class="s1">!isDisabled &amp;&amp;</span>
  <span class="s1">(isForced || (isWindows &amp;&amp; !isDumbTerminal) || isCompatibleTerminal || isCI)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">replaceClose = (</span>
  <span class="s1">index</span><span class="s2">,</span>
  <span class="s1">string</span><span class="s2">,</span>
  <span class="s1">close</span><span class="s2">,</span>
  <span class="s1">replace</span><span class="s2">,</span>
  <span class="s1">head = string.substring(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">index) + replace</span><span class="s2">,</span>
  <span class="s1">tail = string.substring(index + close.length)</span><span class="s2">,</span>
  <span class="s1">next = tail.indexOf(close)</span>
<span class="s1">) =&gt; head + (next &lt; </span><span class="s4">0 </span><span class="s1">? tail : replaceClose(next</span><span class="s2">, </span><span class="s1">tail</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, </span><span class="s1">replace))</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">clearBleed = (index</span><span class="s2">, </span><span class="s1">string</span><span class="s2">, </span><span class="s1">open</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, </span><span class="s1">replace) =&gt;</span>
  <span class="s1">index &lt; </span><span class="s4">0</span>
    <span class="s1">? open + string + close</span>
    <span class="s1">: open + replaceClose(index</span><span class="s2">, </span><span class="s1">string</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, </span><span class="s1">replace) + close</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">filterEmpty =</span>
  <span class="s1">(open</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, </span><span class="s1">replace = open</span><span class="s2">, </span><span class="s1">at = open.length + </span><span class="s4">1</span><span class="s1">) =&gt;</span>
  <span class="s1">(string) =&gt;</span>
    <span class="s1">string || !(string === </span><span class="s3">&quot;&quot; </span><span class="s1">|| string === undefined)</span>
      <span class="s1">? clearBleed(</span>
          <span class="s1">(</span><span class="s3">&quot;&quot; </span><span class="s1">+ string).indexOf(close</span><span class="s2">, </span><span class="s1">at)</span><span class="s2">,</span>
          <span class="s1">string</span><span class="s2">,</span>
          <span class="s1">open</span><span class="s2">,</span>
          <span class="s1">close</span><span class="s2">,</span>
          <span class="s1">replace</span>
        <span class="s1">)</span>
      <span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">init = (open</span><span class="s2">, </span><span class="s1">close</span><span class="s2">, </span><span class="s1">replace) =&gt;</span>
  <span class="s1">filterEmpty(</span><span class="s3">`</span><span class="s2">\x1b</span><span class="s3">[</span><span class="s1">${open}</span><span class="s3">m`</span><span class="s2">, </span><span class="s3">`</span><span class="s2">\x1b</span><span class="s3">[</span><span class="s1">${close}</span><span class="s3">m`</span><span class="s2">, </span><span class="s1">replace)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">colors = {</span>
  <span class="s1">reset: init(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bold: init(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\x1b</span><span class="s3">[22m</span><span class="s2">\x1b</span><span class="s3">[1m&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">dim: init(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">22</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\x1b</span><span class="s3">[22m</span><span class="s2">\x1b</span><span class="s3">[2m&quot;</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">italic: init(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">23</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">underline: init(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">24</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">inverse: init(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">27</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">hidden: init(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">28</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">strikethrough: init(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">29</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">black: init(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">red: init(</span><span class="s4">31</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">green: init(</span><span class="s4">32</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">yellow: init(</span><span class="s4">33</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">blue: init(</span><span class="s4">34</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">magenta: init(</span><span class="s4">35</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">cyan: init(</span><span class="s4">36</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">white: init(</span><span class="s4">37</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">gray: init(</span><span class="s4">90</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgBlack: init(</span><span class="s4">40</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgRed: init(</span><span class="s4">41</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgGreen: init(</span><span class="s4">42</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgYellow: init(</span><span class="s4">43</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgBlue: init(</span><span class="s4">44</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgMagenta: init(</span><span class="s4">45</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgCyan: init(</span><span class="s4">46</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgWhite: init(</span><span class="s4">47</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">blackBright: init(</span><span class="s4">90</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">redBright: init(</span><span class="s4">91</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">greenBright: init(</span><span class="s4">92</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">yellowBright: init(</span><span class="s4">93</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">blueBright: init(</span><span class="s4">94</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">magentaBright: init(</span><span class="s4">95</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">cyanBright: init(</span><span class="s4">96</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">whiteBright: init(</span><span class="s4">97</span><span class="s2">, </span><span class="s4">39</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgBlackBright: init(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgRedBright: init(</span><span class="s4">101</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgGreenBright: init(</span><span class="s4">102</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgYellowBright: init(</span><span class="s4">103</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgBlueBright: init(</span><span class="s4">104</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgMagentaBright: init(</span><span class="s4">105</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgCyanBright: init(</span><span class="s4">106</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
  <span class="s1">bgWhiteBright: init(</span><span class="s4">107</span><span class="s2">, </span><span class="s4">49</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">createColors = ({ useColor = isColorSupported } = {}) =&gt;</span>
  <span class="s1">useColor</span>
    <span class="s1">? colors</span>
    <span class="s1">: Object.keys(colors).reduce(</span>
        <span class="s1">(colors</span><span class="s2">, </span><span class="s1">key) =&gt; ({ ...colors</span><span class="s2">, </span><span class="s1">[key]: String })</span><span class="s2">,</span>
        <span class="s1">{}</span>
      <span class="s1">)</span><span class="s2">;</span>

<span class="s1">createColors()</span><span class="s2">;</span>

<span class="s0">// @see https://no-color.org</span>
<span class="s0">// @see https://www.npmjs.com/package/chalk</span>
<span class="s2">const </span><span class="s1">{ bold</span><span class="s2">, </span><span class="s1">cyan</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">, </span><span class="s1">gray</span><span class="s2">, </span><span class="s1">green</span><span class="s2">, </span><span class="s1">red</span><span class="s2">, </span><span class="s1">underline</span><span class="s2">, </span><span class="s1">yellow } = createColors({</span>
    <span class="s1">useColor: env$1.FORCE_COLOR !== </span><span class="s3">'0' </span><span class="s1">&amp;&amp; !env$1.NO_COLOR</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s0">// log to stderr to keep `rollup main.js &gt; bundle.js` from breaking</span>
<span class="s2">const </span><span class="s1">stderr = (...parameters) =&gt; process$1.stderr.write(</span><span class="s3">`</span><span class="s1">${parameters.join(</span><span class="s3">''</span><span class="s1">)}</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">handleError(error</span><span class="s2">, </span><span class="s1">recover = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">name = error.name || error.cause?.name</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nameSection = name ? </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">: ` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">pluginSection = error.plugin ? </span><span class="s3">`(plugin </span><span class="s1">${error.plugin}</span><span class="s3">) ` </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">message = </span><span class="s3">`</span><span class="s1">${pluginSection}${nameSection}${error.message}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">outputLines = [bold(red(</span><span class="s3">`[!] </span><span class="s1">${bold(message.toString())}</span><span class="s3">`</span><span class="s1">))]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(error.url) {</span>
        <span class="s1">outputLines.push(cyan(error.url))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(error.loc) {</span>
        <span class="s1">outputLines.push(</span><span class="s3">`</span><span class="s1">${relativeId((error.loc.file || error.id))} </span><span class="s3">(</span><span class="s1">${error.loc.line}</span><span class="s3">:</span><span class="s1">${error.loc.column}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(error.id) {</span>
        <span class="s1">outputLines.push(relativeId(error.id))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(error.frame) {</span>
        <span class="s1">outputLines.push(dim(error.frame))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(error.stack) {</span>
        <span class="s1">outputLines.push(dim(error.stack?.replace(</span><span class="s3">`</span><span class="s1">${nameSection}${error.message}</span><span class="s2">\n</span><span class="s3">`</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">outputLines.push(</span><span class="s3">''</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">stderr(outputLines.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s0">// eslint-disable-next-line unicorn/no-process-exit</span>
    <span class="s2">if </span><span class="s1">(!recover)</span>
        <span class="s1">process$1.exit(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">commandAliases = {</span>
    <span class="s1">c: </span><span class="s3">'config'</span><span class="s2">,</span>
    <span class="s1">d: </span><span class="s3">'dir'</span><span class="s2">,</span>
    <span class="s1">e: </span><span class="s3">'external'</span><span class="s2">,</span>
    <span class="s1">f: </span><span class="s3">'format'</span><span class="s2">,</span>
    <span class="s1">g: </span><span class="s3">'globals'</span><span class="s2">,</span>
    <span class="s1">h: </span><span class="s3">'help'</span><span class="s2">,</span>
    <span class="s1">i: </span><span class="s3">'input'</span><span class="s2">,</span>
    <span class="s1">m: </span><span class="s3">'sourcemap'</span><span class="s2">,</span>
    <span class="s1">n: </span><span class="s3">'name'</span><span class="s2">,</span>
    <span class="s1">o: </span><span class="s3">'file'</span><span class="s2">,</span>
    <span class="s1">p: </span><span class="s3">'plugin'</span><span class="s2">,</span>
    <span class="s1">v: </span><span class="s3">'version'</span><span class="s2">,</span>
    <span class="s1">w: </span><span class="s3">'watch'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_COMMAND_OPTIONS = { external: []</span><span class="s2">, </span><span class="s1">globals: undefined }</span><span class="s2">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">mergeOptions(config</span><span class="s2">, </span><span class="s1">rawCommandOptions = EMPTY_COMMAND_OPTIONS</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler = defaultOnWarn) {</span>
    <span class="s2">const </span><span class="s1">command = getCommandOptions(rawCommandOptions)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">inputOptions = </span><span class="s2">await </span><span class="s1">mergeInputOptions(config</span><span class="s2">, </span><span class="s1">command</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">warn = inputOptions.onwarn</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(command.output) {</span>
        <span class="s1">Object.assign(command</span><span class="s2">, </span><span class="s1">command.output)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">outputOptionsArray = ensureArray(config.output)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(outputOptionsArray.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">outputOptionsArray.push({})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">outputOptions = </span><span class="s2">await </span><span class="s1">Promise.all(outputOptionsArray.map(singleOutputOptions =&gt; mergeOutputOptions(singleOutputOptions</span><span class="s2">, </span><span class="s1">command</span><span class="s2">, </span><span class="s1">warn)))</span><span class="s2">;</span>
    <span class="s1">warnUnknownOptions(command</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">...Object.keys(inputOptions)</span><span class="s2">,</span>
        <span class="s1">...Object.keys(outputOptions[</span><span class="s4">0</span><span class="s1">]).filter(option =&gt; option !== </span><span class="s3">'sourcemapIgnoreList' </span><span class="s1">&amp;&amp; option !== </span><span class="s3">'sourcemapPathTransform'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">...Object.keys(commandAliases)</span><span class="s2">,</span>
        <span class="s3">'bundleConfigAsCjs'</span><span class="s2">,</span>
        <span class="s3">'config'</span><span class="s2">,</span>
        <span class="s3">'environment'</span><span class="s2">,</span>
        <span class="s3">'plugin'</span><span class="s2">,</span>
        <span class="s3">'silent'</span><span class="s2">,</span>
        <span class="s3">'failAfterWarnings'</span><span class="s2">,</span>
        <span class="s3">'stdin'</span><span class="s2">,</span>
        <span class="s3">'waitForBundleInput'</span><span class="s2">,</span>
        <span class="s3">'configPlugin'</span>
    <span class="s1">]</span><span class="s2">, </span><span class="s3">'CLI flags'</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s4">/^_$|output$|config/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">inputOptions.output = outputOptions</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">inputOptions</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCommandOptions(rawCommandOptions) {</span>
    <span class="s2">const </span><span class="s1">external = rawCommandOptions.external &amp;&amp; </span><span class="s2">typeof </span><span class="s1">rawCommandOptions.external === </span><span class="s3">'string'</span>
        <span class="s1">? rawCommandOptions.external.split(</span><span class="s3">','</span><span class="s1">)</span>
        <span class="s1">: []</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">...rawCommandOptions</span><span class="s2">,</span>
        <span class="s1">external</span><span class="s2">,</span>
        <span class="s1">globals: </span><span class="s2">typeof </span><span class="s1">rawCommandOptions.globals === </span><span class="s3">'string'</span>
            <span class="s1">? rawCommandOptions.globals.split(</span><span class="s3">','</span><span class="s1">).reduce((globals</span><span class="s2">, </span><span class="s1">globalDefinition) =&gt; {</span>
                <span class="s2">const </span><span class="s1">[id</span><span class="s2">, </span><span class="s1">variableName] = globalDefinition.split(</span><span class="s3">':'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">globals[id] = variableName</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!external.includes(id)) {</span>
                    <span class="s1">external.push(id)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">globals</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">))</span>
            <span class="s1">: undefined</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">mergeInputOptions(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler) {</span>
    <span class="s2">const </span><span class="s1">getOption = (name) =&gt; overrides[name] ?? config[name]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">inputOptions = {</span>
        <span class="s1">acorn: getOption(</span><span class="s3">'acorn'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">acornInjectPlugins: config.acornInjectPlugins</span><span class="s2">,</span>
        <span class="s1">cache: config.cache</span><span class="s2">,</span>
        <span class="s1">context: getOption(</span><span class="s3">'context'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">experimentalCacheExpiry: getOption(</span><span class="s3">'experimentalCacheExpiry'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">experimentalLogSideEffects: getOption(</span><span class="s3">'experimentalLogSideEffects'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">external: getExternal(config</span><span class="s2">, </span><span class="s1">overrides)</span><span class="s2">,</span>
        <span class="s1">inlineDynamicImports: getOption(</span><span class="s3">'inlineDynamicImports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">input: getOption(</span><span class="s3">'input'</span><span class="s1">) || []</span><span class="s2">,</span>
        <span class="s1">makeAbsoluteExternalsRelative: getOption(</span><span class="s3">'makeAbsoluteExternalsRelative'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">manualChunks: getOption(</span><span class="s3">'manualChunks'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">maxParallelFileOps: getOption(</span><span class="s3">'maxParallelFileOps'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">maxParallelFileReads: getOption(</span><span class="s3">'maxParallelFileReads'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">moduleContext: getOption(</span><span class="s3">'moduleContext'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">onwarn: getOnWarn(config</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler)</span><span class="s2">,</span>
        <span class="s1">perf: getOption(</span><span class="s3">'perf'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">plugins: </span><span class="s2">await </span><span class="s1">normalizePluginOption(config.plugins)</span><span class="s2">,</span>
        <span class="s1">preserveEntrySignatures: getOption(</span><span class="s3">'preserveEntrySignatures'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">preserveModules: getOption(</span><span class="s3">'preserveModules'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">preserveSymlinks: getOption(</span><span class="s3">'preserveSymlinks'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">shimMissingExports: getOption(</span><span class="s3">'shimMissingExports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">strictDeprecations: getOption(</span><span class="s3">'strictDeprecations'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">treeshake: getObjectOption(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s3">'treeshake'</span><span class="s2">, </span><span class="s1">objectifyOptionWithPresets(treeshakePresets</span><span class="s2">, </span><span class="s3">'treeshake'</span><span class="s2">, </span><span class="s1">URL_TREESHAKE</span><span class="s2">, </span><span class="s3">'false, true, '</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">watch: getWatch(config</span><span class="s2">, </span><span class="s1">overrides)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">warnUnknownOptions(config</span><span class="s2">, </span><span class="s1">Object.keys(inputOptions)</span><span class="s2">, </span><span class="s3">'input options'</span><span class="s2">, </span><span class="s1">inputOptions.onwarn</span><span class="s2">, </span><span class="s4">/^output$/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">inputOptions</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getExternal = (config</span><span class="s2">, </span><span class="s1">overrides) =&gt; {</span>
    <span class="s2">const </span><span class="s1">configExternal = config.external</span><span class="s2">;</span>
    <span class="s2">return typeof </span><span class="s1">configExternal === </span><span class="s3">'function'</span>
        <span class="s1">? (source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">isResolved) =&gt; configExternal(source</span><span class="s2">, </span><span class="s1">importer</span><span class="s2">, </span><span class="s1">isResolved) || overrides.external.includes(source)</span>
        <span class="s1">: [...ensureArray(configExternal)</span><span class="s2">, </span><span class="s1">...overrides.external]</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getOnWarn = (config</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler) =&gt; config.onwarn ? warning =&gt; config.onwarn(warning</span><span class="s2">, </span><span class="s1">defaultOnWarnHandler) : defaultOnWarnHandler</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getObjectOption = (config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">objectifyValue = objectifyOption) =&gt; {</span>
    <span class="s2">const </span><span class="s1">commandOption = normalizeObjectOptionValue(overrides[name]</span><span class="s2">, </span><span class="s1">objectifyValue)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">configOption = normalizeObjectOptionValue(config[name]</span><span class="s2">, </span><span class="s1">objectifyValue)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(commandOption !== undefined) {</span>
        <span class="s2">return </span><span class="s1">commandOption &amp;&amp; { ...configOption</span><span class="s2">, </span><span class="s1">...commandOption }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">configOption</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getWatch = (config</span><span class="s2">, </span><span class="s1">overrides) =&gt; config.watch !== </span><span class="s2">false </span><span class="s1">&amp;&amp; getObjectOption(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s3">'watch'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeObjectOptionValue = (optionValue</span><span class="s2">, </span><span class="s1">objectifyValue) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!optionValue) {</span>
        <span class="s2">return </span><span class="s1">optionValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(optionValue)) {</span>
        <span class="s2">return </span><span class="s1">optionValue.reduce((result</span><span class="s2">, </span><span class="s1">value) =&gt; value &amp;&amp; result &amp;&amp; { ...result</span><span class="s2">, </span><span class="s1">...objectifyValue(value) }</span><span class="s2">, </span><span class="s1">{})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">objectifyValue(optionValue)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">mergeOutputOptions(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s1">warn) {</span>
    <span class="s2">const </span><span class="s1">getOption = (name) =&gt; overrides[name] ?? config[name]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">outputOptions = {</span>
        <span class="s1">amd: getObjectOption(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s3">'amd'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">assetFileNames: getOption(</span><span class="s3">'assetFileNames'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">banner: getOption(</span><span class="s3">'banner'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">chunkFileNames: getOption(</span><span class="s3">'chunkFileNames'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">compact: getOption(</span><span class="s3">'compact'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dir: getOption(</span><span class="s3">'dir'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dynamicImportFunction: getOption(</span><span class="s3">'dynamicImportFunction'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">dynamicImportInCjs: getOption(</span><span class="s3">'dynamicImportInCjs'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">entryFileNames: getOption(</span><span class="s3">'entryFileNames'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">esModule: getOption(</span><span class="s3">'esModule'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">experimentalDeepDynamicChunkOptimization: getOption(</span><span class="s3">'experimentalDeepDynamicChunkOptimization'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">experimentalMinChunkSize: getOption(</span><span class="s3">'experimentalMinChunkSize'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">exports: getOption(</span><span class="s3">'exports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">extend: getOption(</span><span class="s3">'extend'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">externalImportAssertions: getOption(</span><span class="s3">'externalImportAssertions'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">externalLiveBindings: getOption(</span><span class="s3">'externalLiveBindings'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">file: getOption(</span><span class="s3">'file'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">footer: getOption(</span><span class="s3">'footer'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">format: getOption(</span><span class="s3">'format'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">freeze: getOption(</span><span class="s3">'freeze'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">generatedCode: getObjectOption(config</span><span class="s2">, </span><span class="s1">overrides</span><span class="s2">, </span><span class="s3">'generatedCode'</span><span class="s2">, </span><span class="s1">objectifyOptionWithPresets(generatedCodePresets</span><span class="s2">, </span><span class="s3">'output.generatedCode'</span><span class="s2">, </span><span class="s1">URL_OUTPUT_GENERATEDCODE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">globals: getOption(</span><span class="s3">'globals'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">hoistTransitiveImports: getOption(</span><span class="s3">'hoistTransitiveImports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">indent: getOption(</span><span class="s3">'indent'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">inlineDynamicImports: getOption(</span><span class="s3">'inlineDynamicImports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">interop: getOption(</span><span class="s3">'interop'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">intro: getOption(</span><span class="s3">'intro'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">manualChunks: getOption(</span><span class="s3">'manualChunks'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">minifyInternalExports: getOption(</span><span class="s3">'minifyInternalExports'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">name: getOption(</span><span class="s3">'name'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">namespaceToStringTag: getOption(</span><span class="s3">'namespaceToStringTag'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">noConflict: getOption(</span><span class="s3">'noConflict'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">outro: getOption(</span><span class="s3">'outro'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">paths: getOption(</span><span class="s3">'paths'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">plugins: </span><span class="s2">await </span><span class="s1">normalizePluginOption(config.plugins)</span><span class="s2">,</span>
        <span class="s1">preferConst: getOption(</span><span class="s3">'preferConst'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">preserveModules: getOption(</span><span class="s3">'preserveModules'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">preserveModulesRoot: getOption(</span><span class="s3">'preserveModulesRoot'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sanitizeFileName: getOption(</span><span class="s3">'sanitizeFileName'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemap: getOption(</span><span class="s3">'sourcemap'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapBaseUrl: getOption(</span><span class="s3">'sourcemapBaseUrl'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapExcludeSources: getOption(</span><span class="s3">'sourcemapExcludeSources'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapFile: getOption(</span><span class="s3">'sourcemapFile'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapIgnoreList: getOption(</span><span class="s3">'sourcemapIgnoreList'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">sourcemapPathTransform: getOption(</span><span class="s3">'sourcemapPathTransform'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">strict: getOption(</span><span class="s3">'strict'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">systemNullSetters: getOption(</span><span class="s3">'systemNullSetters'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">validate: getOption(</span><span class="s3">'validate'</span><span class="s1">)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">warnUnknownOptions(config</span><span class="s2">, </span><span class="s1">Object.keys(outputOptions)</span><span class="s2">, </span><span class="s3">'output options'</span><span class="s2">, </span><span class="s1">warn)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">outputOptions</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">WatchEmitter {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.currentHandlers = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.persistentHandlers = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">// Will be overwritten by Rollup</span>
    <span class="s1">async close() { }</span>
    <span class="s1">emit(event</span><span class="s2">, </span><span class="s1">...parameters) {</span>
        <span class="s2">return </span><span class="s1">Promise.all([...</span><span class="s2">this</span><span class="s1">.getCurrentHandlers(event)</span><span class="s2">, </span><span class="s1">...</span><span class="s2">this</span><span class="s1">.getPersistentHandlers(event)].map(handler =&gt; handler(...parameters)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">off(event</span><span class="s2">, </span><span class="s1">listener) {</span>
        <span class="s2">const </span><span class="s1">listeners = </span><span class="s2">this</span><span class="s1">.persistentHandlers[event]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(listeners) {</span>
            <span class="s0">// A hack stolen from &quot;mitt&quot;: &quot;&gt;&gt;&gt; 0&quot; does not change numbers &gt;= 0, but -1</span>
            <span class="s0">// (which would remove the last array element if used unchanged) is turned</span>
            <span class="s0">// into max_int, which is outside the array and does not change anything.</span>
            <span class="s1">listeners.splice(listeners.indexOf(listener) &gt;&gt;&gt; </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">on(event</span><span class="s2">, </span><span class="s1">listener) {</span>
        <span class="s2">this</span><span class="s1">.getPersistentHandlers(event).push(listener)</span><span class="s2">;</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">onCurrentRun(event</span><span class="s2">, </span><span class="s1">listener) {</span>
        <span class="s2">this</span><span class="s1">.getCurrentHandlers(event).push(listener)</span><span class="s2">;</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">once(event</span><span class="s2">, </span><span class="s1">listener) {</span>
        <span class="s2">const </span><span class="s1">selfRemovingListener = (...parameters) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.off(event</span><span class="s2">, </span><span class="s1">selfRemovingListener)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">listener(...parameters)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.on(event</span><span class="s2">, </span><span class="s1">selfRemovingListener)</span><span class="s2">;</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">removeAllListeners() {</span>
        <span class="s2">this</span><span class="s1">.removeListenersForCurrentRun()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.persistentHandlers = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">removeListenersForCurrentRun() {</span>
        <span class="s2">this</span><span class="s1">.currentHandlers = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return this;</span>
    <span class="s1">}</span>
    <span class="s1">getCurrentHandlers(event) {</span>
        <span class="s2">return this</span><span class="s1">.currentHandlers[event] || (</span><span class="s2">this</span><span class="s1">.currentHandlers[event] = [])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">getPersistentHandlers(event) {</span>
        <span class="s2">return this</span><span class="s1">.persistentHandlers[event] || (</span><span class="s2">this</span><span class="s1">.persistentHandlers[event] = [])</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">fsEvents</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">fsEventsImportError</span><span class="s2">;</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">loadFsEvents() {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">({ </span><span class="s2">default</span><span class="s1">: fsEvents } = </span><span class="s2">await import</span><span class="s1">(</span><span class="s3">'fsevents'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(error) {</span>
        <span class="s1">fsEventsImportError = error</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// A call to this function will be injected into the chokidar code</span>
<span class="s2">function </span><span class="s1">getFsEvents() {</span>
    <span class="s2">if </span><span class="s1">(fsEventsImportError)</span>
        <span class="s2">throw </span><span class="s1">fsEventsImportError</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">fsEvents</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">fseventsImporter = </span><span class="s0">/*#__PURE__*/</span><span class="s1">Object.defineProperty({</span>
  <span class="s1">__proto__: </span><span class="s2">null,</span>
  <span class="s1">getFsEvents</span><span class="s2">,</span>
  <span class="s1">loadFsEvents</span>
<span class="s1">}</span><span class="s2">, </span><span class="s1">Symbol.toStringTag</span><span class="s2">, </span><span class="s1">{ value: </span><span class="s3">'Module' </span><span class="s1">})</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">watch(configs) {</span>
    <span class="s2">const </span><span class="s1">emitter = </span><span class="s2">new </span><span class="s1">WatchEmitter()</span><span class="s2">;</span>
    <span class="s1">watchInternal(configs</span><span class="s2">, </span><span class="s1">emitter).catch(error =&gt; {</span>
        <span class="s1">handleError(error)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">emitter</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">watchInternal(configs</span><span class="s2">, </span><span class="s1">emitter) {</span>
    <span class="s2">const </span><span class="s1">optionsList = </span><span class="s2">await </span><span class="s1">Promise.all(ensureArray(configs).map(config =&gt; mergeOptions(config)))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">watchOptionsList = optionsList.filter(config =&gt; config.watch !== </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(watchOptionsList.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">error(errorInvalidOption(</span><span class="s3">'watch'</span><span class="s2">, </span><span class="s1">URL_WATCH</span><span class="s2">, </span><span class="s3">'there must be at least one config where &quot;watch&quot; is not set to &quot;false&quot;'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">loadFsEvents()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ Watcher } = </span><span class="s2">await import</span><span class="s1">(</span><span class="s3">'./watch.js'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">new </span><span class="s1">Watcher(watchOptionsList</span><span class="s2">, </span><span class="s1">emitter)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">export </span><span class="s1">{ createFilter</span><span class="s2">, </span><span class="s1">defineConfig</span><span class="s2">, </span><span class="s1">fseventsImporter</span><span class="s2">, </span><span class="s1">getAugmentedNamespace</span><span class="s2">, </span><span class="s1">picomatchExports</span><span class="s2">, </span><span class="s1">rollup</span><span class="s2">, </span><span class="s1">rollupInternal</span><span class="s2">, </span><span class="s1">version$1 as version</span><span class="s2">, </span><span class="s1">watch }</span><span class="s2">;</span>
</pre>
</body>
</html>