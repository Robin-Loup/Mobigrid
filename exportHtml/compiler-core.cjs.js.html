<html>
<head>
<title>compiler-core.cjs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compiler-core.cjs.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">Object.defineProperty(exports</span><span class="s1">, </span><span class="s0">'__esModule'</span><span class="s1">, </span><span class="s2">{ value: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">shared = require(</span><span class="s0">'@vue/shared'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">parser = require(</span><span class="s0">'@babel/parser'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">sourceMap = require(</span><span class="s0">'source-map'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">estreeWalker = require(</span><span class="s0">'estree-walker'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">defaultOnError(error) {</span>
    <span class="s1">throw </span><span class="s2">error</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">defaultOnWarn(msg) {</span>
    <span class="s2">console.warn(</span><span class="s0">`[Vue warn] </span><span class="s2">${msg.message}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createCompilerError(code</span><span class="s1">, </span><span class="s2">loc</span><span class="s1">, </span><span class="s2">messages</span><span class="s1">, </span><span class="s2">additionalMessage) {</span>
    <span class="s1">const </span><span class="s2">msg = (messages || errorMessages)[code] + (additionalMessage || </span><span class="s0">``</span><span class="s2">)</span>
        <span class="s1">;</span>
    <span class="s1">const </span><span class="s2">error = </span><span class="s1">new </span><span class="s2">SyntaxError(String(msg))</span><span class="s1">;</span>
    <span class="s2">error.code = code</span><span class="s1">;</span>
    <span class="s2">error.loc = loc</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">error</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">errorMessages = {</span>
    <span class="s3">// parse errors</span>
    <span class="s2">[</span><span class="s4">0 </span><span class="s3">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s2">]: </span><span class="s0">'Illegal comment.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">1 </span><span class="s3">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s2">]: </span><span class="s0">'CDATA section is allowed only in XML context.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">2 </span><span class="s3">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s2">]: </span><span class="s0">'Duplicate attribute.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">3 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s2">]: </span><span class="s0">'End tag cannot have attributes.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">4 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s2">]: </span><span class="s0">&quot;Illegal '/' in tags.&quot;</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s2">]: </span><span class="s0">'Unexpected EOF in tag.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">6 </span><span class="s3">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s2">]: </span><span class="s0">'Unexpected EOF in CDATA section.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">7 </span><span class="s3">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s2">]: </span><span class="s0">'Unexpected EOF in comment.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">8 </span><span class="s3">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s2">]: </span><span class="s0">'Unexpected EOF in script.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">9 </span><span class="s3">/* ErrorCodes.EOF_IN_TAG */</span><span class="s2">]: </span><span class="s0">'Unexpected EOF in tag.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">10 </span><span class="s3">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s2">]: </span><span class="s0">'Incorrectly closed comment.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">11 </span><span class="s3">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s2">]: </span><span class="s0">'Incorrectly opened comment.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s2">]: </span><span class="s0">&quot;Illegal tag name. Use '&amp;lt;' to print '&lt;'.&quot;</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">13 </span><span class="s3">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s2">]: </span><span class="s0">'Attribute value was expected.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">14 </span><span class="s3">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s2">]: </span><span class="s0">'End tag name was expected.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">15 </span><span class="s3">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s2">]: </span><span class="s0">'Whitespace was expected.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">16 </span><span class="s3">/* ErrorCodes.NESTED_COMMENT */</span><span class="s2">]: </span><span class="s0">&quot;Unexpected '&lt;!--' in comment.&quot;</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">17 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s2">]: </span><span class="s0">'Attribute name cannot contain U+0022 (&quot;), U+0027 (</span><span class="s1">\'</span><span class="s0">), and U+003C (&lt;).'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">18 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s2">]: </span><span class="s0">'Unquoted attribute value cannot contain U+0022 (&quot;), U+0027 (</span><span class="s1">\'</span><span class="s0">), U+003C (&lt;), U+003D (=), and U+0060 (`).'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">19 </span><span class="s3">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s2">]: </span><span class="s0">&quot;Attribute name cannot start with '='.&quot;</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">21 </span><span class="s3">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s2">]: </span><span class="s0">&quot;'&lt;?' is allowed only in XML context.&quot;</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">20 </span><span class="s3">/* ErrorCodes.UNEXPECTED_NULL_CHARACTER */</span><span class="s2">]: </span><span class="s0">`Unexpected null character.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">22 </span><span class="s3">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s2">]: </span><span class="s0">&quot;Illegal '/' in tags.&quot;</span><span class="s1">,</span>
    <span class="s3">// Vue-specific parse errors</span>
    <span class="s2">[</span><span class="s4">23 </span><span class="s3">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s2">]: </span><span class="s0">'Invalid end tag.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">24 </span><span class="s3">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s2">]: </span><span class="s0">'Element is missing end tag.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">25 </span><span class="s3">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s2">]: </span><span class="s0">'Interpolation end sign was not found.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">27 </span><span class="s3">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s2">]: </span><span class="s0">'End bracket for dynamic directive argument was not found. ' </span><span class="s2">+</span>
        <span class="s0">'Note that dynamic directive argument cannot contain spaces.'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">26 </span><span class="s3">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s2">]: </span><span class="s0">'Legal directive name was expected.'</span><span class="s1">,</span>
    <span class="s3">// transform errors</span>
    <span class="s2">[</span><span class="s4">28 </span><span class="s3">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-if/v-else-if is missing expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">29 </span><span class="s3">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s2">]: </span><span class="s0">`v-if/else branches must use unique keys.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s2">]: </span><span class="s0">`v-else/v-else-if has no adjacent v-if or v-else-if.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">31 </span><span class="s3">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-for is missing expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-for has invalid expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">33 </span><span class="s3">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s2">]: </span><span class="s0">`&lt;template v-for&gt; key should be placed on the &lt;template&gt; tag.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-bind is missing expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-on is missing expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">36 </span><span class="s3">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s2">]: </span><span class="s0">`Unexpected custom directive on &lt;slot&gt; outlet.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">37 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s2">]: </span><span class="s0">`Mixed v-slot usage on both the component and nested &lt;template&gt;. ` </span><span class="s2">+</span>
        <span class="s0">`When there are multiple named slots, all slots should use &lt;template&gt; ` </span><span class="s2">+</span>
        <span class="s0">`syntax to avoid scope ambiguity.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">38 </span><span class="s3">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s2">]: </span><span class="s0">`Duplicate slot names found. `</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">39 </span><span class="s3">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s2">]: </span><span class="s0">`Extraneous children found when component already has explicitly named ` </span><span class="s2">+</span>
        <span class="s0">`default slot. These children will be ignored.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">40 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s2">]: </span><span class="s0">`v-slot can only be used on components or &lt;template&gt; tags.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">41 </span><span class="s3">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-model is missing expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">42 </span><span class="s3">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`v-model value must be a valid JavaScript member expression.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">43 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */</span><span class="s2">]: </span><span class="s0">`v-model cannot be used on v-for or v-slot scope variables because they are not writable.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">44 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s2">]: </span><span class="s0">`v-model cannot be used on a prop, because local prop bindings are not writable.</span><span class="s1">\n</span><span class="s0">Use a v-bind binding combined with a v-on listener that emits update:x event instead.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">45 </span><span class="s3">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s2">]: </span><span class="s0">`Error parsing JavaScript expression: `</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">46 </span><span class="s3">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s2">]: </span><span class="s0">`&lt;KeepAlive&gt; expects exactly one child component.`</span><span class="s1">,</span>
    <span class="s3">// generic errors</span>
    <span class="s2">[</span><span class="s4">47 </span><span class="s3">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s2">]: </span><span class="s0">`&quot;prefixIdentifiers&quot; option is not supported in this build of compiler.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">48 </span><span class="s3">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s2">]: </span><span class="s0">`ES module mode is not supported in this build of compiler.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">49 </span><span class="s3">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s2">]: </span><span class="s0">`&quot;cacheHandlers&quot; option is only supported when the &quot;prefixIdentifiers&quot; option is enabled.`</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">50 </span><span class="s3">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s2">]: </span><span class="s0">`&quot;scopeId&quot; option is only supported in module mode.`</span><span class="s1">,</span>
    <span class="s3">// just to fulfill types</span>
    <span class="s2">[</span><span class="s4">51 </span><span class="s3">/* ErrorCodes.__EXTEND_POINT__ */</span><span class="s2">]: </span><span class="s0">``</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">FRAGMENT = Symbol(</span><span class="s0">`Fragment` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TELEPORT = Symbol(</span><span class="s0">`Teleport` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SUSPENSE = Symbol(</span><span class="s0">`Suspense` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">KEEP_ALIVE = Symbol(</span><span class="s0">`KeepAlive` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">BASE_TRANSITION = Symbol(</span><span class="s0">`BaseTransition` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">OPEN_BLOCK = Symbol(</span><span class="s0">`openBlock` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_BLOCK = Symbol(</span><span class="s0">`createBlock` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_ELEMENT_BLOCK = Symbol(</span><span class="s0">`createElementBlock` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_VNODE = Symbol(</span><span class="s0">`createVNode` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_ELEMENT_VNODE = Symbol(</span><span class="s0">`createElementVNode` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_COMMENT = Symbol(</span><span class="s0">`createCommentVNode` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_TEXT = Symbol(</span><span class="s0">`createTextVNode` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_STATIC = Symbol(</span><span class="s0">`createStaticVNode` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RESOLVE_COMPONENT = Symbol(</span><span class="s0">`resolveComponent` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RESOLVE_DYNAMIC_COMPONENT = Symbol(</span><span class="s0">`resolveDynamicComponent` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RESOLVE_DIRECTIVE = Symbol(</span><span class="s0">`resolveDirective` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RESOLVE_FILTER = Symbol(</span><span class="s0">`resolveFilter` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">WITH_DIRECTIVES = Symbol(</span><span class="s0">`withDirectives` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RENDER_LIST = Symbol(</span><span class="s0">`renderList` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RENDER_SLOT = Symbol(</span><span class="s0">`renderSlot` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CREATE_SLOTS = Symbol(</span><span class="s0">`createSlots` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TO_DISPLAY_STRING = Symbol(</span><span class="s0">`toDisplayString` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">MERGE_PROPS = Symbol(</span><span class="s0">`mergeProps` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NORMALIZE_CLASS = Symbol(</span><span class="s0">`normalizeClass` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NORMALIZE_STYLE = Symbol(</span><span class="s0">`normalizeStyle` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NORMALIZE_PROPS = Symbol(</span><span class="s0">`normalizeProps` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">GUARD_REACTIVE_PROPS = Symbol(</span><span class="s0">`guardReactiveProps` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TO_HANDLERS = Symbol(</span><span class="s0">`toHandlers` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CAMELIZE = Symbol(</span><span class="s0">`camelize` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CAPITALIZE = Symbol(</span><span class="s0">`capitalize` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TO_HANDLER_KEY = Symbol(</span><span class="s0">`toHandlerKey` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SET_BLOCK_TRACKING = Symbol(</span><span class="s0">`setBlockTracking` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">PUSH_SCOPE_ID = Symbol(</span><span class="s0">`pushScopeId` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">POP_SCOPE_ID = Symbol(</span><span class="s0">`popScopeId` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">WITH_CTX = Symbol(</span><span class="s0">`withCtx` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">UNREF = Symbol(</span><span class="s0">`unref` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">IS_REF = Symbol(</span><span class="s0">`isRef` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">WITH_MEMO = Symbol(</span><span class="s0">`withMemo` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">IS_MEMO_SAME = Symbol(</span><span class="s0">`isMemoSame` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s3">// Name mapping for runtime helpers that need to be imported from 'vue' in</span>
<span class="s3">// generated code. Make sure these are correctly exported in the runtime!</span>
<span class="s1">const </span><span class="s2">helperNameMap = {</span>
    <span class="s2">[FRAGMENT]: </span><span class="s0">`Fragment`</span><span class="s1">,</span>
    <span class="s2">[TELEPORT]: </span><span class="s0">`Teleport`</span><span class="s1">,</span>
    <span class="s2">[SUSPENSE]: </span><span class="s0">`Suspense`</span><span class="s1">,</span>
    <span class="s2">[KEEP_ALIVE]: </span><span class="s0">`KeepAlive`</span><span class="s1">,</span>
    <span class="s2">[BASE_TRANSITION]: </span><span class="s0">`BaseTransition`</span><span class="s1">,</span>
    <span class="s2">[OPEN_BLOCK]: </span><span class="s0">`openBlock`</span><span class="s1">,</span>
    <span class="s2">[CREATE_BLOCK]: </span><span class="s0">`createBlock`</span><span class="s1">,</span>
    <span class="s2">[CREATE_ELEMENT_BLOCK]: </span><span class="s0">`createElementBlock`</span><span class="s1">,</span>
    <span class="s2">[CREATE_VNODE]: </span><span class="s0">`createVNode`</span><span class="s1">,</span>
    <span class="s2">[CREATE_ELEMENT_VNODE]: </span><span class="s0">`createElementVNode`</span><span class="s1">,</span>
    <span class="s2">[CREATE_COMMENT]: </span><span class="s0">`createCommentVNode`</span><span class="s1">,</span>
    <span class="s2">[CREATE_TEXT]: </span><span class="s0">`createTextVNode`</span><span class="s1">,</span>
    <span class="s2">[CREATE_STATIC]: </span><span class="s0">`createStaticVNode`</span><span class="s1">,</span>
    <span class="s2">[RESOLVE_COMPONENT]: </span><span class="s0">`resolveComponent`</span><span class="s1">,</span>
    <span class="s2">[RESOLVE_DYNAMIC_COMPONENT]: </span><span class="s0">`resolveDynamicComponent`</span><span class="s1">,</span>
    <span class="s2">[RESOLVE_DIRECTIVE]: </span><span class="s0">`resolveDirective`</span><span class="s1">,</span>
    <span class="s2">[RESOLVE_FILTER]: </span><span class="s0">`resolveFilter`</span><span class="s1">,</span>
    <span class="s2">[WITH_DIRECTIVES]: </span><span class="s0">`withDirectives`</span><span class="s1">,</span>
    <span class="s2">[RENDER_LIST]: </span><span class="s0">`renderList`</span><span class="s1">,</span>
    <span class="s2">[RENDER_SLOT]: </span><span class="s0">`renderSlot`</span><span class="s1">,</span>
    <span class="s2">[CREATE_SLOTS]: </span><span class="s0">`createSlots`</span><span class="s1">,</span>
    <span class="s2">[TO_DISPLAY_STRING]: </span><span class="s0">`toDisplayString`</span><span class="s1">,</span>
    <span class="s2">[MERGE_PROPS]: </span><span class="s0">`mergeProps`</span><span class="s1">,</span>
    <span class="s2">[NORMALIZE_CLASS]: </span><span class="s0">`normalizeClass`</span><span class="s1">,</span>
    <span class="s2">[NORMALIZE_STYLE]: </span><span class="s0">`normalizeStyle`</span><span class="s1">,</span>
    <span class="s2">[NORMALIZE_PROPS]: </span><span class="s0">`normalizeProps`</span><span class="s1">,</span>
    <span class="s2">[GUARD_REACTIVE_PROPS]: </span><span class="s0">`guardReactiveProps`</span><span class="s1">,</span>
    <span class="s2">[TO_HANDLERS]: </span><span class="s0">`toHandlers`</span><span class="s1">,</span>
    <span class="s2">[CAMELIZE]: </span><span class="s0">`camelize`</span><span class="s1">,</span>
    <span class="s2">[CAPITALIZE]: </span><span class="s0">`capitalize`</span><span class="s1">,</span>
    <span class="s2">[TO_HANDLER_KEY]: </span><span class="s0">`toHandlerKey`</span><span class="s1">,</span>
    <span class="s2">[SET_BLOCK_TRACKING]: </span><span class="s0">`setBlockTracking`</span><span class="s1">,</span>
    <span class="s2">[PUSH_SCOPE_ID]: </span><span class="s0">`pushScopeId`</span><span class="s1">,</span>
    <span class="s2">[POP_SCOPE_ID]: </span><span class="s0">`popScopeId`</span><span class="s1">,</span>
    <span class="s2">[WITH_CTX]: </span><span class="s0">`withCtx`</span><span class="s1">,</span>
    <span class="s2">[UNREF]: </span><span class="s0">`unref`</span><span class="s1">,</span>
    <span class="s2">[IS_REF]: </span><span class="s0">`isRef`</span><span class="s1">,</span>
    <span class="s2">[WITH_MEMO]: </span><span class="s0">`withMemo`</span><span class="s1">,</span>
    <span class="s2">[IS_MEMO_SAME]: </span><span class="s0">`isMemoSame`</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">registerRuntimeHelpers(helpers) {</span>
    <span class="s2">Object.getOwnPropertySymbols(helpers).forEach(s =&gt; {</span>
        <span class="s2">helperNameMap[s] = helpers[s]</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">// AST Utilities ---------------------------------------------------------------</span>
<span class="s3">// Some expressions, e.g. sequence and conditional expressions, are never</span>
<span class="s3">// associated with template nodes, so their source locations are just a stub.</span>
<span class="s3">// Container types like CompoundExpression also don't need a real location.</span>
<span class="s1">const </span><span class="s2">locStub = {</span>
    <span class="s2">source: </span><span class="s0">''</span><span class="s1">,</span>
    <span class="s2">start: { line: </span><span class="s4">1</span><span class="s1">, </span><span class="s2">column: </span><span class="s4">1</span><span class="s1">, </span><span class="s2">offset: </span><span class="s4">0 </span><span class="s2">}</span><span class="s1">,</span>
    <span class="s2">end: { line: </span><span class="s4">1</span><span class="s1">, </span><span class="s2">column: </span><span class="s4">1</span><span class="s1">, </span><span class="s2">offset: </span><span class="s4">0 </span><span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createRoot(children</span><span class="s1">, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */</span><span class="s1">,</span>
        <span class="s2">children</span><span class="s1">,</span>
        <span class="s2">helpers: </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">,</span>
        <span class="s2">components: []</span><span class="s1">,</span>
        <span class="s2">directives: []</span><span class="s1">,</span>
        <span class="s2">hoists: []</span><span class="s1">,</span>
        <span class="s2">imports: []</span><span class="s1">,</span>
        <span class="s2">cached: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">temps: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">codegenNode: undefined</span><span class="s1">,</span>
        <span class="s2">loc</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createVNodeCall(context</span><span class="s1">, </span><span class="s2">tag</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">directives</span><span class="s1">, </span><span class="s2">isBlock = </span><span class="s1">false, </span><span class="s2">disableTracking = </span><span class="s1">false, </span><span class="s2">isComponent = </span><span class="s1">false, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">if </span><span class="s2">(context) {</span>
        <span class="s1">if </span><span class="s2">(isBlock) {</span>
            <span class="s2">context.helper(OPEN_BLOCK)</span><span class="s1">;</span>
            <span class="s2">context.helper(getVNodeBlockHelper(context.inSSR</span><span class="s1">, </span><span class="s2">isComponent))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">context.helper(getVNodeHelper(context.inSSR</span><span class="s1">, </span><span class="s2">isComponent))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(directives) {</span>
            <span class="s2">context.helper(WITH_DIRECTIVES)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">,</span>
        <span class="s2">tag</span><span class="s1">,</span>
        <span class="s2">props</span><span class="s1">,</span>
        <span class="s2">children</span><span class="s1">,</span>
        <span class="s2">patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicProps</span><span class="s1">,</span>
        <span class="s2">directives</span><span class="s1">,</span>
        <span class="s2">isBlock</span><span class="s1">,</span>
        <span class="s2">disableTracking</span><span class="s1">,</span>
        <span class="s2">isComponent</span><span class="s1">,</span>
        <span class="s2">loc</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createArrayExpression(elements</span><span class="s1">, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">elements</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createObjectExpression(properties</span><span class="s1">, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">properties</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createObjectProperty(key</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">16 </span><span class="s3">/* NodeTypes.JS_PROPERTY */</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span><span class="s1">,</span>
        <span class="s2">key: shared.isString(key) ? createSimpleExpression(key</span><span class="s1">, true</span><span class="s2">) : key</span><span class="s1">,</span>
        <span class="s2">value</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createSimpleExpression(content</span><span class="s1">, </span><span class="s2">isStatic = </span><span class="s1">false, </span><span class="s2">loc = locStub</span><span class="s1">, </span><span class="s2">constType = </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">content</span><span class="s1">,</span>
        <span class="s2">isStatic</span><span class="s1">,</span>
        <span class="s2">constType: isStatic ? </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */ </span><span class="s2">: constType</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createInterpolation(content</span><span class="s1">, </span><span class="s2">loc) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">content: shared.isString(content)</span>
            <span class="s2">? createSimpleExpression(content</span><span class="s1">, false, </span><span class="s2">loc)</span>
            <span class="s2">: content</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createCompoundExpression(children</span><span class="s1">, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">children</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createCallExpression(callee</span><span class="s1">, </span><span class="s2">args = []</span><span class="s1">, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">loc</span><span class="s1">,</span>
        <span class="s2">callee</span><span class="s1">,</span>
        <span class="s2">arguments: args</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createFunctionExpression(params</span><span class="s1">, </span><span class="s2">returns = undefined</span><span class="s1">, </span><span class="s2">newline = </span><span class="s1">false, </span><span class="s2">isSlot = </span><span class="s1">false, </span><span class="s2">loc = locStub) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">18 </span><span class="s3">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">params</span><span class="s1">,</span>
        <span class="s2">returns</span><span class="s1">,</span>
        <span class="s2">newline</span><span class="s1">,</span>
        <span class="s2">isSlot</span><span class="s1">,</span>
        <span class="s2">loc</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createConditionalExpression(test</span><span class="s1">, </span><span class="s2">consequent</span><span class="s1">, </span><span class="s2">alternate</span><span class="s1">, </span><span class="s2">newline = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">test</span><span class="s1">,</span>
        <span class="s2">consequent</span><span class="s1">,</span>
        <span class="s2">alternate</span><span class="s1">,</span>
        <span class="s2">newline</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createCacheExpression(index</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">isVNode = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">index</span><span class="s1">,</span>
        <span class="s2">value</span><span class="s1">,</span>
        <span class="s2">isVNode</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createBlockStatement(body) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">21 </span><span class="s3">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s1">,</span>
        <span class="s2">body</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createTemplateLiteral(elements) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">22 </span><span class="s3">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s1">,</span>
        <span class="s2">elements</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createIfStatement(test</span><span class="s1">, </span><span class="s2">consequent</span><span class="s1">, </span><span class="s2">alternate) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">23 </span><span class="s3">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s1">,</span>
        <span class="s2">test</span><span class="s1">,</span>
        <span class="s2">consequent</span><span class="s1">,</span>
        <span class="s2">alternate</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createAssignmentExpression(left</span><span class="s1">, </span><span class="s2">right) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">24 </span><span class="s3">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">left</span><span class="s1">,</span>
        <span class="s2">right</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createSequenceExpression(expressions) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">25 </span><span class="s3">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s1">,</span>
        <span class="s2">expressions</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createReturnStatement(returns) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">26 </span><span class="s3">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s1">,</span>
        <span class="s2">returns</span><span class="s1">,</span>
        <span class="s2">loc: locStub</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isStaticExp = (p) =&gt; p.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp; p.isStatic</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isBuiltInType = (tag</span><span class="s1">, </span><span class="s2">expected) =&gt; tag === expected || tag === shared.hyphenate(expected)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">isCoreComponent(tag) {</span>
    <span class="s1">if </span><span class="s2">(isBuiltInType(tag</span><span class="s1">, </span><span class="s0">'Teleport'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">TELEPORT</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(isBuiltInType(tag</span><span class="s1">, </span><span class="s0">'Suspense'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">SUSPENSE</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(isBuiltInType(tag</span><span class="s1">, </span><span class="s0">'KeepAlive'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">KEEP_ALIVE</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(isBuiltInType(tag</span><span class="s1">, </span><span class="s0">'BaseTransition'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">BASE_TRANSITION</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">nonIdentifierRE = </span><span class="s4">/^\d|[^\$\w]/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isSimpleIdentifier = (name) =&gt; !nonIdentifierRE.test(name)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">validFirstIdentCharRE = </span><span class="s4">/[A-Za-z_$\xA0-\uFFFF]/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">validIdentCharRE = </span><span class="s4">/[\.\?\w$\xA0-\uFFFF]/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">whitespaceRE = </span><span class="s4">/\s+[.[]\s*|\s*[.[]\s+/g</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Simple lexer to check if an expression is a member expression. This is</span>
 <span class="s5">* lax and only checks validity at the root level (i.e. does not validate exps</span>
 <span class="s5">* inside square brackets), but it's ok since these are only used on template</span>
 <span class="s5">* expressions and false positives are invalid expressions in the first place.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">isMemberExpressionBrowser = (path) =&gt; {</span>
    <span class="s3">// remove whitespaces around . or [ first</span>
    <span class="s2">path = path.trim().replace(whitespaceRE</span><span class="s1">, </span><span class="s2">s =&gt; s.trim())</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">state = </span><span class="s4">0 </span><span class="s3">/* MemberExpLexState.inMemberExp */</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">stateStack = []</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">currentOpenBracketCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">currentOpenParensCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">currentStringType = </span><span class="s1">null;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; path.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">char = path.charAt(i)</span><span class="s1">;</span>
        <span class="s1">switch </span><span class="s2">(state) {</span>
            <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* MemberExpLexState.inMemberExp */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(char === </span><span class="s0">'['</span><span class="s2">) {</span>
                    <span class="s2">stateStack.push(state)</span><span class="s1">;</span>
                    <span class="s2">state = </span><span class="s4">1 </span><span class="s3">/* MemberExpLexState.inBrackets */</span><span class="s1">;</span>
                    <span class="s2">currentOpenBracketCount++</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(char === </span><span class="s0">'('</span><span class="s2">) {</span>
                    <span class="s2">stateStack.push(state)</span><span class="s1">;</span>
                    <span class="s2">state = </span><span class="s4">2 </span><span class="s3">/* MemberExpLexState.inParens */</span><span class="s1">;</span>
                    <span class="s2">currentOpenParensCount++</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(!(i === </span><span class="s4">0 </span><span class="s2">? validFirstIdentCharRE : validIdentCharRE).test(char)) {</span>
                    <span class="s1">return false;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* MemberExpLexState.inBrackets */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(char === </span><span class="s0">`'` </span><span class="s2">|| char === </span><span class="s0">`&quot;` </span><span class="s2">|| char === </span><span class="s0">'`'</span><span class="s2">) {</span>
                    <span class="s2">stateStack.push(state)</span><span class="s1">;</span>
                    <span class="s2">state = </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s1">;</span>
                    <span class="s2">currentStringType = char</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(char === </span><span class="s0">`[`</span><span class="s2">) {</span>
                    <span class="s2">currentOpenBracketCount++</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(char === </span><span class="s0">`]`</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(!--currentOpenBracketCount) {</span>
                        <span class="s2">state = stateStack.pop()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* MemberExpLexState.inParens */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(char === </span><span class="s0">`'` </span><span class="s2">|| char === </span><span class="s0">`&quot;` </span><span class="s2">|| char === </span><span class="s0">'`'</span><span class="s2">) {</span>
                    <span class="s2">stateStack.push(state)</span><span class="s1">;</span>
                    <span class="s2">state = </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s1">;</span>
                    <span class="s2">currentStringType = char</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(char === </span><span class="s0">`(`</span><span class="s2">) {</span>
                    <span class="s2">currentOpenParensCount++</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(char === </span><span class="s0">`)`</span><span class="s2">) {</span>
                    <span class="s3">// if the exp ends as a call then it should not be considered valid</span>
                    <span class="s1">if </span><span class="s2">(i === path.length - </span><span class="s4">1</span><span class="s2">) {</span>
                        <span class="s1">return false;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(!--currentOpenParensCount) {</span>
                        <span class="s2">state = stateStack.pop()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(char === currentStringType) {</span>
                    <span class="s2">state = stateStack.pop()</span><span class="s1">;</span>
                    <span class="s2">currentStringType = </span><span class="s1">null;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">!currentOpenBracketCount &amp;&amp; !currentOpenParensCount</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isMemberExpressionNode = (path</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
        <span class="s1">try </span><span class="s2">{</span>
            <span class="s1">let </span><span class="s2">ret = parser.parseExpression(path</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">plugins: context.expressionPlugins</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(ret.type === </span><span class="s0">'TSAsExpression' </span><span class="s2">|| ret.type === </span><span class="s0">'TSTypeAssertion'</span><span class="s2">) {</span>
                <span class="s2">ret = ret.expression</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">(ret.type === </span><span class="s0">'MemberExpression' </span><span class="s2">||</span>
                <span class="s2">ret.type === </span><span class="s0">'OptionalMemberExpression' </span><span class="s2">||</span>
                <span class="s2">ret.type === </span><span class="s0">'Identifier'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">catch </span><span class="s2">(e) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isMemberExpression = isMemberExpressionNode</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getInnerRange(loc</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">length) {</span>
    <span class="s1">const </span><span class="s2">source = loc.source.slice(offset</span><span class="s1">, </span><span class="s2">offset + length)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">newLoc = {</span>
        <span class="s2">source</span><span class="s1">,</span>
        <span class="s2">start: advancePositionWithClone(loc.start</span><span class="s1">, </span><span class="s2">loc.source</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">,</span>
        <span class="s2">end: loc.end</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(length != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">newLoc.end = advancePositionWithClone(loc.start</span><span class="s1">, </span><span class="s2">loc.source</span><span class="s1">, </span><span class="s2">offset + length)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">newLoc</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">advancePositionWithClone(pos</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">numberOfCharacters = source.length) {</span>
    <span class="s1">return </span><span class="s2">advancePositionWithMutation(shared.extend({}</span><span class="s1">, </span><span class="s2">pos)</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">numberOfCharacters)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// advance by mutation without cloning (for performance reasons), since this</span>
<span class="s3">// gets called a lot in the parser</span>
<span class="s1">function </span><span class="s2">advancePositionWithMutation(pos</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">numberOfCharacters = source.length) {</span>
    <span class="s1">let </span><span class="s2">linesCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">lastNewLinePos = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; numberOfCharacters</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">if </span><span class="s2">(source.charCodeAt(i) === </span><span class="s4">10 </span><span class="s3">/* newline char code */</span><span class="s2">) {</span>
            <span class="s2">linesCount++</span><span class="s1">;</span>
            <span class="s2">lastNewLinePos = i</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">pos.offset += numberOfCharacters</span><span class="s1">;</span>
    <span class="s2">pos.line += linesCount</span><span class="s1">;</span>
    <span class="s2">pos.column =</span>
        <span class="s2">lastNewLinePos === -</span><span class="s4">1</span>
            <span class="s2">? pos.column + numberOfCharacters</span>
            <span class="s2">: numberOfCharacters - lastNewLinePos</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">pos</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">assert(condition</span><span class="s1">, </span><span class="s2">msg) {</span>
    <span class="s3">/* istanbul ignore if */</span>
    <span class="s1">if </span><span class="s2">(!condition) {</span>
        <span class="s1">throw new </span><span class="s2">Error(msg || </span><span class="s0">`unexpected compiler condition`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">findDir(node</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">allowEmpty = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(allowEmpty || p.exp) &amp;&amp;</span>
            <span class="s2">(shared.isString(name) ? p.name === name : name.test(p.name))) {</span>
            <span class="s1">return </span><span class="s2">p</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">findProp(node</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">dynamicOnly = </span><span class="s1">false, </span><span class="s2">allowEmpty = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(dynamicOnly)</span>
                <span class="s1">continue;</span>
            <span class="s1">if </span><span class="s2">(p.name === name &amp;&amp; (p.value || allowEmpty)) {</span>
                <span class="s1">return </span><span class="s2">p</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(p.exp || allowEmpty) &amp;&amp;</span>
            <span class="s2">isStaticArgOf(p.arg</span><span class="s1">, </span><span class="s2">name)) {</span>
            <span class="s1">return </span><span class="s2">p</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isStaticArgOf(arg</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">return </span><span class="s2">!!(arg &amp;&amp; isStaticExp(arg) &amp;&amp; arg.content === name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasDynamicKeyVBind(node) {</span>
    <span class="s1">return </span><span class="s2">node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(!p.arg || </span><span class="s3">// v-bind=&quot;obj&quot;</span>
            <span class="s2">p.arg.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">|| </span><span class="s3">// v-bind:[_ctx.foo]</span>
            <span class="s2">!p.arg.isStatic) </span><span class="s3">// v-bind:[foo]</span>
    <span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isText$1(node) {</span>
    <span class="s1">return </span><span class="s2">node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s2">|| node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isVSlot(p) {</span>
    <span class="s1">return </span><span class="s2">p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; p.name === </span><span class="s0">'slot'</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isTemplateNode(node) {</span>
    <span class="s1">return </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp; node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSlotOutlet(node) {</span>
    <span class="s1">return </span><span class="s2">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp; node.tagType === </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getVNodeHelper(ssr</span><span class="s1">, </span><span class="s2">isComponent) {</span>
    <span class="s1">return </span><span class="s2">ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getVNodeBlockHelper(ssr</span><span class="s1">, </span><span class="s2">isComponent) {</span>
    <span class="s1">return </span><span class="s2">ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">propsHelperSet = </span><span class="s1">new </span><span class="s2">Set([NORMALIZE_PROPS</span><span class="s1">, </span><span class="s2">GUARD_REACTIVE_PROPS])</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getUnnormalizedProps(props</span><span class="s1">, </span><span class="s2">callPath = []) {</span>
    <span class="s1">if </span><span class="s2">(props &amp;&amp;</span>
        <span class="s2">!shared.isString(props) &amp;&amp;</span>
        <span class="s2">props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">callee = props.callee</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!shared.isString(callee) &amp;&amp; propsHelperSet.has(callee)) {</span>
            <span class="s1">return </span><span class="s2">getUnnormalizedProps(props.arguments[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">, </span><span class="s2">callPath.concat(props))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">[props</span><span class="s1">, </span><span class="s2">callPath]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">injectProp(node</span><span class="s1">, </span><span class="s2">prop</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">let </span><span class="s2">propsWithInjection</span><span class="s1">;</span>
    <span class="s5">/**</span>
     <span class="s5">* 1. mergeProps(...)</span>
     <span class="s5">* 2. toHandlers(...)</span>
     <span class="s5">* 3. normalizeProps(...)</span>
     <span class="s5">* 4. normalizeProps(guardReactiveProps(...))</span>
     <span class="s5">*</span>
     <span class="s5">* we need to get the real props before normalization</span>
     <span class="s5">*/</span>
    <span class="s1">let </span><span class="s2">props = node.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */ </span><span class="s2">? node.props : node.arguments[</span><span class="s4">2</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">callPath = []</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">parentCall</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(props &amp;&amp;</span>
        <span class="s2">!shared.isString(props) &amp;&amp;</span>
        <span class="s2">props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">ret = getUnnormalizedProps(props)</span><span class="s1">;</span>
        <span class="s2">props = ret[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">callPath = ret[</span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">parentCall = callPath[callPath.length - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(props == </span><span class="s1">null </span><span class="s2">|| shared.isString(props)) {</span>
        <span class="s2">propsWithInjection = createObjectExpression([prop])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s3">// merged props... add ours</span>
        <span class="s3">// only inject key to object literal if it's the first argument so that</span>
        <span class="s3">// if doesn't override user provided keys</span>
        <span class="s1">const </span><span class="s2">first = props.arguments[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!shared.isString(first) &amp;&amp; first.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s3">// #6631</span>
            <span class="s1">if </span><span class="s2">(!hasProp(prop</span><span class="s1">, </span><span class="s2">first)) {</span>
                <span class="s2">first.properties.unshift(prop)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(props.callee === TO_HANDLERS) {</span>
                <span class="s3">// #2366</span>
                <span class="s2">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">createObjectExpression([prop])</span><span class="s1">,</span>
                    <span class="s2">props</span>
                <span class="s2">])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">props.arguments.unshift(createObjectExpression([prop]))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">!propsWithInjection &amp;&amp; (propsWithInjection = props)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(props.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(!hasProp(prop</span><span class="s1">, </span><span class="s2">props)) {</span>
            <span class="s2">props.properties.unshift(prop)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">propsWithInjection = props</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// single v-bind with expression, return a merged replacement</span>
        <span class="s2">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s2">createObjectExpression([prop])</span><span class="s1">,</span>
            <span class="s2">props</span>
        <span class="s2">])</span><span class="s1">;</span>
        <span class="s3">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
        <span class="s3">// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
        <span class="s3">// the `guardReactiveProps` will no longer be needed</span>
        <span class="s1">if </span><span class="s2">(parentCall &amp;&amp; parentCall.callee === GUARD_REACTIVE_PROPS) {</span>
            <span class="s2">parentCall = callPath[callPath.length - </span><span class="s4">2</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(parentCall) {</span>
            <span class="s2">parentCall.arguments[</span><span class="s4">0</span><span class="s2">] = propsWithInjection</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">node.props = propsWithInjection</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(parentCall) {</span>
            <span class="s2">parentCall.arguments[</span><span class="s4">0</span><span class="s2">] = propsWithInjection</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">node.arguments[</span><span class="s4">2</span><span class="s2">] = propsWithInjection</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">// check existing key to avoid overriding user provided keys</span>
<span class="s1">function </span><span class="s2">hasProp(prop</span><span class="s1">, </span><span class="s2">props) {</span>
    <span class="s1">let </span><span class="s2">result = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(prop.key.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">propKeyName = prop.key.content</span><span class="s1">;</span>
        <span class="s2">result = props.properties.some(p =&gt; p.key.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">p.key.content === propKeyName)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">toValidAssetId(name</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s3">// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
    <span class="s1">return </span><span class="s0">`_</span><span class="s2">${type}</span><span class="s0">_</span><span class="s2">${name.replace(</span><span class="s4">/[^\w]/g</span><span class="s1">, </span><span class="s2">(searchValue</span><span class="s1">, </span><span class="s2">replaceValue) =&gt; {</span>
        <span class="s1">return </span><span class="s2">searchValue === </span><span class="s0">'-' </span><span class="s2">? </span><span class="s0">'_' </span><span class="s2">: name.charCodeAt(replaceValue).toString()</span><span class="s1">;</span>
    <span class="s2">})}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// Check if a node contains expressions that reference current context scope ids</span>
<span class="s1">function </span><span class="s2">hasScopeRef(node</span><span class="s1">, </span><span class="s2">ids) {</span>
    <span class="s1">if </span><span class="s2">(!node || Object.keys(ids).length === </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">switch </span><span class="s2">(node.type) {</span>
        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">:</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">(hasScopeRef(p.arg</span><span class="s1">, </span><span class="s2">ids) || hasScopeRef(p.exp</span><span class="s1">, </span><span class="s2">ids))) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">node.children.some(c =&gt; hasScopeRef(c</span><span class="s1">, </span><span class="s2">ids))</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(hasScopeRef(node.source</span><span class="s1">, </span><span class="s2">ids)) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">node.children.some(c =&gt; hasScopeRef(c</span><span class="s1">, </span><span class="s2">ids))</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">node.branches.some(b =&gt; hasScopeRef(b</span><span class="s1">, </span><span class="s2">ids))</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(hasScopeRef(node.condition</span><span class="s1">, </span><span class="s2">ids)) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">node.children.some(c =&gt; hasScopeRef(c</span><span class="s1">, </span><span class="s2">ids))</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">(!node.isStatic &amp;&amp;</span>
                <span class="s2">isSimpleIdentifier(node.content) &amp;&amp;</span>
                <span class="s2">!!ids[node.content])</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">node.children.some(c =&gt; shared.isObject(c) &amp;&amp; hasScopeRef(c</span><span class="s1">, </span><span class="s2">ids))</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">hasScopeRef(node.content</span><span class="s1">, </span><span class="s2">ids)</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s1">default</span><span class="s2">:</span>
            <span class="s1">return false;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getMemoedVNodeCall(node) {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s2">&amp;&amp; node.callee === WITH_MEMO) {</span>
        <span class="s1">return </span><span class="s2">node.arguments[</span><span class="s4">1</span><span class="s2">].returns</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">makeBlock(node</span><span class="s1">, </span><span class="s2">{ helper</span><span class="s1">, </span><span class="s2">removeHelper</span><span class="s1">, </span><span class="s2">inSSR }) {</span>
    <span class="s1">if </span><span class="s2">(!node.isBlock) {</span>
        <span class="s2">node.isBlock = </span><span class="s1">true;</span>
        <span class="s2">removeHelper(getVNodeHelper(inSSR</span><span class="s1">, </span><span class="s2">node.isComponent))</span><span class="s1">;</span>
        <span class="s2">helper(OPEN_BLOCK)</span><span class="s1">;</span>
        <span class="s2">helper(getVNodeBlockHelper(inSSR</span><span class="s1">, </span><span class="s2">node.isComponent))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">deprecationData = {</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`Platform-native elements with &quot;is&quot; prop will no longer be ` </span><span class="s2">+</span>
            <span class="s0">`treated as components in Vue 3 unless the &quot;is&quot; value is explicitly ` </span><span class="s2">+</span>
            <span class="s0">`prefixed with &quot;vue:&quot;.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s2">]: {</span>
        <span class="s2">message: key =&gt; </span><span class="s0">`.sync modifier for v-bind has been removed. Use v-model with ` </span><span class="s2">+</span>
            <span class="s0">`argument instead. </span><span class="s1">\`</span><span class="s0">v-bind:</span><span class="s2">${key}</span><span class="s0">.sync</span><span class="s1">\` </span><span class="s0">should be changed to ` </span><span class="s2">+</span>
            <span class="s0">`</span><span class="s1">\`</span><span class="s0">v-model:</span><span class="s2">${key}</span><span class="s1">\`</span><span class="s0">.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/v-model.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`.prop modifier for v-bind has been removed and no longer necessary. ` </span><span class="s2">+</span>
            <span class="s0">`Vue 3 will automatically set a binding as DOM property when appropriate.`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`v-bind=&quot;obj&quot; usage is now order sensitive and behaves like JavaScript ` </span><span class="s2">+</span>
            <span class="s0">`object spread: it will now overwrite an existing non-mergeable attribute ` </span><span class="s2">+</span>
            <span class="s0">`that appears before v-bind in the case of conflict. ` </span><span class="s2">+</span>
            <span class="s0">`To retain 2.x behavior, move v-bind to make it the first attribute. ` </span><span class="s2">+</span>
            <span class="s0">`You can also suppress this warning if the usage is intended.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/v-bind.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_V_ON_NATIVE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`.native modifier for v-on has been removed as is no longer necessary.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`v-if / v-for precedence when used on the same element has changed ` </span><span class="s2">+</span>
            <span class="s0">`in Vue 3: v-if now takes higher precedence and will no longer have ` </span><span class="s2">+</span>
            <span class="s0">`access to v-for scope variables. It is best to avoid the ambiguity ` </span><span class="s2">+</span>
            <span class="s0">`with &lt;template&gt; tags or use a computed property that filters v-for ` </span><span class="s2">+</span>
            <span class="s0">`data source.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`&lt;template&gt; with no special directives will render as a native template ` </span><span class="s2">+</span>
            <span class="s0">`element instead of its inner content in Vue 3.`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`&quot;inline-template&quot; has been removed in Vue 3.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s2">]: {</span>
        <span class="s2">message: </span><span class="s0">`filters have been removed in Vue 3. ` </span><span class="s2">+</span>
            <span class="s0">`The &quot;|&quot; symbol will be treated as native JavaScript bitwise OR operator. ` </span><span class="s2">+</span>
            <span class="s0">`Use method calls or computed properties instead.`</span><span class="s1">,</span>
        <span class="s2">link: </span><span class="s0">`https://v3-migration.vuejs.org/breaking-changes/filters.html`</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getCompatValue(key</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">config = context.options</span>
        <span class="s2">? context.options.compatConfig</span>
        <span class="s2">: context.compatConfig</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">value = config &amp;&amp; config[key]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'MODE'</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">value || </span><span class="s4">3</span><span class="s1">; </span><span class="s3">// compiler defaults to v3 behavior</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isCompatEnabled(key</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">mode = getCompatValue(</span><span class="s0">'MODE'</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">value = getCompatValue(key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s3">// in v3 mode, only enable if explicitly set to true</span>
    <span class="s3">// otherwise enable for any non-false value</span>
    <span class="s1">return </span><span class="s2">mode === </span><span class="s4">3 </span><span class="s2">? value === </span><span class="s1">true </span><span class="s2">: value !== </span><span class="s1">false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">checkCompatEnabled(key</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc</span><span class="s1">, </span><span class="s2">...args) {</span>
    <span class="s1">const </span><span class="s2">enabled = isCompatEnabled(key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(enabled) {</span>
        <span class="s2">warnDeprecation(key</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc</span><span class="s1">, </span><span class="s2">...args)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">enabled</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">warnDeprecation(key</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc</span><span class="s1">, </span><span class="s2">...args) {</span>
    <span class="s1">const </span><span class="s2">val = getCompatValue(key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(val === </span><span class="s0">'suppress-warning'</span><span class="s2">) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ message</span><span class="s1">, </span><span class="s2">link } = deprecationData[key]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">msg = </span><span class="s0">`(deprecation </span><span class="s2">${key}</span><span class="s0">) </span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">message === </span><span class="s0">'function' </span><span class="s2">? message(...args) : message}${link ? </span><span class="s0">`</span><span class="s1">\n  </span><span class="s0">Details: </span><span class="s2">${link}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">err = </span><span class="s1">new </span><span class="s2">SyntaxError(msg)</span><span class="s1">;</span>
    <span class="s2">err.code = key</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(loc)</span>
        <span class="s2">err.loc = loc</span><span class="s1">;</span>
    <span class="s2">context.onWarn(err)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">// The default decoder only provides escapes for characters reserved as part of</span>
<span class="s3">// the template syntax, and is only used if the custom renderer did not provide</span>
<span class="s3">// a platform-specific decoder.</span>
<span class="s1">const </span><span class="s2">decodeRE = </span><span class="s4">/&amp;(gt|lt|amp|apos|quot);/g</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">decodeMap = {</span>
    <span class="s2">gt: </span><span class="s0">'&gt;'</span><span class="s1">,</span>
    <span class="s2">lt: </span><span class="s0">'&lt;'</span><span class="s1">,</span>
    <span class="s2">amp: </span><span class="s0">'&amp;'</span><span class="s1">,</span>
    <span class="s2">apos: </span><span class="s0">&quot;'&quot;</span><span class="s1">,</span>
    <span class="s2">quot: </span><span class="s0">'&quot;'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">defaultParserOptions = {</span>
    <span class="s2">delimiters: [</span><span class="s0">`{{`</span><span class="s1">, </span><span class="s0">`}}`</span><span class="s2">]</span><span class="s1">,</span>
    <span class="s2">getNamespace: () =&gt; </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s1">,</span>
    <span class="s2">getTextMode: () =&gt; </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s1">,</span>
    <span class="s2">isVoidTag: shared.NO</span><span class="s1">,</span>
    <span class="s2">isPreTag: shared.NO</span><span class="s1">,</span>
    <span class="s2">isCustomElement: shared.NO</span><span class="s1">,</span>
    <span class="s2">decodeEntities: (rawText) =&gt; rawText.replace(decodeRE</span><span class="s1">, </span><span class="s2">(_</span><span class="s1">, </span><span class="s2">p1) =&gt; decodeMap[p1])</span><span class="s1">,</span>
    <span class="s2">onError: defaultOnError</span><span class="s1">,</span>
    <span class="s2">onWarn: defaultOnWarn</span><span class="s1">,</span>
    <span class="s2">comments: </span><span class="s1">true</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">baseParse(content</span><span class="s1">, </span><span class="s2">options = {}) {</span>
    <span class="s1">const </span><span class="s2">context = createParserContext(content</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">createRoot(parseChildren(context</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s1">, </span><span class="s2">[])</span><span class="s1">, </span><span class="s2">getSelection(context</span><span class="s1">, </span><span class="s2">start))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createParserContext(content</span><span class="s1">, </span><span class="s2">rawOptions) {</span>
    <span class="s1">const </span><span class="s2">options = shared.extend({}</span><span class="s1">, </span><span class="s2">defaultParserOptions)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">key</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">rawOptions) {</span>
        <span class="s3">// @ts-ignore</span>
        <span class="s2">options[key] =</span>
            <span class="s2">rawOptions[key] === undefined</span>
                <span class="s2">? defaultParserOptions[key]</span>
                <span class="s2">: rawOptions[key]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">options</span><span class="s1">,</span>
        <span class="s2">column: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s2">line: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s2">offset: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">originalSource: content</span><span class="s1">,</span>
        <span class="s2">source: content</span><span class="s1">,</span>
        <span class="s2">inPre: </span><span class="s1">false,</span>
        <span class="s2">inVPre: </span><span class="s1">false,</span>
        <span class="s2">onWarn: options.onWarn</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseChildren(context</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">ancestors) {</span>
    <span class="s1">const </span><span class="s2">parent = last(ancestors)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">nodes = []</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(!isEnd(context</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">ancestors)) {</span>
        <span class="s1">const </span><span class="s2">s = context.source</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">node = undefined</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(mode === </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */ </span><span class="s2">|| mode === </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(!context.inVPre &amp;&amp; startsWith(s</span><span class="s1">, </span><span class="s2">context.options.delimiters[</span><span class="s4">0</span><span class="s2">])) {</span>
                <span class="s3">// '{{'</span>
                <span class="s2">node = parseInterpolation(context</span><span class="s1">, </span><span class="s2">mode)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(mode === </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */ </span><span class="s2">&amp;&amp; s[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'&lt;'</span><span class="s2">) {</span>
                <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state</span>
                <span class="s1">if </span><span class="s2">(s.length === </span><span class="s4">1</span><span class="s2">) {</span>
                    <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(s[</span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'!'</span><span class="s2">) {</span>
                    <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state</span>
                    <span class="s1">if </span><span class="s2">(startsWith(s</span><span class="s1">, </span><span class="s0">'&lt;!--'</span><span class="s2">)) {</span>
                        <span class="s2">node = parseComment(context)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(startsWith(s</span><span class="s1">, </span><span class="s0">'&lt;!DOCTYPE'</span><span class="s2">)) {</span>
                        <span class="s3">// Ignore DOCTYPE by a limitation.</span>
                        <span class="s2">node = parseBogusComment(context)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(startsWith(s</span><span class="s1">, </span><span class="s0">'&lt;![CDATA['</span><span class="s2">)) {</span>
                        <span class="s1">if </span><span class="s2">(ns !== </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s2">) {</span>
                            <span class="s2">node = parseCDATA(context</span><span class="s1">, </span><span class="s2">ancestors)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s2">)</span><span class="s1">;</span>
                            <span class="s2">node = parseBogusComment(context)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">11 </span><span class="s3">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">node = parseBogusComment(context)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(s[</span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'/'</span><span class="s2">) {</span>
                    <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state</span>
                    <span class="s1">if </span><span class="s2">(s.length === </span><span class="s4">2</span><span class="s2">) {</span>
                        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s1">, </span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(s[</span><span class="s4">2</span><span class="s2">] === </span><span class="s0">'&gt;'</span><span class="s2">) {</span>
                        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">14 </span><span class="s3">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s1">, </span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">3</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s1">continue;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(</span><span class="s4">/[a-z]/i</span><span class="s2">.test(s[</span><span class="s4">2</span><span class="s2">])) {</span>
                        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">23 </span><span class="s3">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">parseTag(context</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s1">, </span><span class="s2">parent)</span><span class="s1">;</span>
                        <span class="s1">continue;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s1">, </span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">node = parseBogusComment(context)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(</span><span class="s4">/[a-z]/i</span><span class="s2">.test(s[</span><span class="s4">1</span><span class="s2">])) {</span>
                    <span class="s2">node = parseElement(context</span><span class="s1">, </span><span class="s2">ancestors)</span><span class="s1">;</span>
                    <span class="s3">// 2.x &lt;template&gt; with no directive compat</span>
                    <span class="s1">if </span><span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s1">, </span><span class="s2">context) &amp;&amp;</span>
                        <span class="s2">node &amp;&amp;</span>
                        <span class="s2">node.tag === </span><span class="s0">'template' </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">!node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">isSpecialTemplateDirective(p.name))) {</span>
                        <span class="s2">warnDeprecation(</span><span class="s0">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">node.loc)</span><span class="s1">;</span>
                        <span class="s2">node = node.children</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(s[</span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'?'</span><span class="s2">) {</span>
                    <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">21 </span><span class="s3">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">node = parseBogusComment(context)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!node) {</span>
            <span class="s2">node = parseText(context</span><span class="s1">, </span><span class="s2">mode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(node)) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">pushNode(nodes</span><span class="s1">, </span><span class="s2">node[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">pushNode(nodes</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// Whitespace handling strategy like v2</span>
    <span class="s1">let </span><span class="s2">removedWhitespace = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(mode !== </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */ </span><span class="s2">&amp;&amp; mode !== </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">shouldCondense = context.options.whitespace !== </span><span class="s0">'preserve'</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; nodes.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">node = nodes[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(!context.inPre) {</span>
                    <span class="s1">if </span><span class="s2">(!</span><span class="s4">/[^\t\r\n\f ]/</span><span class="s2">.test(node.content)) {</span>
                        <span class="s1">const </span><span class="s2">prev = nodes[i - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
                        <span class="s1">const </span><span class="s2">next = nodes[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
                        <span class="s3">// Remove if:</span>
                        <span class="s3">// - the whitespace is the first or last node, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between twos comments, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between comment and element, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between two elements AND contains newline</span>
                        <span class="s1">if </span><span class="s2">(!prev ||</span>
                            <span class="s2">!next ||</span>
                            <span class="s2">(shouldCondense &amp;&amp;</span>
                                <span class="s2">((prev.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s2">&amp;&amp;</span>
                                    <span class="s2">next.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">) ||</span>
                                    <span class="s2">(prev.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s2">&amp;&amp;</span>
                                        <span class="s2">next.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) ||</span>
                                    <span class="s2">(prev.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                                        <span class="s2">next.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">) ||</span>
                                    <span class="s2">(prev.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                                        <span class="s2">next.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                                        <span class="s4">/[\r\n]/</span><span class="s2">.test(node.content))))) {</span>
                            <span class="s2">removedWhitespace = </span><span class="s1">true;</span>
                            <span class="s2">nodes[i] = </span><span class="s1">null;</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s3">// Otherwise, the whitespace is condensed into a single space</span>
                            <span class="s2">node.content = </span><span class="s0">' '</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(shouldCondense) {</span>
                        <span class="s3">// in condense mode, consecutive whitespaces in text are condensed</span>
                        <span class="s3">// down to a single space.</span>
                        <span class="s2">node.content = node.content.replace(</span><span class="s4">/[\t\r\n\f ]+/g</span><span class="s1">, </span><span class="s0">' '</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s3">// #6410 normalize windows newlines in &lt;pre&gt;:</span>
                    <span class="s3">// in SSR, browsers normalize server-rendered \r\n into a single \n</span>
                    <span class="s3">// in the DOM</span>
                    <span class="s2">node.content = node.content.replace(</span><span class="s4">/\r\n/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// Remove comment nodes if desired by configuration.</span>
            <span class="s1">else if </span><span class="s2">(node.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s2">&amp;&amp; !context.options.comments) {</span>
                <span class="s2">removedWhitespace = </span><span class="s1">true;</span>
                <span class="s2">nodes[i] = </span><span class="s1">null;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(context.inPre &amp;&amp; parent &amp;&amp; context.options.isPreTag(parent.tag)) {</span>
            <span class="s3">// remove leading newline per html spec</span>
            <span class="s3">// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element</span>
            <span class="s1">const </span><span class="s2">first = nodes[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(first &amp;&amp; first.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">) {</span>
                <span class="s2">first.content = first.content.replace(</span><span class="s4">/^\r?\n/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">removedWhitespace ? nodes.filter(Boolean) : nodes</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">pushNode(nodes</span><span class="s1">, </span><span class="s2">node) {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">prev = last(nodes)</span><span class="s1">;</span>
        <span class="s3">// Merge if both this and the previous node are text and those are</span>
        <span class="s3">// consecutive. This happens for cases like &quot;a &lt; b&quot;.</span>
        <span class="s1">if </span><span class="s2">(prev &amp;&amp;</span>
            <span class="s2">prev.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">prev.loc.end.offset === node.loc.start.offset) {</span>
            <span class="s2">prev.content += node.content</span><span class="s1">;</span>
            <span class="s2">prev.loc.end = node.loc.end</span><span class="s1">;</span>
            <span class="s2">prev.loc.source += node.loc.source</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">nodes.push(node)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseCDATA(context</span><span class="s1">, </span><span class="s2">ancestors) {</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">9</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">nodes = parseChildren(context</span><span class="s1">, </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */</span><span class="s1">, </span><span class="s2">ancestors)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(context.source.length === </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">6 </span><span class="s3">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">3</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">nodes</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseComment(context) {</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">content</span><span class="s1">;</span>
    <span class="s3">// Regular comment.</span>
    <span class="s1">const </span><span class="s2">match = </span><span class="s4">/--(\!)?&gt;/</span><span class="s2">.exec(context.source)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!match) {</span>
        <span class="s2">content = context.source.slice(</span><span class="s4">4</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">context.source.length)</span><span class="s1">;</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">7 </span><span class="s3">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(match.index &lt;= </span><span class="s4">3</span><span class="s2">) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(match[</span><span class="s4">1</span><span class="s2">]) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">10 </span><span class="s3">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">content = context.source.slice(</span><span class="s4">4</span><span class="s1">, </span><span class="s2">match.index)</span><span class="s1">;</span>
        <span class="s3">// Advancing with reporting nested comments.</span>
        <span class="s1">const </span><span class="s2">s = context.source.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">match.index)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">prevIndex = </span><span class="s4">1</span><span class="s1">, </span><span class="s2">nestedIndex = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">((nestedIndex = s.indexOf(</span><span class="s0">'&lt;!--'</span><span class="s1">, </span><span class="s2">prevIndex)) !== -</span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">nestedIndex - prevIndex + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(nestedIndex + </span><span class="s4">4 </span><span class="s2">&lt; s.length) {</span>
                <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">16 </span><span class="s3">/* ErrorCodes.NESTED_COMMENT */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">prevIndex = nestedIndex + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">match.index + match[</span><span class="s4">0</span><span class="s2">].length - prevIndex + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">,</span>
        <span class="s2">content</span><span class="s1">,</span>
        <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseBogusComment(context) {</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">contentStart = context.source[</span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'?' </span><span class="s2">? </span><span class="s4">1 </span><span class="s2">: </span><span class="s4">2</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">content</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">closeIndex = context.source.indexOf(</span><span class="s0">'&gt;'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(closeIndex === -</span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s2">content = context.source.slice(contentStart)</span><span class="s1">;</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">context.source.length)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">content = context.source.slice(contentStart</span><span class="s1">, </span><span class="s2">closeIndex)</span><span class="s1">;</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">closeIndex + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">,</span>
        <span class="s2">content</span><span class="s1">,</span>
        <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseElement(context</span><span class="s1">, </span><span class="s2">ancestors) {</span>
    <span class="s3">// Start tag.</span>
    <span class="s1">const </span><span class="s2">wasInPre = context.inPre</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">wasInVPre = context.inVPre</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">parent = last(ancestors)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">element = parseTag(context</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* TagType.Start */</span><span class="s1">, </span><span class="s2">parent)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isPreBoundary = context.inPre &amp;&amp; !wasInPre</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(element.isSelfClosing || context.options.isVoidTag(element.tag)) {</span>
        <span class="s3">// #4030 self-closing &lt;pre&gt; tag</span>
        <span class="s1">if </span><span class="s2">(isPreBoundary) {</span>
            <span class="s2">context.inPre = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(isVPreBoundary) {</span>
            <span class="s2">context.inVPre = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">element</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// Children.</span>
    <span class="s2">ancestors.push(element)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mode = context.options.getTextMode(element</span><span class="s1">, </span><span class="s2">parent)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">children = parseChildren(context</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">ancestors)</span><span class="s1">;</span>
    <span class="s2">ancestors.pop()</span><span class="s1">;</span>
    <span class="s3">// 2.x inline-template compat</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">inlineTemplateProp = element.props.find(p =&gt; p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s2">&amp;&amp; p.name === </span><span class="s0">'inline-template'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(inlineTemplateProp &amp;&amp;</span>
            <span class="s2">checkCompatEnabled(</span><span class="s0">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">inlineTemplateProp.loc)) {</span>
            <span class="s1">const </span><span class="s2">loc = getSelection(context</span><span class="s1">, </span><span class="s2">element.loc.end)</span><span class="s1">;</span>
            <span class="s2">inlineTemplateProp.value = {</span>
                <span class="s2">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">,</span>
                <span class="s2">content: loc.source</span><span class="s1">,</span>
                <span class="s2">loc</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">element.children = children</span><span class="s1">;</span>
    <span class="s3">// End tag.</span>
    <span class="s1">if </span><span class="s2">(startsWithEndTagOpen(context.source</span><span class="s1">, </span><span class="s2">element.tag)) {</span>
        <span class="s2">parseTag(context</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s1">, </span><span class="s2">parent)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">24 </span><span class="s3">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s2">element.loc.start)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(context.source.length === </span><span class="s4">0 </span><span class="s2">&amp;&amp; element.tag.toLowerCase() === </span><span class="s0">'script'</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">first = children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(first &amp;&amp; startsWith(first.loc.source</span><span class="s1">, </span><span class="s0">'&lt;!--'</span><span class="s2">)) {</span>
                <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">element.loc = getSelection(context</span><span class="s1">, </span><span class="s2">element.loc.start)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isPreBoundary) {</span>
        <span class="s2">context.inPre = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isVPreBoundary) {</span>
        <span class="s2">context.inVPre = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">element</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">isSpecialTemplateDirective = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">shared.makeMap(</span><span class="s0">`if,else,else-if,for,slot`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">parseTag(context</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">parent) {</span>
    <span class="s3">// Tag open.</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">match = </span><span class="s4">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span><span class="s2">.exec(context.source)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">tag = match[</span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ns = context.options.getNamespace(tag</span><span class="s1">, </span><span class="s2">parent)</span><span class="s1">;</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">match[</span><span class="s4">0</span><span class="s2">].length)</span><span class="s1">;</span>
    <span class="s2">advanceSpaces(context)</span><span class="s1">;</span>
    <span class="s3">// save current state in case we need to re-parse attributes with v-pre</span>
    <span class="s1">const </span><span class="s2">cursor = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">currentSource = context.source</span><span class="s1">;</span>
    <span class="s3">// check &lt;pre&gt; tag</span>
    <span class="s1">if </span><span class="s2">(context.options.isPreTag(tag)) {</span>
        <span class="s2">context.inPre = </span><span class="s1">true;</span>
    <span class="s2">}</span>
    <span class="s3">// Attributes.</span>
    <span class="s1">let </span><span class="s2">props = parseAttributes(context</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
    <span class="s3">// check v-pre</span>
    <span class="s1">if </span><span class="s2">(type === </span><span class="s4">0 </span><span class="s3">/* TagType.Start */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!context.inVPre &amp;&amp;</span>
        <span class="s2">props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; p.name === </span><span class="s0">'pre'</span><span class="s2">)) {</span>
        <span class="s2">context.inVPre = </span><span class="s1">true;</span>
        <span class="s3">// reset context</span>
        <span class="s2">shared.extend(context</span><span class="s1">, </span><span class="s2">cursor)</span><span class="s1">;</span>
        <span class="s2">context.source = currentSource</span><span class="s1">;</span>
        <span class="s3">// re-parse attrs and filter out v-pre itself</span>
        <span class="s2">props = parseAttributes(context</span><span class="s1">, </span><span class="s2">type).filter(p =&gt; p.name !== </span><span class="s0">'v-pre'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// Tag close.</span>
    <span class="s1">let </span><span class="s2">isSelfClosing = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(context.source.length === </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">9 </span><span class="s3">/* ErrorCodes.EOF_IN_TAG */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">isSelfClosing = startsWith(context.source</span><span class="s1">, </span><span class="s0">'/&gt;'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */ </span><span class="s2">&amp;&amp; isSelfClosing) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">4 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">isSelfClosing ? </span><span class="s4">2 </span><span class="s2">: </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s2">) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s3">// 2.x deprecation checks</span>
    <span class="s1">if </span><span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s1">, </span><span class="s2">context)) {</span>
        <span class="s1">let </span><span class="s2">hasIf = </span><span class="s1">false;</span>
        <span class="s1">let </span><span class="s2">hasFor = </span><span class="s1">false;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">p = props[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'if'</span><span class="s2">) {</span>
                    <span class="s2">hasIf = </span><span class="s1">true;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(p.name === </span><span class="s0">'for'</span><span class="s2">) {</span>
                    <span class="s2">hasFor = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(hasIf &amp;&amp; hasFor) {</span>
                <span class="s2">warnDeprecation(</span><span class="s0">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">getSelection(context</span><span class="s1">, </span><span class="s2">start))</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">tagType = </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!context.inVPre) {</span>
        <span class="s1">if </span><span class="s2">(tag === </span><span class="s0">'slot'</span><span class="s2">) {</span>
            <span class="s2">tagType = </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(tag === </span><span class="s0">'template'</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; isSpecialTemplateDirective(p.name))) {</span>
                <span class="s2">tagType = </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(isComponent(tag</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">context)) {</span>
            <span class="s2">tagType = </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">,</span>
        <span class="s2">ns</span><span class="s1">,</span>
        <span class="s2">tag</span><span class="s1">,</span>
        <span class="s2">tagType</span><span class="s1">,</span>
        <span class="s2">props</span><span class="s1">,</span>
        <span class="s2">isSelfClosing</span><span class="s1">,</span>
        <span class="s2">children: []</span><span class="s1">,</span>
        <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start)</span><span class="s1">,</span>
        <span class="s2">codegenNode: undefined </span><span class="s3">// to be created during transform phase</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isComponent(tag</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">options = context.options</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(options.isCustomElement(tag)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(tag === </span><span class="s0">'component' </span><span class="s2">||</span>
        <span class="s4">/^[A-Z]/</span><span class="s2">.test(tag) ||</span>
        <span class="s2">isCoreComponent(tag) ||</span>
        <span class="s2">(options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) ||</span>
        <span class="s2">(options.isNativeTag &amp;&amp; !options.isNativeTag(tag))) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s3">// at this point the tag should be a native tag, but check for potential &quot;is&quot;</span>
    <span class="s3">// casting</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">p = props[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'is' </span><span class="s2">&amp;&amp; p.value) {</span>
                <span class="s1">if </span><span class="s2">(p.value.content.startsWith(</span><span class="s0">'vue:'</span><span class="s2">)) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(checkCompatEnabled(</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">p.loc)) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// directive</span>
            <span class="s3">// v-is (TODO Deprecate)</span>
            <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'is'</span><span class="s2">) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(</span>
            <span class="s3">// :is on plain element - only treat as component in compat mode</span>
            <span class="s2">p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">isStaticArgOf(p.arg</span><span class="s1">, </span><span class="s0">'is'</span><span class="s2">) &amp;&amp;</span>
                <span class="s1">true </span><span class="s2">&amp;&amp;</span>
                <span class="s2">checkCompatEnabled(</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">p.loc)) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseAttributes(context</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">const </span><span class="s2">props = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">attributeNames = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(context.source.length &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!startsWith(context.source</span><span class="s1">, </span><span class="s0">'&gt;'</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">!startsWith(context.source</span><span class="s1">, </span><span class="s0">'/&gt;'</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(startsWith(context.source</span><span class="s1">, </span><span class="s0">'/'</span><span class="s2">)) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">22 </span><span class="s3">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">advanceSpaces(context)</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s2">) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">3 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">attr = parseAttribute(context</span><span class="s1">, </span><span class="s2">attributeNames)</span><span class="s1">;</span>
        <span class="s3">// Trim whitespace between class</span>
        <span class="s3">// https://github.com/vuejs/core/issues/4251</span>
        <span class="s1">if </span><span class="s2">(attr.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">attr.value &amp;&amp;</span>
            <span class="s2">attr.name === </span><span class="s0">'class'</span><span class="s2">) {</span>
            <span class="s2">attr.value.content = attr.value.content.replace(</span><span class="s4">/\s+/g</span><span class="s1">, </span><span class="s0">' '</span><span class="s2">).trim()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === </span><span class="s4">0 </span><span class="s3">/* TagType.Start */</span><span class="s2">) {</span>
            <span class="s2">props.push(attr)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s4">/^[^\t\r\n\f /&gt;]/</span><span class="s2">.test(context.source)) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">15 </span><span class="s3">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">advanceSpaces(context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">props</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseAttribute(context</span><span class="s1">, </span><span class="s2">nameSet) {</span>
    <span class="s3">// Name.</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">match = </span><span class="s4">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span><span class="s2">.exec(context.source)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">name = match[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(nameSet.has(name)) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">nameSet.add(name)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(name[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'='</span><span class="s2">) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">19 </span><span class="s3">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">pattern = </span><span class="s4">/[&quot;'&lt;]/g</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">m</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">((m = pattern.exec(name))) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">17 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s1">, </span><span class="s2">m.index)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">name.length)</span><span class="s1">;</span>
    <span class="s3">// Value</span>
    <span class="s1">let </span><span class="s2">value = undefined</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(</span><span class="s4">/^[\t\r\n\f ]*=/</span><span class="s2">.test(context.source)) {</span>
        <span class="s2">advanceSpaces(context)</span><span class="s1">;</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">advanceSpaces(context)</span><span class="s1">;</span>
        <span class="s2">value = parseAttributeValue(context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!value) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">13 </span><span class="s3">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">loc = getSelection(context</span><span class="s1">, </span><span class="s2">start)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!context.inVPre &amp;&amp; </span><span class="s4">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span><span class="s2">.test(name)) {</span>
        <span class="s1">const </span><span class="s2">match = </span><span class="s4">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i</span><span class="s2">.exec(name)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">isPropShorthand = startsWith(name</span><span class="s1">, </span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">dirName = match[</span><span class="s4">1</span><span class="s2">] ||</span>
            <span class="s2">(isPropShorthand || startsWith(name</span><span class="s1">, </span><span class="s0">':'</span><span class="s2">)</span>
                <span class="s2">? </span><span class="s0">'bind'</span>
                <span class="s2">: startsWith(name</span><span class="s1">, </span><span class="s0">'@'</span><span class="s2">)</span>
                    <span class="s2">? </span><span class="s0">'on'</span>
                    <span class="s2">: </span><span class="s0">'slot'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">arg</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(match[</span><span class="s4">2</span><span class="s2">]) {</span>
            <span class="s1">const </span><span class="s2">isSlot = dirName === </span><span class="s0">'slot'</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">startOffset = name.lastIndexOf(match[</span><span class="s4">2</span><span class="s2">])</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">loc = getSelection(context</span><span class="s1">, </span><span class="s2">getNewPosition(context</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">startOffset)</span><span class="s1">, </span><span class="s2">getNewPosition(context</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">startOffset + match[</span><span class="s4">2</span><span class="s2">].length + ((isSlot &amp;&amp; match[</span><span class="s4">3</span><span class="s2">]) || </span><span class="s0">''</span><span class="s2">).length))</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">content = match[</span><span class="s4">2</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">isStatic = </span><span class="s1">true;</span>
            <span class="s1">if </span><span class="s2">(content.startsWith(</span><span class="s0">'['</span><span class="s2">)) {</span>
                <span class="s2">isStatic = </span><span class="s1">false;</span>
                <span class="s1">if </span><span class="s2">(!content.endsWith(</span><span class="s0">']'</span><span class="s2">)) {</span>
                    <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">27 </span><span class="s3">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">content = content.slice(</span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">content = content.slice(</span><span class="s4">1</span><span class="s1">, </span><span class="s2">content.length - </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(isSlot) {</span>
                <span class="s3">// #1241 special case for v-slot: vuetify relies extensively on slot</span>
                <span class="s3">// names containing dots. v-slot doesn't have any modifiers and Vue 2.x</span>
                <span class="s3">// supports such usage so we are keeping it consistent with 2.x.</span>
                <span class="s2">content += match[</span><span class="s4">3</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">arg = {</span>
                <span class="s2">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">,</span>
                <span class="s2">content</span><span class="s1">,</span>
                <span class="s2">isStatic</span><span class="s1">,</span>
                <span class="s2">constType: isStatic</span>
                    <span class="s2">? </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span>
                    <span class="s2">: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">,</span>
                <span class="s2">loc</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(value &amp;&amp; value.isQuoted) {</span>
            <span class="s1">const </span><span class="s2">valueLoc = value.loc</span><span class="s1">;</span>
            <span class="s2">valueLoc.start.offset++</span><span class="s1">;</span>
            <span class="s2">valueLoc.start.column++</span><span class="s1">;</span>
            <span class="s2">valueLoc.end = advancePositionWithClone(valueLoc.start</span><span class="s1">, </span><span class="s2">value.content)</span><span class="s1">;</span>
            <span class="s2">valueLoc.source = valueLoc.source.slice(</span><span class="s4">1</span><span class="s1">, </span><span class="s2">-</span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">modifiers = match[</span><span class="s4">3</span><span class="s2">] ? match[</span><span class="s4">3</span><span class="s2">].slice(</span><span class="s4">1</span><span class="s2">).split(</span><span class="s0">'.'</span><span class="s2">) : []</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isPropShorthand)</span>
            <span class="s2">modifiers.push(</span><span class="s0">'prop'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s3">// 2.x compat v-bind:foo.sync -&gt; v-model:foo</span>
        <span class="s1">if </span><span class="s2">(dirName === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp; arg) {</span>
            <span class="s1">if </span><span class="s2">(modifiers.includes(</span><span class="s0">'sync'</span><span class="s2">) &amp;&amp;</span>
                <span class="s2">checkCompatEnabled(</span><span class="s0">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc</span><span class="s1">, </span><span class="s2">arg.loc.source)) {</span>
                <span class="s2">dirName = </span><span class="s0">'model'</span><span class="s1">;</span>
                <span class="s2">modifiers.splice(modifiers.indexOf(</span><span class="s0">'sync'</span><span class="s2">)</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(modifiers.includes(</span><span class="s0">'prop'</span><span class="s2">)) {</span>
                <span class="s2">checkCompatEnabled(</span><span class="s0">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">{</span>
            <span class="s2">type: </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s1">,</span>
            <span class="s2">name: dirName</span><span class="s1">,</span>
            <span class="s2">exp: value &amp;&amp; {</span>
                <span class="s2">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">,</span>
                <span class="s2">content: value.content</span><span class="s1">,</span>
                <span class="s2">isStatic: </span><span class="s1">false,</span>
                <span class="s3">// Treat as non-constant by default. This can be potentially set to</span>
                <span class="s3">// other values by `transformExpression` to make it eligible for hoisting.</span>
                <span class="s2">constType: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">,</span>
                <span class="s2">loc: value.loc</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">arg</span><span class="s1">,</span>
            <span class="s2">modifiers</span><span class="s1">,</span>
            <span class="s2">loc</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// missing directive name or illegal directive name</span>
    <span class="s1">if </span><span class="s2">(!context.inVPre &amp;&amp; startsWith(name</span><span class="s1">, </span><span class="s0">'v-'</span><span class="s2">)) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">26 </span><span class="s3">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">,</span>
        <span class="s2">name</span><span class="s1">,</span>
        <span class="s2">value: value &amp;&amp; {</span>
            <span class="s2">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">,</span>
            <span class="s2">content: value.content</span><span class="s1">,</span>
            <span class="s2">loc: value.loc</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">loc</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseAttributeValue(context) {</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">content</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">quote = context.source[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isQuoted = quote === </span><span class="s0">`&quot;` </span><span class="s2">|| quote === </span><span class="s0">`'`</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isQuoted) {</span>
        <span class="s3">// Quoted value.</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">endIndex = context.source.indexOf(quote)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(endIndex === -</span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">content = parseTextData(context</span><span class="s1">, </span><span class="s2">context.source.length</span><span class="s1">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">content = parseTextData(context</span><span class="s1">, </span><span class="s2">endIndex</span><span class="s1">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// Unquoted</span>
        <span class="s1">const </span><span class="s2">match = </span><span class="s4">/^[^\t\r\n\f &gt;]+/</span><span class="s2">.exec(context.source)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!match) {</span>
            <span class="s1">return </span><span class="s2">undefined</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">unexpectedChars = </span><span class="s4">/[&quot;'&lt;=`]/g</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">m</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">((m = unexpectedChars.exec(match[</span><span class="s4">0</span><span class="s2">]))) {</span>
            <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">18 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s1">, </span><span class="s2">m.index)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">content = parseTextData(context</span><span class="s1">, </span><span class="s2">match[</span><span class="s4">0</span><span class="s2">].length</span><span class="s1">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{ content</span><span class="s1">, </span><span class="s2">isQuoted</span><span class="s1">, </span><span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start) }</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseInterpolation(context</span><span class="s1">, </span><span class="s2">mode) {</span>
    <span class="s1">const </span><span class="s2">[open</span><span class="s1">, </span><span class="s2">close] = context.options.delimiters</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">closeIndex = context.source.indexOf(close</span><span class="s1">, </span><span class="s2">open.length)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(closeIndex === -</span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s2">emitError(context</span><span class="s1">, </span><span class="s4">25 </span><span class="s3">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">undefined</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">open.length)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">innerStart = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">innerEnd = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rawContentLength = closeIndex - open.length</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rawContent = context.source.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">rawContentLength)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">preTrimContent = parseTextData(context</span><span class="s1">, </span><span class="s2">rawContentLength</span><span class="s1">, </span><span class="s2">mode)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">content = preTrimContent.trim()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">startOffset = preTrimContent.indexOf(content)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(startOffset &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">advancePositionWithMutation(innerStart</span><span class="s1">, </span><span class="s2">rawContent</span><span class="s1">, </span><span class="s2">startOffset)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</span><span class="s1">;</span>
    <span class="s2">advancePositionWithMutation(innerEnd</span><span class="s1">, </span><span class="s2">rawContent</span><span class="s1">, </span><span class="s2">endOffset)</span><span class="s1">;</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">close.length)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">,</span>
        <span class="s2">content: {</span>
            <span class="s2">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">,</span>
            <span class="s2">isStatic: </span><span class="s1">false,</span>
            <span class="s3">// Set `isConstant` to false by default and will decide in transformExpression</span>
            <span class="s2">constType: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">,</span>
            <span class="s2">content</span><span class="s1">,</span>
            <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">innerStart</span><span class="s1">, </span><span class="s2">innerEnd)</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseText(context</span><span class="s1">, </span><span class="s2">mode) {</span>
    <span class="s1">const </span><span class="s2">endTokens = mode === </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */ </span><span class="s2">? [</span><span class="s0">']]&gt;'</span><span class="s2">] : [</span><span class="s0">'&lt;'</span><span class="s1">, </span><span class="s2">context.options.delimiters[</span><span class="s4">0</span><span class="s2">]]</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">endIndex = context.source.length</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; endTokens.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">index = context.source.indexOf(endTokens[i]</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(index !== -</span><span class="s4">1 </span><span class="s2">&amp;&amp; endIndex &gt; index) {</span>
            <span class="s2">endIndex = index</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">start = getCursor(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">content = parseTextData(context</span><span class="s1">, </span><span class="s2">endIndex</span><span class="s1">, </span><span class="s2">mode)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">,</span>
        <span class="s2">content</span><span class="s1">,</span>
        <span class="s2">loc: getSelection(context</span><span class="s1">, </span><span class="s2">start)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Get text data with a given length from the current location.</span>
 <span class="s5">* This translates HTML entities in the text data.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">parseTextData(context</span><span class="s1">, </span><span class="s2">length</span><span class="s1">, </span><span class="s2">mode) {</span>
    <span class="s1">const </span><span class="s2">rawText = context.source.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">length)</span><span class="s1">;</span>
    <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">length)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(mode === </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */ </span><span class="s2">||</span>
        <span class="s2">mode === </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */ </span><span class="s2">||</span>
        <span class="s2">!rawText.includes(</span><span class="s0">'&amp;'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">rawText</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.</span>
        <span class="s1">return </span><span class="s2">context.options.decodeEntities(rawText</span><span class="s1">, </span><span class="s2">mode === </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getCursor(context) {</span>
    <span class="s1">const </span><span class="s2">{ column</span><span class="s1">, </span><span class="s2">line</span><span class="s1">, </span><span class="s2">offset } = context</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{ column</span><span class="s1">, </span><span class="s2">line</span><span class="s1">, </span><span class="s2">offset }</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getSelection(context</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">end) {</span>
    <span class="s2">end = end || getCursor(context)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">start</span><span class="s1">,</span>
        <span class="s2">end</span><span class="s1">,</span>
        <span class="s2">source: context.originalSource.slice(start.offset</span><span class="s1">, </span><span class="s2">end.offset)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">last(xs) {</span>
    <span class="s1">return </span><span class="s2">xs[xs.length - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">startsWith(source</span><span class="s1">, </span><span class="s2">searchString) {</span>
    <span class="s1">return </span><span class="s2">source.startsWith(searchString)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">numberOfCharacters) {</span>
    <span class="s1">const </span><span class="s2">{ source } = context</span><span class="s1">;</span>
    <span class="s2">advancePositionWithMutation(context</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">numberOfCharacters)</span><span class="s1">;</span>
    <span class="s2">context.source = source.slice(numberOfCharacters)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">advanceSpaces(context) {</span>
    <span class="s1">const </span><span class="s2">match = </span><span class="s4">/^[\t\r\n\f ]+/</span><span class="s2">.exec(context.source)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(match) {</span>
        <span class="s2">advanceBy(context</span><span class="s1">, </span><span class="s2">match[</span><span class="s4">0</span><span class="s2">].length)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getNewPosition(context</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">numberOfCharacters) {</span>
    <span class="s1">return </span><span class="s2">advancePositionWithClone(start</span><span class="s1">, </span><span class="s2">context.originalSource.slice(start.offset</span><span class="s1">, </span><span class="s2">numberOfCharacters)</span><span class="s1">, </span><span class="s2">numberOfCharacters)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">emitError(context</span><span class="s1">, </span><span class="s2">code</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">loc = getCursor(context)) {</span>
    <span class="s1">if </span><span class="s2">(offset) {</span>
        <span class="s2">loc.offset += offset</span><span class="s1">;</span>
        <span class="s2">loc.column += offset</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">context.options.onError(createCompilerError(code</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">start: loc</span><span class="s1">,</span>
        <span class="s2">end: loc</span><span class="s1">,</span>
        <span class="s2">source: </span><span class="s0">''</span>
    <span class="s2">}))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isEnd(context</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">ancestors) {</span>
    <span class="s1">const </span><span class="s2">s = context.source</span><span class="s1">;</span>
    <span class="s1">switch </span><span class="s2">(mode) {</span>
        <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(startsWith(s</span><span class="s1">, </span><span class="s0">'&lt;/'</span><span class="s2">)) {</span>
                <span class="s3">// TODO: probably bad performance</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = ancestors.length - </span><span class="s4">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s4">0</span><span class="s1">; </span><span class="s2">--i) {</span>
                    <span class="s1">if </span><span class="s2">(startsWithEndTagOpen(s</span><span class="s1">, </span><span class="s2">ancestors[i].tag)) {</span>
                        <span class="s1">return true;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */</span><span class="s2">: {</span>
            <span class="s1">const </span><span class="s2">parent = last(ancestors)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parent &amp;&amp; startsWithEndTagOpen(s</span><span class="s1">, </span><span class="s2">parent.tag)) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s2">}</span>
        <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(startsWith(s</span><span class="s1">, </span><span class="s0">']]&gt;'</span><span class="s2">)) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">!s</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">startsWithEndTagOpen(source</span><span class="s1">, </span><span class="s2">tag) {</span>
    <span class="s1">return </span><span class="s2">(startsWith(source</span><span class="s1">, </span><span class="s0">'&lt;/'</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">source.slice(</span><span class="s4">2</span><span class="s1">, </span><span class="s4">2 </span><span class="s2">+ tag.length).toLowerCase() === tag.toLowerCase() &amp;&amp;</span>
        <span class="s4">/[\t\r\n\f /&gt;]/</span><span class="s2">.test(source[</span><span class="s4">2 </span><span class="s2">+ tag.length] || </span><span class="s0">'&gt;'</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">hoistStatic(root</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">walk(root</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span>
    <span class="s3">// Root node is unfortunately non-hoistable due to potential parent</span>
    <span class="s3">// fallthrough attributes.</span>
    <span class="s2">isSingleElementRoot(root</span><span class="s1">, </span><span class="s2">root.children[</span><span class="s4">0</span><span class="s2">]))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSingleElementRoot(root</span><span class="s1">, </span><span class="s2">child) {</span>
    <span class="s1">const </span><span class="s2">{ children } = root</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(children.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!isSlotOutlet(child))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">walk(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">doNotHoistNode = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ children } = node</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">originalCount = children.length</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hoistedCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s3">// only plain elements &amp; text calls are eligible for hoisting.</span>
        <span class="s1">if </span><span class="s2">(child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">child.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">constantType = doNotHoistNode</span>
                <span class="s2">? </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span>
                <span class="s2">: getConstantType(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(constantType &gt; </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(constantType &gt;= </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s2">) {</span>
                    <span class="s2">child.codegenNode.patchFlag =</span>
                        <span class="s2">-</span><span class="s4">1 </span><span class="s3">/* PatchFlags.HOISTED */ </span><span class="s2">+ (</span><span class="s0">` /* HOISTED */` </span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">child.codegenNode = context.hoist(child.codegenNode)</span><span class="s1">;</span>
                    <span class="s2">hoistedCount++</span><span class="s1">;</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// node may contain dynamic children, but its props may be eligible for</span>
                <span class="s3">// hoisting.</span>
                <span class="s1">const </span><span class="s2">codegenNode = child.codegenNode</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
                    <span class="s1">const </span><span class="s2">flag = getPatchFlag(codegenNode)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">((!flag ||</span>
                        <span class="s2">flag === </span><span class="s4">512 </span><span class="s3">/* PatchFlags.NEED_PATCH */ </span><span class="s2">||</span>
                        <span class="s2">flag === </span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s2">) &amp;&amp;</span>
                        <span class="s2">getGeneratedPropsConstantType(child</span><span class="s1">, </span><span class="s2">context) &gt;=</span>
                            <span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s2">) {</span>
                        <span class="s1">const </span><span class="s2">props = getNodeProps(child)</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(props) {</span>
                            <span class="s2">codegenNode.props = context.hoist(props)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(codegenNode.dynamicProps) {</span>
                        <span class="s2">codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// walk further</span>
        <span class="s1">if </span><span class="s2">(child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">isComponent = child.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isComponent) {</span>
                <span class="s2">context.scopes.vSlot++</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">walk(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isComponent) {</span>
                <span class="s2">context.scopes.vSlot--</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(child.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">) {</span>
            <span class="s3">// Do not hoist v-for single child because it has to be a block</span>
            <span class="s2">walk(child</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">child.children.length === </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(child.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; child.branches.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s3">// Do not hoist v-if single child because it has to be a block</span>
                <span class="s2">walk(child.branches[i]</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">child.branches[i].children.length === </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(hoistedCount &amp;&amp; context.transformHoist) {</span>
        <span class="s2">context.transformHoist(children</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// all children were hoisted - the entire children array is hoistable.</span>
    <span class="s1">if </span><span class="s2">(hoistedCount &amp;&amp;</span>
        <span class="s2">hoistedCount === originalCount &amp;&amp;</span>
        <span class="s2">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">node.codegenNode &amp;&amp;</span>
        <span class="s2">node.codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">shared.isArray(node.codegenNode.children)) {</span>
        <span class="s2">node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getConstantType(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ constantCache } = context</span><span class="s1">;</span>
    <span class="s1">switch </span><span class="s2">(node.type) {</span>
        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(node.tagType !== </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">cached = constantCache.get(node)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(cached !== undefined) {</span>
                <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">codegenNode = node.codegenNode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(codegenNode.type !== </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(codegenNode.isBlock &amp;&amp;</span>
                <span class="s2">node.tag !== </span><span class="s0">'svg' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">node.tag !== </span><span class="s0">'foreignObject'</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">flag = getPatchFlag(codegenNode)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!flag) {</span>
                <span class="s1">let </span><span class="s2">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
                <span class="s3">// Element itself has no patch flag. However we still need to check:</span>
                <span class="s3">// 1. Even for a node with no patch flag, it is possible for it to contain</span>
                <span class="s3">// non-hoistable expressions that refers to scope variables, e.g. compiler</span>
                <span class="s3">// injected keys or cached event handlers. Therefore we need to always</span>
                <span class="s3">// check the codegenNode's props to be sure.</span>
                <span class="s1">const </span><span class="s2">generatedPropsType = getGeneratedPropsConstantType(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(generatedPropsType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                    <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(generatedPropsType &lt; returnType) {</span>
                    <span class="s2">returnType = generatedPropsType</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// 2. its children.</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">const </span><span class="s2">childType = getConstantType(node.children[i]</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(childType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                        <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(childType &lt; returnType) {</span>
                        <span class="s2">returnType = childType</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s3">// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
                <span class="s3">// type, check if any of the props can cause the type to be lowered</span>
                <span class="s3">// we can skip can_patch because it's guaranteed by the absence of a</span>
                <span class="s3">// patchFlag.</span>
                <span class="s1">if </span><span class="s2">(returnType &gt; </span><span class="s4">1 </span><span class="s3">/* ConstantTypes.CAN_SKIP_PATCH */</span><span class="s2">) {</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp; p.exp) {</span>
                            <span class="s1">const </span><span class="s2">expType = getConstantType(p.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                            <span class="s1">if </span><span class="s2">(expType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                                <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">)</span><span class="s1">;</span>
                                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
                            <span class="s2">}</span>
                            <span class="s1">if </span><span class="s2">(expType &lt; returnType) {</span>
                                <span class="s2">returnType = expType</span><span class="s1">;</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s3">// only svg/foreignObject could be block here, however if they are</span>
                <span class="s3">// static then they don't need to be blocks since there will be no</span>
                <span class="s3">// nested updates.</span>
                <span class="s1">if </span><span class="s2">(codegenNode.isBlock) {</span>
                    <span class="s3">// except set custom directives.</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s2">) {</span>
                            <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">)</span><span class="s1">;</span>
                            <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s2">context.removeHelper(OPEN_BLOCK)</span><span class="s1">;</span>
                    <span class="s2">context.removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s1">, </span><span class="s2">codegenNode.isComponent))</span><span class="s1">;</span>
                    <span class="s2">codegenNode.isBlock = </span><span class="s1">false;</span>
                    <span class="s2">context.helper(getVNodeHelper(context.inSSR</span><span class="s1">, </span><span class="s2">codegenNode.isComponent))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s2">returnType)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">returnType</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">constantCache.set(node</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">getConstantType(node.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">node.constType</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">:</span>
            <span class="s1">let </span><span class="s2">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">child = node.children[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(shared.isString(child) || shared.isSymbol(child)) {</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">childType = getConstantType(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(childType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(childType &lt; returnType) {</span>
                    <span class="s2">returnType = childType</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">returnType</span><span class="s1">;</span>
        <span class="s1">default</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">allowHoistedHelperSet = </span><span class="s1">new </span><span class="s2">Set([</span>
    <span class="s2">NORMALIZE_CLASS</span><span class="s1">,</span>
    <span class="s2">NORMALIZE_STYLE</span><span class="s1">,</span>
    <span class="s2">NORMALIZE_PROPS</span><span class="s1">,</span>
    <span class="s2">GUARD_REACTIVE_PROPS</span>
<span class="s2">])</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getConstantTypeOfHelperCall(value</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(value.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!shared.isString(value.callee) &amp;&amp;</span>
        <span class="s2">allowHoistedHelperSet.has(value.callee)) {</span>
        <span class="s1">const </span><span class="s2">arg = value.arguments[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">getConstantType(arg</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(arg.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s3">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
            <span class="s1">return </span><span class="s2">getConstantTypeOfHelperCall(arg</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getGeneratedPropsConstantType(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">let </span><span class="s2">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">props = getNodeProps(node)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(props &amp;&amp; props.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">{ properties } = props</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; properties.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">{ key</span><span class="s1">, </span><span class="s2">value } = properties[i]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">keyType = getConstantType(key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(keyType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s2">keyType</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(keyType &lt; returnType) {</span>
                <span class="s2">returnType = keyType</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">valueType</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
                <span class="s2">valueType = getConstantType(value</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(value.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">) {</span>
                <span class="s3">// some helper calls can be hoisted,</span>
                <span class="s3">// such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
                <span class="s3">// in this case we need to respect the ConstantType of the helper's arguments</span>
                <span class="s2">valueType = getConstantTypeOfHelperCall(value</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">valueType = </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(valueType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s2">valueType</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(valueType &lt; returnType) {</span>
                <span class="s2">returnType = valueType</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">returnType</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getNodeProps(node) {</span>
    <span class="s1">const </span><span class="s2">codegenNode = node.codegenNode</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">codegenNode.props</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getPatchFlag(node) {</span>
    <span class="s1">const </span><span class="s2">flag = node.patchFlag</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">flag ? parseInt(flag</span><span class="s1">, </span><span class="s4">10</span><span class="s2">) : undefined</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">createTransformContext(root</span><span class="s1">, </span><span class="s2">{ filename = </span><span class="s0">''</span><span class="s1">, </span><span class="s2">prefixIdentifiers = </span><span class="s1">false, </span><span class="s2">hoistStatic = </span><span class="s1">false, </span><span class="s2">cacheHandlers = </span><span class="s1">false, </span><span class="s2">nodeTransforms = []</span><span class="s1">, </span><span class="s2">directiveTransforms = {}</span><span class="s1">, </span><span class="s2">transformHoist = </span><span class="s1">null, </span><span class="s2">isBuiltInComponent = shared.NOOP</span><span class="s1">, </span><span class="s2">isCustomElement = shared.NOOP</span><span class="s1">, </span><span class="s2">expressionPlugins = []</span><span class="s1">, </span><span class="s2">scopeId = </span><span class="s1">null, </span><span class="s2">slotted = </span><span class="s1">true, </span><span class="s2">ssr = </span><span class="s1">false, </span><span class="s2">inSSR = </span><span class="s1">false, </span><span class="s2">ssrCssVars = </span><span class="s0">``</span><span class="s1">, </span><span class="s2">bindingMetadata = shared.EMPTY_OBJ</span><span class="s1">, </span><span class="s2">inline = </span><span class="s1">false, </span><span class="s2">isTS = </span><span class="s1">false, </span><span class="s2">onError = defaultOnError</span><span class="s1">, </span><span class="s2">onWarn = defaultOnWarn</span><span class="s1">, </span><span class="s2">compatConfig }) {</span>
    <span class="s1">const </span><span class="s2">nameMatch = filename.replace(</span><span class="s4">/\?.*$/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">).match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">context = {</span>
        <span class="s3">// options</span>
        <span class="s2">selfName: nameMatch &amp;&amp; shared.capitalize(shared.camelize(nameMatch[</span><span class="s4">1</span><span class="s2">]))</span><span class="s1">,</span>
        <span class="s2">prefixIdentifiers</span><span class="s1">,</span>
        <span class="s2">hoistStatic</span><span class="s1">,</span>
        <span class="s2">cacheHandlers</span><span class="s1">,</span>
        <span class="s2">nodeTransforms</span><span class="s1">,</span>
        <span class="s2">directiveTransforms</span><span class="s1">,</span>
        <span class="s2">transformHoist</span><span class="s1">,</span>
        <span class="s2">isBuiltInComponent</span><span class="s1">,</span>
        <span class="s2">isCustomElement</span><span class="s1">,</span>
        <span class="s2">expressionPlugins</span><span class="s1">,</span>
        <span class="s2">scopeId</span><span class="s1">,</span>
        <span class="s2">slotted</span><span class="s1">,</span>
        <span class="s2">ssr</span><span class="s1">,</span>
        <span class="s2">inSSR</span><span class="s1">,</span>
        <span class="s2">ssrCssVars</span><span class="s1">,</span>
        <span class="s2">bindingMetadata</span><span class="s1">,</span>
        <span class="s2">inline</span><span class="s1">,</span>
        <span class="s2">isTS</span><span class="s1">,</span>
        <span class="s2">onError</span><span class="s1">,</span>
        <span class="s2">onWarn</span><span class="s1">,</span>
        <span class="s2">compatConfig</span><span class="s1">,</span>
        <span class="s3">// state</span>
        <span class="s2">root</span><span class="s1">,</span>
        <span class="s2">helpers: </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">,</span>
        <span class="s2">components: </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">,</span>
        <span class="s2">directives: </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">,</span>
        <span class="s2">hoists: []</span><span class="s1">,</span>
        <span class="s2">imports: []</span><span class="s1">,</span>
        <span class="s2">constantCache: </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">,</span>
        <span class="s2">temps: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">cached: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">identifiers: Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">scopes: {</span>
            <span class="s2">vFor: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s2">vSlot: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s2">vPre: </span><span class="s4">0</span><span class="s1">,</span>
            <span class="s2">vOnce: </span><span class="s4">0</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">parent: </span><span class="s1">null,</span>
        <span class="s2">currentNode: root</span><span class="s1">,</span>
        <span class="s2">childIndex: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">inVOnce: </span><span class="s1">false,</span>
        <span class="s3">// methods</span>
        <span class="s2">helper(name) {</span>
            <span class="s1">const </span><span class="s2">count = context.helpers.get(name) || </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">context.helpers.set(name</span><span class="s1">, </span><span class="s2">count + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">name</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">removeHelper(name) {</span>
            <span class="s1">const </span><span class="s2">count = context.helpers.get(name)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(count) {</span>
                <span class="s1">const </span><span class="s2">currentCount = count - </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(!currentCount) {</span>
                    <span class="s2">context.helpers.delete(name)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">context.helpers.set(name</span><span class="s1">, </span><span class="s2">currentCount)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">helperString(name) {</span>
            <span class="s1">return </span><span class="s0">`_</span><span class="s2">${helperNameMap[context.helper(name)]}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">replaceNode(node) {</span>
            <span class="s3">/* istanbul ignore if */</span>
            <span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(!context.currentNode) {</span>
                    <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`Node being replaced is already removed.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!context.parent) {</span>
                    <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`Cannot replace root node.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">context.parent.children[context.childIndex] = context.currentNode = node</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">removeNode(node) {</span>
            <span class="s1">if </span><span class="s2">(!context.parent) {</span>
                <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`Cannot remove root node.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">list = context.parent.children</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">removalIndex = node</span>
                <span class="s2">? list.indexOf(node)</span>
                <span class="s2">: context.currentNode</span>
                    <span class="s2">? context.childIndex</span>
                    <span class="s2">: -</span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">/* istanbul ignore if */</span>
            <span class="s1">if </span><span class="s2">(removalIndex &lt; </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`node being removed is not a child of current parent`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(!node || node === context.currentNode) {</span>
                <span class="s3">// current node removed</span>
                <span class="s2">context.currentNode = </span><span class="s1">null;</span>
                <span class="s2">context.onNodeRemoved()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// sibling node removed</span>
                <span class="s1">if </span><span class="s2">(context.childIndex &gt; removalIndex) {</span>
                    <span class="s2">context.childIndex--</span><span class="s1">;</span>
                    <span class="s2">context.onNodeRemoved()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">context.parent.children.splice(removalIndex</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">onNodeRemoved: () =&gt; { }</span><span class="s1">,</span>
        <span class="s2">addIdentifiers(exp) {</span>
            <span class="s3">// identifier tracking only happens in non-browser builds.</span>
            <span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(shared.isString(exp)) {</span>
                    <span class="s2">addId(exp)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(exp.identifiers) {</span>
                    <span class="s2">exp.identifiers.forEach(addId)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
                    <span class="s2">addId(exp.content)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">removeIdentifiers(exp) {</span>
            <span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(shared.isString(exp)) {</span>
                    <span class="s2">removeId(exp)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(exp.identifiers) {</span>
                    <span class="s2">exp.identifiers.forEach(removeId)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
                    <span class="s2">removeId(exp.content)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">hoist(exp) {</span>
            <span class="s1">if </span><span class="s2">(shared.isString(exp))</span>
                <span class="s2">exp = createSimpleExpression(exp)</span><span class="s1">;</span>
            <span class="s2">context.hoists.push(exp)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">identifier = createSimpleExpression(</span><span class="s0">`_hoisted_</span><span class="s2">${context.hoists.length}</span><span class="s0">`</span><span class="s1">, false, </span><span class="s2">exp.loc</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">identifier.hoisted = exp</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">identifier</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">cache(exp</span><span class="s1">, </span><span class="s2">isVNode = </span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">createCacheExpression(context.cached++</span><span class="s1">, </span><span class="s2">exp</span><span class="s1">, </span><span class="s2">isVNode)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">context.filters = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">addId(id) {</span>
        <span class="s1">const </span><span class="s2">{ identifiers } = context</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(identifiers[id] === undefined) {</span>
            <span class="s2">identifiers[id] = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">identifiers[id]++</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">removeId(id) {</span>
        <span class="s2">context.identifiers[id]--</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">context</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">transform(root</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">const </span><span class="s2">context = createTransformContext(root</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s2">traverseNode(root</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(options.hoistStatic) {</span>
        <span class="s2">hoistStatic(root</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!options.ssr) {</span>
        <span class="s2">createRootCodegen(root</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// finalize meta information</span>
    <span class="s2">root.helpers = </span><span class="s1">new </span><span class="s2">Set([...context.helpers.keys()])</span><span class="s1">;</span>
    <span class="s2">root.components = [...context.components]</span><span class="s1">;</span>
    <span class="s2">root.directives = [...context.directives]</span><span class="s1">;</span>
    <span class="s2">root.imports = context.imports</span><span class="s1">;</span>
    <span class="s2">root.hoists = context.hoists</span><span class="s1">;</span>
    <span class="s2">root.temps = context.temps</span><span class="s1">;</span>
    <span class="s2">root.cached = context.cached</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">root.filters = [...context.filters]</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createRootCodegen(root</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ helper } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ children } = root</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(children.length === </span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">child = children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s3">// if the single child is an element, turn it into a block.</span>
        <span class="s1">if </span><span class="s2">(isSingleElementRoot(root</span><span class="s1">, </span><span class="s2">child) &amp;&amp; child.codegenNode) {</span>
            <span class="s3">// single element root is never hoisted so codegenNode will never be</span>
            <span class="s3">// SimpleExpressionNode</span>
            <span class="s1">const </span><span class="s2">codegenNode = child.codegenNode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
                <span class="s2">makeBlock(codegenNode</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">root.codegenNode = codegenNode</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// - single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
            <span class="s3">// - single text node: always patched.</span>
            <span class="s3">// root codegen falls through via genNode()</span>
            <span class="s2">root.codegenNode = child</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(children.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s3">// root has multiple nodes - return a fragment block.</span>
        <span class="s1">let </span><span class="s2">patchFlag = </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">patchFlagText = shared.PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s3">// check if the fragment actually contains a single valid child with</span>
        <span class="s3">// the rest being comments</span>
        <span class="s1">if </span><span class="s2">(children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">).length === </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">patchFlag |= </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">;</span>
            <span class="s2">patchFlagText += </span><span class="s0">`, </span><span class="s2">${shared.PatchFlagNames[</span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">]}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">root.codegenNode = createVNodeCall(context</span><span class="s1">, </span><span class="s2">helper(FRAGMENT)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">root.children</span><span class="s1">, </span><span class="s2">patchFlag + (</span><span class="s0">` /* </span><span class="s2">${patchFlagText} </span><span class="s0">*/` </span><span class="s2">)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, true, </span><span class="s2">undefined</span><span class="s1">, false </span><span class="s3">/* isComponent */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else ;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">traverseChildren(parent</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">nodeRemoved = () =&gt; {</span>
        <span class="s2">i--</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">; </span><span class="s2">i &lt; parent.children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = parent.children[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isString(child))</span>
            <span class="s1">continue;</span>
        <span class="s2">context.parent = parent</span><span class="s1">;</span>
        <span class="s2">context.childIndex = i</span><span class="s1">;</span>
        <span class="s2">context.onNodeRemoved = nodeRemoved</span><span class="s1">;</span>
        <span class="s2">traverseNode(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">traverseNode(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">context.currentNode = node</span><span class="s1">;</span>
    <span class="s3">// apply transform plugins</span>
    <span class="s1">const </span><span class="s2">{ nodeTransforms } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">exitFns = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; nodeTransforms.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">onExit = nodeTransforms[i](node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(onExit) {</span>
            <span class="s1">if </span><span class="s2">(shared.isArray(onExit)) {</span>
                <span class="s2">exitFns.push(...onExit)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">exitFns.push(onExit)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!context.currentNode) {</span>
            <span class="s3">// node was removed</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// node may have been replaced</span>
            <span class="s2">node = context.currentNode</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">switch </span><span class="s2">(node.type) {</span>
        <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(!context.ssr) {</span>
                <span class="s3">// inject import for the Comment symbol, which is needed for creating</span>
                <span class="s3">// comment nodes with `createVNode`</span>
                <span class="s2">context.helper(CREATE_COMMENT)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">:</span>
            <span class="s3">// no need to traverse, but we need to inject toString helper</span>
            <span class="s1">if </span><span class="s2">(!context.ssr) {</span>
                <span class="s2">context.helper(TO_DISPLAY_STRING)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s3">// for container types, further traverse downwards</span>
        <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">:</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.branches.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">traverseNode(node.branches[i]</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */</span><span class="s2">:</span>
            <span class="s2">traverseChildren(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s3">// exit transforms</span>
    <span class="s2">context.currentNode = node</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">i = exitFns.length</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(i--) {</span>
        <span class="s2">exitFns[i]()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createStructuralDirectiveTransform(name</span><span class="s1">, </span><span class="s2">fn) {</span>
    <span class="s1">const </span><span class="s2">matches = shared.isString(name)</span>
        <span class="s2">? (n) =&gt; n === name</span>
        <span class="s2">: (n) =&gt; name.test(n)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">{ props } = node</span><span class="s1">;</span>
            <span class="s3">// structural directive transforms are not concerned with slots</span>
            <span class="s3">// as they are handled separately in vSlot.ts</span>
            <span class="s1">if </span><span class="s2">(node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */ </span><span class="s2">&amp;&amp; props.some(isVSlot)) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">exitFns = []</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">prop = props[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prop.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; matches(prop.name)) {</span>
                    <span class="s3">// structural directives are removed to avoid infinite recursion</span>
                    <span class="s3">// also we remove them *before* applying so that it can further</span>
                    <span class="s3">// traverse itself in case it moves the node around</span>
                    <span class="s2">props.splice(i</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">i--</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">onExit = fn(node</span><span class="s1">, </span><span class="s2">prop</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(onExit)</span>
                        <span class="s2">exitFns.push(onExit)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">exitFns</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">PURE_ANNOTATION = </span><span class="s0">`/*#__PURE__*/`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">aliasHelper = (s) =&gt; </span><span class="s0">`</span><span class="s2">${helperNameMap[s]}</span><span class="s0">: _</span><span class="s2">${helperNameMap[s]}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createCodegenContext(ast</span><span class="s1">, </span><span class="s2">{ mode = </span><span class="s0">'function'</span><span class="s1">, </span><span class="s2">prefixIdentifiers = mode === </span><span class="s0">'module'</span><span class="s1">, </span><span class="s2">sourceMap: sourceMap$1 = </span><span class="s1">false, </span><span class="s2">filename = </span><span class="s0">`template.vue.html`</span><span class="s1">, </span><span class="s2">scopeId = </span><span class="s1">null, </span><span class="s2">optimizeImports = </span><span class="s1">false, </span><span class="s2">runtimeGlobalName = </span><span class="s0">`Vue`</span><span class="s1">, </span><span class="s2">runtimeModuleName = </span><span class="s0">`vue`</span><span class="s1">, </span><span class="s2">ssrRuntimeModuleName = </span><span class="s0">'vue/server-renderer'</span><span class="s1">, </span><span class="s2">ssr = </span><span class="s1">false, </span><span class="s2">isTS = </span><span class="s1">false, </span><span class="s2">inSSR = </span><span class="s1">false </span><span class="s2">}) {</span>
    <span class="s1">const </span><span class="s2">context = {</span>
        <span class="s2">mode</span><span class="s1">,</span>
        <span class="s2">prefixIdentifiers</span><span class="s1">,</span>
        <span class="s2">sourceMap: sourceMap$1</span><span class="s1">,</span>
        <span class="s2">filename</span><span class="s1">,</span>
        <span class="s2">scopeId</span><span class="s1">,</span>
        <span class="s2">optimizeImports</span><span class="s1">,</span>
        <span class="s2">runtimeGlobalName</span><span class="s1">,</span>
        <span class="s2">runtimeModuleName</span><span class="s1">,</span>
        <span class="s2">ssrRuntimeModuleName</span><span class="s1">,</span>
        <span class="s2">ssr</span><span class="s1">,</span>
        <span class="s2">isTS</span><span class="s1">,</span>
        <span class="s2">inSSR</span><span class="s1">,</span>
        <span class="s2">source: ast.loc.source</span><span class="s1">,</span>
        <span class="s2">code: </span><span class="s0">``</span><span class="s1">,</span>
        <span class="s2">column: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s2">line: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s2">offset: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">indentLevel: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">pure: </span><span class="s1">false,</span>
        <span class="s2">map: undefined</span><span class="s1">,</span>
        <span class="s2">helper(key) {</span>
            <span class="s1">return </span><span class="s0">`_</span><span class="s2">${helperNameMap[key]}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">push(code</span><span class="s1">, </span><span class="s2">node) {</span>
            <span class="s2">context.code += code</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(context.map) {</span>
                <span class="s1">if </span><span class="s2">(node) {</span>
                    <span class="s1">let </span><span class="s2">name</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp; !node.isStatic) {</span>
                        <span class="s1">const </span><span class="s2">content = node.content.replace(</span><span class="s4">/^_ctx\./</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(content !== node.content &amp;&amp; isSimpleIdentifier(content)) {</span>
                            <span class="s2">name = content</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s2">addMapping(node.loc.start</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">advancePositionWithMutation(context</span><span class="s1">, </span><span class="s2">code)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(node &amp;&amp; node.loc !== locStub) {</span>
                    <span class="s2">addMapping(node.loc.end)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">indent() {</span>
            <span class="s2">newline(++context.indentLevel)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">deindent(withoutNewLine = </span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(withoutNewLine) {</span>
                <span class="s2">--context.indentLevel</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">newline(--context.indentLevel)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">newline() {</span>
            <span class="s2">newline(context.indentLevel)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">function </span><span class="s2">newline(n) {</span>
        <span class="s2">context.push(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ </span><span class="s0">`  `</span><span class="s2">.repeat(n))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">addMapping(loc</span><span class="s1">, </span><span class="s2">name) {</span>
        <span class="s2">context.map.addMapping({</span>
            <span class="s2">name</span><span class="s1">,</span>
            <span class="s2">source: context.filename</span><span class="s1">,</span>
            <span class="s2">original: {</span>
                <span class="s2">line: loc.line</span><span class="s1">,</span>
                <span class="s2">column: loc.column - </span><span class="s4">1 </span><span class="s3">// source-map column is 0 based</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">generated: {</span>
                <span class="s2">line: context.line</span><span class="s1">,</span>
                <span class="s2">column: context.column - </span><span class="s4">1</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(sourceMap$1) {</span>
        <span class="s3">// lazy require source-map implementation, only in non-browser builds</span>
        <span class="s2">context.map = </span><span class="s1">new </span><span class="s2">sourceMap.SourceMapGenerator()</span><span class="s1">;</span>
        <span class="s2">context.map.setSourceContent(filename</span><span class="s1">, </span><span class="s2">context.source)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">context</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">generate(ast</span><span class="s1">, </span><span class="s2">options = {}) {</span>
    <span class="s1">const </span><span class="s2">context = createCodegenContext(ast</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(options.onContextCreated)</span>
        <span class="s2">options.onContextCreated(context)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ mode</span><span class="s1">, </span><span class="s2">push</span><span class="s1">, </span><span class="s2">prefixIdentifiers</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">scopeId</span><span class="s1">, </span><span class="s2">ssr } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">helpers = Array.from(ast.helpers)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hasHelpers = helpers.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">useWithBlock = !prefixIdentifiers &amp;&amp; mode !== </span><span class="s0">'module'</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">genScopeId = scopeId != </span><span class="s1">null </span><span class="s2">&amp;&amp; mode === </span><span class="s0">'module'</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isSetupInlined = !!options.inline</span><span class="s1">;</span>
    <span class="s3">// preambles</span>
    <span class="s3">// in setup() inline mode, the preamble is generated in a sub context</span>
    <span class="s3">// and returned separately.</span>
    <span class="s1">const </span><span class="s2">preambleContext = isSetupInlined</span>
        <span class="s2">? createCodegenContext(ast</span><span class="s1">, </span><span class="s2">options)</span>
        <span class="s2">: context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(mode === </span><span class="s0">'module'</span><span class="s2">) {</span>
        <span class="s2">genModulePreamble(ast</span><span class="s1">, </span><span class="s2">preambleContext</span><span class="s1">, </span><span class="s2">genScopeId</span><span class="s1">, </span><span class="s2">isSetupInlined)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">genFunctionPreamble(ast</span><span class="s1">, </span><span class="s2">preambleContext)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// enter render function</span>
    <span class="s1">const </span><span class="s2">functionName = ssr ? </span><span class="s0">`ssrRender` </span><span class="s2">: </span><span class="s0">`render`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">args = ssr ? [</span><span class="s0">'_ctx'</span><span class="s1">, </span><span class="s0">'_push'</span><span class="s1">, </span><span class="s0">'_parent'</span><span class="s1">, </span><span class="s0">'_attrs'</span><span class="s2">] : [</span><span class="s0">'_ctx'</span><span class="s1">, </span><span class="s0">'_cache'</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(options.bindingMetadata &amp;&amp; !options.inline) {</span>
        <span class="s3">// binding optimization args</span>
        <span class="s2">args.push(</span><span class="s0">'$props'</span><span class="s1">, </span><span class="s0">'$setup'</span><span class="s1">, </span><span class="s0">'$data'</span><span class="s1">, </span><span class="s0">'$options'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">signature = options.isTS</span>
        <span class="s2">? args.map(arg =&gt; </span><span class="s0">`</span><span class="s2">${arg}</span><span class="s0">: any`</span><span class="s2">).join(</span><span class="s0">','</span><span class="s2">)</span>
        <span class="s2">: args.join(</span><span class="s0">', '</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isSetupInlined) {</span>
        <span class="s2">push(</span><span class="s0">`(</span><span class="s2">${signature}</span><span class="s0">) =&gt; {`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">push(</span><span class="s0">`function </span><span class="s2">${functionName}</span><span class="s0">(</span><span class="s2">${signature}</span><span class="s0">) {`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">indent()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(useWithBlock) {</span>
        <span class="s2">push(</span><span class="s0">`with (_ctx) {`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">indent()</span><span class="s1">;</span>
        <span class="s3">// function mode const declarations should be inside with block</span>
        <span class="s3">// also they should be renamed to avoid collision with user properties</span>
        <span class="s1">if </span><span class="s2">(hasHelpers) {</span>
            <span class="s2">push(</span><span class="s0">`const { </span><span class="s2">${helpers.map(aliasHelper).join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} = _Vue`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">push(</span><span class="s0">`</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// generate asset resolution statements</span>
    <span class="s1">if </span><span class="s2">(ast.components.length) {</span>
        <span class="s2">genAssets(ast.components</span><span class="s1">, </span><span class="s0">'component'</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(ast.directives.length || ast.temps &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.directives.length) {</span>
        <span class="s2">genAssets(ast.directives</span><span class="s1">, </span><span class="s0">'directive'</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(ast.temps &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.filters &amp;&amp; ast.filters.length) {</span>
        <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">genAssets(ast.filters</span><span class="s1">, </span><span class="s0">'filter'</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.temps &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">push(</span><span class="s0">`let `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; ast.temps</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">push(</span><span class="s0">`</span><span class="s2">${i &gt; </span><span class="s4">0 </span><span class="s2">? </span><span class="s0">`, ` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">_temp</span><span class="s2">${i}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.components.length || ast.directives.length || ast.temps) {</span>
        <span class="s2">push(</span><span class="s0">`</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// generate the VNode tree expression</span>
    <span class="s1">if </span><span class="s2">(!ssr) {</span>
        <span class="s2">push(</span><span class="s0">`return `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.codegenNode) {</span>
        <span class="s2">genNode(ast.codegenNode</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">push(</span><span class="s0">`null`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(useWithBlock) {</span>
        <span class="s2">deindent()</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`}`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">deindent()</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`}`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">ast</span><span class="s1">,</span>
        <span class="s2">code: context.code</span><span class="s1">,</span>
        <span class="s2">preamble: isSetupInlined ? preambleContext.code : </span><span class="s0">``</span><span class="s1">,</span>
        <span class="s3">// SourceMapGenerator does have toJSON() method but it's not in the types</span>
        <span class="s2">map: context.map ? context.map.toJSON() : undefined</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genFunctionPreamble(ast</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ ssr</span><span class="s1">, </span><span class="s2">prefixIdentifiers</span><span class="s1">, </span><span class="s2">push</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">runtimeModuleName</span><span class="s1">, </span><span class="s2">runtimeGlobalName</span><span class="s1">, </span><span class="s2">ssrRuntimeModuleName } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">VueBinding = ssr</span>
        <span class="s2">? </span><span class="s0">`require(</span><span class="s2">${JSON.stringify(runtimeModuleName)}</span><span class="s0">)`</span>
        <span class="s2">: runtimeGlobalName</span><span class="s1">;</span>
    <span class="s3">// Generate const declaration for helpers</span>
    <span class="s3">// In prefix mode, we place the const declaration at top so it's done</span>
    <span class="s3">// only once; But if we not prefixing, we place the declaration inside the</span>
    <span class="s3">// with block so it doesn't incur the `in` check cost for every helper access.</span>
    <span class="s1">const </span><span class="s2">helpers = Array.from(ast.helpers)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(helpers.length &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(prefixIdentifiers) {</span>
            <span class="s2">push(</span><span class="s0">`const { </span><span class="s2">${helpers.map(aliasHelper).join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} = </span><span class="s2">${VueBinding}</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// &quot;with&quot; mode.</span>
            <span class="s3">// save Vue in a separate variable to avoid collision</span>
            <span class="s2">push(</span><span class="s0">`const _Vue = </span><span class="s2">${VueBinding}</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s3">// in &quot;with&quot; mode, helpers are declared inside the with block to avoid</span>
            <span class="s3">// has check cost, but hoists are lifted out of the function - we need</span>
            <span class="s3">// to provide the helper here.</span>
            <span class="s1">if </span><span class="s2">(ast.hoists.length) {</span>
                <span class="s1">const </span><span class="s2">staticHelpers = [</span>
                    <span class="s2">CREATE_VNODE</span><span class="s1">,</span>
                    <span class="s2">CREATE_ELEMENT_VNODE</span><span class="s1">,</span>
                    <span class="s2">CREATE_COMMENT</span><span class="s1">,</span>
                    <span class="s2">CREATE_TEXT</span><span class="s1">,</span>
                    <span class="s2">CREATE_STATIC</span>
                <span class="s2">]</span>
                    <span class="s2">.filter(helper =&gt; helpers.includes(helper))</span>
                    <span class="s2">.map(aliasHelper)</span>
                    <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">push(</span><span class="s0">`const { </span><span class="s2">${staticHelpers} </span><span class="s0">} = _Vue</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// generate variables for ssr helpers</span>
    <span class="s1">if </span><span class="s2">(ast.ssrHelpers &amp;&amp; ast.ssrHelpers.length) {</span>
        <span class="s3">// ssr guarantees prefixIdentifier: true</span>
        <span class="s2">push(</span><span class="s0">`const { </span><span class="s2">${ast.ssrHelpers</span>
            <span class="s2">.map(aliasHelper)</span>
            <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} = require(&quot;</span><span class="s2">${ssrRuntimeModuleName}</span><span class="s0">&quot;)</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">genHoists(ast.hoists</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`return `</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genModulePreamble(ast</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">genScopeId</span><span class="s1">, </span><span class="s2">inline) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">optimizeImports</span><span class="s1">, </span><span class="s2">runtimeModuleName</span><span class="s1">, </span><span class="s2">ssrRuntimeModuleName } = context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(genScopeId &amp;&amp; ast.hoists.length) {</span>
        <span class="s2">ast.helpers.add(PUSH_SCOPE_ID)</span><span class="s1">;</span>
        <span class="s2">ast.helpers.add(POP_SCOPE_ID)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// generate import statements for helpers</span>
    <span class="s1">if </span><span class="s2">(ast.helpers.size) {</span>
        <span class="s1">const </span><span class="s2">helpers = Array.from(ast.helpers)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(optimizeImports) {</span>
            <span class="s3">// when bundled with webpack with code-split, calling an import binding</span>
            <span class="s3">// as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,</span>
            <span class="s3">// incurring both payload size increase and potential perf overhead.</span>
            <span class="s3">// therefore we assign the imports to variables (which is a constant ~50b</span>
            <span class="s3">// cost per-component instead of scaling with template size)</span>
            <span class="s2">push(</span><span class="s0">`import { </span><span class="s2">${helpers</span>
                <span class="s2">.map(s =&gt; helperNameMap[s])</span>
                <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} from </span><span class="s2">${JSON.stringify(runtimeModuleName)}</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">push(</span><span class="s0">`</span><span class="s1">\n</span><span class="s0">// Binding optimization for webpack code-split</span><span class="s1">\n</span><span class="s0">const </span><span class="s2">${helpers</span>
                <span class="s2">.map(s =&gt; </span><span class="s0">`_</span><span class="s2">${helperNameMap[s]} </span><span class="s0">= </span><span class="s2">${helperNameMap[s]}</span><span class="s0">`</span><span class="s2">)</span>
                <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)}</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">push(</span><span class="s0">`import { </span><span class="s2">${helpers</span>
                <span class="s2">.map(s =&gt; </span><span class="s0">`</span><span class="s2">${helperNameMap[s]} </span><span class="s0">as _</span><span class="s2">${helperNameMap[s]}</span><span class="s0">`</span><span class="s2">)</span>
                <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} from </span><span class="s2">${JSON.stringify(runtimeModuleName)}</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.ssrHelpers &amp;&amp; ast.ssrHelpers.length) {</span>
        <span class="s2">push(</span><span class="s0">`import { </span><span class="s2">${ast.ssrHelpers</span>
            <span class="s2">.map(s =&gt; </span><span class="s0">`</span><span class="s2">${helperNameMap[s]} </span><span class="s0">as _</span><span class="s2">${helperNameMap[s]}</span><span class="s0">`</span><span class="s2">)</span>
            <span class="s2">.join(</span><span class="s0">', '</span><span class="s2">)} </span><span class="s0">} from &quot;</span><span class="s2">${ssrRuntimeModuleName}</span><span class="s0">&quot;</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(ast.imports.length) {</span>
        <span class="s2">genImports(ast.imports</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">genHoists(ast.hoists</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!inline) {</span>
        <span class="s2">push(</span><span class="s0">`export `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genAssets(assets</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">{ helper</span><span class="s1">, </span><span class="s2">push</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">isTS }) {</span>
    <span class="s1">const </span><span class="s2">resolver = helper(type === </span><span class="s0">'filter'</span>
        <span class="s2">? RESOLVE_FILTER</span>
        <span class="s2">: type === </span><span class="s0">'component'</span>
            <span class="s2">? RESOLVE_COMPONENT</span>
            <span class="s2">: RESOLVE_DIRECTIVE)</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; assets.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">let </span><span class="s2">id = assets[i]</span><span class="s1">;</span>
        <span class="s3">// potential component implicit self-reference inferred from SFC filename</span>
        <span class="s1">const </span><span class="s2">maybeSelfReference = id.endsWith(</span><span class="s0">'__self'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(maybeSelfReference) {</span>
            <span class="s2">id = id.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">-</span><span class="s4">6</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">push(</span><span class="s0">`const </span><span class="s2">${toValidAssetId(id</span><span class="s1">, </span><span class="s2">type)} </span><span class="s0">= </span><span class="s2">${resolver}</span><span class="s0">(</span><span class="s2">${JSON.stringify(id)}${maybeSelfReference ? </span><span class="s0">`, true` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">)</span><span class="s2">${isTS ? </span><span class="s0">`!` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(i &lt; assets.length - </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genHoists(hoists</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(!hoists.length) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s2">context.pure = </span><span class="s1">true;</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">scopeId</span><span class="s1">, </span><span class="s2">mode } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">genScopeId = scopeId != </span><span class="s1">null </span><span class="s2">&amp;&amp; mode !== </span><span class="s0">'function'</span><span class="s1">;</span>
    <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s3">// generate inlined withScopeId helper</span>
    <span class="s1">if </span><span class="s2">(genScopeId) {</span>
        <span class="s2">push(</span><span class="s0">`const _withScopeId = n =&gt; (</span><span class="s2">${helper(PUSH_SCOPE_ID)}</span><span class="s0">(&quot;</span><span class="s2">${scopeId}</span><span class="s0">&quot;),n=n(),</span><span class="s2">${helper(POP_SCOPE_ID)}</span><span class="s0">(),n)`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; hoists.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">exp = hoists[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(exp) {</span>
            <span class="s1">const </span><span class="s2">needScopeIdWrapper = genScopeId &amp;&amp; exp.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">;</span>
            <span class="s2">push(</span><span class="s0">`const _hoisted_</span><span class="s2">${i + </span><span class="s4">1</span><span class="s2">} </span><span class="s0">= </span><span class="s2">${needScopeIdWrapper ? </span><span class="s0">`</span><span class="s2">${PURE_ANNOTATION} </span><span class="s0">_withScopeId(() =&gt; ` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">genNode(exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(needScopeIdWrapper) {</span>
                <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">context.pure = </span><span class="s1">false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genImports(importsOptions</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(!importsOptions.length) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s2">importsOptions.forEach(imports =&gt; {</span>
        <span class="s2">context.push(</span><span class="s0">`import `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">genNode(imports.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">context.push(</span><span class="s0">` from '</span><span class="s2">${imports.path}</span><span class="s0">'`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">context.newline()</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isText(n) {</span>
    <span class="s1">return </span><span class="s2">(shared.isString(n) ||</span>
        <span class="s2">n.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">||</span>
        <span class="s2">n.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s2">||</span>
        <span class="s2">n.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s2">||</span>
        <span class="s2">n.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genNodeListAsArray(nodes</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">multilines = nodes.length &gt; </span><span class="s4">3 </span><span class="s2">||</span>
        <span class="s2">(nodes.some(n =&gt; shared.isArray(n) || !isText(n)))</span><span class="s1">;</span>
    <span class="s2">context.push(</span><span class="s0">`[`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">multilines &amp;&amp; context.indent()</span><span class="s1">;</span>
    <span class="s2">genNodeList(nodes</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">multilines)</span><span class="s1">;</span>
    <span class="s2">multilines &amp;&amp; context.deindent()</span><span class="s1">;</span>
    <span class="s2">context.push(</span><span class="s0">`]`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genNodeList(nodes</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">multilines = </span><span class="s1">false, </span><span class="s2">comma = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">newline } = context</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; nodes.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">node = nodes[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isString(node)) {</span>
            <span class="s2">push(node)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.isArray(node)) {</span>
            <span class="s2">genNodeListAsArray(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">genNode(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(i &lt; nodes.length - </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(multilines) {</span>
                <span class="s2">comma &amp;&amp; push(</span><span class="s0">','</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">newline()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">comma &amp;&amp; push(</span><span class="s0">', '</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genNode(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(shared.isString(node)) {</span>
        <span class="s2">context.push(node)</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isSymbol(node)) {</span>
        <span class="s2">context.push(context.helper(node))</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">switch </span><span class="s2">(node.type) {</span>
        <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">:</span>
            <span class="s2">assert(node.codegenNode != </span><span class="s1">null, </span><span class="s0">`Codegen node is missing for element/if/for node. ` </span><span class="s2">+</span>
                    <span class="s0">`Apply appropriate transforms first.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">genNode(node.codegenNode</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">:</span>
            <span class="s2">genText(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">:</span>
            <span class="s2">genInterpolation(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s2">:</span>
            <span class="s2">genNode(node.codegenNode</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genCompoundExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">:</span>
            <span class="s2">genComment(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">:</span>
            <span class="s2">genVNodeCall(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genCallExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genObjectExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genArrayExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">18 </span><span class="s3">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genFunctionExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genConditionalExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genCacheExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">21 </span><span class="s3">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s2">:</span>
            <span class="s2">genNodeList(node.body</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, true, false</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s3">// SSR only types</span>
        <span class="s1">case </span><span class="s4">22 </span><span class="s3">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s2">:</span>
            <span class="s2">genTemplateLiteral(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">23 </span><span class="s3">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s2">:</span>
            <span class="s2">genIfStatement(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">24 </span><span class="s3">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genAssignmentExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">25 </span><span class="s3">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s2">:</span>
            <span class="s2">genSequenceExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s4">26 </span><span class="s3">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s2">:</span>
            <span class="s2">genReturnStatement(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s3">/* istanbul ignore next */</span>
        <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">:</span>
            <span class="s3">// noop</span>
            <span class="s1">break;</span>
        <span class="s1">default</span><span class="s2">:</span>
            <span class="s2">{</span>
                <span class="s2">assert(</span><span class="s1">false, </span><span class="s0">`unhandled codegen node type: </span><span class="s2">${node.type}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s3">// make sure we exhaust all possible types</span>
                <span class="s1">const </span><span class="s2">exhaustiveCheck = node</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">exhaustiveCheck</span><span class="s1">;</span>
            <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genText(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">context.push(JSON.stringify(node.content)</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ content</span><span class="s1">, </span><span class="s2">isStatic } = node</span><span class="s1">;</span>
    <span class="s2">context.push(isStatic ? JSON.stringify(content) : content</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genInterpolation(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">pure } = context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(pure)</span>
        <span class="s2">push(PURE_ANNOTATION)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`</span><span class="s2">${helper(TO_DISPLAY_STRING)}</span><span class="s0">(`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNode(node.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genCompoundExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = node.children[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isString(child)) {</span>
            <span class="s2">context.push(child)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">genNode(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genExpressionAsPropertyKey(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push } = context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s2">push(</span><span class="s0">`[`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">genCompoundExpression(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`]`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(node.isStatic) {</span>
        <span class="s3">// only quote keys if necessary</span>
        <span class="s1">const </span><span class="s2">text = isSimpleIdentifier(node.content)</span>
            <span class="s2">? node.content</span>
            <span class="s2">: JSON.stringify(node.content)</span><span class="s1">;</span>
        <span class="s2">push(text</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">push(</span><span class="s0">`[</span><span class="s2">${node.content}</span><span class="s0">]`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genComment(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">pure } = context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(pure) {</span>
        <span class="s2">push(PURE_ANNOTATION)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">`</span><span class="s2">${helper(CREATE_COMMENT)}</span><span class="s0">(</span><span class="s2">${JSON.stringify(node.content)}</span><span class="s0">)`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genVNodeCall(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">pure } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ tag</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">directives</span><span class="s1">, </span><span class="s2">isBlock</span><span class="s1">, </span><span class="s2">disableTracking</span><span class="s1">, </span><span class="s2">isComponent } = node</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(directives) {</span>
        <span class="s2">push(helper(WITH_DIRECTIVES) + </span><span class="s0">`(`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isBlock) {</span>
        <span class="s2">push(</span><span class="s0">`(</span><span class="s2">${helper(OPEN_BLOCK)}</span><span class="s0">(</span><span class="s2">${disableTracking ? </span><span class="s0">`true` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">), `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(pure) {</span>
        <span class="s2">push(PURE_ANNOTATION)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">callHelper = isBlock</span>
        <span class="s2">? getVNodeBlockHelper(context.inSSR</span><span class="s1">, </span><span class="s2">isComponent)</span>
        <span class="s2">: getVNodeHelper(context.inSSR</span><span class="s1">, </span><span class="s2">isComponent)</span><span class="s1">;</span>
    <span class="s2">push(helper(callHelper) + </span><span class="s0">`(`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s2">genNodeList(genNullableArgs([tag</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps])</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isBlock) {</span>
        <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(directives) {</span>
        <span class="s2">push(</span><span class="s0">`, `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">genNode(directives</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genNullableArgs(args) {</span>
    <span class="s1">let </span><span class="s2">i = args.length</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(i--) {</span>
        <span class="s1">if </span><span class="s2">(args[i] != </span><span class="s1">null</span><span class="s2">)</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">args.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">i + </span><span class="s4">1</span><span class="s2">).map(arg =&gt; arg || </span><span class="s0">`null`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// JavaScript</span>
<span class="s1">function </span><span class="s2">genCallExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">pure } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">callee = shared.isString(node.callee) ? node.callee : helper(node.callee)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(pure) {</span>
        <span class="s2">push(PURE_ANNOTATION)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(callee + </span><span class="s0">`(`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s2">genNodeList(node.arguments</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genObjectExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent</span><span class="s1">, </span><span class="s2">newline } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ properties } = node</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!properties.length) {</span>
        <span class="s2">push(</span><span class="s0">`{}`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">multilines = properties.length &gt; </span><span class="s4">1 </span><span class="s2">||</span>
        <span class="s2">(properties.some(p =&gt; p.value.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">push(multilines ? </span><span class="s0">`{` </span><span class="s2">: </span><span class="s0">`{ `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">multilines &amp;&amp; indent()</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; properties.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">{ key</span><span class="s1">, </span><span class="s2">value } = properties[i]</span><span class="s1">;</span>
        <span class="s3">// key</span>
        <span class="s2">genExpressionAsPropertyKey(key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`: `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s3">// value</span>
        <span class="s2">genNode(value</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(i &lt; properties.length - </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s3">// will only reach this if it's multilines</span>
            <span class="s2">push(</span><span class="s0">`,`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">multilines &amp;&amp; deindent()</span><span class="s1">;</span>
    <span class="s2">push(multilines ? </span><span class="s0">`}` </span><span class="s2">: </span><span class="s0">` }`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genArrayExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">genNodeListAsArray(node.elements</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genFunctionExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ params</span><span class="s1">, </span><span class="s2">returns</span><span class="s1">, </span><span class="s2">body</span><span class="s1">, </span><span class="s2">newline</span><span class="s1">, </span><span class="s2">isSlot } = node</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isSlot) {</span>
        <span class="s3">// wrap slot functions with owner context</span>
        <span class="s2">push(</span><span class="s0">`_</span><span class="s2">${helperNameMap[WITH_CTX]}</span><span class="s0">(`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">`(`</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(params)) {</span>
        <span class="s2">genNodeList(params</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(params) {</span>
        <span class="s2">genNode(params</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">`) =&gt; `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(newline || body) {</span>
        <span class="s2">push(</span><span class="s0">`{`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">indent()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(returns) {</span>
        <span class="s1">if </span><span class="s2">(newline) {</span>
            <span class="s2">push(</span><span class="s0">`return `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(returns)) {</span>
            <span class="s2">genNodeListAsArray(returns</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">genNode(returns</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(body) {</span>
        <span class="s2">genNode(body</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(newline || body) {</span>
        <span class="s2">deindent()</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`}`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isSlot) {</span>
        <span class="s1">if </span><span class="s2">(node.isNonScopedSlot) {</span>
            <span class="s2">push(</span><span class="s0">`, undefined, true`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genConditionalExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ test</span><span class="s1">, </span><span class="s2">consequent</span><span class="s1">, </span><span class="s2">alternate</span><span class="s1">, </span><span class="s2">newline: needNewline } = node</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent</span><span class="s1">, </span><span class="s2">newline } = context</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(test.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">needsParens = !isSimpleIdentifier(test.content)</span><span class="s1">;</span>
        <span class="s2">needsParens &amp;&amp; push(</span><span class="s0">`(`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">genExpression(test</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">needsParens &amp;&amp; push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">push(</span><span class="s0">`(`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">genNode(test</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">needNewline &amp;&amp; indent()</span><span class="s1">;</span>
    <span class="s2">context.indentLevel++</span><span class="s1">;</span>
    <span class="s2">needNewline || push(</span><span class="s0">` `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`? `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNode(consequent</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">context.indentLevel--</span><span class="s1">;</span>
    <span class="s2">needNewline &amp;&amp; newline()</span><span class="s1">;</span>
    <span class="s2">needNewline || push(</span><span class="s0">` `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`: `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isNested = alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!isNested) {</span>
        <span class="s2">context.indentLevel++</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">genNode(alternate</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!isNested) {</span>
        <span class="s2">context.indentLevel--</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">needNewline &amp;&amp; deindent(</span><span class="s1">true </span><span class="s3">/* without newline */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genCacheExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">helper</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent</span><span class="s1">, </span><span class="s2">newline } = context</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`_cache[</span><span class="s2">${node.index}</span><span class="s0">] || (`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(node.isVNode) {</span>
        <span class="s2">indent()</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`</span><span class="s2">${helper(SET_BLOCK_TRACKING)}</span><span class="s0">(-1),`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">`_cache[</span><span class="s2">${node.index}</span><span class="s0">] = `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNode(node.value</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(node.isVNode) {</span>
        <span class="s2">push(</span><span class="s0">`,`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`</span><span class="s2">${helper(SET_BLOCK_TRACKING)}</span><span class="s0">(1),`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">newline()</span><span class="s1">;</span>
        <span class="s2">push(</span><span class="s0">`_cache[</span><span class="s2">${node.index}</span><span class="s0">]`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">deindent()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genTemplateLiteral(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent } = context</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">'`'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">l = node.elements.length</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">multilines = l &gt; </span><span class="s4">3</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">e = node.elements[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isString(e)) {</span>
            <span class="s2">push(e.replace(</span><span class="s4">/(`|\$|\\)/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">$1'</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">push(</span><span class="s0">'${'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(multilines)</span>
                <span class="s2">indent()</span><span class="s1">;</span>
            <span class="s2">genNode(e</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(multilines)</span>
                <span class="s2">deindent()</span><span class="s1">;</span>
            <span class="s2">push(</span><span class="s0">'}'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">push(</span><span class="s0">'`'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genIfStatement(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ push</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">deindent } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ test</span><span class="s1">, </span><span class="s2">consequent</span><span class="s1">, </span><span class="s2">alternate } = node</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`if (`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNode(test</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`) {`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">indent()</span><span class="s1">;</span>
    <span class="s2">genNode(consequent</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">deindent()</span><span class="s1">;</span>
    <span class="s2">push(</span><span class="s0">`}`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(alternate) {</span>
        <span class="s2">push(</span><span class="s0">` else `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(alternate.type === </span><span class="s4">23 </span><span class="s3">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s2">) {</span>
            <span class="s2">genIfStatement(alternate</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">push(</span><span class="s0">`{`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">indent()</span><span class="s1">;</span>
            <span class="s2">genNode(alternate</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">deindent()</span><span class="s1">;</span>
            <span class="s2">push(</span><span class="s0">`}`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genAssignmentExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">genNode(node.left</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">context.push(</span><span class="s0">` = `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNode(node.right</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genSequenceExpression(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">context.push(</span><span class="s0">`(`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">genNodeList(node.expressions</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">context.push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genReturnStatement({ returns }</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">context.push(</span><span class="s0">`return `</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(returns)) {</span>
        <span class="s2">genNodeListAsArray(returns</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">genNode(returns</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">walkIdentifiers(root</span><span class="s1">, </span><span class="s2">onIdentifier</span><span class="s1">, </span><span class="s2">includeAll = </span><span class="s1">false, </span><span class="s2">parentStack = []</span><span class="s1">, </span><span class="s2">knownIds = Object.create(</span><span class="s1">null</span><span class="s2">)) {</span>
    <span class="s1">const </span><span class="s2">rootExp = root.type === </span><span class="s0">'Program' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">root.body[</span><span class="s4">0</span><span class="s2">].type === </span><span class="s0">'ExpressionStatement' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">root.body[</span><span class="s4">0</span><span class="s2">].expression</span><span class="s1">;</span>
    <span class="s2">estreeWalker.walk(root</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">enter(node</span><span class="s1">, </span><span class="s2">parent) {</span>
            <span class="s2">parent &amp;&amp; parentStack.push(parent)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parent &amp;&amp;</span>
                <span class="s2">parent.type.startsWith(</span><span class="s0">'TS'</span><span class="s2">) &amp;&amp;</span>
                <span class="s2">parent.type !== </span><span class="s0">'TSAsExpression' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">parent.type !== </span><span class="s0">'TSNonNullExpression' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">parent.type !== </span><span class="s0">'TSTypeAssertion'</span><span class="s2">) {</span>
                <span class="s1">return this</span><span class="s2">.skip()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(node.type === </span><span class="s0">'Identifier'</span><span class="s2">) {</span>
                <span class="s1">const </span><span class="s2">isLocal = !!knownIds[node.name]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">isRefed = isReferencedIdentifier(node</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">parentStack)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(includeAll || (isRefed &amp;&amp; !isLocal)) {</span>
                    <span class="s2">onIdentifier(node</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">parentStack</span><span class="s1">, </span><span class="s2">isRefed</span><span class="s1">, </span><span class="s2">isLocal)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(node.type === </span><span class="s0">'ObjectProperty' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">parent.type === </span><span class="s0">'ObjectPattern'</span><span class="s2">) {</span>
                <span class="s2">node.inPattern = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(isFunctionType(node)) {</span>
                <span class="s3">// walk function expressions and add its arguments to known identifiers</span>
                <span class="s3">// so that we don't prefix them</span>
                <span class="s2">walkFunctionParams(node</span><span class="s1">, </span><span class="s2">id =&gt; markScopeIdentifier(node</span><span class="s1">, </span><span class="s2">id</span><span class="s1">, </span><span class="s2">knownIds))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(node.type === </span><span class="s0">'BlockStatement'</span><span class="s2">) {</span>
                <span class="s3">// #3445 record block-level local variables</span>
                <span class="s2">walkBlockDeclarations(node</span><span class="s1">, </span><span class="s2">id =&gt; markScopeIdentifier(node</span><span class="s1">, </span><span class="s2">id</span><span class="s1">, </span><span class="s2">knownIds))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">leave(node</span><span class="s1">, </span><span class="s2">parent) {</span>
            <span class="s2">parent &amp;&amp; parentStack.pop()</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node !== rootExp &amp;&amp; node.scopeIds) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">id of node.scopeIds) {</span>
                    <span class="s2">knownIds[id]--</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(knownIds[id] === </span><span class="s4">0</span><span class="s2">) {</span>
                        <span class="s1">delete </span><span class="s2">knownIds[id]</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isReferencedIdentifier(id</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">parentStack) {</span>
    <span class="s1">if </span><span class="s2">(!parent) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s3">// is a special keyword but parsed as identifier</span>
    <span class="s1">if </span><span class="s2">(id.name === </span><span class="s0">'arguments'</span><span class="s2">) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isReferenced(id</span><span class="s1">, </span><span class="s2">parent)) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s3">// babel's isReferenced check returns false for ids being assigned to, so we</span>
    <span class="s3">// need to cover those cases here</span>
    <span class="s1">switch </span><span class="s2">(parent.type) {</span>
        <span class="s1">case </span><span class="s0">'AssignmentExpression'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'AssignmentPattern'</span><span class="s2">:</span>
            <span class="s1">return true;</span>
        <span class="s1">case </span><span class="s0">'ObjectPattern'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ArrayPattern'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">isInDestructureAssignment(parent</span><span class="s1">, </span><span class="s2">parentStack)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isInDestructureAssignment(parent</span><span class="s1">, </span><span class="s2">parentStack) {</span>
    <span class="s1">if </span><span class="s2">(parent &amp;&amp;</span>
        <span class="s2">(parent.type === </span><span class="s0">'ObjectProperty' </span><span class="s2">|| parent.type === </span><span class="s0">'ArrayPattern'</span><span class="s2">)) {</span>
        <span class="s1">let </span><span class="s2">i = parentStack.length</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(i--) {</span>
            <span class="s1">const </span><span class="s2">p = parentStack[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(p.type === </span><span class="s0">'AssignmentExpression'</span><span class="s2">) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(p.type !== </span><span class="s0">'ObjectProperty' </span><span class="s2">&amp;&amp; !p.type.endsWith(</span><span class="s0">'Pattern'</span><span class="s2">)) {</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">walkFunctionParams(node</span><span class="s1">, </span><span class="s2">onIdent) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">p of node.params) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">id of extractIdentifiers(p)) {</span>
            <span class="s2">onIdent(id)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">walkBlockDeclarations(block</span><span class="s1">, </span><span class="s2">onIdent) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">stmt of block.body) {</span>
        <span class="s1">if </span><span class="s2">(stmt.type === </span><span class="s0">'VariableDeclaration'</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(stmt.declare)</span>
                <span class="s1">continue;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">decl of stmt.declarations) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">id of extractIdentifiers(decl.id)) {</span>
                    <span class="s2">onIdent(id)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(stmt.type === </span><span class="s0">'FunctionDeclaration' </span><span class="s2">||</span>
            <span class="s2">stmt.type === </span><span class="s0">'ClassDeclaration'</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(stmt.declare || !stmt.id)</span>
                <span class="s1">continue;</span>
            <span class="s2">onIdent(stmt.id)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">extractIdentifiers(param</span><span class="s1">, </span><span class="s2">nodes = []) {</span>
    <span class="s1">switch </span><span class="s2">(param.type) {</span>
        <span class="s1">case </span><span class="s0">'Identifier'</span><span class="s2">:</span>
            <span class="s2">nodes.push(param)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s0">'MemberExpression'</span><span class="s2">:</span>
            <span class="s1">let </span><span class="s2">object = param</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(object.type === </span><span class="s0">'MemberExpression'</span><span class="s2">) {</span>
                <span class="s2">object = object.object</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">nodes.push(object)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s0">'ObjectPattern'</span><span class="s2">:</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">prop of param.properties) {</span>
                <span class="s1">if </span><span class="s2">(prop.type === </span><span class="s0">'RestElement'</span><span class="s2">) {</span>
                    <span class="s2">extractIdentifiers(prop.argument</span><span class="s1">, </span><span class="s2">nodes)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">extractIdentifiers(prop.value</span><span class="s1">, </span><span class="s2">nodes)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s0">'ArrayPattern'</span><span class="s2">:</span>
            <span class="s2">param.elements.forEach(element =&gt; {</span>
                <span class="s1">if </span><span class="s2">(element)</span>
                    <span class="s2">extractIdentifiers(element</span><span class="s1">, </span><span class="s2">nodes)</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s0">'RestElement'</span><span class="s2">:</span>
            <span class="s2">extractIdentifiers(param.argument</span><span class="s1">, </span><span class="s2">nodes)</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s1">case </span><span class="s0">'AssignmentPattern'</span><span class="s2">:</span>
            <span class="s2">extractIdentifiers(param.left</span><span class="s1">, </span><span class="s2">nodes)</span><span class="s1">;</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">nodes</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">markScopeIdentifier(node</span><span class="s1">, </span><span class="s2">child</span><span class="s1">, </span><span class="s2">knownIds) {</span>
    <span class="s1">const </span><span class="s2">{ name } = child</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(node.scopeIds &amp;&amp; node.scopeIds.has(name)) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(name </span><span class="s1">in </span><span class="s2">knownIds) {</span>
        <span class="s2">knownIds[name]++</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">knownIds[name] = </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">(node.scopeIds || (node.scopeIds = </span><span class="s1">new </span><span class="s2">Set())).add(name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">isFunctionType = (node) =&gt; {</span>
    <span class="s1">return </span><span class="s4">/Function(?:Expression|Declaration)$|Method$/</span><span class="s2">.test(node.type)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isStaticProperty = (node) =&gt; node &amp;&amp;</span>
    <span class="s2">(node.type === </span><span class="s0">'ObjectProperty' </span><span class="s2">|| node.type === </span><span class="s0">'ObjectMethod'</span><span class="s2">) &amp;&amp;</span>
    <span class="s2">!node.computed</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isStaticPropertyKey = (node</span><span class="s1">, </span><span class="s2">parent) =&gt; isStaticProperty(parent) &amp;&amp; parent.key === node</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts</span>
 <span class="s5">* To avoid runtime dependency on @babel/types (which includes process references)</span>
 <span class="s5">* This file should not change very often in babel but we may need to keep it</span>
 <span class="s5">* up-to-date from time to time.</span>
 <span class="s5">*</span>
 <span class="s5">* https://github.com/babel/babel/blob/main/LICENSE</span>
 <span class="s5">*</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">isReferenced(node</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">grandparent) {</span>
    <span class="s1">switch </span><span class="s2">(parent.type) {</span>
        <span class="s3">// yes: PARENT[NODE]</span>
        <span class="s3">// yes: NODE.child</span>
        <span class="s3">// no: parent.NODE</span>
        <span class="s1">case </span><span class="s0">'MemberExpression'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'OptionalMemberExpression'</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(parent.property === node) {</span>
                <span class="s1">return </span><span class="s2">!!parent.computed</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">parent.object === node</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s0">'JSXMemberExpression'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.object === node</span><span class="s1">;</span>
        <span class="s3">// no: let NODE = init;</span>
        <span class="s3">// yes: let id = NODE;</span>
        <span class="s1">case </span><span class="s0">'VariableDeclarator'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.init === node</span><span class="s1">;</span>
        <span class="s3">// yes: () =&gt; NODE</span>
        <span class="s3">// no: (NODE) =&gt; {}</span>
        <span class="s1">case </span><span class="s0">'ArrowFunctionExpression'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.body === node</span><span class="s1">;</span>
        <span class="s3">// no: class { #NODE; }</span>
        <span class="s3">// no: class { get #NODE() {} }</span>
        <span class="s3">// no: class { #NODE() {} }</span>
        <span class="s3">// no: class { fn() { return this.#NODE; } }</span>
        <span class="s1">case </span><span class="s0">'PrivateName'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: class { NODE() {} }</span>
        <span class="s3">// yes: class { [NODE]() {} }</span>
        <span class="s3">// no: class { foo(NODE) {} }</span>
        <span class="s1">case </span><span class="s0">'ClassMethod'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ClassPrivateMethod'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ObjectMethod'</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(parent.key === node) {</span>
                <span class="s1">return </span><span class="s2">!!parent.computed</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return false;</span>
        <span class="s3">// yes: { [NODE]: &quot;&quot; }</span>
        <span class="s3">// no: { NODE: &quot;&quot; }</span>
        <span class="s3">// depends: { NODE }</span>
        <span class="s3">// depends: { key: NODE }</span>
        <span class="s1">case </span><span class="s0">'ObjectProperty'</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(parent.key === node) {</span>
                <span class="s1">return </span><span class="s2">!!parent.computed</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// parent.value === node</span>
            <span class="s1">return </span><span class="s2">!grandparent || grandparent.type !== </span><span class="s0">'ObjectPattern'</span><span class="s1">;</span>
        <span class="s3">// no: class { NODE = value; }</span>
        <span class="s3">// yes: class { [NODE] = value; }</span>
        <span class="s3">// yes: class { key = NODE; }</span>
        <span class="s1">case </span><span class="s0">'ClassProperty'</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(parent.key === node) {</span>
                <span class="s1">return </span><span class="s2">!!parent.computed</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return true;</span>
        <span class="s1">case </span><span class="s0">'ClassPrivateProperty'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.key !== node</span><span class="s1">;</span>
        <span class="s3">// no: class NODE {}</span>
        <span class="s3">// yes: class Foo extends NODE {}</span>
        <span class="s1">case </span><span class="s0">'ClassDeclaration'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ClassExpression'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.superClass === node</span><span class="s1">;</span>
        <span class="s3">// yes: left = NODE;</span>
        <span class="s3">// no: NODE = right;</span>
        <span class="s1">case </span><span class="s0">'AssignmentExpression'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.right === node</span><span class="s1">;</span>
        <span class="s3">// no: [NODE = foo] = [];</span>
        <span class="s3">// yes: [foo = NODE] = [];</span>
        <span class="s1">case </span><span class="s0">'AssignmentPattern'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.right === node</span><span class="s1">;</span>
        <span class="s3">// no: NODE: for (;;) {}</span>
        <span class="s1">case </span><span class="s0">'LabeledStatement'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: try {} catch (NODE) {}</span>
        <span class="s1">case </span><span class="s0">'CatchClause'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: function foo(...NODE) {}</span>
        <span class="s1">case </span><span class="s0">'RestElement'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s1">case </span><span class="s0">'BreakStatement'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ContinueStatement'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: function NODE() {}</span>
        <span class="s3">// no: function foo(NODE) {}</span>
        <span class="s1">case </span><span class="s0">'FunctionDeclaration'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'FunctionExpression'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: export NODE from &quot;foo&quot;;</span>
        <span class="s3">// no: export * as NODE from &quot;foo&quot;;</span>
        <span class="s1">case </span><span class="s0">'ExportNamespaceSpecifier'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ExportDefaultSpecifier'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: export { foo as NODE };</span>
        <span class="s3">// yes: export { NODE as foo };</span>
        <span class="s3">// no: export { NODE as foo } from &quot;foo&quot;;</span>
        <span class="s1">case </span><span class="s0">'ExportSpecifier'</span><span class="s2">:</span>
            <span class="s3">// @ts-expect-error</span>
            <span class="s1">if </span><span class="s2">(grandparent === </span><span class="s1">null </span><span class="s2">|| grandparent === </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">: grandparent.source) {</span>
                <span class="s1">return false;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">parent.local === node</span><span class="s1">;</span>
        <span class="s3">// no: import NODE from &quot;foo&quot;;</span>
        <span class="s3">// no: import * as NODE from &quot;foo&quot;;</span>
        <span class="s3">// no: import { NODE as foo } from &quot;foo&quot;;</span>
        <span class="s3">// no: import { foo as NODE } from &quot;foo&quot;;</span>
        <span class="s3">// no: import NODE from &quot;bar&quot;;</span>
        <span class="s1">case </span><span class="s0">'ImportDefaultSpecifier'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ImportNamespaceSpecifier'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ImportSpecifier'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: import &quot;foo&quot; assert { NODE: &quot;json&quot; }</span>
        <span class="s1">case </span><span class="s0">'ImportAttribute'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: &lt;div NODE=&quot;foo&quot; /&gt;</span>
        <span class="s1">case </span><span class="s0">'JSXAttribute'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: [NODE] = [];</span>
        <span class="s3">// no: ({ NODE }) = [];</span>
        <span class="s1">case </span><span class="s0">'ObjectPattern'</span><span class="s2">:</span>
        <span class="s1">case </span><span class="s0">'ArrayPattern'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// no: new.NODE</span>
        <span class="s3">// no: NODE.target</span>
        <span class="s1">case </span><span class="s0">'MetaProperty'</span><span class="s2">:</span>
            <span class="s1">return false;</span>
        <span class="s3">// yes: type X = { someProperty: NODE }</span>
        <span class="s3">// no: type X = { NODE: OtherType }</span>
        <span class="s1">case </span><span class="s0">'ObjectTypeProperty'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.key !== node</span><span class="s1">;</span>
        <span class="s3">// yes: enum X { Foo = NODE }</span>
        <span class="s3">// no: enum X { NODE }</span>
        <span class="s1">case </span><span class="s0">'TSEnumMember'</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">parent.id !== node</span><span class="s1">;</span>
        <span class="s3">// yes: { [NODE]: value }</span>
        <span class="s3">// no: { NODE: value }</span>
        <span class="s1">case </span><span class="s0">'TSPropertySignature'</span><span class="s2">:</span>
            <span class="s1">if </span><span class="s2">(parent.key === node) {</span>
                <span class="s1">return </span><span class="s2">!!parent.computed</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isLiteralWhitelisted = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">shared.makeMap(</span><span class="s0">'true,false,null,this'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">transformExpression = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">) {</span>
        <span class="s2">node.content = processExpression(node.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
        <span class="s3">// handle directives on element</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">dir = node.props[i]</span><span class="s1">;</span>
            <span class="s3">// do not process for v-on &amp; v-for since they are special handled</span>
            <span class="s1">if </span><span class="s2">(dir.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp; dir.name !== </span><span class="s0">'for'</span><span class="s2">) {</span>
                <span class="s1">const </span><span class="s2">exp = dir.exp</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">arg = dir.arg</span><span class="s1">;</span>
                <span class="s3">// do not process exp if this is v-on:arg - we need special handling</span>
                <span class="s3">// for wrapping inline statements.</span>
                <span class="s1">if </span><span class="s2">(exp &amp;&amp;</span>
                    <span class="s2">exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">!(dir.name === </span><span class="s0">'on' </span><span class="s2">&amp;&amp; arg)) {</span>
                    <span class="s2">dir.exp = processExpression(exp</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span>
                    <span class="s3">// slot args must be processed as function params</span>
                    <span class="s2">dir.name === </span><span class="s0">'slot'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(arg &amp;&amp; arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp; !arg.isStatic) {</span>
                    <span class="s2">dir.arg = processExpression(arg</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">// Important: since this function uses Node.js only dependencies, it should</span>
<span class="s3">// always be used with a leading !false check so that it can be</span>
<span class="s3">// tree-shaken from the browser build.</span>
<span class="s1">function </span><span class="s2">processExpression(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span>
<span class="s3">// some expressions like v-slot props &amp; v-for aliases should be parsed as</span>
<span class="s3">// function params</span>
<span class="s2">asParams = </span><span class="s1">false, </span>
<span class="s3">// v-on handler values may contain multiple statements</span>
<span class="s2">asRawStatements = </span><span class="s1">false, </span><span class="s2">localVars = Object.create(context.identifiers)) {</span>
    <span class="s1">if </span><span class="s2">(!context.prefixIdentifiers || !node.content.trim()) {</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ inline</span><span class="s1">, </span><span class="s2">bindingMetadata } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rewriteIdentifier = (raw</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">id) =&gt; {</span>
        <span class="s1">const </span><span class="s2">type = shared.hasOwn(bindingMetadata</span><span class="s1">, </span><span class="s2">raw) &amp;&amp; bindingMetadata[raw]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(inline) {</span>
            <span class="s3">// x = y</span>
            <span class="s1">const </span><span class="s2">isAssignmentLVal = parent &amp;&amp; parent.type === </span><span class="s0">'AssignmentExpression' </span><span class="s2">&amp;&amp; parent.left === id</span><span class="s1">;</span>
            <span class="s3">// x++</span>
            <span class="s1">const </span><span class="s2">isUpdateArg = parent &amp;&amp; parent.type === </span><span class="s0">'UpdateExpression' </span><span class="s2">&amp;&amp; parent.argument === id</span><span class="s1">;</span>
            <span class="s3">// ({ x } = y)</span>
            <span class="s1">const </span><span class="s2">isDestructureAssignment = parent &amp;&amp; isInDestructureAssignment(parent</span><span class="s1">, </span><span class="s2">parentStack)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(type === </span><span class="s0">&quot;setup-const&quot; </span><span class="s3">/* BindingTypes.SETUP_CONST */ </span><span class="s2">||</span>
                <span class="s2">type === </span><span class="s0">&quot;setup-reactive-const&quot; </span><span class="s3">/* BindingTypes.SETUP_REACTIVE_CONST */ </span><span class="s2">||</span>
                <span class="s2">localVars[raw]) {</span>
                <span class="s1">return </span><span class="s2">raw</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;setup-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_REF */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s0">`</span><span class="s2">${raw}</span><span class="s0">.value`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;setup-maybe-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_MAYBE_REF */</span><span class="s2">) {</span>
                <span class="s3">// const binding that may or may not be ref</span>
                <span class="s3">// if it's not a ref, then assignments don't make sense -</span>
                <span class="s3">// so we ignore the non-ref assignment case and generate code</span>
                <span class="s3">// that assumes the value to be a ref for more efficiency</span>
                <span class="s1">return </span><span class="s2">isAssignmentLVal || isUpdateArg || isDestructureAssignment</span>
                    <span class="s2">? </span><span class="s0">`</span><span class="s2">${raw}</span><span class="s0">.value`</span>
                    <span class="s2">: </span><span class="s0">`</span><span class="s2">${context.helperString(UNREF)}</span><span class="s0">(</span><span class="s2">${raw}</span><span class="s0">)`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;setup-let&quot; </span><span class="s3">/* BindingTypes.SETUP_LET */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(isAssignmentLVal) {</span>
                    <span class="s3">// let binding.</span>
                    <span class="s3">// this is a bit more tricky as we need to cover the case where</span>
                    <span class="s3">// let is a local non-ref value, and we need to replicate the</span>
                    <span class="s3">// right hand side value.</span>
                    <span class="s3">// x = y --&gt; isRef(x) ? x.value = y : x = y</span>
                    <span class="s1">const </span><span class="s2">{ right: rVal</span><span class="s1">, </span><span class="s2">operator } = parent</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">rExp = rawExp.slice(rVal.start - </span><span class="s4">1</span><span class="s1">, </span><span class="s2">rVal.end - </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, false, false, </span><span class="s2">knownIds))</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s0">`</span><span class="s2">${context.helperString(IS_REF)}</span><span class="s0">(</span><span class="s2">${raw}</span><span class="s0">)</span><span class="s2">${context.isTS ? </span><span class="s0">` //@ts-ignore</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">} </span><span class="s0">? </span><span class="s2">${raw}</span><span class="s0">.value </span><span class="s2">${operator} ${rExpString} </span><span class="s0">: </span><span class="s2">${raw}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(isUpdateArg) {</span>
                    <span class="s3">// make id replace parent in the code range so the raw update operator</span>
                    <span class="s3">// is removed</span>
                    <span class="s2">id.start = parent.start</span><span class="s1">;</span>
                    <span class="s2">id.end = parent.end</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">{ prefix: isPrefix</span><span class="s1">, </span><span class="s2">operator } = parent</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">prefix = isPrefix ? operator : </span><span class="s0">``</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">postfix = isPrefix ? </span><span class="s0">`` </span><span class="s2">: operator</span><span class="s1">;</span>
                    <span class="s3">// let binding.</span>
                    <span class="s3">// x++ --&gt; isRef(a) ? a.value++ : a++</span>
                    <span class="s1">return </span><span class="s0">`</span><span class="s2">${context.helperString(IS_REF)}</span><span class="s0">(</span><span class="s2">${raw}</span><span class="s0">)</span><span class="s2">${context.isTS ? </span><span class="s0">` //@ts-ignore</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">} </span><span class="s0">? </span><span class="s2">${prefix}${raw}</span><span class="s0">.value</span><span class="s2">${postfix} </span><span class="s0">: </span><span class="s2">${prefix}${raw}${postfix}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(isDestructureAssignment) {</span>
                    <span class="s3">// TODO</span>
                    <span class="s3">// let binding in a destructure assignment - it's very tricky to</span>
                    <span class="s3">// handle both possible cases here without altering the original</span>
                    <span class="s3">// structure of the code, so we just assume it's not a ref here</span>
                    <span class="s3">// for now</span>
                    <span class="s1">return </span><span class="s2">raw</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return </span><span class="s0">`</span><span class="s2">${context.helperString(UNREF)}</span><span class="s0">(</span><span class="s2">${raw}</span><span class="s0">)`</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;props&quot; </span><span class="s3">/* BindingTypes.PROPS */</span><span class="s2">) {</span>
                <span class="s3">// use __props which is generated by compileScript so in ts mode</span>
                <span class="s3">// it gets correct type</span>
                <span class="s1">return </span><span class="s2">shared.genPropsAccessExp(raw)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;props-aliased&quot; </span><span class="s3">/* BindingTypes.PROPS_ALIASED */</span><span class="s2">) {</span>
                <span class="s3">// prop with a different local alias (from defineProps() destructure)</span>
                <span class="s1">return </span><span class="s2">shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(type &amp;&amp; type.startsWith(</span><span class="s0">'setup'</span><span class="s2">)) {</span>
                <span class="s3">// setup bindings in non-inline mode</span>
                <span class="s1">return </span><span class="s0">`$setup.</span><span class="s2">${raw}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">&quot;props-aliased&quot; </span><span class="s3">/* BindingTypes.PROPS_ALIASED */</span><span class="s2">) {</span>
                <span class="s1">return </span><span class="s0">`$props['</span><span class="s2">${bindingMetadata.__propsAliases[raw]}</span><span class="s0">']`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(type) {</span>
                <span class="s1">return </span><span class="s0">`$</span><span class="s2">${type}</span><span class="s0">.</span><span class="s2">${raw}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// fallback to ctx</span>
        <span class="s1">return </span><span class="s0">`_ctx.</span><span class="s2">${raw}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// fast path if expression is a simple identifier.</span>
    <span class="s1">const </span><span class="s2">rawExp = node.content</span><span class="s1">;</span>
    <span class="s3">// bail constant on parens (function invocation) and dot (member access)</span>
    <span class="s1">const </span><span class="s2">bailConstant = rawExp.indexOf(</span><span class="s0">`(`</span><span class="s2">) &gt; -</span><span class="s4">1 </span><span class="s2">|| rawExp.indexOf(</span><span class="s0">'.'</span><span class="s2">) &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isSimpleIdentifier(rawExp)) {</span>
        <span class="s1">const </span><span class="s2">isScopeVarReference = context.identifiers[rawExp]</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isAllowedGlobal = shared.isGloballyWhitelisted(rawExp)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isLiteral = isLiteralWhitelisted(rawExp)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!asParams &amp;&amp; !isScopeVarReference &amp;&amp; !isAllowedGlobal &amp;&amp; !isLiteral) {</span>
            <span class="s3">// const bindings exposed from setup can be skipped for patching but</span>
            <span class="s3">// cannot be hoisted to module scope</span>
            <span class="s1">if </span><span class="s2">(bindingMetadata[node.content] === </span><span class="s0">&quot;setup-const&quot; </span><span class="s3">/* BindingTypes.SETUP_CONST */</span><span class="s2">) {</span>
                <span class="s2">node.constType = </span><span class="s4">1 </span><span class="s3">/* ConstantTypes.CAN_SKIP_PATCH */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">node.content = rewriteIdentifier(rawExp)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!isScopeVarReference) {</span>
            <span class="s1">if </span><span class="s2">(isLiteral) {</span>
                <span class="s2">node.constType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">node.constType = </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">ast</span><span class="s1">;</span>
    <span class="s3">// exp needs to be parsed differently:</span>
    <span class="s3">// 1. Multiple inline statements (v-on, with presence of `;`): parse as raw</span>
    <span class="s3">//    exp, but make sure to pad with spaces for consistent ranges</span>
    <span class="s3">// 2. Expressions: wrap with parens (for e.g. object expressions)</span>
    <span class="s3">// 3. Function arguments (v-for, v-slot): place in a function argument position</span>
    <span class="s1">const </span><span class="s2">source = asRawStatements</span>
        <span class="s2">? </span><span class="s0">` </span><span class="s2">${rawExp} </span><span class="s0">`</span>
        <span class="s2">: </span><span class="s0">`(</span><span class="s2">${rawExp}</span><span class="s0">)</span><span class="s2">${asParams ? </span><span class="s0">`=&gt;{}` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s2">ast = parser.parse(source</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">plugins: context.expressionPlugins</span>
        <span class="s2">}).program</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">(e) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">45 </span><span class="s3">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s1">, </span><span class="s2">node.loc</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">e.message))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">ids = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">parentStack = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">knownIds = Object.create(context.identifiers)</span><span class="s1">;</span>
    <span class="s2">walkIdentifiers(ast</span><span class="s1">, </span><span class="s2">(node</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">_</span><span class="s1">, </span><span class="s2">isReferenced</span><span class="s1">, </span><span class="s2">isLocal) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(isStaticPropertyKey(node</span><span class="s1">, </span><span class="s2">parent)) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s3">// v2 wrapped filter call</span>
        <span class="s1">if </span><span class="s2">(node.name.startsWith(</span><span class="s0">'_filter_'</span><span class="s2">)) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">needPrefix = isReferenced &amp;&amp; canPrefix(node)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(needPrefix &amp;&amp; !isLocal) {</span>
            <span class="s1">if </span><span class="s2">(isStaticProperty(parent) &amp;&amp; parent.shorthand) {</span>
                <span class="s2">node.prefix = </span><span class="s0">`</span><span class="s2">${node.name}</span><span class="s0">: `</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">node.name = rewriteIdentifier(node.name</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
            <span class="s2">ids.push(node)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// The identifier is considered constant unless it's pointing to a</span>
            <span class="s3">// local scope variable (a v-for alias, or a v-slot prop)</span>
            <span class="s1">if </span><span class="s2">(!(needPrefix &amp;&amp; isLocal) &amp;&amp; !bailConstant) {</span>
                <span class="s2">node.isConstant = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s3">// also generate sub-expressions for other identifiers for better</span>
            <span class="s3">// source map support. (except for property keys which are static)</span>
            <span class="s2">ids.push(node)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">, true, </span><span class="s3">// invoke on ALL identifiers</span>
    <span class="s2">parentStack</span><span class="s1">, </span><span class="s2">knownIds)</span><span class="s1">;</span>
    <span class="s3">// We break up the compound expression into an array of strings and sub</span>
    <span class="s3">// expressions (for identifiers that have been prefixed). In codegen, if</span>
    <span class="s3">// an ExpressionNode has the `.children` property, it will be used instead of</span>
    <span class="s3">// `.content`.</span>
    <span class="s1">const </span><span class="s2">children = []</span><span class="s1">;</span>
    <span class="s2">ids.sort((a</span><span class="s1">, </span><span class="s2">b) =&gt; a.start - b.start)</span><span class="s1">;</span>
    <span class="s2">ids.forEach((id</span><span class="s1">, </span><span class="s2">i) =&gt; {</span>
        <span class="s3">// range is offset by -1 due to the wrapping parens when parsed</span>
        <span class="s1">const </span><span class="s2">start = id.start - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">end = id.end - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">last = ids[i - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">leadingText = rawExp.slice(last ? last.end - </span><span class="s4">1 </span><span class="s2">: </span><span class="s4">0</span><span class="s1">, </span><span class="s2">start)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(leadingText.length || id.prefix) {</span>
            <span class="s2">children.push(leadingText + (id.prefix || </span><span class="s0">``</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">source = rawExp.slice(start</span><span class="s1">, </span><span class="s2">end)</span><span class="s1">;</span>
        <span class="s2">children.push(createSimpleExpression(id.name</span><span class="s1">, false, </span><span class="s2">{</span>
            <span class="s2">source</span><span class="s1">,</span>
            <span class="s2">start: advancePositionWithClone(node.loc.start</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">start)</span><span class="s1">,</span>
            <span class="s2">end: advancePositionWithClone(node.loc.start</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">end)</span>
        <span class="s2">}</span><span class="s1">, </span><span class="s2">id.isConstant ? </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */ </span><span class="s2">: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(i === ids.length - </span><span class="s4">1 </span><span class="s2">&amp;&amp; end &lt; rawExp.length) {</span>
            <span class="s2">children.push(rawExp.slice(end))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(children.length) {</span>
        <span class="s2">ret = createCompoundExpression(children</span><span class="s1">, </span><span class="s2">node.loc)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">ret = node</span><span class="s1">;</span>
        <span class="s2">ret.constType = bailConstant</span>
            <span class="s2">? </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span>
            <span class="s2">: </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">ret.identifiers = Object.keys(knownIds)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">canPrefix(id) {</span>
    <span class="s3">// skip whitelisted globals</span>
    <span class="s1">if </span><span class="s2">(shared.isGloballyWhitelisted(id.name)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s3">// special case for webpack compilation</span>
    <span class="s1">if </span><span class="s2">(id.name === </span><span class="s0">'require'</span><span class="s2">) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">stringifyExpression(exp) {</span>
    <span class="s1">if </span><span class="s2">(shared.isString(exp)) {</span>
        <span class="s1">return </span><span class="s2">exp</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">exp.content</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">exp.children</span>
            <span class="s2">.map(stringifyExpression)</span>
            <span class="s2">.join(</span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">transformIf = createStructuralDirectiveTransform(</span><span class="s4">/^(if|else|else-if)$/</span><span class="s1">, </span><span class="s2">(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">return </span><span class="s2">processIf(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">(ifNode</span><span class="s1">, </span><span class="s2">branch</span><span class="s1">, </span><span class="s2">isRoot) =&gt; {</span>
        <span class="s3">// #1587: We need to dynamically increment the key based on the current</span>
        <span class="s3">// node's sibling nodes, since chained v-if/else branches are</span>
        <span class="s3">// rendered at the same depth</span>
        <span class="s1">const </span><span class="s2">siblings = context.parent.children</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">i = siblings.indexOf(ifNode)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">key = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(i-- &gt;= </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">sibling = siblings[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">) {</span>
                <span class="s2">key += sibling.branches.length</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// Exit callback. Complete the codegenNode when all children have been</span>
        <span class="s3">// transformed.</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s1">if </span><span class="s2">(isRoot) {</span>
                <span class="s2">ifNode.codegenNode = createCodegenNodeForBranch(branch</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// attach this branch's codegen node to the v-if root.</span>
                <span class="s1">const </span><span class="s2">parentCondition = getParentCondition(ifNode.codegenNode)</span><span class="s1">;</span>
                <span class="s2">parentCondition.alternate = createCodegenNodeForBranch(branch</span><span class="s1">, </span><span class="s2">key + ifNode.branches.length - </span><span class="s4">1</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s3">// target-agnostic transform used for both Client and SSR</span>
<span class="s1">function </span><span class="s2">processIf(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">processCodegen) {</span>
    <span class="s1">if </span><span class="s2">(dir.name !== </span><span class="s0">'else' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(!dir.exp || !dir.exp.content.trim())) {</span>
        <span class="s1">const </span><span class="s2">loc = dir.exp ? dir.exp.loc : node.loc</span><span class="s1">;</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">28 </span><span class="s3">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">dir.loc))</span><span class="s1">;</span>
        <span class="s2">dir.exp = createSimpleExpression(</span><span class="s0">`true`</span><span class="s1">, false, </span><span class="s2">loc)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(context.prefixIdentifiers &amp;&amp; dir.exp) {</span>
        <span class="s3">// dir.exp can only be simple expression because vIf transform is applied</span>
        <span class="s3">// before expression transform.</span>
        <span class="s2">dir.exp = processExpression(dir.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(dir.name === </span><span class="s0">'if'</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">branch = createIfBranch(node</span><span class="s1">, </span><span class="s2">dir)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">ifNode = {</span>
            <span class="s2">type: </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">,</span>
            <span class="s2">loc: node.loc</span><span class="s1">,</span>
            <span class="s2">branches: [branch]</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">context.replaceNode(ifNode)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(processCodegen) {</span>
            <span class="s1">return </span><span class="s2">processCodegen(ifNode</span><span class="s1">, </span><span class="s2">branch</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// locate the adjacent v-if</span>
        <span class="s1">const </span><span class="s2">siblings = context.parent.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">comments = []</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">i = siblings.indexOf(node)</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(i-- &gt;= -</span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">sibling = siblings[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(sibling &amp;&amp; sibling.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">) {</span>
                <span class="s2">context.removeNode(sibling)</span><span class="s1">;</span>
                <span class="s2">comments.unshift(sibling)</span><span class="s1">;</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(sibling &amp;&amp;</span>
                <span class="s2">sibling.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s2">&amp;&amp;</span>
                <span class="s2">!sibling.content.trim().length) {</span>
                <span class="s2">context.removeNode(sibling)</span><span class="s1">;</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">) {</span>
                <span class="s3">// Check if v-else was followed by v-else-if</span>
                <span class="s1">if </span><span class="s2">(dir.name === </span><span class="s0">'else-if' </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">sibling.branches[sibling.branches.length - </span><span class="s4">1</span><span class="s2">].condition === undefined) {</span>
                    <span class="s2">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">, </span><span class="s2">node.loc))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// move the node to the if node's branches</span>
                <span class="s2">context.removeNode()</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">branch = createIfBranch(node</span><span class="s1">, </span><span class="s2">dir)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(comments.length &amp;&amp;</span>
                    <span class="s3">// #3619 ignore comments if the v-if is direct child of &lt;transition&gt;</span>
                    <span class="s2">!(context.parent &amp;&amp;</span>
                        <span class="s2">context.parent.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">isBuiltInType(context.parent.tag</span><span class="s1">, </span><span class="s0">'transition'</span><span class="s2">))) {</span>
                    <span class="s2">branch.children = [...comments</span><span class="s1">, </span><span class="s2">...branch.children]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// check if user is forcing same key on different branches</span>
                <span class="s2">{</span>
                    <span class="s1">const </span><span class="s2">key = branch.userKey</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(key) {</span>
                        <span class="s2">sibling.branches.forEach(({ userKey }) =&gt; {</span>
                            <span class="s1">if </span><span class="s2">(isSameKey(userKey</span><span class="s1">, </span><span class="s2">key)) {</span>
                                <span class="s2">context.onError(createCompilerError(</span><span class="s4">29 </span><span class="s3">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s1">, </span><span class="s2">branch.userKey.loc))</span><span class="s1">;</span>
                            <span class="s2">}</span>
                        <span class="s2">})</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s2">sibling.branches.push(branch)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">onExit = processCodegen &amp;&amp; processCodegen(sibling</span><span class="s1">, </span><span class="s2">branch</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s3">// since the branch was removed, it will not be traversed.</span>
                <span class="s3">// make sure to traverse here.</span>
                <span class="s2">traverseNode(branch</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s3">// call on exit</span>
                <span class="s1">if </span><span class="s2">(onExit)</span>
                    <span class="s2">onExit()</span><span class="s1">;</span>
                <span class="s3">// make sure to reset currentNode after traversal to indicate this</span>
                <span class="s3">// node has been removed.</span>
                <span class="s2">context.currentNode = </span><span class="s1">null;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">, </span><span class="s2">node.loc))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">break;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createIfBranch(node</span><span class="s1">, </span><span class="s2">dir) {</span>
    <span class="s1">const </span><span class="s2">isTemplateIf = node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">type: </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">,</span>
        <span class="s2">loc: node.loc</span><span class="s1">,</span>
        <span class="s2">condition: dir.name === </span><span class="s0">'else' </span><span class="s2">? undefined : dir.exp</span><span class="s1">,</span>
        <span class="s2">children: isTemplateIf &amp;&amp; !findDir(node</span><span class="s1">, </span><span class="s0">'for'</span><span class="s2">) ? node.children : [node]</span><span class="s1">,</span>
        <span class="s2">userKey: findProp(node</span><span class="s1">, </span><span class="s0">`key`</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">isTemplateIf</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createCodegenNodeForBranch(branch</span><span class="s1">, </span><span class="s2">keyIndex</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(branch.condition) {</span>
        <span class="s1">return </span><span class="s2">createConditionalExpression(branch.condition</span><span class="s1">, </span><span class="s2">createChildrenCodegenNode(branch</span><span class="s1">, </span><span class="s2">keyIndex</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">, </span>
        <span class="s3">// make sure to pass in asBlock: true so that the comment node call</span>
        <span class="s3">// closes the current block.</span>
        <span class="s2">createCallExpression(context.helper(CREATE_COMMENT)</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s0">'&quot;v-if&quot;' </span><span class="s1">,</span>
            <span class="s0">'true'</span>
        <span class="s2">]))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">createChildrenCodegenNode(branch</span><span class="s1">, </span><span class="s2">keyIndex</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createChildrenCodegenNode(branch</span><span class="s1">, </span><span class="s2">keyIndex</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">{ helper } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">keyProperty = createObjectProperty(</span><span class="s0">`key`</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">`</span><span class="s2">${keyIndex}</span><span class="s0">`</span><span class="s1">, false, </span><span class="s2">locStub</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ children } = branch</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">firstChild = children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s2">|| firstChild.type !== </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(needFragmentWrapper) {</span>
        <span class="s1">if </span><span class="s2">(children.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp; firstChild.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">) {</span>
            <span class="s3">// optimize away nested fragments when child is a ForNode</span>
            <span class="s1">const </span><span class="s2">vnodeCall = firstChild.codegenNode</span><span class="s1">;</span>
            <span class="s2">injectProp(vnodeCall</span><span class="s1">, </span><span class="s2">keyProperty</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">vnodeCall</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">let </span><span class="s2">patchFlag = </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">patchFlagText = shared.PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s3">// check if the fragment actually contains a single valid child with</span>
            <span class="s3">// the rest being comments</span>
            <span class="s1">if </span><span class="s2">(!branch.isTemplateIf &amp;&amp;</span>
                <span class="s2">children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">).length === </span><span class="s4">1</span><span class="s2">) {</span>
                <span class="s2">patchFlag |= </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">;</span>
                <span class="s2">patchFlagText += </span><span class="s0">`, </span><span class="s2">${shared.PatchFlagNames[</span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">]}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">createVNodeCall(context</span><span class="s1">, </span><span class="s2">helper(FRAGMENT)</span><span class="s1">, </span><span class="s2">createObjectExpression([keyProperty])</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag + (</span><span class="s0">` /* </span><span class="s2">${patchFlagText} </span><span class="s0">*/` </span><span class="s2">)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, true, false, false </span><span class="s3">/* isComponent */</span><span class="s1">, </span><span class="s2">branch.loc)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">ret = firstChild.codegenNode</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">vnodeCall = getMemoedVNodeCall(ret)</span><span class="s1">;</span>
        <span class="s3">// Change createVNode to createBlock.</span>
        <span class="s1">if </span><span class="s2">(vnodeCall.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
            <span class="s2">makeBlock(vnodeCall</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// inject branch key</span>
        <span class="s2">injectProp(vnodeCall</span><span class="s1">, </span><span class="s2">keyProperty</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSameKey(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">if </span><span class="s2">(!a || a.type !== b.type) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(a.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(a.value.content !== b.value.content) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// directive</span>
        <span class="s1">const </span><span class="s2">exp = a.exp</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">branchExp = b.exp</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(exp.type !== branchExp.type) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(exp.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">||</span>
            <span class="s2">exp.isStatic !== branchExp.isStatic ||</span>
            <span class="s2">exp.content !== branchExp.content) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getParentCondition(node) {</span>
    <span class="s1">while </span><span class="s2">(</span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(node.alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">) {</span>
                <span class="s2">node = node.alternate</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(node.type === </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s2">node = node.value</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">transformFor = createStructuralDirectiveTransform(</span><span class="s0">'for'</span><span class="s1">, </span><span class="s2">(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ helper</span><span class="s1">, </span><span class="s2">removeHelper } = context</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">processFor(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">forNode =&gt; {</span>
        <span class="s3">// create the loop render function expression now, and add the</span>
        <span class="s3">// iterator on exit after all children have been traversed</span>
        <span class="s1">const </span><span class="s2">renderExp = createCallExpression(helper(RENDER_LIST)</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s2">forNode.source</span>
        <span class="s2">])</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isTemplate = isTemplateNode(node)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">memo = findDir(node</span><span class="s1">, </span><span class="s0">'memo'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keyProp = findProp(node</span><span class="s1">, </span><span class="s0">`key`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keyExp = keyProp &amp;&amp;</span>
            <span class="s2">(keyProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s2">? createSimpleExpression(keyProp.value.content</span><span class="s1">, true</span><span class="s2">)</span>
                <span class="s2">: keyProp.exp)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keyProperty = keyProp ? createObjectProperty(</span><span class="s0">`key`</span><span class="s1">, </span><span class="s2">keyExp) : </span><span class="s1">null;</span>
        <span class="s1">if </span><span class="s2">(isTemplate) {</span>
            <span class="s3">// #2085 / #5288 process :key and v-memo expressions need to be</span>
            <span class="s3">// processed on `&lt;template v-for&gt;`. In this case the node is discarded</span>
            <span class="s3">// and never traversed so its binding expressions won't be processed</span>
            <span class="s3">// by the normal transforms.</span>
            <span class="s1">if </span><span class="s2">(memo) {</span>
                <span class="s2">memo.exp = processExpression(memo.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(keyProperty &amp;&amp; keyProp.type !== </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
                <span class="s2">keyProperty.value = processExpression(keyProperty.value</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">isStableFragment = forNode.source.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">forNode.source.constType &gt; </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">fragmentFlag = isStableFragment</span>
            <span class="s2">? </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span>
            <span class="s2">: keyProp</span>
                <span class="s2">? </span><span class="s4">128 </span><span class="s3">/* PatchFlags.KEYED_FRAGMENT */</span>
                <span class="s2">: </span><span class="s4">256 </span><span class="s3">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s1">;</span>
        <span class="s2">forNode.codegenNode = createVNodeCall(context</span><span class="s1">, </span><span class="s2">helper(FRAGMENT)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">renderExp</span><span class="s1">, </span><span class="s2">fragmentFlag +</span>
            <span class="s2">(</span><span class="s0">` /* </span><span class="s2">${shared.PatchFlagNames[fragmentFlag]} </span><span class="s0">*/` </span><span class="s2">)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, true </span><span class="s3">/* isBlock */</span><span class="s1">, </span><span class="s2">!isStableFragment </span><span class="s3">/* disableTracking */</span><span class="s1">, false </span><span class="s3">/* isComponent */</span><span class="s1">, </span><span class="s2">node.loc)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s3">// finish the codegen now that all children have been traversed</span>
            <span class="s1">let </span><span class="s2">childBlock</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ children } = forNode</span><span class="s1">;</span>
            <span class="s3">// check &lt;template v-for&gt; key placement</span>
            <span class="s1">if </span><span class="s2">(isTemplate) {</span>
                <span class="s2">node.children.some(c =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(c.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
                        <span class="s1">const </span><span class="s2">key = findProp(c</span><span class="s1">, </span><span class="s0">'key'</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(key) {</span>
                            <span class="s2">context.onError(createCompilerError(</span><span class="s4">33 </span><span class="s3">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s1">, </span><span class="s2">key.loc))</span><span class="s1">;</span>
                            <span class="s1">return true;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s2">|| children[</span><span class="s4">0</span><span class="s2">].type !== </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">slotOutlet = isSlotOutlet(node)</span>
                <span class="s2">? node</span>
                <span class="s2">: isTemplate &amp;&amp;</span>
                    <span class="s2">node.children.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">isSlotOutlet(node.children[</span><span class="s4">0</span><span class="s2">])</span>
                    <span class="s2">? node.children[</span><span class="s4">0</span><span class="s2">] </span><span class="s3">// api-extractor somehow fails to infer this</span>
                    <span class="s2">: </span><span class="s1">null;</span>
            <span class="s1">if </span><span class="s2">(slotOutlet) {</span>
                <span class="s3">// &lt;slot v-for=&quot;...&quot;&gt; or &lt;template v-for=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                <span class="s2">childBlock = slotOutlet.codegenNode</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s3">// &lt;template v-for=&quot;...&quot; :key=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                    <span class="s3">// we need to inject the key to the renderSlot() call.</span>
                    <span class="s3">// the props for renderSlot is passed as the 3rd argument.</span>
                    <span class="s2">injectProp(childBlock</span><span class="s1">, </span><span class="s2">keyProperty</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(needFragmentWrapper) {</span>
                <span class="s3">// &lt;template v-for=&quot;...&quot;&gt; with text or multi-elements</span>
                <span class="s3">// should generate a fragment block for each loop</span>
                <span class="s2">childBlock = createVNodeCall(context</span><span class="s1">, </span><span class="s2">helper(FRAGMENT)</span><span class="s1">, </span><span class="s2">keyProperty ? createObjectExpression([keyProperty]) : undefined</span><span class="s1">, </span><span class="s2">node.children</span><span class="s1">, </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s2">+</span>
                    <span class="s2">(</span><span class="s0">` /* </span><span class="s2">${shared.PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">]} </span><span class="s0">*/`</span>
                        <span class="s2">)</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, true, </span><span class="s2">undefined</span><span class="s1">, false </span><span class="s3">/* isComponent */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// Normal element v-for. Directly use the child's codegenNode</span>
                <span class="s3">// but mark it as a block.</span>
                <span class="s2">childBlock = children[</span><span class="s4">0</span><span class="s2">]</span>
                    <span class="s2">.codegenNode</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s2">injectProp(childBlock</span><span class="s1">, </span><span class="s2">keyProperty</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(childBlock.isBlock !== !isStableFragment) {</span>
                    <span class="s1">if </span><span class="s2">(childBlock.isBlock) {</span>
                        <span class="s3">// switch from block to vnode</span>
                        <span class="s2">removeHelper(OPEN_BLOCK)</span><span class="s1">;</span>
                        <span class="s2">removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s1">, </span><span class="s2">childBlock.isComponent))</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s3">// switch from vnode to block</span>
                        <span class="s2">removeHelper(getVNodeHelper(context.inSSR</span><span class="s1">, </span><span class="s2">childBlock.isComponent))</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s2">childBlock.isBlock = !isStableFragment</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(childBlock.isBlock) {</span>
                    <span class="s2">helper(OPEN_BLOCK)</span><span class="s1">;</span>
                    <span class="s2">helper(getVNodeBlockHelper(context.inSSR</span><span class="s1">, </span><span class="s2">childBlock.isComponent))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">helper(getVNodeHelper(context.inSSR</span><span class="s1">, </span><span class="s2">childBlock.isComponent))</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(memo) {</span>
                <span class="s1">const </span><span class="s2">loop = createFunctionExpression(createForLoopParams(forNode.parseResult</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">createSimpleExpression(</span><span class="s0">`_cached`</span><span class="s2">)</span>
                <span class="s2">]))</span><span class="s1">;</span>
                <span class="s2">loop.body = createBlockStatement([</span>
                    <span class="s2">createCompoundExpression([</span><span class="s0">`const _memo = (`</span><span class="s1">, </span><span class="s2">memo.exp</span><span class="s1">, </span><span class="s0">`)`</span><span class="s2">])</span><span class="s1">,</span>
                    <span class="s2">createCompoundExpression([</span>
                        <span class="s0">`if (_cached`</span><span class="s1">,</span>
                        <span class="s2">...(keyExp ? [</span><span class="s0">` &amp;&amp; _cached.key === `</span><span class="s1">, </span><span class="s2">keyExp] : [])</span><span class="s1">,</span>
                        <span class="s0">` &amp;&amp; </span><span class="s2">${context.helperString(IS_MEMO_SAME)}</span><span class="s0">(_cached, _memo)) return _cached`</span>
                    <span class="s2">])</span><span class="s1">,</span>
                    <span class="s2">createCompoundExpression([</span><span class="s0">`const _item = `</span><span class="s1">, </span><span class="s2">childBlock])</span><span class="s1">,</span>
                    <span class="s2">createSimpleExpression(</span><span class="s0">`_item.memo = _memo`</span><span class="s2">)</span><span class="s1">,</span>
                    <span class="s2">createSimpleExpression(</span><span class="s0">`return _item`</span><span class="s2">)</span>
                <span class="s2">])</span><span class="s1">;</span>
                <span class="s2">renderExp.arguments.push(loop</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">`_cache`</span><span class="s2">)</span><span class="s1">, </span><span class="s2">createSimpleExpression(String(context.cached++)))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult)</span><span class="s1">, </span><span class="s2">childBlock</span><span class="s1">, true </span><span class="s3">/* force newline */</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s3">// target-agnostic transform used for both Client and SSR</span>
<span class="s1">function </span><span class="s2">processFor(node</span><span class="s1">, </span><span class="s2">dir</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">processCodegen) {</span>
    <span class="s1">if </span><span class="s2">(!dir.exp) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">31 </span><span class="s3">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">dir.loc))</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">parseResult = parseForExpression(</span>
    <span class="s3">// can only be simple expression because vFor transform is applied</span>
    <span class="s3">// before expression transform.</span>
    <span class="s2">dir.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!parseResult) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s1">, </span><span class="s2">dir.loc))</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ addIdentifiers</span><span class="s1">, </span><span class="s2">removeIdentifiers</span><span class="s1">, </span><span class="s2">scopes } = context</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ source</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">index } = parseResult</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">forNode = {</span>
        <span class="s2">type: </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">,</span>
        <span class="s2">loc: dir.loc</span><span class="s1">,</span>
        <span class="s2">source</span><span class="s1">,</span>
        <span class="s2">valueAlias: value</span><span class="s1">,</span>
        <span class="s2">keyAlias: key</span><span class="s1">,</span>
        <span class="s2">objectIndexAlias: index</span><span class="s1">,</span>
        <span class="s2">parseResult</span><span class="s1">,</span>
        <span class="s2">children: isTemplateNode(node) ? node.children : [node]</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">context.replaceNode(forNode)</span><span class="s1">;</span>
    <span class="s3">// bookkeeping</span>
    <span class="s2">scopes.vFor++</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
        <span class="s3">// scope management</span>
        <span class="s3">// inject identifiers to context</span>
        <span class="s2">value &amp;&amp; addIdentifiers(value)</span><span class="s1">;</span>
        <span class="s2">key &amp;&amp; addIdentifiers(key)</span><span class="s1">;</span>
        <span class="s2">index &amp;&amp; addIdentifiers(index)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">onExit = processCodegen &amp;&amp; processCodegen(forNode)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">() =&gt; {</span>
        <span class="s2">scopes.vFor--</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
            <span class="s2">value &amp;&amp; removeIdentifiers(value)</span><span class="s1">;</span>
            <span class="s2">key &amp;&amp; removeIdentifiers(key)</span><span class="s1">;</span>
            <span class="s2">index &amp;&amp; removeIdentifiers(index)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(onExit)</span>
            <span class="s2">onExit()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">forAliasRE = </span><span class="s4">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span><span class="s1">;</span>
<span class="s3">// This regex doesn't cover the case if key or index aliases have destructuring,</span>
<span class="s3">// but those do not make sense in the first place, so this works in practice.</span>
<span class="s1">const </span><span class="s2">forIteratorRE = </span><span class="s4">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">stripParensRE = </span><span class="s4">/^\(|\)$/g</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">parseForExpression(input</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">loc = input.loc</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">exp = input.content</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">inMatch = exp.match(forAliasRE)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!inMatch)</span>
        <span class="s1">return;</span>
    <span class="s1">const </span><span class="s2">[</span><span class="s1">, </span><span class="s2">LHS</span><span class="s1">, </span><span class="s2">RHS] = inMatch</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">result = {</span>
        <span class="s2">source: createAliasExpression(loc</span><span class="s1">, </span><span class="s2">RHS.trim()</span><span class="s1">, </span><span class="s2">exp.indexOf(RHS</span><span class="s1">, </span><span class="s2">LHS.length))</span><span class="s1">,</span>
        <span class="s2">value: undefined</span><span class="s1">,</span>
        <span class="s2">key: undefined</span><span class="s1">,</span>
        <span class="s2">index: undefined</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
        <span class="s2">result.source = processExpression(result.source</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">valueContent = LHS.trim().replace(stripParensRE</span><span class="s1">, </span><span class="s0">''</span><span class="s2">).trim()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">trimmedOffset = LHS.indexOf(valueContent)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">iteratorMatch = valueContent.match(forIteratorRE)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(iteratorMatch) {</span>
        <span class="s2">valueContent = valueContent.replace(forIteratorRE</span><span class="s1">, </span><span class="s0">''</span><span class="s2">).trim()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keyContent = iteratorMatch[</span><span class="s4">1</span><span class="s2">].trim()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">keyOffset</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(keyContent) {</span>
            <span class="s2">keyOffset = exp.indexOf(keyContent</span><span class="s1">, </span><span class="s2">trimmedOffset + valueContent.length)</span><span class="s1">;</span>
            <span class="s2">result.key = createAliasExpression(loc</span><span class="s1">, </span><span class="s2">keyContent</span><span class="s1">, </span><span class="s2">keyOffset)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
                <span class="s2">result.key = processExpression(result.key</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(iteratorMatch[</span><span class="s4">2</span><span class="s2">]) {</span>
            <span class="s1">const </span><span class="s2">indexContent = iteratorMatch[</span><span class="s4">2</span><span class="s2">].trim()</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(indexContent) {</span>
                <span class="s2">result.index = createAliasExpression(loc</span><span class="s1">, </span><span class="s2">indexContent</span><span class="s1">, </span><span class="s2">exp.indexOf(indexContent</span><span class="s1">, </span><span class="s2">result.key</span>
                    <span class="s2">? keyOffset + keyContent.length</span>
                    <span class="s2">: trimmedOffset + valueContent.length))</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
                    <span class="s2">result.index = processExpression(result.index</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(valueContent) {</span>
        <span class="s2">result.value = createAliasExpression(loc</span><span class="s1">, </span><span class="s2">valueContent</span><span class="s1">, </span><span class="s2">trimmedOffset)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
            <span class="s2">result.value = processExpression(result.value</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createAliasExpression(range</span><span class="s1">, </span><span class="s2">content</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s1">return </span><span class="s2">createSimpleExpression(content</span><span class="s1">, false, </span><span class="s2">getInnerRange(range</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">content.length))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createForLoopParams({ value</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">index }</span><span class="s1">, </span><span class="s2">memoArgs = []) {</span>
    <span class="s1">return </span><span class="s2">createParamsList([value</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">...memoArgs])</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createParamsList(args) {</span>
    <span class="s1">let </span><span class="s2">i = args.length</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(i--) {</span>
        <span class="s1">if </span><span class="s2">(args[i])</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">args</span>
        <span class="s2">.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">i + </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s2">.map((arg</span><span class="s1">, </span><span class="s2">i) =&gt; arg || createSimpleExpression(</span><span class="s0">`_`</span><span class="s2">.repeat(i + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">, false</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">defaultFallback = createSimpleExpression(</span><span class="s0">`undefined`</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
<span class="s3">// A NodeTransform that:</span>
<span class="s3">// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
<span class="s3">//    by transformExpression. This is only applied in non-browser builds with</span>
<span class="s3">//    { prefixIdentifiers: true }.</span>
<span class="s3">// 2. Track v-slot depths so that we know a slot is inside another slot.</span>
<span class="s3">//    Note the exit callback is executed before buildSlots() on the same node,</span>
<span class="s3">//    so only nested slots see positive numbers.</span>
<span class="s1">const </span><span class="s2">trackSlotScopes = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">(node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */ </span><span class="s2">||</span>
            <span class="s2">node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s2">)) {</span>
        <span class="s3">// We are only checking non-empty v-slot here</span>
        <span class="s3">// since we only care about slots that introduce scope variables.</span>
        <span class="s1">const </span><span class="s2">vSlot = findDir(node</span><span class="s1">, </span><span class="s0">'slot'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(vSlot) {</span>
            <span class="s1">const </span><span class="s2">slotProps = vSlot.exp</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
                <span class="s2">slotProps &amp;&amp; context.addIdentifiers(slotProps)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">context.scopes.vSlot++</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
                    <span class="s2">slotProps &amp;&amp; context.removeIdentifiers(slotProps)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.scopes.vSlot--</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">// A NodeTransform that tracks scope identifiers for scoped slots with v-for.</span>
<span class="s3">// This transform is only applied in non-browser builds with { prefixIdentifiers: true }</span>
<span class="s1">const </span><span class="s2">trackVForSlotScopes = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">let </span><span class="s2">vFor</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isTemplateNode(node) &amp;&amp;</span>
        <span class="s2">node.props.some(isVSlot) &amp;&amp;</span>
        <span class="s2">(vFor = findDir(node</span><span class="s1">, </span><span class="s0">'for'</span><span class="s2">))) {</span>
        <span class="s1">const </span><span class="s2">result = (vFor.parseResult = parseForExpression(vFor.exp</span><span class="s1">, </span><span class="s2">context))</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(result) {</span>
            <span class="s1">const </span><span class="s2">{ value</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">index } = result</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ addIdentifiers</span><span class="s1">, </span><span class="s2">removeIdentifiers } = context</span><span class="s1">;</span>
            <span class="s2">value &amp;&amp; addIdentifiers(value)</span><span class="s1">;</span>
            <span class="s2">key &amp;&amp; addIdentifiers(key)</span><span class="s1">;</span>
            <span class="s2">index &amp;&amp; addIdentifiers(index)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s2">value &amp;&amp; removeIdentifiers(value)</span><span class="s1">;</span>
                <span class="s2">key &amp;&amp; removeIdentifiers(key)</span><span class="s1">;</span>
                <span class="s2">index &amp;&amp; removeIdentifiers(index)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">buildClientSlotFn = (props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">loc) =&gt; createFunctionExpression(props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, false </span><span class="s3">/* newline */</span><span class="s1">, true </span><span class="s3">/* isSlot */</span><span class="s1">, </span><span class="s2">children.length ? children[</span><span class="s4">0</span><span class="s2">].loc : loc)</span><span class="s1">;</span>
<span class="s3">// Instead of being a DirectiveTransform, v-slot processing is called during</span>
<span class="s3">// transformElement to build the slots object for a component.</span>
<span class="s1">function </span><span class="s2">buildSlots(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">buildSlotFn = buildClientSlotFn) {</span>
    <span class="s2">context.helper(WITH_CTX)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ children</span><span class="s1">, </span><span class="s2">loc } = node</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">slotsProperties = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">dynamicSlots = []</span><span class="s1">;</span>
    <span class="s3">// If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
    <span class="s3">// since it likely uses a scope variable.</span>
    <span class="s1">let </span><span class="s2">hasDynamicSlots = context.scopes.vSlot &gt; </span><span class="s4">0 </span><span class="s2">|| context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">// with `prefixIdentifiers: true`, this can be further optimized to make</span>
    <span class="s3">// it dynamic only when the slot actually uses the scope variables.</span>
    <span class="s1">if </span><span class="s2">(!context.ssr &amp;&amp; context.prefixIdentifiers) {</span>
        <span class="s2">hasDynamicSlots = hasScopeRef(node</span><span class="s1">, </span><span class="s2">context.identifiers)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 1. Check for slot with slotProps on component itself.</span>
    <span class="s3">//    &lt;Comp v-slot=&quot;{ prop }&quot;/&gt;</span>
    <span class="s1">const </span><span class="s2">onComponentSlot = findDir(node</span><span class="s1">, </span><span class="s0">'slot'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(onComponentSlot) {</span>
        <span class="s1">const </span><span class="s2">{ arg</span><span class="s1">, </span><span class="s2">exp } = onComponentSlot</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(arg &amp;&amp; !isStaticExp(arg)) {</span>
            <span class="s2">hasDynamicSlots = </span><span class="s1">true;</span>
        <span class="s2">}</span>
        <span class="s2">slotsProperties.push(createObjectProperty(arg || createSimpleExpression(</span><span class="s0">'default'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">, </span><span class="s2">buildSlotFn(exp</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">loc)))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 2. Iterate through children and check for template slots</span>
    <span class="s3">//    &lt;template v-slot:foo=&quot;{ prop }&quot;&gt;</span>
    <span class="s1">let </span><span class="s2">hasTemplateSlots = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasNamedDefaultSlot = </span><span class="s1">false;</span>
    <span class="s1">const </span><span class="s2">implicitDefaultChildren = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">seenSlotNames = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">conditionalBranchIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">slotElement = children[i]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">slotDir</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!isTemplateNode(slotElement) ||</span>
            <span class="s2">!(slotDir = findDir(slotElement</span><span class="s1">, </span><span class="s0">'slot'</span><span class="s1">, true</span><span class="s2">))) {</span>
            <span class="s3">// not a &lt;template v-slot&gt;, skip.</span>
            <span class="s1">if </span><span class="s2">(slotElement.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">) {</span>
                <span class="s2">implicitDefaultChildren.push(slotElement)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(onComponentSlot) {</span>
            <span class="s3">// already has on-component slot - this is incorrect usage.</span>
            <span class="s2">context.onError(createCompilerError(</span><span class="s4">37 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s1">, </span><span class="s2">slotDir.loc))</span><span class="s1">;</span>
            <span class="s1">break;</span>
        <span class="s2">}</span>
        <span class="s2">hasTemplateSlots = </span><span class="s1">true;</span>
        <span class="s1">const </span><span class="s2">{ children: slotChildren</span><span class="s1">, </span><span class="s2">loc: slotLoc } = slotElement</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ arg: slotName = createSimpleExpression(</span><span class="s0">`default`</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">, </span><span class="s2">exp: slotProps</span><span class="s1">, </span><span class="s2">loc: dirLoc } = slotDir</span><span class="s1">;</span>
        <span class="s3">// check if name is dynamic.</span>
        <span class="s1">let </span><span class="s2">staticSlotName</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isStaticExp(slotName)) {</span>
            <span class="s2">staticSlotName = slotName ? slotName.content : </span><span class="s0">`default`</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hasDynamicSlots = </span><span class="s1">true;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">slotFunction = buildSlotFn(slotProps</span><span class="s1">, </span><span class="s2">slotChildren</span><span class="s1">, </span><span class="s2">slotLoc)</span><span class="s1">;</span>
        <span class="s3">// check if this slot is conditional (v-if/v-for)</span>
        <span class="s1">let </span><span class="s2">vIf</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vElse</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vFor</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((vIf = findDir(slotElement</span><span class="s1">, </span><span class="s0">'if'</span><span class="s2">))) {</span>
            <span class="s2">hasDynamicSlots = </span><span class="s1">true;</span>
            <span class="s2">dynamicSlots.push(createConditionalExpression(vIf.exp</span><span class="s1">, </span><span class="s2">buildDynamicSlot(slotName</span><span class="s1">, </span><span class="s2">slotFunction</span><span class="s1">, </span><span class="s2">conditionalBranchIndex++)</span><span class="s1">, </span><span class="s2">defaultFallback))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">((vElse = findDir(slotElement</span><span class="s1">, </span><span class="s4">/^else(-if)?$/</span><span class="s1">, true </span><span class="s3">/* allowEmpty */</span><span class="s2">))) {</span>
            <span class="s3">// find adjacent v-if</span>
            <span class="s1">let </span><span class="s2">j = i</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">prev</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(j--) {</span>
                <span class="s2">prev = children[j]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prev.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s2">) {</span>
                    <span class="s1">break;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(prev &amp;&amp; isTemplateNode(prev) &amp;&amp; findDir(prev</span><span class="s1">, </span><span class="s0">'if'</span><span class="s2">)) {</span>
                <span class="s3">// remove node</span>
                <span class="s2">children.splice(i</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">i--</span><span class="s1">;</span>
                <span class="s3">// attach this slot to previous conditional</span>
                <span class="s1">let </span><span class="s2">conditional = dynamicSlots[dynamicSlots.length - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(conditional.alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">) {</span>
                    <span class="s2">conditional = conditional.alternate</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">conditional.alternate = vElse.exp</span>
                    <span class="s2">? createConditionalExpression(vElse.exp</span><span class="s1">, </span><span class="s2">buildDynamicSlot(slotName</span><span class="s1">, </span><span class="s2">slotFunction</span><span class="s1">, </span><span class="s2">conditionalBranchIndex++)</span><span class="s1">, </span><span class="s2">defaultFallback)</span>
                    <span class="s2">: buildDynamicSlot(slotName</span><span class="s1">, </span><span class="s2">slotFunction</span><span class="s1">, </span><span class="s2">conditionalBranchIndex++)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">, </span><span class="s2">vElse.loc))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">((vFor = findDir(slotElement</span><span class="s1">, </span><span class="s0">'for'</span><span class="s2">))) {</span>
            <span class="s2">hasDynamicSlots = </span><span class="s1">true;</span>
            <span class="s1">const </span><span class="s2">parseResult = vFor.parseResult ||</span>
                <span class="s2">parseForExpression(vFor.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parseResult) {</span>
                <span class="s3">// Render the dynamic slots as an array and add it to the createSlot()</span>
                <span class="s3">// args. The runtime knows how to handle it appropriately.</span>
                <span class="s2">dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST)</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">parseResult.source</span><span class="s1">,</span>
                    <span class="s2">createFunctionExpression(createForLoopParams(parseResult)</span><span class="s1">, </span><span class="s2">buildDynamicSlot(slotName</span><span class="s1">, </span><span class="s2">slotFunction)</span><span class="s1">, true </span><span class="s3">/* force newline */</span><span class="s2">)</span>
                <span class="s2">]))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s1">, </span><span class="s2">vFor.loc))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// check duplicate static names</span>
            <span class="s1">if </span><span class="s2">(staticSlotName) {</span>
                <span class="s1">if </span><span class="s2">(seenSlotNames.has(staticSlotName)) {</span>
                    <span class="s2">context.onError(createCompilerError(</span><span class="s4">38 </span><span class="s3">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s1">, </span><span class="s2">dirLoc))</span><span class="s1">;</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s2">seenSlotNames.add(staticSlotName)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(staticSlotName === </span><span class="s0">'default'</span><span class="s2">) {</span>
                    <span class="s2">hasNamedDefaultSlot = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">slotsProperties.push(createObjectProperty(slotName</span><span class="s1">, </span><span class="s2">slotFunction))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!onComponentSlot) {</span>
        <span class="s1">const </span><span class="s2">buildDefaultSlotProperty = (props</span><span class="s1">, </span><span class="s2">children) =&gt; {</span>
            <span class="s1">const </span><span class="s2">fn = buildSlotFn(props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">loc)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(context.compatConfig) {</span>
                <span class="s2">fn.isNonScopedSlot = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">createObjectProperty(</span><span class="s0">`default`</span><span class="s1">, </span><span class="s2">fn)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!hasTemplateSlots) {</span>
            <span class="s3">// implicit default slot (on component)</span>
            <span class="s2">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s1">, </span><span class="s2">children))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(implicitDefaultChildren.length &amp;&amp;</span>
            <span class="s3">// #3766</span>
            <span class="s3">// with whitespace: 'preserve', whitespaces between slots will end up in</span>
            <span class="s3">// implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
            <span class="s2">implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))) {</span>
            <span class="s3">// implicit default slot (mixed with named slots)</span>
            <span class="s1">if </span><span class="s2">(hasNamedDefaultSlot) {</span>
                <span class="s2">context.onError(createCompilerError(</span><span class="s4">39 </span><span class="s3">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s1">, </span><span class="s2">implicitDefaultChildren[</span><span class="s4">0</span><span class="s2">].loc))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s1">, </span><span class="s2">implicitDefaultChildren))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">slotFlag = hasDynamicSlots</span>
        <span class="s2">? </span><span class="s4">2 </span><span class="s3">/* SlotFlags.DYNAMIC */</span>
        <span class="s2">: hasForwardedSlots(node.children)</span>
            <span class="s2">? </span><span class="s4">3 </span><span class="s3">/* SlotFlags.FORWARDED */</span>
            <span class="s2">: </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">slots = createObjectExpression(slotsProperties.concat(createObjectProperty(</span><span class="s0">`_`</span><span class="s1">, </span>
    <span class="s3">// 2 = compiled but dynamic = can skip normalization, but must run diff</span>
    <span class="s3">// 1 = compiled and static = can skip normalization AND diff as optimized</span>
    <span class="s2">createSimpleExpression(slotFlag + (</span><span class="s0">` /* </span><span class="s2">${shared.slotFlagsText[slotFlag]} </span><span class="s0">*/` </span><span class="s2">)</span><span class="s1">, false</span><span class="s2">)))</span><span class="s1">, </span><span class="s2">loc)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(dynamicSlots.length) {</span>
        <span class="s2">slots = createCallExpression(context.helper(CREATE_SLOTS)</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s2">slots</span><span class="s1">,</span>
            <span class="s2">createArrayExpression(dynamicSlots)</span>
        <span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">slots</span><span class="s1">,</span>
        <span class="s2">hasDynamicSlots</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">buildDynamicSlot(name</span><span class="s1">, </span><span class="s2">fn</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">const </span><span class="s2">props = [</span>
        <span class="s2">createObjectProperty(</span><span class="s0">`name`</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">,</span>
        <span class="s2">createObjectProperty(</span><span class="s0">`fn`</span><span class="s1">, </span><span class="s2">fn)</span>
    <span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(index != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">props.push(createObjectProperty(</span><span class="s0">`key`</span><span class="s1">, </span><span class="s2">createSimpleExpression(String(index)</span><span class="s1">, true</span><span class="s2">)))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">createObjectExpression(props)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasForwardedSlots(children) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s1">switch </span><span class="s2">(child.type) {</span>
            <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(child.tagType === </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */ </span><span class="s2">||</span>
                    <span class="s2">hasForwardedSlots(child.children)) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(hasForwardedSlots(child.branches))</span>
                    <span class="s1">return true;</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">:</span>
            <span class="s1">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(hasForwardedSlots(child.children))</span>
                    <span class="s1">return true;</span>
                <span class="s1">break;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isNonWhitespaceContent(node) {</span>
    <span class="s1">if </span><span class="s2">(node.type !== </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s2">&amp;&amp; node.type !== </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s2">)</span>
        <span class="s1">return true;</span>
    <span class="s1">return </span><span class="s2">node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span>
        <span class="s2">? !!node.content.trim()</span>
        <span class="s2">: isNonWhitespaceContent(node.content)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">// some directive transforms (e.g. v-model) may return a symbol for runtime</span>
<span class="s3">// import, which should be used instead of a resolveDirective call.</span>
<span class="s1">const </span><span class="s2">directiveImportMap = </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">;</span>
<span class="s3">// generate a JavaScript AST for this element's codegen</span>
<span class="s1">const </span><span class="s2">transformElement = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s3">// perform the work on exit, after all child expressions have been</span>
    <span class="s3">// processed and merged.</span>
    <span class="s1">return function </span><span class="s2">postTransformElement() {</span>
        <span class="s2">node = context.currentNode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s2">||</span>
                <span class="s2">node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s2">))) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">{ tag</span><span class="s1">, </span><span class="s2">props } = node</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isComponent = node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">;</span>
        <span class="s3">// The goal of the transform is to create a codegenNode implementing the</span>
        <span class="s3">// VNodeCall interface.</span>
        <span class="s1">let </span><span class="s2">vnodeTag = isComponent</span>
            <span class="s2">? resolveComponentType(node</span><span class="s1">, </span><span class="s2">context)</span>
            <span class="s2">: </span><span class="s0">`&quot;</span><span class="s2">${tag}</span><span class="s0">&quot;`</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isDynamicComponent = shared.isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeProps</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeChildren</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodePatchFlag</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeDynamicProps</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">dynamicPropNames</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeDirectives</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">shouldUseBlock = </span>
        <span class="s3">// dynamic component may resolve to plain elements</span>
        <span class="s2">isDynamicComponent ||</span>
            <span class="s2">vnodeTag === TELEPORT ||</span>
            <span class="s2">vnodeTag === SUSPENSE ||</span>
            <span class="s2">(!isComponent &amp;&amp;</span>
                <span class="s3">// &lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
                <span class="s3">// updates inside get proper isSVG flag at runtime. (#639, #643)</span>
                <span class="s3">// This is technically web-specific, but splitting the logic out of core</span>
                <span class="s3">// leads to too much unnecessary complexity.</span>
                <span class="s2">(tag === </span><span class="s0">'svg' </span><span class="s2">|| tag === </span><span class="s0">'foreignObject'</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s3">// props</span>
        <span class="s1">if </span><span class="s2">(props.length &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">propsBuildResult = buildProps(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">isComponent</span><span class="s1">, </span><span class="s2">isDynamicComponent)</span><span class="s1">;</span>
            <span class="s2">vnodeProps = propsBuildResult.props</span><span class="s1">;</span>
            <span class="s2">patchFlag = propsBuildResult.patchFlag</span><span class="s1">;</span>
            <span class="s2">dynamicPropNames = propsBuildResult.dynamicPropNames</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">directives = propsBuildResult.directives</span><span class="s1">;</span>
            <span class="s2">vnodeDirectives =</span>
                <span class="s2">directives &amp;&amp; directives.length</span>
                    <span class="s2">? createArrayExpression(directives.map(dir =&gt; buildDirectiveArgs(dir</span><span class="s1">, </span><span class="s2">context)))</span>
                    <span class="s2">: undefined</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(propsBuildResult.shouldUseBlock) {</span>
                <span class="s2">shouldUseBlock = </span><span class="s1">true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// children</span>
        <span class="s1">if </span><span class="s2">(node.children.length &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(vnodeTag === KEEP_ALIVE) {</span>
                <span class="s3">// Although a built-in component, we compile KeepAlive with raw children</span>
                <span class="s3">// instead of slot functions so that it can be used inside Transition</span>
                <span class="s3">// or other Transition-wrapping HOCs.</span>
                <span class="s3">// To ensure correct updates with block optimizations, we need to:</span>
                <span class="s3">// 1. Force keep-alive into a block. This avoids its children being</span>
                <span class="s3">//    collected by a parent block.</span>
                <span class="s2">shouldUseBlock = </span><span class="s1">true;</span>
                <span class="s3">// 2. Force keep-alive to always be updated, since it uses raw children.</span>
                <span class="s2">patchFlag |= </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(node.children.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
                    <span class="s2">context.onError(createCompilerError(</span><span class="s4">46 </span><span class="s3">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s1">, </span><span class="s2">{</span>
                        <span class="s2">start: node.children[</span><span class="s4">0</span><span class="s2">].loc.start</span><span class="s1">,</span>
                        <span class="s2">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s2">].loc.end</span><span class="s1">,</span>
                        <span class="s2">source: </span><span class="s0">''</span>
                    <span class="s2">}))</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">shouldBuildAsSlots = isComponent &amp;&amp;</span>
                <span class="s3">// Teleport is not a real component and has dedicated runtime handling</span>
                <span class="s2">vnodeTag !== TELEPORT &amp;&amp;</span>
                <span class="s3">// explained above.</span>
                <span class="s2">vnodeTag !== KEEP_ALIVE</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shouldBuildAsSlots) {</span>
                <span class="s1">const </span><span class="s2">{ slots</span><span class="s1">, </span><span class="s2">hasDynamicSlots } = buildSlots(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">vnodeChildren = slots</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(hasDynamicSlots) {</span>
                    <span class="s2">patchFlag |= </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(node.children.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp; vnodeTag !== TELEPORT) {</span>
                <span class="s1">const </span><span class="s2">child = node.children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">type = child.type</span><span class="s1">;</span>
                <span class="s3">// check for dynamic text children</span>
                <span class="s1">const </span><span class="s2">hasDynamicTextChild = type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s2">||</span>
                    <span class="s2">type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(hasDynamicTextChild &amp;&amp;</span>
                    <span class="s2">getConstantType(child</span><span class="s1">, </span><span class="s2">context) === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                    <span class="s2">patchFlag |= </span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// pass directly if the only child is a text node</span>
                <span class="s3">// (plain / interpolation / expression)</span>
                <span class="s1">if </span><span class="s2">(hasDynamicTextChild || type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s2">) {</span>
                    <span class="s2">vnodeChildren = child</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">vnodeChildren = node.children</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">vnodeChildren = node.children</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// patchFlag &amp; dynamicPropNames</span>
        <span class="s1">if </span><span class="s2">(patchFlag !== </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(patchFlag &lt; </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s3">// special flags (negative and mutually exclusive)</span>
                    <span class="s2">vnodePatchFlag = patchFlag + </span><span class="s0">` /* </span><span class="s2">${shared.PatchFlagNames[patchFlag]} </span><span class="s0">*/`</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s3">// bitwise flags</span>
                    <span class="s1">const </span><span class="s2">flagNames = Object.keys(shared.PatchFlagNames)</span>
                        <span class="s2">.map(Number)</span>
                        <span class="s2">.filter(n =&gt; n &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp; patchFlag &amp; n)</span>
                        <span class="s2">.map(n =&gt; shared.PatchFlagNames[n])</span>
                        <span class="s2">.join(</span><span class="s0">`, `</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">vnodePatchFlag = patchFlag + </span><span class="s0">` /* </span><span class="s2">${flagNames} </span><span class="s0">*/`</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(dynamicPropNames &amp;&amp; dynamicPropNames.length) {</span>
                <span class="s2">vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">node.codegenNode = createVNodeCall(context</span><span class="s1">, </span><span class="s2">vnodeTag</span><span class="s1">, </span><span class="s2">vnodeProps</span><span class="s1">, </span><span class="s2">vnodeChildren</span><span class="s1">, </span><span class="s2">vnodePatchFlag</span><span class="s1">, </span><span class="s2">vnodeDynamicProps</span><span class="s1">, </span><span class="s2">vnodeDirectives</span><span class="s1">, </span><span class="s2">!!shouldUseBlock</span><span class="s1">, false </span><span class="s3">/* disableTracking */</span><span class="s1">, </span><span class="s2">isComponent</span><span class="s1">, </span><span class="s2">node.loc)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">resolveComponentType(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">ssr = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">let </span><span class="s2">{ tag } = node</span><span class="s1">;</span>
    <span class="s3">// 1. dynamic component</span>
    <span class="s1">const </span><span class="s2">isExplicitDynamic = isComponentTag(tag)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isProp = findProp(node</span><span class="s1">, </span><span class="s0">'is'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isProp) {</span>
        <span class="s1">if </span><span class="s2">(isExplicitDynamic ||</span>
            <span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">, </span><span class="s2">context))) {</span>
            <span class="s1">const </span><span class="s2">exp = isProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s2">? isProp.value &amp;&amp; createSimpleExpression(isProp.value.content</span><span class="s1">, true</span><span class="s2">)</span>
                <span class="s2">: isProp.exp</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(exp) {</span>
                <span class="s1">return </span><span class="s2">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">exp</span>
                <span class="s2">])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(isProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">isProp.value.content.startsWith(</span><span class="s0">'vue:'</span><span class="s2">)) {</span>
            <span class="s3">// &lt;button is=&quot;vue:xxx&quot;&gt;</span>
            <span class="s3">// if not &lt;component&gt;, only is value that starts with &quot;vue:&quot; will be</span>
            <span class="s3">// treated as component by the parse phase and reach here, unless it's</span>
            <span class="s3">// compat mode where all is values are considered components</span>
            <span class="s2">tag = isProp.value.content.slice(</span><span class="s4">4</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// 1.5 v-is (TODO: Deprecate)</span>
    <span class="s1">const </span><span class="s2">isDir = !isExplicitDynamic &amp;&amp; findDir(node</span><span class="s1">, </span><span class="s0">'is'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isDir &amp;&amp; isDir.exp) {</span>
        <span class="s1">return </span><span class="s2">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s2">isDir.exp</span>
        <span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
    <span class="s1">const </span><span class="s2">builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(builtIn) {</span>
        <span class="s3">// built-ins are simply fallthroughs / have special handling during ssr</span>
        <span class="s3">// so we don't need to import their runtime equivalents</span>
        <span class="s1">if </span><span class="s2">(!ssr)</span>
            <span class="s2">context.helper(builtIn)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">builtIn</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 3. user component (from setup bindings)</span>
    <span class="s3">// this is skipped in browser build since browser builds do not perform</span>
    <span class="s3">// binding analysis.</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">fromSetup = resolveSetupReference(tag</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(fromSetup) {</span>
            <span class="s1">return </span><span class="s2">fromSetup</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">dotIndex = tag.indexOf(</span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dotIndex &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">ns = resolveSetupReference(tag.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">dotIndex)</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(ns) {</span>
                <span class="s1">return </span><span class="s2">ns + tag.slice(dotIndex)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// 4. Self referencing component (inferred from filename)</span>
    <span class="s1">if </span><span class="s2">(context.selfName &amp;&amp;</span>
        <span class="s2">shared.capitalize(shared.camelize(tag)) === context.selfName) {</span>
        <span class="s2">context.helper(RESOLVE_COMPONENT)</span><span class="s1">;</span>
        <span class="s3">// codegen.ts has special check for __self postfix when generating</span>
        <span class="s3">// component imports, which will pass additional `maybeSelfReference` flag</span>
        <span class="s3">// to `resolveComponent`.</span>
        <span class="s2">context.components.add(tag + </span><span class="s0">`__self`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">toValidAssetId(tag</span><span class="s1">, </span><span class="s0">`component`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 5. user component (resolve)</span>
    <span class="s2">context.helper(RESOLVE_COMPONENT)</span><span class="s1">;</span>
    <span class="s2">context.components.add(tag)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">toValidAssetId(tag</span><span class="s1">, </span><span class="s0">`component`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveSetupReference(name</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">bindings = context.bindingMetadata</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!bindings || bindings.__isScriptSetup === </span><span class="s1">false</span><span class="s2">) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">camelName = shared.camelize(name)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">PascalName = shared.capitalize(camelName)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">checkType = (type) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(bindings[name] === type) {</span>
            <span class="s1">return </span><span class="s2">name</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(bindings[camelName] === type) {</span>
            <span class="s1">return </span><span class="s2">camelName</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(bindings[PascalName] === type) {</span>
            <span class="s1">return </span><span class="s2">PascalName</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">fromConst = checkType(</span><span class="s0">&quot;setup-const&quot; </span><span class="s3">/* BindingTypes.SETUP_CONST */</span><span class="s2">) ||</span>
        <span class="s2">checkType(</span><span class="s0">&quot;setup-reactive-const&quot; </span><span class="s3">/* BindingTypes.SETUP_REACTIVE_CONST */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(fromConst) {</span>
        <span class="s1">return </span><span class="s2">context.inline</span>
            <span class="s2">? </span><span class="s3">// in inline mode, const setup bindings (e.g. imports) can be used as-is</span>
                <span class="s2">fromConst</span>
            <span class="s2">: </span><span class="s0">`$setup[</span><span class="s2">${JSON.stringify(fromConst)}</span><span class="s0">]`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">fromMaybeRef = checkType(</span><span class="s0">&quot;setup-let&quot; </span><span class="s3">/* BindingTypes.SETUP_LET */</span><span class="s2">) ||</span>
        <span class="s2">checkType(</span><span class="s0">&quot;setup-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_REF */</span><span class="s2">) ||</span>
        <span class="s2">checkType(</span><span class="s0">&quot;setup-maybe-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_MAYBE_REF */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(fromMaybeRef) {</span>
        <span class="s1">return </span><span class="s2">context.inline</span>
            <span class="s2">? </span><span class="s3">// setup scope bindings that may be refs need to be unrefed</span>
                <span class="s0">`</span><span class="s2">${context.helperString(UNREF)}</span><span class="s0">(</span><span class="s2">${fromMaybeRef}</span><span class="s0">)`</span>
            <span class="s2">: </span><span class="s0">`$setup[</span><span class="s2">${JSON.stringify(fromMaybeRef)}</span><span class="s0">]`</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">buildProps(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">props = node.props</span><span class="s1">, </span><span class="s2">isComponent</span><span class="s1">, </span><span class="s2">isDynamicComponent</span><span class="s1">, </span><span class="s2">ssr = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ tag</span><span class="s1">, </span><span class="s2">loc: elementLoc</span><span class="s1">, </span><span class="s2">children } = node</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">properties = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mergeArgs = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">runtimeDirectives = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hasChildren = children.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">shouldUseBlock = </span><span class="s1">false;</span>
    <span class="s3">// patchFlag analysis</span>
    <span class="s1">let </span><span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hasRef = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasClassBinding = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasStyleBinding = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasHydrationEventBinding = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasDynamicKeys = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">hasVnodeHook = </span><span class="s1">false;</span>
    <span class="s1">const </span><span class="s2">dynamicPropNames = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">pushMergeArg = (arg) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(properties.length) {</span>
            <span class="s2">mergeArgs.push(createObjectExpression(dedupeProperties(properties)</span><span class="s1">, </span><span class="s2">elementLoc))</span><span class="s1">;</span>
            <span class="s2">properties = []</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(arg)</span>
            <span class="s2">mergeArgs.push(arg)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">analyzePatchFlag = ({ key</span><span class="s1">, </span><span class="s2">value }) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(isStaticExp(key)) {</span>
            <span class="s1">const </span><span class="s2">name = key.content</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">isEventHandler = shared.isOn(name)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isEventHandler &amp;&amp;</span>
                <span class="s2">(!isComponent || isDynamicComponent) &amp;&amp;</span>
                <span class="s3">// omit the flag for click handlers because hydration gives click</span>
                <span class="s3">// dedicated fast path.</span>
                <span class="s2">name.toLowerCase() !== </span><span class="s0">'onclick' </span><span class="s2">&amp;&amp;</span>
                <span class="s3">// omit v-model handlers</span>
                <span class="s2">name !== </span><span class="s0">'onUpdate:modelValue' </span><span class="s2">&amp;&amp;</span>
                <span class="s3">// omit onVnodeXXX hooks</span>
                <span class="s2">!shared.isReservedProp(name)) {</span>
                <span class="s2">hasHydrationEventBinding = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(isEventHandler &amp;&amp; shared.isReservedProp(name)) {</span>
                <span class="s2">hasVnodeHook = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(value.type === </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */ </span><span class="s2">||</span>
                <span class="s2">((value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">||</span>
                    <span class="s2">value.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">) &amp;&amp;</span>
                    <span class="s2">getConstantType(value</span><span class="s1">, </span><span class="s2">context) &gt; </span><span class="s4">0</span><span class="s2">)) {</span>
                <span class="s3">// skip if the prop is a cached handler or has constant value</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'ref'</span><span class="s2">) {</span>
                <span class="s2">hasRef = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(name === </span><span class="s0">'class'</span><span class="s2">) {</span>
                <span class="s2">hasClassBinding = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(name === </span><span class="s0">'style'</span><span class="s2">) {</span>
                <span class="s2">hasStyleBinding = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(name !== </span><span class="s0">'key' </span><span class="s2">&amp;&amp; !dynamicPropNames.includes(name)) {</span>
                <span class="s2">dynamicPropNames.push(name)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// treat the dynamic class and style binding of the component as dynamic props</span>
            <span class="s1">if </span><span class="s2">(isComponent &amp;&amp;</span>
                <span class="s2">(name === </span><span class="s0">'class' </span><span class="s2">|| name === </span><span class="s0">'style'</span><span class="s2">) &amp;&amp;</span>
                <span class="s2">!dynamicPropNames.includes(name)) {</span>
                <span class="s2">dynamicPropNames.push(name)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hasDynamicKeys = </span><span class="s1">true;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s3">// static attribute</span>
        <span class="s1">const </span><span class="s2">prop = props[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(prop.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">{ loc</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">value } = prop</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">isStatic = </span><span class="s1">true;</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'ref'</span><span class="s2">) {</span>
                <span class="s2">hasRef = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s0">'ref_for'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">'true'</span><span class="s2">)))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// in inline mode there is no setupState object, so we can't use string</span>
                <span class="s3">// keys to set the ref. Instead, we need to transform it to pass the</span>
                <span class="s3">// actual ref instead.</span>
                <span class="s1">if </span><span class="s2">(value &amp;&amp; context.inline) {</span>
                    <span class="s1">const </span><span class="s2">binding = context.bindingMetadata[value.content]</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(binding === </span><span class="s0">&quot;setup-let&quot; </span><span class="s3">/* BindingTypes.SETUP_LET */ </span><span class="s2">||</span>
                        <span class="s2">binding === </span><span class="s0">&quot;setup-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_REF */ </span><span class="s2">||</span>
                        <span class="s2">binding === </span><span class="s0">&quot;setup-maybe-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_MAYBE_REF */</span><span class="s2">) {</span>
                        <span class="s2">isStatic = </span><span class="s1">false;</span>
                        <span class="s2">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s0">'ref_key'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">, </span><span class="s2">createSimpleExpression(value.content</span><span class="s1">, true, </span><span class="s2">value.loc)))</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// skip is on &lt;component&gt;, or is=&quot;vue:xxx&quot;</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'is' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">(isComponentTag(tag) ||</span>
                    <span class="s2">(value &amp;&amp; value.content.startsWith(</span><span class="s0">'vue:'</span><span class="s2">)) ||</span>
                    <span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">, </span><span class="s2">context)))) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s2">properties.push(createObjectProperty(createSimpleExpression(name</span><span class="s1">, true, </span><span class="s2">getInnerRange(loc</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s2">name.length))</span><span class="s1">, </span><span class="s2">createSimpleExpression(value ? value.content : </span><span class="s0">''</span><span class="s1">, </span><span class="s2">isStatic</span><span class="s1">, </span><span class="s2">value ? value.loc : loc)))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// directives</span>
            <span class="s1">const </span><span class="s2">{ name</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">exp</span><span class="s1">, </span><span class="s2">loc } = prop</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">isVBind = name === </span><span class="s0">'bind'</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">isVOn = name === </span><span class="s0">'on'</span><span class="s1">;</span>
            <span class="s3">// skip v-slot - it is handled by its dedicated transform.</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'slot'</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(!isComponent) {</span>
                    <span class="s2">context.onError(createCompilerError(</span><span class="s4">40 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s1">, </span><span class="s2">loc))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s3">// skip v-once/v-memo - they are handled by dedicated transforms.</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'once' </span><span class="s2">|| name === </span><span class="s0">'memo'</span><span class="s2">) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s3">// skip v-is and :is on &lt;component&gt;</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'is' </span><span class="s2">||</span>
                <span class="s2">(isVBind &amp;&amp;</span>
                    <span class="s2">isStaticArgOf(arg</span><span class="s1">, </span><span class="s0">'is'</span><span class="s2">) &amp;&amp;</span>
                    <span class="s2">(isComponentTag(tag) ||</span>
                        <span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">, </span><span class="s2">context))))) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s3">// skip v-on in SSR compilation</span>
            <span class="s1">if </span><span class="s2">(isVOn &amp;&amp; ssr) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(</span>
            <span class="s3">// #938: elements with dynamic keys should be forced into blocks</span>
            <span class="s2">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s1">, </span><span class="s0">'key'</span><span class="s2">)) ||</span>
                <span class="s3">// inline before-update hooks need to force block so that it is invoked</span>
                <span class="s3">// before children</span>
                <span class="s2">(isVOn &amp;&amp; hasChildren &amp;&amp; isStaticArgOf(arg</span><span class="s1">, </span><span class="s0">'vue:before-update'</span><span class="s2">))) {</span>
                <span class="s2">shouldUseBlock = </span><span class="s1">true;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s1">, </span><span class="s0">'ref'</span><span class="s2">) &amp;&amp; context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s2">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s0">'ref_for'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">'true'</span><span class="s2">)))</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// special case for v-bind and v-on with no argument</span>
            <span class="s1">if </span><span class="s2">(!arg &amp;&amp; (isVBind || isVOn)) {</span>
                <span class="s2">hasDynamicKeys = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(exp) {</span>
                    <span class="s1">if </span><span class="s2">(isVBind) {</span>
                        <span class="s3">// have to merge early for compat build check</span>
                        <span class="s2">pushMergeArg()</span><span class="s1">;</span>
                        <span class="s2">{</span>
                            <span class="s3">// 2.x v-bind object order compat</span>
                            <span class="s2">{</span>
                                <span class="s1">const </span><span class="s2">hasOverridableKeys = mergeArgs.some(arg =&gt; {</span>
                                    <span class="s1">if </span><span class="s2">(arg.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">) {</span>
                                        <span class="s1">return </span><span class="s2">arg.properties.some(({ key }) =&gt; {</span>
                                            <span class="s1">if </span><span class="s2">(key.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">||</span>
                                                <span class="s2">!key.isStatic) {</span>
                                                <span class="s1">return true;</span>
                                            <span class="s2">}</span>
                                            <span class="s1">return </span><span class="s2">(key.content !== </span><span class="s0">'class' </span><span class="s2">&amp;&amp;</span>
                                                <span class="s2">key.content !== </span><span class="s0">'style' </span><span class="s2">&amp;&amp;</span>
                                                <span class="s2">!shared.isOn(key.content))</span><span class="s1">;</span>
                                        <span class="s2">})</span><span class="s1">;</span>
                                    <span class="s2">}</span>
                                    <span class="s1">else </span><span class="s2">{</span>
                                        <span class="s3">// dynamic expression</span>
                                        <span class="s1">return true;</span>
                                    <span class="s2">}</span>
                                <span class="s2">})</span><span class="s1">;</span>
                                <span class="s1">if </span><span class="s2">(hasOverridableKeys) {</span>
                                    <span class="s2">checkCompatEnabled(</span><span class="s0">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">loc)</span><span class="s1">;</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s1">if </span><span class="s2">(isCompatEnabled(</span><span class="s0">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s1">, </span><span class="s2">context)) {</span>
                                <span class="s2">mergeArgs.unshift(exp)</span><span class="s1">;</span>
                                <span class="s1">continue;</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s2">mergeArgs.push(exp)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s3">// v-on=&quot;obj&quot; -&gt; toHandlers(obj)</span>
                        <span class="s2">pushMergeArg({</span>
                            <span class="s2">type: </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">,</span>
                            <span class="s2">loc</span><span class="s1">,</span>
                            <span class="s2">callee: context.helper(TO_HANDLERS)</span><span class="s1">,</span>
                            <span class="s2">arguments: isComponent ? [exp] : [exp</span><span class="s1">, </span><span class="s0">`true`</span><span class="s2">]</span>
                        <span class="s2">})</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">context.onError(createCompilerError(isVBind</span>
                        <span class="s2">? </span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span>
                        <span class="s2">: </span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">loc))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">directiveTransform = context.directiveTransforms[name]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(directiveTransform) {</span>
                <span class="s3">// has built-in directive transform.</span>
                <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">needRuntime } = directiveTransform(prop</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">!ssr &amp;&amp; props.forEach(analyzePatchFlag)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(isVOn &amp;&amp; arg &amp;&amp; !isStaticExp(arg)) {</span>
                    <span class="s2">pushMergeArg(createObjectExpression(props</span><span class="s1">, </span><span class="s2">elementLoc))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">properties.push(...props)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(needRuntime) {</span>
                    <span class="s2">runtimeDirectives.push(prop)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(shared.isSymbol(needRuntime)) {</span>
                        <span class="s2">directiveImportMap.set(prop</span><span class="s1">, </span><span class="s2">needRuntime)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!shared.isBuiltInDirective(name)) {</span>
                <span class="s3">// no built-in transform, this is a user custom directive.</span>
                <span class="s2">runtimeDirectives.push(prop)</span><span class="s1">;</span>
                <span class="s3">// custom dirs may use beforeUpdate so they need to force blocks</span>
                <span class="s3">// to ensure before-update gets called before children update</span>
                <span class="s1">if </span><span class="s2">(hasChildren) {</span>
                    <span class="s2">shouldUseBlock = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">propsExpression = undefined</span><span class="s1">;</span>
    <span class="s3">// has v-bind=&quot;object&quot; or v-on=&quot;object&quot;, wrap with mergeProps</span>
    <span class="s1">if </span><span class="s2">(mergeArgs.length) {</span>
        <span class="s3">// close up any not-yet-merged props</span>
        <span class="s2">pushMergeArg()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(mergeArgs.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">propsExpression = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s1">, </span><span class="s2">mergeArgs</span><span class="s1">, </span><span class="s2">elementLoc)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// single v-bind with nothing else - no need for a mergeProps call</span>
            <span class="s2">propsExpression = mergeArgs[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(properties.length) {</span>
        <span class="s2">propsExpression = createObjectExpression(dedupeProperties(properties)</span><span class="s1">, </span><span class="s2">elementLoc)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// patchFlag analysis</span>
    <span class="s1">if </span><span class="s2">(hasDynamicKeys) {</span>
        <span class="s2">patchFlag |= </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(hasClassBinding &amp;&amp; !isComponent) {</span>
            <span class="s2">patchFlag |= </span><span class="s4">2 </span><span class="s3">/* PatchFlags.CLASS */</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(hasStyleBinding &amp;&amp; !isComponent) {</span>
            <span class="s2">patchFlag |= </span><span class="s4">4 </span><span class="s3">/* PatchFlags.STYLE */</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dynamicPropNames.length) {</span>
            <span class="s2">patchFlag |= </span><span class="s4">8 </span><span class="s3">/* PatchFlags.PROPS */</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(hasHydrationEventBinding) {</span>
            <span class="s2">patchFlag |= </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!shouldUseBlock &amp;&amp;</span>
        <span class="s2">(patchFlag === </span><span class="s4">0 </span><span class="s2">|| patchFlag === </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">(hasRef || hasVnodeHook || runtimeDirectives.length &gt; </span><span class="s4">0</span><span class="s2">)) {</span>
        <span class="s2">patchFlag |= </span><span class="s4">512 </span><span class="s3">/* PatchFlags.NEED_PATCH */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// pre-normalize props, SSR is skipped for now</span>
    <span class="s1">if </span><span class="s2">(!context.inSSR &amp;&amp; propsExpression) {</span>
        <span class="s1">switch </span><span class="s2">(propsExpression.type) {</span>
            <span class="s1">case </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">:</span>
                <span class="s3">// means that there is no v-bind,</span>
                <span class="s3">// but still need to deal with dynamic key binding</span>
                <span class="s1">let </span><span class="s2">classKeyIndex = -</span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">styleKeyIndex = -</span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">hasDynamicKey = </span><span class="s1">false;</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; propsExpression.properties.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">const </span><span class="s2">key = propsExpression.properties[i].key</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isStaticExp(key)) {</span>
                        <span class="s1">if </span><span class="s2">(key.content === </span><span class="s0">'class'</span><span class="s2">) {</span>
                            <span class="s2">classKeyIndex = i</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s1">else if </span><span class="s2">(key.content === </span><span class="s0">'style'</span><span class="s2">) {</span>
                            <span class="s2">styleKeyIndex = i</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(!key.isHandlerKey) {</span>
                        <span class="s2">hasDynamicKey = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">classProp = propsExpression.properties[classKeyIndex]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">styleProp = propsExpression.properties[styleKeyIndex]</span><span class="s1">;</span>
                <span class="s3">// no dynamic key</span>
                <span class="s1">if </span><span class="s2">(!hasDynamicKey) {</span>
                    <span class="s1">if </span><span class="s2">(classProp &amp;&amp; !isStaticExp(classProp.value)) {</span>
                        <span class="s2">classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS)</span><span class="s1">, </span><span class="s2">[classProp.value])</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(styleProp &amp;&amp;</span>
                        <span class="s3">// the static style is compiled into an object,</span>
                        <span class="s3">// so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
                        <span class="s2">(hasStyleBinding ||</span>
                            <span class="s2">(styleProp.value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">styleProp.value.content.trim()[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">`[`</span><span class="s2">) ||</span>
                            <span class="s3">// v-bind:style and style both exist,</span>
                            <span class="s3">// v-bind:style with static literal object</span>
                            <span class="s2">styleProp.value.type === </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s2">)) {</span>
                        <span class="s2">styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE)</span><span class="s1">, </span><span class="s2">[styleProp.value])</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s3">// dynamic key binding, wrap with `normalizeProps`</span>
                    <span class="s2">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s1">, </span><span class="s2">[propsExpression])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">:</span>
                <span class="s3">// mergeProps call, do nothing</span>
                <span class="s1">break;</span>
            <span class="s1">default</span><span class="s2">:</span>
                <span class="s3">// single v-bind</span>
                <span class="s2">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">createCallExpression(context.helper(GUARD_REACTIVE_PROPS)</span><span class="s1">, </span><span class="s2">[</span>
                        <span class="s2">propsExpression</span>
                    <span class="s2">])</span>
                <span class="s2">])</span><span class="s1">;</span>
                <span class="s1">break;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">props: propsExpression</span><span class="s1">,</span>
        <span class="s2">directives: runtimeDirectives</span><span class="s1">,</span>
        <span class="s2">patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicPropNames</span><span class="s1">,</span>
        <span class="s2">shouldUseBlock</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// Dedupe props in an object literal.</span>
<span class="s3">// Literal duplicated attributes would have been warned during the parse phase,</span>
<span class="s3">// however, it's possible to encounter duplicated `onXXX` handlers with different</span>
<span class="s3">// modifiers. We also need to merge static and dynamic class / style attributes.</span>
<span class="s3">// - onXXX handlers / style: merge into array</span>
<span class="s3">// - class: merge into single expression with concatenation</span>
<span class="s1">function </span><span class="s2">dedupeProperties(properties) {</span>
    <span class="s1">const </span><span class="s2">knownProps = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">deduped = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; properties.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">prop = properties[i]</span><span class="s1">;</span>
        <span class="s3">// dynamic keys are always allowed</span>
        <span class="s1">if </span><span class="s2">(prop.key.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */ </span><span class="s2">|| !prop.key.isStatic) {</span>
            <span class="s2">deduped.push(prop)</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">name = prop.key.content</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">existing = knownProps.get(name)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(existing) {</span>
            <span class="s1">if </span><span class="s2">(name === </span><span class="s0">'style' </span><span class="s2">|| name === </span><span class="s0">'class' </span><span class="s2">|| shared.isOn(name)) {</span>
                <span class="s2">mergeAsArray(existing</span><span class="s1">, </span><span class="s2">prop)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// unexpected duplicate, should have emitted error during parse</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">knownProps.set(name</span><span class="s1">, </span><span class="s2">prop)</span><span class="s1">;</span>
            <span class="s2">deduped.push(prop)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">deduped</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeAsArray(existing</span><span class="s1">, </span><span class="s2">incoming) {</span>
    <span class="s1">if </span><span class="s2">(existing.value.type === </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s2">existing.value.elements.push(incoming.value)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">existing.value = createArrayExpression([existing.value</span><span class="s1">, </span><span class="s2">incoming.value]</span><span class="s1">, </span><span class="s2">existing.loc)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">buildDirectiveArgs(dir</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">dirArgs = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">runtime = directiveImportMap.get(dir)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(runtime) {</span>
        <span class="s3">// built-in directive with runtime</span>
        <span class="s2">dirArgs.push(context.helperString(runtime))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// user directive.</span>
        <span class="s3">// see if we have directives exposed via &lt;script setup&gt;</span>
        <span class="s1">const </span><span class="s2">fromSetup = resolveSetupReference(</span><span class="s0">'v-' </span><span class="s2">+ dir.name</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(fromSetup) {</span>
            <span class="s2">dirArgs.push(fromSetup)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// inject statement for resolving directive</span>
            <span class="s2">context.helper(RESOLVE_DIRECTIVE)</span><span class="s1">;</span>
            <span class="s2">context.directives.add(dir.name)</span><span class="s1">;</span>
            <span class="s2">dirArgs.push(toValidAssetId(dir.name</span><span class="s1">, </span><span class="s0">`directive`</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ loc } = dir</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(dir.exp)</span>
        <span class="s2">dirArgs.push(dir.exp)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(dir.arg) {</span>
        <span class="s1">if </span><span class="s2">(!dir.exp) {</span>
            <span class="s2">dirArgs.push(</span><span class="s0">`void 0`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">dirArgs.push(dir.arg)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(Object.keys(dir.modifiers).length) {</span>
        <span class="s1">if </span><span class="s2">(!dir.arg) {</span>
            <span class="s1">if </span><span class="s2">(!dir.exp) {</span>
                <span class="s2">dirArgs.push(</span><span class="s0">`void 0`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">dirArgs.push(</span><span class="s0">`void 0`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">trueExpression = createSimpleExpression(</span><span class="s0">`true`</span><span class="s1">, false, </span><span class="s2">loc)</span><span class="s1">;</span>
        <span class="s2">dirArgs.push(createObjectExpression(dir.modifiers.map(modifier =&gt; createObjectProperty(modifier</span><span class="s1">, </span><span class="s2">trueExpression))</span><span class="s1">, </span><span class="s2">loc))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">createArrayExpression(dirArgs</span><span class="s1">, </span><span class="s2">dir.loc)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">stringifyDynamicPropNames(props) {</span>
    <span class="s1">let </span><span class="s2">propsNamesString = </span><span class="s0">`[`</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">l = props.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">propsNamesString += JSON.stringify(props[i])</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(i &lt; l - </span><span class="s4">1</span><span class="s2">)</span>
            <span class="s2">propsNamesString += </span><span class="s0">', '</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">propsNamesString + </span><span class="s0">`]`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isComponentTag(tag) {</span>
    <span class="s1">return </span><span class="s2">tag === </span><span class="s0">'component' </span><span class="s2">|| tag === </span><span class="s0">'Component'</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">cacheStringFunction = (fn) =&gt; {</span>
    <span class="s1">const </span><span class="s2">cache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">((str) =&gt; {</span>
        <span class="s1">const </span><span class="s2">hit = cache[str]</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">hit || (cache[str] = fn(str))</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">camelizeRE = </span><span class="s4">/-(\w)/g</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">camelize = cacheStringFunction((str) =&gt; {</span>
    <span class="s1">return </span><span class="s2">str.replace(camelizeRE</span><span class="s1">, </span><span class="s2">(_</span><span class="s1">, </span><span class="s2">c) =&gt; (c ? c.toUpperCase() : </span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">transformSlotOutlet = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(isSlotOutlet(node)) {</span>
        <span class="s1">const </span><span class="s2">{ children</span><span class="s1">, </span><span class="s2">loc } = node</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ slotName</span><span class="s1">, </span><span class="s2">slotProps } = processSlotOutlet(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">slotArgs = [</span>
            <span class="s2">context.prefixIdentifiers ? </span><span class="s0">`_ctx.$slots` </span><span class="s2">: </span><span class="s0">`$slots`</span><span class="s1">,</span>
            <span class="s2">slotName</span><span class="s1">,</span>
            <span class="s0">'{}'</span><span class="s1">,</span>
            <span class="s0">'undefined'</span><span class="s1">,</span>
            <span class="s0">'true'</span>
        <span class="s2">]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">expectedLen = </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(slotProps) {</span>
            <span class="s2">slotArgs[</span><span class="s4">2</span><span class="s2">] = slotProps</span><span class="s1">;</span>
            <span class="s2">expectedLen = </span><span class="s4">3</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(children.length) {</span>
            <span class="s2">slotArgs[</span><span class="s4">3</span><span class="s2">] = createFunctionExpression([]</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, false, false, </span><span class="s2">loc)</span><span class="s1">;</span>
            <span class="s2">expectedLen = </span><span class="s4">4</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(context.scopeId &amp;&amp; !context.slotted) {</span>
            <span class="s2">expectedLen = </span><span class="s4">5</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">slotArgs.splice(expectedLen)</span><span class="s1">; </span><span class="s3">// remove unused arguments</span>
        <span class="s2">node.codegenNode = createCallExpression(context.helper(RENDER_SLOT)</span><span class="s1">, </span><span class="s2">slotArgs</span><span class="s1">, </span><span class="s2">loc)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">processSlotOutlet(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">let </span><span class="s2">slotName = </span><span class="s0">`&quot;default&quot;`</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">slotProps = undefined</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">nonNameProps = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.props.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">p = node.props[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(p.value) {</span>
                <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'name'</span><span class="s2">) {</span>
                    <span class="s2">slotName = JSON.stringify(p.value.content)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">p.name = camelize(p.name)</span><span class="s1">;</span>
                    <span class="s2">nonNameProps.push(p)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp; isStaticArgOf(p.arg</span><span class="s1">, </span><span class="s0">'name'</span><span class="s2">)) {</span>
                <span class="s1">if </span><span class="s2">(p.exp)</span>
                    <span class="s2">slotName = p.exp</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(p.name === </span><span class="s0">'bind' </span><span class="s2">&amp;&amp; p.arg &amp;&amp; isStaticExp(p.arg)) {</span>
                    <span class="s2">p.arg.content = camelize(p.arg.content)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">nonNameProps.push(p)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(nonNameProps.length &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">directives } = buildProps(node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">nonNameProps</span><span class="s1">, false, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">slotProps = props</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(directives.length) {</span>
            <span class="s2">context.onError(createCompilerError(</span><span class="s4">36 </span><span class="s3">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s1">, </span><span class="s2">directives[</span><span class="s4">0</span><span class="s2">].loc))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">slotName</span><span class="s1">,</span>
        <span class="s2">slotProps</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">fnExpRE = </span><span class="s4">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">transformOn = (dir</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">augmentor) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ loc</span><span class="s1">, </span><span class="s2">modifiers</span><span class="s1">, </span><span class="s2">arg } = dir</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!dir.exp &amp;&amp; !modifiers.length) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">loc))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">eventName</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(arg.isStatic) {</span>
            <span class="s1">let </span><span class="s2">rawName = arg.content</span><span class="s1">;</span>
            <span class="s3">// TODO deprecate @vnodeXXX usage</span>
            <span class="s1">if </span><span class="s2">(rawName.startsWith(</span><span class="s0">'vue:'</span><span class="s2">)) {</span>
                <span class="s2">rawName = </span><span class="s0">`vnode-</span><span class="s2">${rawName.slice(</span><span class="s4">4</span><span class="s2">)}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">eventString = node.tagType !== </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s2">||</span>
                <span class="s2">rawName.startsWith(</span><span class="s0">'vnode'</span><span class="s2">) ||</span>
                <span class="s2">!</span><span class="s4">/[A-Z]/</span><span class="s2">.test(rawName)</span>
                <span class="s2">? </span><span class="s3">// for non-element and vnode lifecycle event listeners, auto convert</span>
                    <span class="s3">// it to camelCase. See issue #2249</span>
                    <span class="s2">shared.toHandlerKey(shared.camelize(rawName))</span>
                <span class="s2">: </span><span class="s3">// preserve case for plain element listeners that have uppercase</span>
                    <span class="s3">// letters, as these may be custom elements' custom events</span>
                    <span class="s0">`on:</span><span class="s2">${rawName}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">eventName = createSimpleExpression(eventString</span><span class="s1">, true, </span><span class="s2">arg.loc)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// #2388</span>
            <span class="s2">eventName = createCompoundExpression([</span>
                <span class="s0">`</span><span class="s2">${context.helperString(TO_HANDLER_KEY)}</span><span class="s0">(`</span><span class="s1">,</span>
                <span class="s2">arg</span><span class="s1">,</span>
                <span class="s0">`)`</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// already a compound expression.</span>
        <span class="s2">eventName = arg</span><span class="s1">;</span>
        <span class="s2">eventName.children.unshift(</span><span class="s0">`</span><span class="s2">${context.helperString(TO_HANDLER_KEY)}</span><span class="s0">(`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">eventName.children.push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// handler processing</span>
    <span class="s1">let </span><span class="s2">exp = dir.exp</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(exp &amp;&amp; !exp.content.trim()) {</span>
        <span class="s2">exp = undefined</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">shouldCache = context.cacheHandlers &amp;&amp; !exp &amp;&amp; !context.inVOnce</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(exp) {</span>
        <span class="s1">const </span><span class="s2">isMemberExp = isMemberExpression(exp.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">hasMultipleStatements = exp.content.includes(</span><span class="s0">`;`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s3">// process the expression since it's been skipped</span>
        <span class="s1">if </span><span class="s2">(context.prefixIdentifiers) {</span>
            <span class="s2">isInlineStatement &amp;&amp; context.addIdentifiers(</span><span class="s0">`$event`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">exp = dir.exp = processExpression(exp</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, false, </span><span class="s2">hasMultipleStatements)</span><span class="s1">;</span>
            <span class="s2">isInlineStatement &amp;&amp; context.removeIdentifiers(</span><span class="s0">`$event`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s3">// with scope analysis, the function is hoistable if it has no reference</span>
            <span class="s3">// to scope variables.</span>
            <span class="s2">shouldCache =</span>
                <span class="s2">context.cacheHandlers &amp;&amp;</span>
                    <span class="s3">// unnecessary to cache inside v-once</span>
                    <span class="s2">!context.inVOnce &amp;&amp;</span>
                    <span class="s3">// runtime constants don't need to be cached</span>
                    <span class="s3">// (this is analyzed by compileScript in SFC &lt;script setup&gt;)</span>
                    <span class="s2">!(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp; exp.constType &gt; </span><span class="s4">0</span><span class="s2">) &amp;&amp;</span>
                    <span class="s3">// #1541 bail if this is a member exp handler passed to a component -</span>
                    <span class="s3">// we need to use the original function to preserve arity,</span>
                    <span class="s3">// e.g. &lt;transition&gt; relies on checking cb.length to determine</span>
                    <span class="s3">// transition end handling. Inline function is ok since its arity</span>
                    <span class="s3">// is preserved even when cached.</span>
                    <span class="s2">!(isMemberExp &amp;&amp; node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s2">) &amp;&amp;</span>
                    <span class="s3">// bail if the function references closure variables (v-for, v-slot)</span>
                    <span class="s3">// it must be passed fresh to avoid stale values.</span>
                    <span class="s2">!hasScopeRef(exp</span><span class="s1">, </span><span class="s2">context.identifiers)</span><span class="s1">;</span>
            <span class="s3">// If the expression is optimizable and is a member expression pointing</span>
            <span class="s3">// to a function, turn it into invocation (and wrap in an arrow function</span>
            <span class="s3">// below) so that it always accesses the latest value when called - thus</span>
            <span class="s3">// avoiding the need to be patched.</span>
            <span class="s1">if </span><span class="s2">(shouldCache &amp;&amp; isMemberExp) {</span>
                <span class="s1">if </span><span class="s2">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
                    <span class="s2">exp.content = </span><span class="s0">`</span><span class="s2">${exp.content} </span><span class="s0">&amp;&amp; </span><span class="s2">${exp.content}</span><span class="s0">(...args)`</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">exp.children = [...exp.children</span><span class="s1">, </span><span class="s0">` &amp;&amp; `</span><span class="s1">, </span><span class="s2">...exp.children</span><span class="s1">, </span><span class="s0">`(...args)`</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(isInlineStatement || (shouldCache &amp;&amp; isMemberExp)) {</span>
            <span class="s3">// wrap inline statement in a function expression</span>
            <span class="s2">exp = createCompoundExpression([</span>
                <span class="s0">`</span><span class="s2">${isInlineStatement</span>
                    <span class="s2">? context.isTS</span>
                        <span class="s2">? </span><span class="s0">`($event: any)`</span>
                        <span class="s2">: </span><span class="s0">`$event`</span>
                    <span class="s2">: </span><span class="s0">`</span><span class="s2">${context.isTS ? </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">//@ts-ignore</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">(...args)`</span><span class="s2">} </span><span class="s0">=&gt; </span><span class="s2">${hasMultipleStatements ? </span><span class="s0">`{` </span><span class="s2">: </span><span class="s0">`(`</span><span class="s2">}</span><span class="s0">`</span><span class="s1">,</span>
                <span class="s2">exp</span><span class="s1">,</span>
                <span class="s2">hasMultipleStatements ? </span><span class="s0">`}` </span><span class="s2">: </span><span class="s0">`)`</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">ret = {</span>
        <span class="s2">props: [</span>
            <span class="s2">createObjectProperty(eventName</span><span class="s1">, </span><span class="s2">exp || createSimpleExpression(</span><span class="s0">`() =&gt; {}`</span><span class="s1">, false, </span><span class="s2">loc))</span>
        <span class="s2">]</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// apply extended compiler augmentor</span>
    <span class="s1">if </span><span class="s2">(augmentor) {</span>
        <span class="s2">ret = augmentor(ret)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shouldCache) {</span>
        <span class="s3">// cache handlers so that it's always the same handler being passed down.</span>
        <span class="s3">// this avoids unnecessary re-renders when users use inline handlers on</span>
        <span class="s3">// components.</span>
        <span class="s2">ret.props[</span><span class="s4">0</span><span class="s2">].value = context.cache(ret.props[</span><span class="s4">0</span><span class="s2">].value)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// mark the key as handler for props normalization check</span>
    <span class="s2">ret.props.forEach(p =&gt; (p.key.isHandlerKey = </span><span class="s1">true</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">// v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
<span class="s3">// codegen for the entire props object. This transform here is only for v-bind</span>
<span class="s3">// *with* args.</span>
<span class="s1">const </span><span class="s2">transformBind = (dir</span><span class="s1">, </span><span class="s2">_node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ exp</span><span class="s1">, </span><span class="s2">modifiers</span><span class="s1">, </span><span class="s2">loc } = dir</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">arg = dir.arg</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(arg.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s2">arg.children.unshift(</span><span class="s0">`(`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">arg.children.push(</span><span class="s0">`) || &quot;&quot;`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(!arg.isStatic) {</span>
        <span class="s2">arg.content = </span><span class="s0">`</span><span class="s2">${arg.content} </span><span class="s0">|| &quot;&quot;`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// .sync is replaced by v-model:arg</span>
    <span class="s1">if </span><span class="s2">(modifiers.includes(</span><span class="s0">'camel'</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(arg.isStatic) {</span>
                <span class="s2">arg.content = shared.camelize(arg.content)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">arg.content = </span><span class="s0">`</span><span class="s2">${context.helperString(CAMELIZE)}</span><span class="s0">(</span><span class="s2">${arg.content}</span><span class="s0">)`</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">arg.children.unshift(</span><span class="s0">`</span><span class="s2">${context.helperString(CAMELIZE)}</span><span class="s0">(`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">arg.children.push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!context.inSSR) {</span>
        <span class="s1">if </span><span class="s2">(modifiers.includes(</span><span class="s0">'prop'</span><span class="s2">)) {</span>
            <span class="s2">injectPrefix(arg</span><span class="s1">, </span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(modifiers.includes(</span><span class="s0">'attr'</span><span class="s2">)) {</span>
            <span class="s2">injectPrefix(arg</span><span class="s1">, </span><span class="s0">'^'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!exp ||</span>
        <span class="s2">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">&amp;&amp; !exp.content.trim())) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">loc))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">{</span>
            <span class="s2">props: [createObjectProperty(arg</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">''</span><span class="s1">, true, </span><span class="s2">loc))]</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">props: [createObjectProperty(arg</span><span class="s1">, </span><span class="s2">exp)]</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">injectPrefix = (arg</span><span class="s1">, </span><span class="s2">prefix) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(arg.isStatic) {</span>
            <span class="s2">arg.content = prefix + arg.content</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">arg.content = </span><span class="s0">`</span><span class="s1">\`</span><span class="s2">${prefix}</span><span class="s1">\$</span><span class="s0">{</span><span class="s2">${arg.content}</span><span class="s0">}</span><span class="s1">\`</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">arg.children.unshift(</span><span class="s0">`'</span><span class="s2">${prefix}</span><span class="s0">' + (`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">arg.children.push(</span><span class="s0">`)`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">// Merge adjacent text nodes and expressions into a single expression</span>
<span class="s3">// e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
<span class="s1">const </span><span class="s2">transformText = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */ </span><span class="s2">||</span>
        <span class="s2">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">||</span>
        <span class="s2">node.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */ </span><span class="s2">||</span>
        <span class="s2">node.type === </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s2">) {</span>
        <span class="s3">// perform the transform on node exit so that all expressions have already</span>
        <span class="s3">// been processed.</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s1">const </span><span class="s2">children = node.children</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">currentContainer = undefined</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">hasText = </span><span class="s1">false;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(isText$1(child)) {</span>
                    <span class="s2">hasText = </span><span class="s1">true;</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = i + </span><span class="s4">1</span><span class="s1">; </span><span class="s2">j &lt; children.length</span><span class="s1">; </span><span class="s2">j++) {</span>
                        <span class="s1">const </span><span class="s2">next = children[j]</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(isText$1(next)) {</span>
                            <span class="s1">if </span><span class="s2">(!currentContainer) {</span>
                                <span class="s2">currentContainer = children[i] = createCompoundExpression([child]</span><span class="s1">, </span><span class="s2">child.loc)</span><span class="s1">;</span>
                            <span class="s2">}</span>
                            <span class="s3">// merge adjacent text node into current</span>
                            <span class="s2">currentContainer.children.push(</span><span class="s0">` + `</span><span class="s1">, </span><span class="s2">next)</span><span class="s1">;</span>
                            <span class="s2">children.splice(j</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                            <span class="s2">j--</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s2">currentContainer = undefined</span><span class="s1">;</span>
                            <span class="s1">break;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(!hasText ||</span>
                <span class="s3">// if this is a plain element with a single text child, leave it</span>
                <span class="s3">// as-is since the runtime has dedicated fast path for this by directly</span>
                <span class="s3">// setting textContent of the element.</span>
                <span class="s3">// for component root it's always normalized anyway.</span>
                <span class="s2">(children.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp;</span>
                    <span class="s2">(node.type === </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */ </span><span class="s2">||</span>
                        <span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
                            <span class="s3">// #3756</span>
                            <span class="s3">// custom directives can potentially add DOM elements arbitrarily,</span>
                            <span class="s3">// we need to avoid setting textContent of the element at runtime</span>
                            <span class="s3">// to avoid accidentally overwriting the DOM elements added</span>
                            <span class="s3">// by the user through custom directives.</span>
                            <span class="s2">!node.props.find(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
                                <span class="s2">!context.directiveTransforms[p.name]) &amp;&amp;</span>
                            <span class="s3">// in compat mode, &lt;template&gt; tags with no special directives</span>
                            <span class="s3">// will be rendered as a fragment so its children must be</span>
                            <span class="s3">// converted into vnodes.</span>
                            <span class="s2">!(node.tag === </span><span class="s0">'template'</span><span class="s2">))))) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s3">// pre-convert text nodes into createTextVNode(text) calls to avoid</span>
            <span class="s3">// runtime normalization.</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(isText$1(child) || child.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">) {</span>
                    <span class="s1">const </span><span class="s2">callArgs = []</span><span class="s1">;</span>
                    <span class="s3">// createTextVNode defaults to single whitespace, so if it is a</span>
                    <span class="s3">// single space the code could be an empty call to save bytes.</span>
                    <span class="s1">if </span><span class="s2">(child.type !== </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s2">|| child.content !== </span><span class="s0">' '</span><span class="s2">) {</span>
                        <span class="s2">callArgs.push(child)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s3">// mark dynamic text with flag so it gets patched inside a block</span>
                    <span class="s1">if </span><span class="s2">(!context.ssr &amp;&amp;</span>
                        <span class="s2">getConstantType(child</span><span class="s1">, </span><span class="s2">context) === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">) {</span>
                        <span class="s2">callArgs.push(</span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */ </span><span class="s2">+</span>
                            <span class="s2">(</span><span class="s0">` /* </span><span class="s2">${shared.PatchFlagNames[</span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s2">]} </span><span class="s0">*/` </span><span class="s2">))</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">children[i] = {</span>
                        <span class="s2">type: </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s1">,</span>
                        <span class="s2">content: child</span><span class="s1">,</span>
                        <span class="s2">loc: child.loc</span><span class="s1">,</span>
                        <span class="s2">codegenNode: createCallExpression(context.helper(CREATE_TEXT)</span><span class="s1">, </span><span class="s2">callArgs)</span>
                    <span class="s2">}</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">seen$1 = </span><span class="s1">new </span><span class="s2">WeakSet()</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">transformOnce = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s2">&amp;&amp; findDir(node</span><span class="s1">, </span><span class="s0">'once'</span><span class="s1">, true</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(seen$1.has(node) || context.inVOnce) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">seen$1.add(node)</span><span class="s1">;</span>
        <span class="s2">context.inVOnce = </span><span class="s1">true;</span>
        <span class="s2">context.helper(SET_BLOCK_TRACKING)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s2">context.inVOnce = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">cur = context.currentNode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(cur.codegenNode) {</span>
                <span class="s2">cur.codegenNode = context.cache(cur.codegenNode</span><span class="s1">, true </span><span class="s3">/* isVNode */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">transformModel = (dir</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ exp</span><span class="s1">, </span><span class="s2">arg } = dir</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!exp) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">41 </span><span class="s3">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s1">, </span><span class="s2">dir.loc))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createTransformProps()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">rawExp = exp.loc.source</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">expString = exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s2">? exp.content : rawExp</span><span class="s1">;</span>
    <span class="s3">// im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
    <span class="s3">// _unref(exp)</span>
    <span class="s1">const </span><span class="s2">bindingType = context.bindingMetadata[rawExp]</span><span class="s1">;</span>
    <span class="s3">// check props</span>
    <span class="s1">if </span><span class="s2">(bindingType === </span><span class="s0">&quot;props&quot; </span><span class="s3">/* BindingTypes.PROPS */ </span><span class="s2">||</span>
        <span class="s2">bindingType === </span><span class="s0">&quot;props-aliased&quot; </span><span class="s3">/* BindingTypes.PROPS_ALIASED */</span><span class="s2">) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">44 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s1">, </span><span class="s2">exp.loc))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createTransformProps()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">maybeRef = context.inline &amp;&amp;</span>
        <span class="s2">(bindingType === </span><span class="s0">&quot;setup-let&quot; </span><span class="s3">/* BindingTypes.SETUP_LET */ </span><span class="s2">||</span>
            <span class="s2">bindingType === </span><span class="s0">&quot;setup-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_REF */ </span><span class="s2">||</span>
            <span class="s2">bindingType === </span><span class="s0">&quot;setup-maybe-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_MAYBE_REF */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!expString.trim() ||</span>
        <span class="s2">(!isMemberExpression(expString</span><span class="s1">, </span><span class="s2">context) &amp;&amp; !maybeRef)) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">42 </span><span class="s3">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s1">, </span><span class="s2">exp.loc))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createTransformProps()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(context.prefixIdentifiers &amp;&amp;</span>
        <span class="s2">isSimpleIdentifier(expString) &amp;&amp;</span>
        <span class="s2">context.identifiers[expString]) {</span>
        <span class="s2">context.onError(createCompilerError(</span><span class="s4">43 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */</span><span class="s1">, </span><span class="s2">exp.loc))</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createTransformProps()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">propName = arg ? arg : createSimpleExpression(</span><span class="s0">'modelValue'</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">eventName = arg</span>
        <span class="s2">? isStaticExp(arg)</span>
            <span class="s2">? </span><span class="s0">`onUpdate:</span><span class="s2">${shared.camelize(arg.content)}</span><span class="s0">`</span>
            <span class="s2">: createCompoundExpression([</span><span class="s0">'&quot;onUpdate:&quot; + '</span><span class="s1">, </span><span class="s2">arg])</span>
        <span class="s2">: </span><span class="s0">`onUpdate:modelValue`</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">assignmentExp</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">eventArg = context.isTS ? </span><span class="s0">`($event: any)` </span><span class="s2">: </span><span class="s0">`$event`</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(maybeRef) {</span>
        <span class="s1">if </span><span class="s2">(bindingType === </span><span class="s0">&quot;setup-ref&quot; </span><span class="s3">/* BindingTypes.SETUP_REF */</span><span class="s2">) {</span>
            <span class="s3">// v-model used on known ref.</span>
            <span class="s2">assignmentExp = createCompoundExpression([</span>
                <span class="s0">`</span><span class="s2">${eventArg} </span><span class="s0">=&gt; ((`</span><span class="s1">,</span>
                <span class="s2">createSimpleExpression(rawExp</span><span class="s1">, false, </span><span class="s2">exp.loc)</span><span class="s1">,</span>
                <span class="s0">`).value = $event)`</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// v-model used on a potentially ref binding in &lt;script setup&gt; inline mode.</span>
            <span class="s3">// the assignment needs to check whether the binding is actually a ref.</span>
            <span class="s1">const </span><span class="s2">altAssignment = bindingType === </span><span class="s0">&quot;setup-let&quot; </span><span class="s3">/* BindingTypes.SETUP_LET */ </span><span class="s2">? </span><span class="s0">`</span><span class="s2">${rawExp} </span><span class="s0">= $event` </span><span class="s2">: </span><span class="s0">`null`</span><span class="s1">;</span>
            <span class="s2">assignmentExp = createCompoundExpression([</span>
                <span class="s0">`</span><span class="s2">${eventArg} </span><span class="s0">=&gt; (</span><span class="s2">${context.helperString(IS_REF)}</span><span class="s0">(</span><span class="s2">${rawExp}</span><span class="s0">) ? (`</span><span class="s1">,</span>
                <span class="s2">createSimpleExpression(rawExp</span><span class="s1">, false, </span><span class="s2">exp.loc)</span><span class="s1">,</span>
                <span class="s0">`).value = $event : </span><span class="s2">${altAssignment}</span><span class="s0">)`</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">assignmentExp = createCompoundExpression([</span>
            <span class="s0">`</span><span class="s2">${eventArg} </span><span class="s0">=&gt; ((`</span><span class="s1">,</span>
            <span class="s2">exp</span><span class="s1">,</span>
            <span class="s0">`) = $event)`</span>
        <span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">props = [</span>
        <span class="s3">// modelValue: foo</span>
        <span class="s2">createObjectProperty(propName</span><span class="s1">, </span><span class="s2">dir.exp)</span><span class="s1">,</span>
        <span class="s3">// &quot;onUpdate:modelValue&quot;: $event =&gt; (foo = $event)</span>
        <span class="s2">createObjectProperty(eventName</span><span class="s1">, </span><span class="s2">assignmentExp)</span>
    <span class="s2">]</span><span class="s1">;</span>
    <span class="s3">// cache v-model handler if applicable (when it doesn't refer any scope vars)</span>
    <span class="s1">if </span><span class="s2">(context.prefixIdentifiers &amp;&amp;</span>
        <span class="s2">!context.inVOnce &amp;&amp;</span>
        <span class="s2">context.cacheHandlers &amp;&amp;</span>
        <span class="s2">!hasScopeRef(exp</span><span class="s1">, </span><span class="s2">context.identifiers)) {</span>
        <span class="s2">props[</span><span class="s4">1</span><span class="s2">].value = context.cache(props[</span><span class="s4">1</span><span class="s2">].value)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// modelModifiers: { foo: true, &quot;bar-baz&quot;: true }</span>
    <span class="s1">if </span><span class="s2">(dir.modifiers.length &amp;&amp; node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">modifiers = dir.modifiers</span>
            <span class="s2">.map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + </span><span class="s0">`: true`</span><span class="s2">)</span>
            <span class="s2">.join(</span><span class="s0">`, `</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">modifiersKey = arg</span>
            <span class="s2">? isStaticExp(arg)</span>
                <span class="s2">? </span><span class="s0">`</span><span class="s2">${arg.content}</span><span class="s0">Modifiers`</span>
                <span class="s2">: createCompoundExpression([arg</span><span class="s1">, </span><span class="s0">' + &quot;Modifiers&quot;'</span><span class="s2">])</span>
            <span class="s2">: </span><span class="s0">`modelModifiers`</span><span class="s1">;</span>
        <span class="s2">props.push(createObjectProperty(modifiersKey</span><span class="s1">, </span><span class="s2">createSimpleExpression(</span><span class="s0">`{ </span><span class="s2">${modifiers} </span><span class="s0">}`</span><span class="s1">, false, </span><span class="s2">dir.loc</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s2">)))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">createTransformProps(props)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createTransformProps(props = []) {</span>
    <span class="s1">return </span><span class="s2">{ props }</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">validDivisionCharRE = </span><span class="s4">/[\w).+\-_$\]]/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">transformFilter = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(!isCompatEnabled(</span><span class="s0">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s1">, </span><span class="s2">context)) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">) {</span>
        <span class="s3">// filter rewrite is applied before expression transform so only</span>
        <span class="s3">// simple expressions are possible at this stage</span>
        <span class="s2">rewriteFilter(node.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
        <span class="s2">node.props.forEach((prop) =&gt; {</span>
            <span class="s1">if </span><span class="s2">(prop.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s2">&amp;&amp;</span>
                <span class="s2">prop.name !== </span><span class="s0">'for' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">prop.exp) {</span>
                <span class="s2">rewriteFilter(prop.exp</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">rewriteFilter(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
        <span class="s2">parseFilter(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; node.children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">child = node.children[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">child !== </span><span class="s0">'object'</span><span class="s2">)</span>
                <span class="s1">continue;</span>
            <span class="s1">if </span><span class="s2">(child.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">) {</span>
                <span class="s2">parseFilter(child</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(child.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">) {</span>
                <span class="s2">rewriteFilter(node</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(child.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s2">) {</span>
                <span class="s2">rewriteFilter(child.content</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseFilter(node</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s1">const </span><span class="s2">exp = node.content</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">inSingle = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">inDouble = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">inTemplateString = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">inRegex = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">curly = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">square = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">paren = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">lastFilterIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">c</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">expression</span><span class="s1">, </span><span class="s2">filters = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; exp.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">prev = c</span><span class="s1">;</span>
        <span class="s2">c = exp.charCodeAt(i)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(inSingle) {</span>
            <span class="s1">if </span><span class="s2">(c === </span><span class="s4">0x27 </span><span class="s2">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s2">)</span>
                <span class="s2">inSingle = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(inDouble) {</span>
            <span class="s1">if </span><span class="s2">(c === </span><span class="s4">0x22 </span><span class="s2">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s2">)</span>
                <span class="s2">inDouble = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(inTemplateString) {</span>
            <span class="s1">if </span><span class="s2">(c === </span><span class="s4">0x60 </span><span class="s2">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s2">)</span>
                <span class="s2">inTemplateString = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(inRegex) {</span>
            <span class="s1">if </span><span class="s2">(c === </span><span class="s4">0x2f </span><span class="s2">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s2">)</span>
                <span class="s2">inRegex = </span><span class="s1">false;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(c === </span><span class="s4">0x7c </span><span class="s2">&amp;&amp; </span><span class="s3">// pipe</span>
            <span class="s2">exp.charCodeAt(i + </span><span class="s4">1</span><span class="s2">) !== </span><span class="s4">0x7c </span><span class="s2">&amp;&amp;</span>
            <span class="s2">exp.charCodeAt(i - </span><span class="s4">1</span><span class="s2">) !== </span><span class="s4">0x7c </span><span class="s2">&amp;&amp;</span>
            <span class="s2">!curly &amp;&amp;</span>
            <span class="s2">!square &amp;&amp;</span>
            <span class="s2">!paren) {</span>
            <span class="s1">if </span><span class="s2">(expression === undefined) {</span>
                <span class="s3">// first filter, end of expression</span>
                <span class="s2">lastFilterIndex = i + </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s2">expression = exp.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">i).trim()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">pushFilter()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">switch </span><span class="s2">(c) {</span>
                <span class="s1">case </span><span class="s4">0x22</span><span class="s2">:</span>
                    <span class="s2">inDouble = </span><span class="s1">true;</span>
                    <span class="s1">break; </span><span class="s3">// &quot;</span>
                <span class="s1">case </span><span class="s4">0x27</span><span class="s2">:</span>
                    <span class="s2">inSingle = </span><span class="s1">true;</span>
                    <span class="s1">break; </span><span class="s3">// '</span>
                <span class="s1">case </span><span class="s4">0x60</span><span class="s2">:</span>
                    <span class="s2">inTemplateString = </span><span class="s1">true;</span>
                    <span class="s1">break; </span><span class="s3">// `</span>
                <span class="s1">case </span><span class="s4">0x28</span><span class="s2">:</span>
                    <span class="s2">paren++</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// (</span>
                <span class="s1">case </span><span class="s4">0x29</span><span class="s2">:</span>
                    <span class="s2">paren--</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// )</span>
                <span class="s1">case </span><span class="s4">0x5b</span><span class="s2">:</span>
                    <span class="s2">square++</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// [</span>
                <span class="s1">case </span><span class="s4">0x5d</span><span class="s2">:</span>
                    <span class="s2">square--</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// ]</span>
                <span class="s1">case </span><span class="s4">0x7b</span><span class="s2">:</span>
                    <span class="s2">curly++</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// {</span>
                <span class="s1">case </span><span class="s4">0x7d</span><span class="s2">:</span>
                    <span class="s2">curly--</span><span class="s1">;</span>
                    <span class="s1">break; </span><span class="s3">// }</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(c === </span><span class="s4">0x2f</span><span class="s2">) {</span>
                <span class="s3">// /</span>
                <span class="s1">let </span><span class="s2">j = i - </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">p</span><span class="s1">;</span>
                <span class="s3">// find first non-whitespace prev char</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">; </span><span class="s2">j &gt;= </span><span class="s4">0</span><span class="s1">; </span><span class="s2">j--) {</span>
                    <span class="s2">p = exp.charAt(j)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(p !== </span><span class="s0">' '</span><span class="s2">)</span>
                        <span class="s1">break;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!p || !validDivisionCharRE.test(p)) {</span>
                    <span class="s2">inRegex = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(expression === undefined) {</span>
        <span class="s2">expression = exp.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">i).trim()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(lastFilterIndex !== </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">pushFilter()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">pushFilter() {</span>
        <span class="s2">filters.push(exp.slice(lastFilterIndex</span><span class="s1">, </span><span class="s2">i).trim())</span><span class="s1">;</span>
        <span class="s2">lastFilterIndex = i + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(filters.length) {</span>
        <span class="s2">warnDeprecation(</span><span class="s0">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s1">, </span><span class="s2">context</span><span class="s1">, </span><span class="s2">node.loc)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; filters.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">expression = wrapFilter(expression</span><span class="s1">, </span><span class="s2">filters[i]</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">node.content = expression</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">wrapFilter(exp</span><span class="s1">, </span><span class="s2">filter</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">context.helper(RESOLVE_FILTER)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">i = filter.indexOf(</span><span class="s0">'('</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(i &lt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">context.filters.add(filter)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${toValidAssetId(filter</span><span class="s1">, </span><span class="s0">'filter'</span><span class="s2">)}</span><span class="s0">(</span><span class="s2">${exp}</span><span class="s0">)`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">name = filter.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">args = filter.slice(i + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">context.filters.add(name)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${toValidAssetId(name</span><span class="s1">, </span><span class="s0">'filter'</span><span class="s2">)}</span><span class="s0">(</span><span class="s2">${exp}${args !== </span><span class="s0">')' </span><span class="s2">? </span><span class="s0">',' </span><span class="s2">+ args : args}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">seen = </span><span class="s1">new </span><span class="s2">WeakSet()</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">transformMemo = (node</span><span class="s1">, </span><span class="s2">context) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">dir = findDir(node</span><span class="s1">, </span><span class="s0">'memo'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!dir || seen.has(node)) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">seen.add(node)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s1">const </span><span class="s2">codegenNode = node.codegenNode ||</span>
                <span class="s2">context.currentNode.codegenNode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(codegenNode &amp;&amp; codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s2">) {</span>
                <span class="s3">// non-component sub tree should be turned into a block</span>
                <span class="s1">if </span><span class="s2">(node.tagType !== </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s2">) {</span>
                    <span class="s2">makeBlock(codegenNode</span><span class="s1">, </span><span class="s2">context)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">node.codegenNode = createCallExpression(context.helper(WITH_MEMO)</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">dir.exp</span><span class="s1">,</span>
                    <span class="s2">createFunctionExpression(undefined</span><span class="s1">, </span><span class="s2">codegenNode)</span><span class="s1">,</span>
                    <span class="s0">`_cache`</span><span class="s1">,</span>
                    <span class="s2">String(context.cached++)</span>
                <span class="s2">])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">getBaseTransformPreset(prefixIdentifiers) {</span>
    <span class="s1">return </span><span class="s2">[</span>
        <span class="s2">[</span>
            <span class="s2">transformOnce</span><span class="s1">,</span>
            <span class="s2">transformIf</span><span class="s1">,</span>
            <span class="s2">transformMemo</span><span class="s1">,</span>
            <span class="s2">transformFor</span><span class="s1">,</span>
            <span class="s2">...([transformFilter] )</span><span class="s1">,</span>
            <span class="s2">...(prefixIdentifiers</span>
                <span class="s2">? [</span>
                    <span class="s3">// order is important</span>
                    <span class="s2">trackVForSlotScopes</span><span class="s1">,</span>
                    <span class="s2">transformExpression</span>
                <span class="s2">]</span>
                <span class="s2">: [])</span><span class="s1">,</span>
            <span class="s2">transformSlotOutlet</span><span class="s1">,</span>
            <span class="s2">transformElement</span><span class="s1">,</span>
            <span class="s2">trackSlotScopes</span><span class="s1">,</span>
            <span class="s2">transformText</span>
        <span class="s2">]</span><span class="s1">,</span>
        <span class="s2">{</span>
            <span class="s2">on: transformOn</span><span class="s1">,</span>
            <span class="s2">bind: transformBind</span><span class="s1">,</span>
            <span class="s2">model: transformModel</span>
        <span class="s2">}</span>
    <span class="s2">]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// we name it `baseCompile` so that higher order compilers like</span>
<span class="s3">// @vue/compiler-dom can export `compile` while re-exporting everything else.</span>
<span class="s1">function </span><span class="s2">baseCompile(template</span><span class="s1">, </span><span class="s2">options = {}) {</span>
    <span class="s1">const </span><span class="s2">onError = options.onError || defaultOnError</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isModuleMode = options.mode === </span><span class="s0">'module'</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">prefixIdentifiers = (options.prefixIdentifiers === </span><span class="s1">true </span><span class="s2">|| isModuleMode)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!prefixIdentifiers &amp;&amp; options.cacheHandlers) {</span>
        <span class="s2">onError(createCompilerError(</span><span class="s4">49 </span><span class="s3">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(options.scopeId &amp;&amp; !isModuleMode) {</span>
        <span class="s2">onError(createCompilerError(</span><span class="s4">50 </span><span class="s3">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">ast = shared.isString(template) ? baseParse(template</span><span class="s1">, </span><span class="s2">options) : template</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">[nodeTransforms</span><span class="s1">, </span><span class="s2">directiveTransforms] = getBaseTransformPreset(prefixIdentifiers)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(options.isTS) {</span>
        <span class="s1">const </span><span class="s2">{ expressionPlugins } = options</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!expressionPlugins || !expressionPlugins.includes(</span><span class="s0">'typescript'</span><span class="s2">)) {</span>
            <span class="s2">options.expressionPlugins = [...(expressionPlugins || [])</span><span class="s1">, </span><span class="s0">'typescript'</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">transform(ast</span><span class="s1">, </span><span class="s2">shared.extend({}</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">prefixIdentifiers</span><span class="s1">,</span>
        <span class="s2">nodeTransforms: [</span>
            <span class="s2">...nodeTransforms</span><span class="s1">,</span>
            <span class="s2">...(options.nodeTransforms || []) </span><span class="s3">// user transforms</span>
        <span class="s2">]</span><span class="s1">,</span>
        <span class="s2">directiveTransforms: shared.extend({}</span><span class="s1">, </span><span class="s2">directiveTransforms</span><span class="s1">, </span><span class="s2">options.directiveTransforms || {} </span><span class="s3">// user transforms</span>
        <span class="s2">)</span>
    <span class="s2">}))</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">generate(ast</span><span class="s1">, </span><span class="s2">shared.extend({}</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">prefixIdentifiers</span>
    <span class="s2">}))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">noopDirectiveTransform = () =&gt; ({ props: [] })</span><span class="s1">;</span>

<span class="s2">exports.generateCodeFrame = shared.generateCodeFrame</span><span class="s1">;</span>
<span class="s2">exports.BASE_TRANSITION = BASE_TRANSITION</span><span class="s1">;</span>
<span class="s2">exports.CAMELIZE = CAMELIZE</span><span class="s1">;</span>
<span class="s2">exports.CAPITALIZE = CAPITALIZE</span><span class="s1">;</span>
<span class="s2">exports.CREATE_BLOCK = CREATE_BLOCK</span><span class="s1">;</span>
<span class="s2">exports.CREATE_COMMENT = CREATE_COMMENT</span><span class="s1">;</span>
<span class="s2">exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK</span><span class="s1">;</span>
<span class="s2">exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE</span><span class="s1">;</span>
<span class="s2">exports.CREATE_SLOTS = CREATE_SLOTS</span><span class="s1">;</span>
<span class="s2">exports.CREATE_STATIC = CREATE_STATIC</span><span class="s1">;</span>
<span class="s2">exports.CREATE_TEXT = CREATE_TEXT</span><span class="s1">;</span>
<span class="s2">exports.CREATE_VNODE = CREATE_VNODE</span><span class="s1">;</span>
<span class="s2">exports.FRAGMENT = FRAGMENT</span><span class="s1">;</span>
<span class="s2">exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS</span><span class="s1">;</span>
<span class="s2">exports.IS_MEMO_SAME = IS_MEMO_SAME</span><span class="s1">;</span>
<span class="s2">exports.IS_REF = IS_REF</span><span class="s1">;</span>
<span class="s2">exports.KEEP_ALIVE = KEEP_ALIVE</span><span class="s1">;</span>
<span class="s2">exports.MERGE_PROPS = MERGE_PROPS</span><span class="s1">;</span>
<span class="s2">exports.NORMALIZE_CLASS = NORMALIZE_CLASS</span><span class="s1">;</span>
<span class="s2">exports.NORMALIZE_PROPS = NORMALIZE_PROPS</span><span class="s1">;</span>
<span class="s2">exports.NORMALIZE_STYLE = NORMALIZE_STYLE</span><span class="s1">;</span>
<span class="s2">exports.OPEN_BLOCK = OPEN_BLOCK</span><span class="s1">;</span>
<span class="s2">exports.POP_SCOPE_ID = POP_SCOPE_ID</span><span class="s1">;</span>
<span class="s2">exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID</span><span class="s1">;</span>
<span class="s2">exports.RENDER_LIST = RENDER_LIST</span><span class="s1">;</span>
<span class="s2">exports.RENDER_SLOT = RENDER_SLOT</span><span class="s1">;</span>
<span class="s2">exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT</span><span class="s1">;</span>
<span class="s2">exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE</span><span class="s1">;</span>
<span class="s2">exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT</span><span class="s1">;</span>
<span class="s2">exports.RESOLVE_FILTER = RESOLVE_FILTER</span><span class="s1">;</span>
<span class="s2">exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING</span><span class="s1">;</span>
<span class="s2">exports.SUSPENSE = SUSPENSE</span><span class="s1">;</span>
<span class="s2">exports.TELEPORT = TELEPORT</span><span class="s1">;</span>
<span class="s2">exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING</span><span class="s1">;</span>
<span class="s2">exports.TO_HANDLERS = TO_HANDLERS</span><span class="s1">;</span>
<span class="s2">exports.TO_HANDLER_KEY = TO_HANDLER_KEY</span><span class="s1">;</span>
<span class="s2">exports.UNREF = UNREF</span><span class="s1">;</span>
<span class="s2">exports.WITH_CTX = WITH_CTX</span><span class="s1">;</span>
<span class="s2">exports.WITH_DIRECTIVES = WITH_DIRECTIVES</span><span class="s1">;</span>
<span class="s2">exports.WITH_MEMO = WITH_MEMO</span><span class="s1">;</span>
<span class="s2">exports.advancePositionWithClone = advancePositionWithClone</span><span class="s1">;</span>
<span class="s2">exports.advancePositionWithMutation = advancePositionWithMutation</span><span class="s1">;</span>
<span class="s2">exports.assert = assert</span><span class="s1">;</span>
<span class="s2">exports.baseCompile = baseCompile</span><span class="s1">;</span>
<span class="s2">exports.baseParse = baseParse</span><span class="s1">;</span>
<span class="s2">exports.buildDirectiveArgs = buildDirectiveArgs</span><span class="s1">;</span>
<span class="s2">exports.buildProps = buildProps</span><span class="s1">;</span>
<span class="s2">exports.buildSlots = buildSlots</span><span class="s1">;</span>
<span class="s2">exports.checkCompatEnabled = checkCompatEnabled</span><span class="s1">;</span>
<span class="s2">exports.createArrayExpression = createArrayExpression</span><span class="s1">;</span>
<span class="s2">exports.createAssignmentExpression = createAssignmentExpression</span><span class="s1">;</span>
<span class="s2">exports.createBlockStatement = createBlockStatement</span><span class="s1">;</span>
<span class="s2">exports.createCacheExpression = createCacheExpression</span><span class="s1">;</span>
<span class="s2">exports.createCallExpression = createCallExpression</span><span class="s1">;</span>
<span class="s2">exports.createCompilerError = createCompilerError</span><span class="s1">;</span>
<span class="s2">exports.createCompoundExpression = createCompoundExpression</span><span class="s1">;</span>
<span class="s2">exports.createConditionalExpression = createConditionalExpression</span><span class="s1">;</span>
<span class="s2">exports.createForLoopParams = createForLoopParams</span><span class="s1">;</span>
<span class="s2">exports.createFunctionExpression = createFunctionExpression</span><span class="s1">;</span>
<span class="s2">exports.createIfStatement = createIfStatement</span><span class="s1">;</span>
<span class="s2">exports.createInterpolation = createInterpolation</span><span class="s1">;</span>
<span class="s2">exports.createObjectExpression = createObjectExpression</span><span class="s1">;</span>
<span class="s2">exports.createObjectProperty = createObjectProperty</span><span class="s1">;</span>
<span class="s2">exports.createReturnStatement = createReturnStatement</span><span class="s1">;</span>
<span class="s2">exports.createRoot = createRoot</span><span class="s1">;</span>
<span class="s2">exports.createSequenceExpression = createSequenceExpression</span><span class="s1">;</span>
<span class="s2">exports.createSimpleExpression = createSimpleExpression</span><span class="s1">;</span>
<span class="s2">exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform</span><span class="s1">;</span>
<span class="s2">exports.createTemplateLiteral = createTemplateLiteral</span><span class="s1">;</span>
<span class="s2">exports.createTransformContext = createTransformContext</span><span class="s1">;</span>
<span class="s2">exports.createVNodeCall = createVNodeCall</span><span class="s1">;</span>
<span class="s2">exports.extractIdentifiers = extractIdentifiers</span><span class="s1">;</span>
<span class="s2">exports.findDir = findDir</span><span class="s1">;</span>
<span class="s2">exports.findProp = findProp</span><span class="s1">;</span>
<span class="s2">exports.generate = generate</span><span class="s1">;</span>
<span class="s2">exports.getBaseTransformPreset = getBaseTransformPreset</span><span class="s1">;</span>
<span class="s2">exports.getConstantType = getConstantType</span><span class="s1">;</span>
<span class="s2">exports.getInnerRange = getInnerRange</span><span class="s1">;</span>
<span class="s2">exports.getMemoedVNodeCall = getMemoedVNodeCall</span><span class="s1">;</span>
<span class="s2">exports.getVNodeBlockHelper = getVNodeBlockHelper</span><span class="s1">;</span>
<span class="s2">exports.getVNodeHelper = getVNodeHelper</span><span class="s1">;</span>
<span class="s2">exports.hasDynamicKeyVBind = hasDynamicKeyVBind</span><span class="s1">;</span>
<span class="s2">exports.hasScopeRef = hasScopeRef</span><span class="s1">;</span>
<span class="s2">exports.helperNameMap = helperNameMap</span><span class="s1">;</span>
<span class="s2">exports.injectProp = injectProp</span><span class="s1">;</span>
<span class="s2">exports.isBuiltInType = isBuiltInType</span><span class="s1">;</span>
<span class="s2">exports.isCoreComponent = isCoreComponent</span><span class="s1">;</span>
<span class="s2">exports.isFunctionType = isFunctionType</span><span class="s1">;</span>
<span class="s2">exports.isInDestructureAssignment = isInDestructureAssignment</span><span class="s1">;</span>
<span class="s2">exports.isMemberExpression = isMemberExpression</span><span class="s1">;</span>
<span class="s2">exports.isMemberExpressionBrowser = isMemberExpressionBrowser</span><span class="s1">;</span>
<span class="s2">exports.isMemberExpressionNode = isMemberExpressionNode</span><span class="s1">;</span>
<span class="s2">exports.isReferencedIdentifier = isReferencedIdentifier</span><span class="s1">;</span>
<span class="s2">exports.isSimpleIdentifier = isSimpleIdentifier</span><span class="s1">;</span>
<span class="s2">exports.isSlotOutlet = isSlotOutlet</span><span class="s1">;</span>
<span class="s2">exports.isStaticArgOf = isStaticArgOf</span><span class="s1">;</span>
<span class="s2">exports.isStaticExp = isStaticExp</span><span class="s1">;</span>
<span class="s2">exports.isStaticProperty = isStaticProperty</span><span class="s1">;</span>
<span class="s2">exports.isStaticPropertyKey = isStaticPropertyKey</span><span class="s1">;</span>
<span class="s2">exports.isTemplateNode = isTemplateNode</span><span class="s1">;</span>
<span class="s2">exports.isText = isText$1</span><span class="s1">;</span>
<span class="s2">exports.isVSlot = isVSlot</span><span class="s1">;</span>
<span class="s2">exports.locStub = locStub</span><span class="s1">;</span>
<span class="s2">exports.makeBlock = makeBlock</span><span class="s1">;</span>
<span class="s2">exports.noopDirectiveTransform = noopDirectiveTransform</span><span class="s1">;</span>
<span class="s2">exports.processExpression = processExpression</span><span class="s1">;</span>
<span class="s2">exports.processFor = processFor</span><span class="s1">;</span>
<span class="s2">exports.processIf = processIf</span><span class="s1">;</span>
<span class="s2">exports.processSlotOutlet = processSlotOutlet</span><span class="s1">;</span>
<span class="s2">exports.registerRuntimeHelpers = registerRuntimeHelpers</span><span class="s1">;</span>
<span class="s2">exports.resolveComponentType = resolveComponentType</span><span class="s1">;</span>
<span class="s2">exports.stringifyExpression = stringifyExpression</span><span class="s1">;</span>
<span class="s2">exports.toValidAssetId = toValidAssetId</span><span class="s1">;</span>
<span class="s2">exports.trackSlotScopes = trackSlotScopes</span><span class="s1">;</span>
<span class="s2">exports.trackVForSlotScopes = trackVForSlotScopes</span><span class="s1">;</span>
<span class="s2">exports.transform = transform</span><span class="s1">;</span>
<span class="s2">exports.transformBind = transformBind</span><span class="s1">;</span>
<span class="s2">exports.transformElement = transformElement</span><span class="s1">;</span>
<span class="s2">exports.transformExpression = transformExpression</span><span class="s1">;</span>
<span class="s2">exports.transformModel = transformModel</span><span class="s1">;</span>
<span class="s2">exports.transformOn = transformOn</span><span class="s1">;</span>
<span class="s2">exports.traverseNode = traverseNode</span><span class="s1">;</span>
<span class="s2">exports.walkBlockDeclarations = walkBlockDeclarations</span><span class="s1">;</span>
<span class="s2">exports.walkFunctionParams = walkFunctionParams</span><span class="s1">;</span>
<span class="s2">exports.walkIdentifiers = walkIdentifiers</span><span class="s1">;</span>
<span class="s2">exports.warnDeprecation = warnDeprecation</span><span class="s1">;</span>
</pre>
</body>
</html>