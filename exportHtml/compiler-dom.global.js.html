<html>
<head>
<title>compiler-dom.global.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compiler-dom.global.js</font>
</center></td></tr></table>
<pre><span class="s0">var </span><span class="s1">VueCompilerDOM = (</span><span class="s0">function </span><span class="s1">(exports) {</span>
  <span class="s2">'use strict'</span><span class="s0">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Make a map and return a function for checking if a key</span>
   <span class="s3">* is in that map.</span>
   <span class="s3">* IMPORTANT: all calls of this function must be prefixed with</span>
   <span class="s3">* \/\*#\_\_PURE\_\_\*\/</span>
   <span class="s3">* So that rollup can tree-shake them if necessary.</span>
   <span class="s3">*/</span>
  <span class="s0">function </span><span class="s1">makeMap(str</span><span class="s0">, </span><span class="s1">expectsLowerCase) {</span>
      <span class="s0">const </span><span class="s1">map = Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">list = str.split(</span><span class="s2">','</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; list.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s1">map[list[i]] = </span><span class="s0">true;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val]</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* dev only flag -&gt; name mapping</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">PatchFlagNames = {</span>
      <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">]: </span><span class="s2">`TEXT`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* PatchFlags.CLASS */</span><span class="s1">]: </span><span class="s2">`CLASS`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">4 </span><span class="s5">/* PatchFlags.STYLE */</span><span class="s1">]: </span><span class="s2">`STYLE`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s1">]: </span><span class="s2">`PROPS`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s1">]: </span><span class="s2">`FULL_PROPS`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">]: </span><span class="s2">`HYDRATE_EVENTS`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]: </span><span class="s2">`STABLE_FRAGMENT`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s1">]: </span><span class="s2">`KEYED_FRAGMENT`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s1">]: </span><span class="s2">`UNKEYED_FRAGMENT`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */</span><span class="s1">]: </span><span class="s2">`NEED_PATCH`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">]: </span><span class="s2">`DYNAMIC_SLOTS`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]: </span><span class="s2">`DEV_ROOT_FRAGMENT`</span><span class="s0">,</span>
      <span class="s1">[-</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */</span><span class="s1">]: </span><span class="s2">`HOISTED`</span><span class="s0">,</span>
      <span class="s1">[-</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s1">]: </span><span class="s2">`BAIL`</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Dev only</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">slotFlagsText = {</span>
      <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s1">]: </span><span class="s2">'STABLE'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* SlotFlags.DYNAMIC */</span><span class="s1">]: </span><span class="s2">'DYNAMIC'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">3 </span><span class="s5">/* SlotFlags.FORWARDED */</span><span class="s1">]: </span><span class="s2">'FORWARDED'</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">range = </span><span class="s4">2</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">generateCodeFrame(source</span><span class="s0">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s0">, </span><span class="s1">end = source.length) {</span>
      <span class="s5">// Split the content into individual lines but capture the newline sequence</span>
      <span class="s5">// that separated each line. This is important because the actual sequence is</span>
      <span class="s5">// needed to properly take into account the full line length for offset</span>
      <span class="s5">// comparison</span>
      <span class="s0">let </span><span class="s1">lines = source.split(</span><span class="s4">/(\r?\n)/</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s5">// Separate the lines and newline sequences into separate arrays for easier referencing</span>
      <span class="s0">const </span><span class="s1">newlineSequences = lines.filter((_</span><span class="s0">, </span><span class="s1">idx) =&gt; idx % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">lines = lines.filter((_</span><span class="s0">, </span><span class="s1">idx) =&gt; idx % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">count = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">res = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; lines.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s1">count +=</span>
              <span class="s1">lines[i].length +</span>
                  <span class="s1">((newlineSequences[i] &amp;&amp; newlineSequences[i].length) || </span><span class="s4">0</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(count &gt;= start) {</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = i - range</span><span class="s0">; </span><span class="s1">j &lt;= i + range || end &gt; count</span><span class="s0">; </span><span class="s1">j++) {</span>
                  <span class="s0">if </span><span class="s1">(j &lt; </span><span class="s4">0 </span><span class="s1">|| j &gt;= lines.length)</span>
                      <span class="s0">continue;</span>
                  <span class="s0">const </span><span class="s1">line = j + </span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s1">res.push(</span><span class="s2">`</span><span class="s1">${line}${</span><span class="s2">' '</span><span class="s1">.repeat(Math.max(</span><span class="s4">3 </span><span class="s1">- String(line).length</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))}</span><span class="s2">|  </span><span class="s1">${lines[j]}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">lineLength = lines[j].length</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">newLineSeqLength = (newlineSequences[j] &amp;&amp; newlineSequences[j].length) || </span><span class="s4">0</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(j === i) {</span>
                      <span class="s5">// push underline</span>
                      <span class="s0">const </span><span class="s1">pad = start - (count - (lineLength + newLineSeqLength))</span><span class="s0">;</span>
                      <span class="s0">const </span><span class="s1">length = Math.max(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">end &gt; count ? lineLength - pad : end - start)</span><span class="s0">;</span>
                      <span class="s1">res.push(</span><span class="s2">`   |  ` </span><span class="s1">+ </span><span class="s2">' '</span><span class="s1">.repeat(pad) + </span><span class="s2">'^'</span><span class="s1">.repeat(length))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(j &gt; i) {</span>
                      <span class="s0">if </span><span class="s1">(end &gt; count) {</span>
                          <span class="s0">const </span><span class="s1">length = Math.max(Math.min(end - count</span><span class="s0">, </span><span class="s1">lineLength)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s1">res.push(</span><span class="s2">`   |  ` </span><span class="s1">+ </span><span class="s2">'^'</span><span class="s1">.repeat(length))</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s1">count += lineLength + newLineSeqLength</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">res.join(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">listDelimiterRE = </span><span class="s4">/;(?![^(]*\))/g</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">propertyDelimiterRE = </span><span class="s4">/:([^]+)/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">styleCommentRE = </span><span class="s4">/\/\*.*?\*\//gs</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">parseStringStyle(cssText) {</span>
      <span class="s0">const </span><span class="s1">ret = {}</span><span class="s0">;</span>
      <span class="s1">cssText</span>
          <span class="s1">.replace(styleCommentRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
          <span class="s1">.split(listDelimiterRE)</span>
          <span class="s1">.forEach(item =&gt; {</span>
          <span class="s0">if </span><span class="s1">(item) {</span>
              <span class="s0">const </span><span class="s1">tmp = item.split(propertyDelimiterRE)</span><span class="s0">;</span>
              <span class="s1">tmp.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; (ret[tmp[</span><span class="s4">0</span><span class="s1">].trim()] = tmp[</span><span class="s4">1</span><span class="s1">].trim())</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">})</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s5">// These tag configs are shared between compiler-dom and runtime-dom, so they</span>
  <span class="s5">// https://developer.mozilla.org/en-US/docs/Web/HTML/Element</span>
  <span class="s0">const </span><span class="s1">HTML_TAGS = </span><span class="s2">'html,body,base,head,link,meta,style,title,address,article,aside,footer,' </span><span class="s1">+</span>
      <span class="s2">'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' </span><span class="s1">+</span>
      <span class="s2">'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' </span><span class="s1">+</span>
      <span class="s2">'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' </span><span class="s1">+</span>
      <span class="s2">'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' </span><span class="s1">+</span>
      <span class="s2">'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' </span><span class="s1">+</span>
      <span class="s2">'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' </span><span class="s1">+</span>
      <span class="s2">'option,output,progress,select,textarea,details,dialog,menu,' </span><span class="s1">+</span>
      <span class="s2">'summary,template,blockquote,iframe,tfoot'</span><span class="s0">;</span>
  <span class="s5">// https://developer.mozilla.org/en-US/docs/Web/SVG/Element</span>
  <span class="s0">const </span><span class="s1">SVG_TAGS = </span><span class="s2">'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' </span><span class="s1">+</span>
      <span class="s2">'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' </span><span class="s1">+</span>
      <span class="s2">'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' </span><span class="s1">+</span>
      <span class="s2">'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' </span><span class="s1">+</span>
      <span class="s2">'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' </span><span class="s1">+</span>
      <span class="s2">'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' </span><span class="s1">+</span>
      <span class="s2">'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' </span><span class="s1">+</span>
      <span class="s2">'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' </span><span class="s1">+</span>
      <span class="s2">'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' </span><span class="s1">+</span>
      <span class="s2">'text,textPath,title,tspan,unknown,use,view'</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">VOID_TAGS = </span><span class="s2">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Compiler only.</span>
   <span class="s3">* Do NOT use in runtime code paths unless behind `true` flag.</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">isHTMLTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(HTML_TAGS)</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Compiler only.</span>
   <span class="s3">* Do NOT use in runtime code paths unless behind `true` flag.</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">isSVGTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(SVG_TAGS)</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Compiler only.</span>
   <span class="s3">* Do NOT use in runtime code paths unless behind `true` flag.</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">isVoidTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(VOID_TAGS)</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">EMPTY_OBJ = Object.freeze({})</span>
      <span class="s0">;</span>
  <span class="s0">const </span><span class="s1">NOOP = () =&gt; { }</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Always return false.</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">NO = () =&gt; </span><span class="s0">false;</span>
  <span class="s0">const </span><span class="s1">onRE = </span><span class="s4">/^on[^a-z]/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isOn = (key) =&gt; onRE.test(key)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">extend = Object.assign</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isArray = Array.isArray</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isString = (val) =&gt; </span><span class="s0">typeof </span><span class="s1">val === </span><span class="s2">'string'</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isSymbol = (val) =&gt; </span><span class="s0">typeof </span><span class="s1">val === </span><span class="s2">'symbol'</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isObject = (val) =&gt; val !== </span><span class="s0">null </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">val === </span><span class="s2">'object'</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isReservedProp = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span>
  <span class="s5">// the leading comma is intentional so empty string &quot;&quot; is also included</span>
  <span class="s2">',key,ref,ref_for,ref_key,' </span><span class="s1">+</span>
      <span class="s2">'onVnodeBeforeMount,onVnodeMounted,' </span><span class="s1">+</span>
      <span class="s2">'onVnodeBeforeUpdate,onVnodeUpdated,' </span><span class="s1">+</span>
      <span class="s2">'onVnodeBeforeUnmount,onVnodeUnmounted'</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isBuiltInDirective = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">cacheStringFunction = (fn) =&gt; {</span>
      <span class="s0">const </span><span class="s1">cache = Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">((str) =&gt; {</span>
          <span class="s0">const </span><span class="s1">hit = cache[str]</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">hit || (cache[str] = fn(str))</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">camelizeRE = </span><span class="s4">/-(\w)/g</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s6">@private</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">camelize = cacheStringFunction((str) =&gt; {</span>
      <span class="s0">return </span><span class="s1">str.replace(camelizeRE</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">c) =&gt; (c ? c.toUpperCase() : </span><span class="s2">''</span><span class="s1">))</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hyphenateRE = </span><span class="s4">/\B([A-Z])/g</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s6">@private</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">hyphenate = cacheStringFunction((str) =&gt; str.replace(hyphenateRE</span><span class="s0">, </span><span class="s2">'-$1'</span><span class="s1">).toLowerCase())</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s6">@private</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">capitalize = cacheStringFunction((str) =&gt; str.charAt(</span><span class="s4">0</span><span class="s1">).toUpperCase() + str.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* </span><span class="s6">@private</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">toHandlerKey = cacheStringFunction((str) =&gt; str ? </span><span class="s2">`on</span><span class="s1">${capitalize(str)}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>

  <span class="s0">function </span><span class="s1">defaultOnError(error) {</span>
      <span class="s0">throw </span><span class="s1">error</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">defaultOnWarn(msg) {</span>
      <span class="s1">console.warn(</span><span class="s2">`[Vue warn] </span><span class="s1">${msg.message}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createCompilerError(code</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">messages</span><span class="s0">, </span><span class="s1">additionalMessage) {</span>
      <span class="s0">const </span><span class="s1">msg = (messages || errorMessages)[code] + (additionalMessage || </span><span class="s2">``</span><span class="s1">)</span>
          <span class="s0">;</span>
      <span class="s0">const </span><span class="s1">error = </span><span class="s0">new </span><span class="s1">SyntaxError(String(msg))</span><span class="s0">;</span>
      <span class="s1">error.code = code</span><span class="s0">;</span>
      <span class="s1">error.loc = loc</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">error</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">errorMessages = {</span>
      <span class="s5">// parse errors</span>
      <span class="s1">[</span><span class="s4">0 </span><span class="s5">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">]: </span><span class="s2">'Illegal comment.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">]: </span><span class="s2">'CDATA section is allowed only in XML context.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">]: </span><span class="s2">'Duplicate attribute.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">3 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">]: </span><span class="s2">'End tag cannot have attributes.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">4 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">]: </span><span class="s2">&quot;Illegal '/' in tags.&quot;</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in tag.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">6 </span><span class="s5">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in CDATA section.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">7 </span><span class="s5">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in comment.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">8 </span><span class="s5">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in script.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">9 </span><span class="s5">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in tag.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">10 </span><span class="s5">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">]: </span><span class="s2">'Incorrectly closed comment.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">11 </span><span class="s5">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">]: </span><span class="s2">'Incorrectly opened comment.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s2">&quot;Illegal tag name. Use '&amp;lt;' to print '&lt;'.&quot;</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">13 </span><span class="s5">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s2">'Attribute value was expected.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">14 </span><span class="s5">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s1">]: </span><span class="s2">'End tag name was expected.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">15 </span><span class="s5">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">]: </span><span class="s2">'Whitespace was expected.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">16 </span><span class="s5">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">]: </span><span class="s2">&quot;Unexpected '&lt;!--' in comment.&quot;</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">17 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s2">'Attribute name cannot contain U+0022 (&quot;), U+0027 (</span><span class="s0">\'</span><span class="s2">), and U+003C (&lt;).'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">18 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s2">'Unquoted attribute value cannot contain U+0022 (&quot;), U+0027 (</span><span class="s0">\'</span><span class="s2">), U+003C (&lt;), U+003D (=), and U+0060 (`).'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">19 </span><span class="s5">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s2">&quot;Attribute name cannot start with '='.&quot;</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">21 </span><span class="s5">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s2">&quot;'&lt;?' is allowed only in XML context.&quot;</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">20 </span><span class="s5">/* ErrorCodes.UNEXPECTED_NULL_CHARACTER */</span><span class="s1">]: </span><span class="s2">`Unexpected null character.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">22 </span><span class="s5">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">]: </span><span class="s2">&quot;Illegal '/' in tags.&quot;</span><span class="s0">,</span>
      <span class="s5">// Vue-specific parse errors</span>
      <span class="s1">[</span><span class="s4">23 </span><span class="s5">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">]: </span><span class="s2">'Invalid end tag.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">24 </span><span class="s5">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s1">]: </span><span class="s2">'Element is missing end tag.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">25 </span><span class="s5">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">]: </span><span class="s2">'Interpolation end sign was not found.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">27 </span><span class="s5">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">]: </span><span class="s2">'End bracket for dynamic directive argument was not found. ' </span><span class="s1">+</span>
          <span class="s2">'Note that dynamic directive argument cannot contain spaces.'</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">26 </span><span class="s5">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">]: </span><span class="s2">'Legal directive name was expected.'</span><span class="s0">,</span>
      <span class="s5">// transform errors</span>
      <span class="s1">[</span><span class="s4">28 </span><span class="s5">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-if/v-else-if is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">29 </span><span class="s5">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s1">]: </span><span class="s2">`v-if/else branches must use unique keys.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">]: </span><span class="s2">`v-else/v-else-if has no adjacent v-if or v-else-if.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">31 </span><span class="s5">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-for is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-for has invalid expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">33 </span><span class="s5">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s1">]: </span><span class="s2">`&lt;template v-for&gt; key should be placed on the &lt;template&gt; tag.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-bind is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-on is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">36 </span><span class="s5">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s1">]: </span><span class="s2">`Unexpected custom directive on &lt;slot&gt; outlet.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">37 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s1">]: </span><span class="s2">`Mixed v-slot usage on both the component and nested &lt;template&gt;. ` </span><span class="s1">+</span>
          <span class="s2">`When there are multiple named slots, all slots should use &lt;template&gt; ` </span><span class="s1">+</span>
          <span class="s2">`syntax to avoid scope ambiguity.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">38 </span><span class="s5">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s1">]: </span><span class="s2">`Duplicate slot names found. `</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">39 </span><span class="s5">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s1">]: </span><span class="s2">`Extraneous children found when component already has explicitly named ` </span><span class="s1">+</span>
          <span class="s2">`default slot. These children will be ignored.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">40 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s1">]: </span><span class="s2">`v-slot can only be used on components or &lt;template&gt; tags.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">41 </span><span class="s5">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-model is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">42 </span><span class="s5">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-model value must be a valid JavaScript member expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">43 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */</span><span class="s1">]: </span><span class="s2">`v-model cannot be used on v-for or v-slot scope variables because they are not writable.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">44 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s1">]: </span><span class="s2">`v-model cannot be used on a prop, because local prop bindings are not writable.</span><span class="s0">\n</span><span class="s2">Use a v-bind binding combined with a v-on listener that emits update:x event instead.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">45 </span><span class="s5">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`Error parsing JavaScript expression: `</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">46 </span><span class="s5">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s1">]: </span><span class="s2">`&lt;KeepAlive&gt; expects exactly one child component.`</span><span class="s0">,</span>
      <span class="s5">// generic errors</span>
      <span class="s1">[</span><span class="s4">47 </span><span class="s5">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;prefixIdentifiers&quot; option is not supported in this build of compiler.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">48 </span><span class="s5">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`ES module mode is not supported in this build of compiler.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">49 </span><span class="s5">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;cacheHandlers&quot; option is only supported when the &quot;prefixIdentifiers&quot; option is enabled.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">50 </span><span class="s5">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;scopeId&quot; option is only supported in module mode.`</span><span class="s0">,</span>
      <span class="s5">// just to fulfill types</span>
      <span class="s1">[</span><span class="s4">51 </span><span class="s5">/* ErrorCodes.__EXTEND_POINT__ */</span><span class="s1">]: </span><span class="s2">``</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">FRAGMENT = Symbol(</span><span class="s2">`Fragment` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TELEPORT = Symbol(</span><span class="s2">`Teleport` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">SUSPENSE = Symbol(</span><span class="s2">`Suspense` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">KEEP_ALIVE = Symbol(</span><span class="s2">`KeepAlive` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">BASE_TRANSITION = Symbol(</span><span class="s2">`BaseTransition` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">OPEN_BLOCK = Symbol(</span><span class="s2">`openBlock` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_BLOCK = Symbol(</span><span class="s2">`createBlock` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_ELEMENT_BLOCK = Symbol(</span><span class="s2">`createElementBlock` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_VNODE = Symbol(</span><span class="s2">`createVNode` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_ELEMENT_VNODE = Symbol(</span><span class="s2">`createElementVNode` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_COMMENT = Symbol(</span><span class="s2">`createCommentVNode` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_TEXT = Symbol(</span><span class="s2">`createTextVNode` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_STATIC = Symbol(</span><span class="s2">`createStaticVNode` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RESOLVE_COMPONENT = Symbol(</span><span class="s2">`resolveComponent` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RESOLVE_DYNAMIC_COMPONENT = Symbol(</span><span class="s2">`resolveDynamicComponent` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RESOLVE_DIRECTIVE = Symbol(</span><span class="s2">`resolveDirective` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RESOLVE_FILTER = Symbol(</span><span class="s2">`resolveFilter` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">WITH_DIRECTIVES = Symbol(</span><span class="s2">`withDirectives` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RENDER_LIST = Symbol(</span><span class="s2">`renderList` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">RENDER_SLOT = Symbol(</span><span class="s2">`renderSlot` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CREATE_SLOTS = Symbol(</span><span class="s2">`createSlots` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TO_DISPLAY_STRING = Symbol(</span><span class="s2">`toDisplayString` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">MERGE_PROPS = Symbol(</span><span class="s2">`mergeProps` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">NORMALIZE_CLASS = Symbol(</span><span class="s2">`normalizeClass` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">NORMALIZE_STYLE = Symbol(</span><span class="s2">`normalizeStyle` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">NORMALIZE_PROPS = Symbol(</span><span class="s2">`normalizeProps` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">GUARD_REACTIVE_PROPS = Symbol(</span><span class="s2">`guardReactiveProps` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TO_HANDLERS = Symbol(</span><span class="s2">`toHandlers` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CAMELIZE = Symbol(</span><span class="s2">`camelize` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">CAPITALIZE = Symbol(</span><span class="s2">`capitalize` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TO_HANDLER_KEY = Symbol(</span><span class="s2">`toHandlerKey` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">SET_BLOCK_TRACKING = Symbol(</span><span class="s2">`setBlockTracking` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">PUSH_SCOPE_ID = Symbol(</span><span class="s2">`pushScopeId` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">POP_SCOPE_ID = Symbol(</span><span class="s2">`popScopeId` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">WITH_CTX = Symbol(</span><span class="s2">`withCtx` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">UNREF = Symbol(</span><span class="s2">`unref` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">IS_REF = Symbol(</span><span class="s2">`isRef` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">WITH_MEMO = Symbol(</span><span class="s2">`withMemo` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">IS_MEMO_SAME = Symbol(</span><span class="s2">`isMemoSame` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s5">// Name mapping for runtime helpers that need to be imported from 'vue' in</span>
  <span class="s5">// generated code. Make sure these are correctly exported in the runtime!</span>
  <span class="s0">const </span><span class="s1">helperNameMap = {</span>
      <span class="s1">[FRAGMENT]: </span><span class="s2">`Fragment`</span><span class="s0">,</span>
      <span class="s1">[TELEPORT]: </span><span class="s2">`Teleport`</span><span class="s0">,</span>
      <span class="s1">[SUSPENSE]: </span><span class="s2">`Suspense`</span><span class="s0">,</span>
      <span class="s1">[KEEP_ALIVE]: </span><span class="s2">`KeepAlive`</span><span class="s0">,</span>
      <span class="s1">[BASE_TRANSITION]: </span><span class="s2">`BaseTransition`</span><span class="s0">,</span>
      <span class="s1">[OPEN_BLOCK]: </span><span class="s2">`openBlock`</span><span class="s0">,</span>
      <span class="s1">[CREATE_BLOCK]: </span><span class="s2">`createBlock`</span><span class="s0">,</span>
      <span class="s1">[CREATE_ELEMENT_BLOCK]: </span><span class="s2">`createElementBlock`</span><span class="s0">,</span>
      <span class="s1">[CREATE_VNODE]: </span><span class="s2">`createVNode`</span><span class="s0">,</span>
      <span class="s1">[CREATE_ELEMENT_VNODE]: </span><span class="s2">`createElementVNode`</span><span class="s0">,</span>
      <span class="s1">[CREATE_COMMENT]: </span><span class="s2">`createCommentVNode`</span><span class="s0">,</span>
      <span class="s1">[CREATE_TEXT]: </span><span class="s2">`createTextVNode`</span><span class="s0">,</span>
      <span class="s1">[CREATE_STATIC]: </span><span class="s2">`createStaticVNode`</span><span class="s0">,</span>
      <span class="s1">[RESOLVE_COMPONENT]: </span><span class="s2">`resolveComponent`</span><span class="s0">,</span>
      <span class="s1">[RESOLVE_DYNAMIC_COMPONENT]: </span><span class="s2">`resolveDynamicComponent`</span><span class="s0">,</span>
      <span class="s1">[RESOLVE_DIRECTIVE]: </span><span class="s2">`resolveDirective`</span><span class="s0">,</span>
      <span class="s1">[RESOLVE_FILTER]: </span><span class="s2">`resolveFilter`</span><span class="s0">,</span>
      <span class="s1">[WITH_DIRECTIVES]: </span><span class="s2">`withDirectives`</span><span class="s0">,</span>
      <span class="s1">[RENDER_LIST]: </span><span class="s2">`renderList`</span><span class="s0">,</span>
      <span class="s1">[RENDER_SLOT]: </span><span class="s2">`renderSlot`</span><span class="s0">,</span>
      <span class="s1">[CREATE_SLOTS]: </span><span class="s2">`createSlots`</span><span class="s0">,</span>
      <span class="s1">[TO_DISPLAY_STRING]: </span><span class="s2">`toDisplayString`</span><span class="s0">,</span>
      <span class="s1">[MERGE_PROPS]: </span><span class="s2">`mergeProps`</span><span class="s0">,</span>
      <span class="s1">[NORMALIZE_CLASS]: </span><span class="s2">`normalizeClass`</span><span class="s0">,</span>
      <span class="s1">[NORMALIZE_STYLE]: </span><span class="s2">`normalizeStyle`</span><span class="s0">,</span>
      <span class="s1">[NORMALIZE_PROPS]: </span><span class="s2">`normalizeProps`</span><span class="s0">,</span>
      <span class="s1">[GUARD_REACTIVE_PROPS]: </span><span class="s2">`guardReactiveProps`</span><span class="s0">,</span>
      <span class="s1">[TO_HANDLERS]: </span><span class="s2">`toHandlers`</span><span class="s0">,</span>
      <span class="s1">[CAMELIZE]: </span><span class="s2">`camelize`</span><span class="s0">,</span>
      <span class="s1">[CAPITALIZE]: </span><span class="s2">`capitalize`</span><span class="s0">,</span>
      <span class="s1">[TO_HANDLER_KEY]: </span><span class="s2">`toHandlerKey`</span><span class="s0">,</span>
      <span class="s1">[SET_BLOCK_TRACKING]: </span><span class="s2">`setBlockTracking`</span><span class="s0">,</span>
      <span class="s1">[PUSH_SCOPE_ID]: </span><span class="s2">`pushScopeId`</span><span class="s0">,</span>
      <span class="s1">[POP_SCOPE_ID]: </span><span class="s2">`popScopeId`</span><span class="s0">,</span>
      <span class="s1">[WITH_CTX]: </span><span class="s2">`withCtx`</span><span class="s0">,</span>
      <span class="s1">[UNREF]: </span><span class="s2">`unref`</span><span class="s0">,</span>
      <span class="s1">[IS_REF]: </span><span class="s2">`isRef`</span><span class="s0">,</span>
      <span class="s1">[WITH_MEMO]: </span><span class="s2">`withMemo`</span><span class="s0">,</span>
      <span class="s1">[IS_MEMO_SAME]: </span><span class="s2">`isMemoSame`</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">registerRuntimeHelpers(helpers) {</span>
      <span class="s1">Object.getOwnPropertySymbols(helpers).forEach(s =&gt; {</span>
          <span class="s1">helperNameMap[s] = helpers[s]</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s5">// AST Utilities ---------------------------------------------------------------</span>
  <span class="s5">// Some expressions, e.g. sequence and conditional expressions, are never</span>
  <span class="s5">// associated with template nodes, so their source locations are just a stub.</span>
  <span class="s5">// Container types like CompoundExpression also don't need a real location.</span>
  <span class="s0">const </span><span class="s1">locStub = {</span>
      <span class="s1">source: </span><span class="s2">''</span><span class="s0">,</span>
      <span class="s1">start: { line: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span><span class="s0">,</span>
      <span class="s1">end: { line: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">createRoot(children</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */</span><span class="s0">,</span>
          <span class="s1">children</span><span class="s0">,</span>
          <span class="s1">helpers: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
          <span class="s1">components: []</span><span class="s0">,</span>
          <span class="s1">directives: []</span><span class="s0">,</span>
          <span class="s1">hoists: []</span><span class="s0">,</span>
          <span class="s1">imports: []</span><span class="s0">,</span>
          <span class="s1">cached: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">temps: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">codegenNode: undefined</span><span class="s0">,</span>
          <span class="s1">loc</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createVNodeCall(context</span><span class="s0">, </span><span class="s1">tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps</span><span class="s0">, </span><span class="s1">directives</span><span class="s0">, </span><span class="s1">isBlock = </span><span class="s0">false, </span><span class="s1">disableTracking = </span><span class="s0">false, </span><span class="s1">isComponent = </span><span class="s0">false, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">if </span><span class="s1">(context) {</span>
          <span class="s0">if </span><span class="s1">(isBlock) {</span>
              <span class="s1">context.helper(OPEN_BLOCK)</span><span class="s0">;</span>
              <span class="s1">context.helper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(directives) {</span>
              <span class="s1">context.helper(WITH_DIRECTIVES)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s0">,</span>
          <span class="s1">tag</span><span class="s0">,</span>
          <span class="s1">props</span><span class="s0">,</span>
          <span class="s1">children</span><span class="s0">,</span>
          <span class="s1">patchFlag</span><span class="s0">,</span>
          <span class="s1">dynamicProps</span><span class="s0">,</span>
          <span class="s1">directives</span><span class="s0">,</span>
          <span class="s1">isBlock</span><span class="s0">,</span>
          <span class="s1">disableTracking</span><span class="s0">,</span>
          <span class="s1">isComponent</span><span class="s0">,</span>
          <span class="s1">loc</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createArrayExpression(elements</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">elements</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createObjectExpression(properties</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">properties</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createObjectProperty(key</span><span class="s0">, </span><span class="s1">value) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">16 </span><span class="s5">/* NodeTypes.JS_PROPERTY */</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span><span class="s0">,</span>
          <span class="s1">key: isString(key) ? createSimpleExpression(key</span><span class="s0">, true</span><span class="s1">) : key</span><span class="s0">,</span>
          <span class="s1">value</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createSimpleExpression(content</span><span class="s0">, </span><span class="s1">isStatic = </span><span class="s0">false, </span><span class="s1">loc = locStub</span><span class="s0">, </span><span class="s1">constType = </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">content</span><span class="s0">,</span>
          <span class="s1">isStatic</span><span class="s0">,</span>
          <span class="s1">constType: isStatic ? </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */ </span><span class="s1">: constType</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createInterpolation(content</span><span class="s0">, </span><span class="s1">loc) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">content: isString(content)</span>
              <span class="s1">? createSimpleExpression(content</span><span class="s0">, false, </span><span class="s1">loc)</span>
              <span class="s1">: content</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createCompoundExpression(children</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">children</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createCallExpression(callee</span><span class="s0">, </span><span class="s1">args = []</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">loc</span><span class="s0">,</span>
          <span class="s1">callee</span><span class="s0">,</span>
          <span class="s1">arguments: args</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createFunctionExpression(params</span><span class="s0">, </span><span class="s1">returns = undefined</span><span class="s0">, </span><span class="s1">newline = </span><span class="s0">false, </span><span class="s1">isSlot = </span><span class="s0">false, </span><span class="s1">loc = locStub) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">18 </span><span class="s5">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">params</span><span class="s0">,</span>
          <span class="s1">returns</span><span class="s0">,</span>
          <span class="s1">newline</span><span class="s0">,</span>
          <span class="s1">isSlot</span><span class="s0">,</span>
          <span class="s1">loc</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createConditionalExpression(test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate</span><span class="s0">, </span><span class="s1">newline = </span><span class="s0">true</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">test</span><span class="s0">,</span>
          <span class="s1">consequent</span><span class="s0">,</span>
          <span class="s1">alternate</span><span class="s0">,</span>
          <span class="s1">newline</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createCacheExpression(index</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">isVNode = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">index</span><span class="s0">,</span>
          <span class="s1">value</span><span class="s0">,</span>
          <span class="s1">isVNode</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createBlockStatement(body) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">21 </span><span class="s5">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s0">,</span>
          <span class="s1">body</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createTemplateLiteral(elements) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">22 </span><span class="s5">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s0">,</span>
          <span class="s1">elements</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createIfStatement(test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">23 </span><span class="s5">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s0">,</span>
          <span class="s1">test</span><span class="s0">,</span>
          <span class="s1">consequent</span><span class="s0">,</span>
          <span class="s1">alternate</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createAssignmentExpression(left</span><span class="s0">, </span><span class="s1">right) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">24 </span><span class="s5">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">left</span><span class="s0">,</span>
          <span class="s1">right</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createSequenceExpression(expressions) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">25 </span><span class="s5">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s0">,</span>
          <span class="s1">expressions</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createReturnStatement(returns) {</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">26 </span><span class="s5">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s0">,</span>
          <span class="s1">returns</span><span class="s0">,</span>
          <span class="s1">loc: locStub</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">isStaticExp = (p) =&gt; p.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; p.isStatic</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isBuiltInType = (tag</span><span class="s0">, </span><span class="s1">expected) =&gt; tag === expected || tag === hyphenate(expected)</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">isCoreComponent(tag) {</span>
      <span class="s0">if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'Teleport'</span><span class="s1">)) {</span>
          <span class="s0">return </span><span class="s1">TELEPORT</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'Suspense'</span><span class="s1">)) {</span>
          <span class="s0">return </span><span class="s1">SUSPENSE</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'KeepAlive'</span><span class="s1">)) {</span>
          <span class="s0">return </span><span class="s1">KEEP_ALIVE</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'BaseTransition'</span><span class="s1">)) {</span>
          <span class="s0">return </span><span class="s1">BASE_TRANSITION</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">nonIdentifierRE = </span><span class="s4">/^\d|[^\$\w]/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isSimpleIdentifier = (name) =&gt; !nonIdentifierRE.test(name)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">validFirstIdentCharRE = </span><span class="s4">/[A-Za-z_$\xA0-\uFFFF]/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">validIdentCharRE = </span><span class="s4">/[\.\?\w$\xA0-\uFFFF]/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">whitespaceRE = </span><span class="s4">/\s+[.[]\s*|\s*[.[]\s+/g</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Simple lexer to check if an expression is a member expression. This is</span>
   <span class="s3">* lax and only checks validity at the root level (i.e. does not validate exps</span>
   <span class="s3">* inside square brackets), but it's ok since these are only used on template</span>
   <span class="s3">* expressions and false positives are invalid expressions in the first place.</span>
   <span class="s3">*/</span>
  <span class="s0">const </span><span class="s1">isMemberExpressionBrowser = (path) =&gt; {</span>
      <span class="s5">// remove whitespaces around . or [ first</span>
      <span class="s1">path = path.trim().replace(whitespaceRE</span><span class="s0">, </span><span class="s1">s =&gt; s.trim())</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">state = </span><span class="s4">0 </span><span class="s5">/* MemberExpLexState.inMemberExp */</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">stateStack = []</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">currentOpenBracketCount = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">currentOpenParensCount = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">currentStringType = </span><span class="s0">null;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; path.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">char = path.charAt(i)</span><span class="s0">;</span>
          <span class="s0">switch </span><span class="s1">(state) {</span>
              <span class="s0">case </span><span class="s4">0 </span><span class="s5">/* MemberExpLexState.inMemberExp */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(char === </span><span class="s2">'['</span><span class="s1">) {</span>
                      <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                      <span class="s1">state = </span><span class="s4">1 </span><span class="s5">/* MemberExpLexState.inBrackets */</span><span class="s0">;</span>
                      <span class="s1">currentOpenBracketCount++</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">'('</span><span class="s1">) {</span>
                      <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                      <span class="s1">state = </span><span class="s4">2 </span><span class="s5">/* MemberExpLexState.inParens */</span><span class="s0">;</span>
                      <span class="s1">currentOpenParensCount++</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(!(i === </span><span class="s4">0 </span><span class="s1">? validFirstIdentCharRE : validIdentCharRE).test(char)) {</span>
                      <span class="s0">return false;</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* MemberExpLexState.inBrackets */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(char === </span><span class="s2">`'` </span><span class="s1">|| char === </span><span class="s2">`&quot;` </span><span class="s1">|| char === </span><span class="s2">'`'</span><span class="s1">) {</span>
                      <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                      <span class="s1">state = </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s0">;</span>
                      <span class="s1">currentStringType = char</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`[`</span><span class="s1">) {</span>
                      <span class="s1">currentOpenBracketCount++</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`]`</span><span class="s1">) {</span>
                      <span class="s0">if </span><span class="s1">(!--currentOpenBracketCount) {</span>
                          <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">2 </span><span class="s5">/* MemberExpLexState.inParens */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(char === </span><span class="s2">`'` </span><span class="s1">|| char === </span><span class="s2">`&quot;` </span><span class="s1">|| char === </span><span class="s2">'`'</span><span class="s1">) {</span>
                      <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                      <span class="s1">state = </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s0">;</span>
                      <span class="s1">currentStringType = char</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`(`</span><span class="s1">) {</span>
                      <span class="s1">currentOpenParensCount++</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`)`</span><span class="s1">) {</span>
                      <span class="s5">// if the exp ends as a call then it should not be considered valid</span>
                      <span class="s0">if </span><span class="s1">(i === path.length - </span><span class="s4">1</span><span class="s1">) {</span>
                          <span class="s0">return false;</span>
                      <span class="s1">}</span>
                      <span class="s0">if </span><span class="s1">(!--currentOpenParensCount) {</span>
                          <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(char === currentStringType) {</span>
                      <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                      <span class="s1">currentStringType = </span><span class="s0">null;</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">!currentOpenBracketCount &amp;&amp; !currentOpenParensCount</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isMemberExpressionNode = NOOP</span>
      <span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isMemberExpression = isMemberExpressionBrowser</span>
      <span class="s0">;</span>
  <span class="s0">function </span><span class="s1">getInnerRange(loc</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">length) {</span>
      <span class="s0">const </span><span class="s1">source = loc.source.slice(offset</span><span class="s0">, </span><span class="s1">offset + length)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">newLoc = {</span>
          <span class="s1">source</span><span class="s0">,</span>
          <span class="s1">start: advancePositionWithClone(loc.start</span><span class="s0">, </span><span class="s1">loc.source</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">,</span>
          <span class="s1">end: loc.end</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(length != </span><span class="s0">null</span><span class="s1">) {</span>
          <span class="s1">newLoc.end = advancePositionWithClone(loc.start</span><span class="s0">, </span><span class="s1">loc.source</span><span class="s0">, </span><span class="s1">offset + length)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">newLoc</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">advancePositionWithClone(pos</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters = source.length) {</span>
      <span class="s0">return </span><span class="s1">advancePositionWithMutation(extend({}</span><span class="s0">, </span><span class="s1">pos)</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s5">// advance by mutation without cloning (for performance reasons), since this</span>
  <span class="s5">// gets called a lot in the parser</span>
  <span class="s0">function </span><span class="s1">advancePositionWithMutation(pos</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters = source.length) {</span>
      <span class="s0">let </span><span class="s1">linesCount = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">lastNewLinePos = -</span><span class="s4">1</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; numberOfCharacters</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">if </span><span class="s1">(source.charCodeAt(i) === </span><span class="s4">10 </span><span class="s5">/* newline char code */</span><span class="s1">) {</span>
              <span class="s1">linesCount++</span><span class="s0">;</span>
              <span class="s1">lastNewLinePos = i</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">pos.offset += numberOfCharacters</span><span class="s0">;</span>
      <span class="s1">pos.line += linesCount</span><span class="s0">;</span>
      <span class="s1">pos.column =</span>
          <span class="s1">lastNewLinePos === -</span><span class="s4">1</span>
              <span class="s1">? pos.column + numberOfCharacters</span>
              <span class="s1">: numberOfCharacters - lastNewLinePos</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">pos</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">assert(condition</span><span class="s0">, </span><span class="s1">msg) {</span>
      <span class="s5">/* istanbul ignore if */</span>
      <span class="s0">if </span><span class="s1">(!condition) {</span>
          <span class="s0">throw new </span><span class="s1">Error(msg || </span><span class="s2">`unexpected compiler condition`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">findDir(node</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">allowEmpty = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">(allowEmpty || p.exp) &amp;&amp;</span>
              <span class="s1">(isString(name) ? p.name === name : name.test(p.name))) {</span>
              <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">findProp(node</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">dynamicOnly = </span><span class="s0">false, </span><span class="s1">allowEmpty = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(dynamicOnly)</span>
                  <span class="s0">continue;</span>
              <span class="s0">if </span><span class="s1">(p.name === name &amp;&amp; (p.value || allowEmpty)) {</span>
                  <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
              <span class="s1">(p.exp || allowEmpty) &amp;&amp;</span>
              <span class="s1">isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s1">name)) {</span>
              <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isStaticArgOf(arg</span><span class="s0">, </span><span class="s1">name) {</span>
      <span class="s0">return </span><span class="s1">!!(arg &amp;&amp; isStaticExp(arg) &amp;&amp; arg.content === name)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">hasDynamicKeyVBind(node) {</span>
      <span class="s0">return </span><span class="s1">node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
          <span class="s1">(!p.arg || </span><span class="s5">// v-bind=&quot;obj&quot;</span>
              <span class="s1">p.arg.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">|| </span><span class="s5">// v-bind:[_ctx.foo]</span>
              <span class="s1">!p.arg.isStatic) </span><span class="s5">// v-bind:[foo]</span>
      <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isText$1(node) {</span>
      <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">|| node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isVSlot(p) {</span>
      <span class="s0">return </span><span class="s1">p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'slot'</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isTemplateNode(node) {</span>
      <span class="s0">return </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isSlotOutlet(node) {</span>
      <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getVNodeHelper(ssr</span><span class="s0">, </span><span class="s1">isComponent) {</span>
      <span class="s0">return </span><span class="s1">ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getVNodeBlockHelper(ssr</span><span class="s0">, </span><span class="s1">isComponent) {</span>
      <span class="s0">return </span><span class="s1">ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">propsHelperSet = </span><span class="s0">new </span><span class="s1">Set([NORMALIZE_PROPS</span><span class="s0">, </span><span class="s1">GUARD_REACTIVE_PROPS])</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">getUnnormalizedProps(props</span><span class="s0">, </span><span class="s1">callPath = []) {</span>
      <span class="s0">if </span><span class="s1">(props &amp;&amp;</span>
          <span class="s1">!isString(props) &amp;&amp;</span>
          <span class="s1">props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">callee = props.callee</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!isString(callee) &amp;&amp; propsHelperSet.has(callee)) {</span>
              <span class="s0">return </span><span class="s1">getUnnormalizedProps(props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">callPath.concat(props))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">[props</span><span class="s0">, </span><span class="s1">callPath]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">injectProp(node</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">let </span><span class="s1">propsWithInjection</span><span class="s0">;</span>
      <span class="s3">/**</span>
       <span class="s3">* 1. mergeProps(...)</span>
       <span class="s3">* 2. toHandlers(...)</span>
       <span class="s3">* 3. normalizeProps(...)</span>
       <span class="s3">* 4. normalizeProps(guardReactiveProps(...))</span>
       <span class="s3">*</span>
       <span class="s3">* we need to get the real props before normalization</span>
       <span class="s3">*/</span>
      <span class="s0">let </span><span class="s1">props = node.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */ </span><span class="s1">? node.props : node.arguments[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">callPath = []</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">parentCall</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(props &amp;&amp;</span>
          <span class="s1">!isString(props) &amp;&amp;</span>
          <span class="s1">props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">ret = getUnnormalizedProps(props)</span><span class="s0">;</span>
          <span class="s1">props = ret[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s1">callPath = ret[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(props == </span><span class="s0">null </span><span class="s1">|| isString(props)) {</span>
          <span class="s1">propsWithInjection = createObjectExpression([prop])</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s5">// merged props... add ours</span>
          <span class="s5">// only inject key to object literal if it's the first argument so that</span>
          <span class="s5">// if doesn't override user provided keys</span>
          <span class="s0">const </span><span class="s1">first = props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!isString(first) &amp;&amp; first.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s5">// #6631</span>
              <span class="s0">if </span><span class="s1">(!hasProp(prop</span><span class="s0">, </span><span class="s1">first)) {</span>
                  <span class="s1">first.properties.unshift(prop)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s0">if </span><span class="s1">(props.callee === TO_HANDLERS) {</span>
                  <span class="s5">// #2366</span>
                  <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">createObjectExpression([prop])</span><span class="s0">,</span>
                      <span class="s1">props</span>
                  <span class="s1">])</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">props.arguments.unshift(createObjectExpression([prop]))</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">!propsWithInjection &amp;&amp; (propsWithInjection = props)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(props.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(!hasProp(prop</span><span class="s0">, </span><span class="s1">props)) {</span>
              <span class="s1">props.properties.unshift(prop)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">propsWithInjection = props</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// single v-bind with expression, return a merged replacement</span>
          <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
              <span class="s1">createObjectExpression([prop])</span><span class="s0">,</span>
              <span class="s1">props</span>
          <span class="s1">])</span><span class="s0">;</span>
          <span class="s5">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
          <span class="s5">// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
          <span class="s5">// the `guardReactiveProps` will no longer be needed</span>
          <span class="s0">if </span><span class="s1">(parentCall &amp;&amp; parentCall.callee === GUARD_REACTIVE_PROPS) {</span>
              <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(parentCall) {</span>
              <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">node.props = propsWithInjection</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(parentCall) {</span>
              <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">node.arguments[</span><span class="s4">2</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s5">// check existing key to avoid overriding user provided keys</span>
  <span class="s0">function </span><span class="s1">hasProp(prop</span><span class="s0">, </span><span class="s1">props) {</span>
      <span class="s0">let </span><span class="s1">result = </span><span class="s0">false;</span>
      <span class="s0">if </span><span class="s1">(prop.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">propKeyName = prop.key.content</span><span class="s0">;</span>
          <span class="s1">result = props.properties.some(p =&gt; p.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">p.key.content === propKeyName)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">toValidAssetId(name</span><span class="s0">, </span><span class="s1">type) {</span>
      <span class="s5">// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
      <span class="s0">return </span><span class="s2">`_</span><span class="s1">${type}</span><span class="s2">_</span><span class="s1">${name.replace(</span><span class="s4">/[^\w]/g</span><span class="s0">, </span><span class="s1">(searchValue</span><span class="s0">, </span><span class="s1">replaceValue) =&gt; {</span>
        <span class="s0">return </span><span class="s1">searchValue === </span><span class="s2">'-' </span><span class="s1">? </span><span class="s2">'_' </span><span class="s1">: name.charCodeAt(replaceValue).toString()</span><span class="s0">;</span>
    <span class="s1">})}</span><span class="s2">`</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s5">// Check if a node contains expressions that reference current context scope ids</span>
  <span class="s0">function </span><span class="s1">hasScopeRef(node</span><span class="s0">, </span><span class="s1">ids) {</span>
      <span class="s0">if </span><span class="s1">(!node || Object.keys(ids).length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s0">return false;</span>
      <span class="s1">}</span>
      <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">(hasScopeRef(p.arg</span><span class="s0">, </span><span class="s1">ids) || hasScopeRef(p.exp</span><span class="s0">, </span><span class="s1">ids))) {</span>
                      <span class="s0">return true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(hasScopeRef(node.source</span><span class="s0">, </span><span class="s1">ids)) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">node.branches.some(b =&gt; hasScopeRef(b</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(hasScopeRef(node.condition</span><span class="s0">, </span><span class="s1">ids)) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">(!node.isStatic &amp;&amp;</span>
                  <span class="s1">isSimpleIdentifier(node.content) &amp;&amp;</span>
                  <span class="s1">!!ids[node.content])</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">node.children.some(c =&gt; isObject(c) &amp;&amp; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">hasScopeRef(node.content</span><span class="s0">, </span><span class="s1">ids)</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
              <span class="s0">return false;</span>
          <span class="s0">default</span><span class="s1">:</span>
              <span class="s0">return false;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getMemoedVNodeCall(node) {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp; node.callee === WITH_MEMO) {</span>
          <span class="s0">return </span><span class="s1">node.arguments[</span><span class="s4">1</span><span class="s1">].returns</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">makeBlock(node</span><span class="s0">, </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">removeHelper</span><span class="s0">, </span><span class="s1">inSSR }) {</span>
      <span class="s0">if </span><span class="s1">(!node.isBlock) {</span>
          <span class="s1">node.isBlock = </span><span class="s0">true;</span>
          <span class="s1">removeHelper(getVNodeHelper(inSSR</span><span class="s0">, </span><span class="s1">node.isComponent))</span><span class="s0">;</span>
          <span class="s1">helper(OPEN_BLOCK)</span><span class="s0">;</span>
          <span class="s1">helper(getVNodeBlockHelper(inSSR</span><span class="s0">, </span><span class="s1">node.isComponent))</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">deprecationData = {</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`Platform-native elements with &quot;is&quot; prop will no longer be ` </span><span class="s1">+</span>
              <span class="s2">`treated as components in Vue 3 unless the &quot;is&quot; value is explicitly ` </span><span class="s1">+</span>
              <span class="s2">`prefixed with &quot;vue:&quot;.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s1">]: {</span>
          <span class="s1">message: key =&gt; </span><span class="s2">`.sync modifier for v-bind has been removed. Use v-model with ` </span><span class="s1">+</span>
              <span class="s2">`argument instead. </span><span class="s0">\`</span><span class="s2">v-bind:</span><span class="s1">${key}</span><span class="s2">.sync</span><span class="s0">\` </span><span class="s2">should be changed to ` </span><span class="s1">+</span>
              <span class="s2">`</span><span class="s0">\`</span><span class="s2">v-model:</span><span class="s1">${key}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-model.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`.prop modifier for v-bind has been removed and no longer necessary. ` </span><span class="s1">+</span>
              <span class="s2">`Vue 3 will automatically set a binding as DOM property when appropriate.`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`v-bind=&quot;obj&quot; usage is now order sensitive and behaves like JavaScript ` </span><span class="s1">+</span>
              <span class="s2">`object spread: it will now overwrite an existing non-mergeable attribute ` </span><span class="s1">+</span>
              <span class="s2">`that appears before v-bind in the case of conflict. ` </span><span class="s1">+</span>
              <span class="s2">`To retain 2.x behavior, move v-bind to make it the first attribute. ` </span><span class="s1">+</span>
              <span class="s2">`You can also suppress this warning if the usage is intended.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-bind.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_V_ON_NATIVE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`.native modifier for v-on has been removed as is no longer necessary.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`v-if / v-for precedence when used on the same element has changed ` </span><span class="s1">+</span>
              <span class="s2">`in Vue 3: v-if now takes higher precedence and will no longer have ` </span><span class="s1">+</span>
              <span class="s2">`access to v-for scope variables. It is best to avoid the ambiguity ` </span><span class="s1">+</span>
              <span class="s2">`with &lt;template&gt; tags or use a computed property that filters v-for ` </span><span class="s1">+</span>
              <span class="s2">`data source.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`&lt;template&gt; with no special directives will render as a native template ` </span><span class="s1">+</span>
              <span class="s2">`element instead of its inner content in Vue 3.`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`&quot;inline-template&quot; has been removed in Vue 3.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s1">]: {</span>
          <span class="s1">message: </span><span class="s2">`filters have been removed in Vue 3. ` </span><span class="s1">+</span>
              <span class="s2">`The &quot;|&quot; symbol will be treated as native JavaScript bitwise OR operator. ` </span><span class="s1">+</span>
              <span class="s2">`Use method calls or computed properties instead.`</span><span class="s0">,</span>
          <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/filters.html`</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">getCompatValue(key</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">config = context.options</span>
          <span class="s1">? context.options.compatConfig</span>
          <span class="s1">: context.compatConfig</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">value = config &amp;&amp; config[key]</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(key === </span><span class="s2">'MODE'</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">value || </span><span class="s4">3</span><span class="s0">; </span><span class="s5">// compiler defaults to v3 behavior</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">return </span><span class="s1">value</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isCompatEnabled(key</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">mode = getCompatValue(</span><span class="s2">'MODE'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">value = getCompatValue(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s5">// in v3 mode, only enable if explicitly set to true</span>
      <span class="s5">// otherwise enable for any non-false value</span>
      <span class="s0">return </span><span class="s1">mode === </span><span class="s4">3 </span><span class="s1">? value === </span><span class="s0">true </span><span class="s1">: value !== </span><span class="s0">false;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">checkCompatEnabled(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args) {</span>
      <span class="s0">const </span><span class="s1">enabled = isCompatEnabled(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(enabled) {</span>
          <span class="s1">warnDeprecation(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">enabled</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">warnDeprecation(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args) {</span>
      <span class="s0">const </span><span class="s1">val = getCompatValue(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(val === </span><span class="s2">'suppress-warning'</span><span class="s1">) {</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">{ message</span><span class="s0">, </span><span class="s1">link } = deprecationData[key]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">msg = </span><span class="s2">`(deprecation </span><span class="s1">${key}</span><span class="s2">) </span><span class="s1">${</span><span class="s0">typeof </span><span class="s1">message === </span><span class="s2">'function' </span><span class="s1">? message(...args) : message}${link ? </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">Details: </span><span class="s1">${link}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">SyntaxError(msg)</span><span class="s0">;</span>
      <span class="s1">err.code = key</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(loc)</span>
          <span class="s1">err.loc = loc</span><span class="s0">;</span>
      <span class="s1">context.onWarn(err)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s5">// The default decoder only provides escapes for characters reserved as part of</span>
  <span class="s5">// the template syntax, and is only used if the custom renderer did not provide</span>
  <span class="s5">// a platform-specific decoder.</span>
  <span class="s0">const </span><span class="s1">decodeRE = </span><span class="s4">/&amp;(gt|lt|amp|apos|quot);/g</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">decodeMap = {</span>
      <span class="s1">gt: </span><span class="s2">'&gt;'</span><span class="s0">,</span>
      <span class="s1">lt: </span><span class="s2">'&lt;'</span><span class="s0">,</span>
      <span class="s1">amp: </span><span class="s2">'&amp;'</span><span class="s0">,</span>
      <span class="s1">apos: </span><span class="s2">&quot;'&quot;</span><span class="s0">,</span>
      <span class="s1">quot: </span><span class="s2">'&quot;'</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">defaultParserOptions = {</span>
      <span class="s1">delimiters: [</span><span class="s2">`{{`</span><span class="s0">, </span><span class="s2">`}}`</span><span class="s1">]</span><span class="s0">,</span>
      <span class="s1">getNamespace: () =&gt; </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s0">,</span>
      <span class="s1">getTextMode: () =&gt; </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s0">,</span>
      <span class="s1">isVoidTag: NO</span><span class="s0">,</span>
      <span class="s1">isPreTag: NO</span><span class="s0">,</span>
      <span class="s1">isCustomElement: NO</span><span class="s0">,</span>
      <span class="s1">decodeEntities: (rawText) =&gt; rawText.replace(decodeRE</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">p1) =&gt; decodeMap[p1])</span><span class="s0">,</span>
      <span class="s1">onError: defaultOnError</span><span class="s0">,</span>
      <span class="s1">onWarn: defaultOnWarn</span><span class="s0">,</span>
      <span class="s1">comments: </span><span class="s0">true</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">baseParse(content</span><span class="s0">, </span><span class="s1">options = {}) {</span>
      <span class="s0">const </span><span class="s1">context = createParserContext(content</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">createRoot(parseChildren(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">, </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createParserContext(content</span><span class="s0">, </span><span class="s1">rawOptions) {</span>
      <span class="s0">const </span><span class="s1">options = extend({}</span><span class="s0">, </span><span class="s1">defaultParserOptions)</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">key</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(key </span><span class="s0">in </span><span class="s1">rawOptions) {</span>
          <span class="s5">// @ts-ignore</span>
          <span class="s1">options[key] =</span>
              <span class="s1">rawOptions[key] === undefined</span>
                  <span class="s1">? defaultParserOptions[key]</span>
                  <span class="s1">: rawOptions[key]</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">options</span><span class="s0">,</span>
          <span class="s1">column: </span><span class="s4">1</span><span class="s0">,</span>
          <span class="s1">line: </span><span class="s4">1</span><span class="s0">,</span>
          <span class="s1">offset: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">originalSource: content</span><span class="s0">,</span>
          <span class="s1">source: content</span><span class="s0">,</span>
          <span class="s1">inPre: </span><span class="s0">false,</span>
          <span class="s1">inVPre: </span><span class="s0">false,</span>
          <span class="s1">onWarn: options.onWarn</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseChildren(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors) {</span>
      <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">nodes = []</span><span class="s0">;</span>
      <span class="s0">while </span><span class="s1">(!isEnd(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors)) {</span>
          <span class="s0">const </span><span class="s1">s = context.source</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">node = undefined</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */ </span><span class="s1">|| mode === </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(s</span><span class="s0">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">])) {</span>
                  <span class="s5">// '{{'</span>
                  <span class="s1">node = parseInterpolation(context</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */ </span><span class="s1">&amp;&amp; s[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'&lt;'</span><span class="s1">) {</span>
                  <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state</span>
                  <span class="s0">if </span><span class="s1">(s.length === </span><span class="s4">1</span><span class="s1">) {</span>
                      <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'!'</span><span class="s1">) {</span>
                      <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state</span>
                      <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;!--'</span><span class="s1">)) {</span>
                          <span class="s1">node = parseComment(context)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;!DOCTYPE'</span><span class="s1">)) {</span>
                          <span class="s5">// Ignore DOCTYPE by a limitation.</span>
                          <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;![CDATA['</span><span class="s1">)) {</span>
                          <span class="s0">if </span><span class="s1">(ns !== </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s1">) {</span>
                              <span class="s1">node = parseCDATA(context</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
                          <span class="s1">}</span>
                          <span class="s0">else </span><span class="s1">{</span>
                              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s5">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">)</span><span class="s0">;</span>
                              <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                      <span class="s0">else </span><span class="s1">{</span>
                          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">11 </span><span class="s5">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'/'</span><span class="s1">) {</span>
                      <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state</span>
                      <span class="s0">if </span><span class="s1">(s.length === </span><span class="s4">2</span><span class="s1">) {</span>
                          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">2</span><span class="s1">] === </span><span class="s2">'&gt;'</span><span class="s1">) {</span>
                          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">14 </span><span class="s5">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s0">continue;</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">2</span><span class="s1">])) {</span>
                          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">23 </span><span class="s5">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s1">parseTag(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
                          <span class="s0">continue;</span>
                      <span class="s1">}</span>
                      <span class="s0">else </span><span class="s1">{</span>
                          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">1</span><span class="s1">])) {</span>
                      <span class="s1">node = parseElement(context</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
                      <span class="s5">// 2.x &lt;template&gt; with no directive compat</span>
                      <span class="s0">if </span><span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context) &amp;&amp;</span>
                          <span class="s1">node &amp;&amp;</span>
                          <span class="s1">node.tag === </span><span class="s2">'template' </span><span class="s1">&amp;&amp;</span>
                          <span class="s1">!node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                              <span class="s1">isSpecialTemplateDirective(p.name))) {</span>
                          <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
                          <span class="s1">node = node.children</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'?'</span><span class="s1">) {</span>
                      <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">21 </span><span class="s5">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(!node) {</span>
              <span class="s1">node = parseText(context</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(isArray(node)) {</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node[i])</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s5">// Whitespace handling strategy like v2</span>
      <span class="s0">let </span><span class="s1">removedWhitespace = </span><span class="s0">false;</span>
      <span class="s0">if </span><span class="s1">(mode !== </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */ </span><span class="s1">&amp;&amp; mode !== </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">shouldCondense = context.options.whitespace !== </span><span class="s2">'preserve'</span><span class="s0">;</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodes.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s0">const </span><span class="s1">node = nodes[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                  <span class="s0">if </span><span class="s1">(!context.inPre) {</span>
                      <span class="s0">if </span><span class="s1">(!</span><span class="s4">/[^\t\r\n\f ]/</span><span class="s1">.test(node.content)) {</span>
                          <span class="s0">const </span><span class="s1">prev = nodes[i - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                          <span class="s0">const </span><span class="s1">next = nodes[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                          <span class="s5">// Remove if:</span>
                          <span class="s5">// - the whitespace is the first or last node, or:</span>
                          <span class="s5">// - (condense mode) the whitespace is between twos comments, or:</span>
                          <span class="s5">// - (condense mode) the whitespace is between comment and element, or:</span>
                          <span class="s5">// - (condense mode) the whitespace is between two elements AND contains newline</span>
                          <span class="s0">if </span><span class="s1">(!prev ||</span>
                              <span class="s1">!next ||</span>
                              <span class="s1">(shouldCondense &amp;&amp;</span>
                                  <span class="s1">((prev.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                      <span class="s1">next.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                      <span class="s1">(prev.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                          <span class="s1">next.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) ||</span>
                                      <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                          <span class="s1">next.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                      <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                          <span class="s1">next.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                          <span class="s4">/[\r\n]/</span><span class="s1">.test(node.content))))) {</span>
                              <span class="s1">removedWhitespace = </span><span class="s0">true;</span>
                              <span class="s1">nodes[i] = </span><span class="s0">null;</span>
                          <span class="s1">}</span>
                          <span class="s0">else </span><span class="s1">{</span>
                              <span class="s5">// Otherwise, the whitespace is condensed into a single space</span>
                              <span class="s1">node.content = </span><span class="s2">' '</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(shouldCondense) {</span>
                          <span class="s5">// in condense mode, consecutive whitespaces in text are condensed</span>
                          <span class="s5">// down to a single space.</span>
                          <span class="s1">node.content = node.content.replace(</span><span class="s4">/[\t\r\n\f ]+/g</span><span class="s0">, </span><span class="s2">' '</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s5">// #6410 normalize windows newlines in &lt;pre&gt;:</span>
                      <span class="s5">// in SSR, browsers normalize server-rendered \r\n into a single \n</span>
                      <span class="s5">// in the DOM</span>
                      <span class="s1">node.content = node.content.replace(</span><span class="s4">/\r\n/g</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s5">// Remove comment nodes if desired by configuration.</span>
              <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp; !context.options.comments) {</span>
                  <span class="s1">removedWhitespace = </span><span class="s0">true;</span>
                  <span class="s1">nodes[i] = </span><span class="s0">null;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(context.inPre &amp;&amp; parent &amp;&amp; context.options.isPreTag(parent.tag)) {</span>
              <span class="s5">// remove leading newline per html spec</span>
              <span class="s5">// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element</span>
              <span class="s0">const </span><span class="s1">first = nodes[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(first &amp;&amp; first.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                  <span class="s1">first.content = first.content.replace(</span><span class="s4">/^\r?\n/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">removedWhitespace ? nodes.filter(Boolean) : nodes</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node) {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">prev = last(nodes)</span><span class="s0">;</span>
          <span class="s5">// Merge if both this and the previous node are text and those are</span>
          <span class="s5">// consecutive. This happens for cases like &quot;a &lt; b&quot;.</span>
          <span class="s0">if </span><span class="s1">(prev &amp;&amp;</span>
              <span class="s1">prev.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">prev.loc.end.offset === node.loc.start.offset) {</span>
              <span class="s1">prev.content += node.content</span><span class="s0">;</span>
              <span class="s1">prev.loc.end = node.loc.end</span><span class="s0">;</span>
              <span class="s1">prev.loc.source += node.loc.source</span><span class="s0">;</span>
              <span class="s0">return;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">nodes.push(node)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseCDATA(context</span><span class="s0">, </span><span class="s1">ancestors) {</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">9</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">nodes = parseChildren(context</span><span class="s0">, </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">6 </span><span class="s5">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">nodes</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseComment(context) {</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
      <span class="s5">// Regular comment.</span>
      <span class="s0">const </span><span class="s1">match = </span><span class="s4">/--(\!)?&gt;/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!match) {</span>
          <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">context.source.length)</span><span class="s0">;</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">7 </span><span class="s5">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(match.index &lt;= </span><span class="s4">3</span><span class="s1">) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(match[</span><span class="s4">1</span><span class="s1">]) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">10 </span><span class="s5">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s0">, </span><span class="s1">match.index)</span><span class="s0">;</span>
          <span class="s5">// Advancing with reporting nested comments.</span>
          <span class="s0">const </span><span class="s1">s = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">match.index)</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">prevIndex = </span><span class="s4">1</span><span class="s0">, </span><span class="s1">nestedIndex = </span><span class="s4">0</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">((nestedIndex = s.indexOf(</span><span class="s2">'&lt;!--'</span><span class="s0">, </span><span class="s1">prevIndex)) !== -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">nestedIndex - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(nestedIndex + </span><span class="s4">4 </span><span class="s1">&lt; s.length) {</span>
                  <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">16 </span><span class="s5">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">prevIndex = nestedIndex + </span><span class="s4">1</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match.index + match[</span><span class="s4">0</span><span class="s1">].length - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s0">,</span>
          <span class="s1">content</span><span class="s0">,</span>
          <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseBogusComment(context) {</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">contentStart = context.source[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'?' </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">closeIndex = context.source.indexOf(</span><span class="s2">'&gt;'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">content = context.source.slice(contentStart)</span><span class="s0">;</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">context.source.length)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">content = context.source.slice(contentStart</span><span class="s0">, </span><span class="s1">closeIndex)</span><span class="s0">;</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">closeIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s0">,</span>
          <span class="s1">content</span><span class="s0">,</span>
          <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseElement(context</span><span class="s0">, </span><span class="s1">ancestors) {</span>
      <span class="s5">// Start tag.</span>
      <span class="s0">const </span><span class="s1">wasInPre = context.inPre</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">wasInVPre = context.inVPre</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">element = parseTag(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* TagType.Start */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isPreBoundary = context.inPre &amp;&amp; !wasInPre</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(element.isSelfClosing || context.options.isVoidTag(element.tag)) {</span>
          <span class="s5">// #4030 self-closing &lt;pre&gt; tag</span>
          <span class="s0">if </span><span class="s1">(isPreBoundary) {</span>
              <span class="s1">context.inPre = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(isVPreBoundary) {</span>
              <span class="s1">context.inVPre = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">element</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// Children.</span>
      <span class="s1">ancestors.push(element)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">mode = context.options.getTextMode(element</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">children = parseChildren(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
      <span class="s1">ancestors.pop()</span><span class="s0">;</span>
      <span class="s5">// 2.x inline-template compat</span>
      <span class="s1">{</span>
          <span class="s0">const </span><span class="s1">inlineTemplateProp = element.props.find(p =&gt; p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'inline-template'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(inlineTemplateProp &amp;&amp;</span>
              <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">inlineTemplateProp.loc)) {</span>
              <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">element.loc.end)</span><span class="s0">;</span>
              <span class="s1">inlineTemplateProp.value = {</span>
                  <span class="s1">type: </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s0">,</span>
                  <span class="s1">content: loc.source</span><span class="s0">,</span>
                  <span class="s1">loc</span>
              <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">element.children = children</span><span class="s0">;</span>
      <span class="s5">// End tag.</span>
      <span class="s0">if </span><span class="s1">(startsWithEndTagOpen(context.source</span><span class="s0">, </span><span class="s1">element.tag)) {</span>
          <span class="s1">parseTag(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">24 </span><span class="s5">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">element.loc.start)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; element.tag.toLowerCase() === </span><span class="s2">'script'</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">first = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(first &amp;&amp; startsWith(first.loc.source</span><span class="s0">, </span><span class="s2">'&lt;!--'</span><span class="s1">)) {</span>
                  <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">8 </span><span class="s5">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">element.loc = getSelection(context</span><span class="s0">, </span><span class="s1">element.loc.start)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isPreBoundary) {</span>
          <span class="s1">context.inPre = </span><span class="s0">false;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(isVPreBoundary) {</span>
          <span class="s1">context.inVPre = </span><span class="s0">false;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">element</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">isSpecialTemplateDirective = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">`if,else,else-if,for,slot`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">parseTag(context</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">parent) {</span>
      <span class="s5">// Tag open.</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">tag = match[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">ns = context.options.getNamespace(tag</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s0">;</span>
      <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
      <span class="s5">// save current state in case we need to re-parse attributes with v-pre</span>
      <span class="s0">const </span><span class="s1">cursor = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">currentSource = context.source</span><span class="s0">;</span>
      <span class="s5">// check &lt;pre&gt; tag</span>
      <span class="s0">if </span><span class="s1">(context.options.isPreTag(tag)) {</span>
          <span class="s1">context.inPre = </span><span class="s0">true;</span>
      <span class="s1">}</span>
      <span class="s5">// Attributes.</span>
      <span class="s0">let </span><span class="s1">props = parseAttributes(context</span><span class="s0">, </span><span class="s1">type)</span><span class="s0">;</span>
      <span class="s5">// check v-pre</span>
      <span class="s0">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s5">/* TagType.Start */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!context.inVPre &amp;&amp;</span>
          <span class="s1">props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'pre'</span><span class="s1">)) {</span>
          <span class="s1">context.inVPre = </span><span class="s0">true;</span>
          <span class="s5">// reset context</span>
          <span class="s1">extend(context</span><span class="s0">, </span><span class="s1">cursor)</span><span class="s0">;</span>
          <span class="s1">context.source = currentSource</span><span class="s0">;</span>
          <span class="s5">// re-parse attrs and filter out v-pre itself</span>
          <span class="s1">props = parseAttributes(context</span><span class="s0">, </span><span class="s1">type).filter(p =&gt; p.name !== </span><span class="s2">'v-pre'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// Tag close.</span>
      <span class="s0">let </span><span class="s1">isSelfClosing = </span><span class="s0">false;</span>
      <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">9 </span><span class="s5">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">isSelfClosing = startsWith(context.source</span><span class="s0">, </span><span class="s2">'/&gt;'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */ </span><span class="s1">&amp;&amp; isSelfClosing) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">4 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">isSelfClosing ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s1">) {</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s5">// 2.x deprecation checks</span>
      <span class="s0">if </span><span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s0">, </span><span class="s1">context)) {</span>
          <span class="s0">let </span><span class="s1">hasIf = </span><span class="s0">false;</span>
          <span class="s0">let </span><span class="s1">hasFor = </span><span class="s0">false;</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s0">const </span><span class="s1">p = props[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                  <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'if'</span><span class="s1">) {</span>
                      <span class="s1">hasIf = </span><span class="s0">true;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(p.name === </span><span class="s2">'for'</span><span class="s1">) {</span>
                      <span class="s1">hasFor = </span><span class="s0">true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(hasIf &amp;&amp; hasFor) {</span>
                  <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start))</span><span class="s0">;</span>
                  <span class="s0">break;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">tagType = </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!context.inVPre) {</span>
          <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'slot'</span><span class="s1">) {</span>
              <span class="s1">tagType = </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(tag === </span><span class="s2">'template'</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; isSpecialTemplateDirective(p.name))) {</span>
                  <span class="s1">tagType = </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isComponent(tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">context)) {</span>
              <span class="s1">tagType = </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s0">,</span>
          <span class="s1">ns</span><span class="s0">,</span>
          <span class="s1">tag</span><span class="s0">,</span>
          <span class="s1">tagType</span><span class="s0">,</span>
          <span class="s1">props</span><span class="s0">,</span>
          <span class="s1">isSelfClosing</span><span class="s0">,</span>
          <span class="s1">children: []</span><span class="s0">,</span>
          <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">,</span>
          <span class="s1">codegenNode: undefined </span><span class="s5">// to be created during transform phase</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isComponent(tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">options = context.options</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(options.isCustomElement(tag)) {</span>
          <span class="s0">return false;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'component' </span><span class="s1">||</span>
          <span class="s4">/^[A-Z]/</span><span class="s1">.test(tag) ||</span>
          <span class="s1">isCoreComponent(tag) ||</span>
          <span class="s1">(options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) ||</span>
          <span class="s1">(options.isNativeTag &amp;&amp; !options.isNativeTag(tag))) {</span>
          <span class="s0">return true;</span>
      <span class="s1">}</span>
      <span class="s5">// at this point the tag should be a native tag, but check for potential &quot;is&quot;</span>
      <span class="s5">// casting</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">p = props[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'is' </span><span class="s1">&amp;&amp; p.value) {</span>
                  <span class="s0">if </span><span class="s1">(p.value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
                      <span class="s0">return true;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(checkCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">p.loc)) {</span>
                      <span class="s0">return true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// directive</span>
              <span class="s5">// v-is (TODO Deprecate)</span>
              <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'is'</span><span class="s1">) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(</span>
              <span class="s5">// :is on plain element - only treat as component in compat mode</span>
              <span class="s1">p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">) &amp;&amp;</span>
                  <span class="s0">true </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">p.loc)) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseAttributes(context</span><span class="s0">, </span><span class="s1">type) {</span>
      <span class="s0">const </span><span class="s1">props = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">attributeNames = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
      <span class="s0">while </span><span class="s1">(context.source.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!startsWith(context.source</span><span class="s0">, </span><span class="s2">'&gt;'</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">!startsWith(context.source</span><span class="s0">, </span><span class="s2">'/&gt;'</span><span class="s1">)) {</span>
          <span class="s0">if </span><span class="s1">(startsWith(context.source</span><span class="s0">, </span><span class="s2">'/'</span><span class="s1">)) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">22 </span><span class="s5">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
              <span class="s0">continue;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s1">) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">3 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">attr = parseAttribute(context</span><span class="s0">, </span><span class="s1">attributeNames)</span><span class="s0">;</span>
          <span class="s5">// Trim whitespace between class</span>
          <span class="s5">// https://github.com/vuejs/core/issues/4251</span>
          <span class="s0">if </span><span class="s1">(attr.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">attr.value &amp;&amp;</span>
              <span class="s1">attr.name === </span><span class="s2">'class'</span><span class="s1">) {</span>
              <span class="s1">attr.value.content = attr.value.content.replace(</span><span class="s4">/\s+/g</span><span class="s0">, </span><span class="s2">' '</span><span class="s1">).trim()</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s5">/* TagType.Start */</span><span class="s1">) {</span>
              <span class="s1">props.push(attr)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(</span><span class="s4">/^[^\t\r\n\f /&gt;]/</span><span class="s1">.test(context.source)) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">15 </span><span class="s5">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">props</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseAttribute(context</span><span class="s0">, </span><span class="s1">nameSet) {</span>
      <span class="s5">// Name.</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">name = match[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(nameSet.has(name)) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">2 </span><span class="s5">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">nameSet.add(name)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'='</span><span class="s1">) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">19 </span><span class="s5">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">{</span>
          <span class="s0">const </span><span class="s1">pattern = </span><span class="s4">/[&quot;'&lt;]/g</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">m</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">((m = pattern.exec(name))) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">17 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s0">, </span><span class="s1">m.index)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">name.length)</span><span class="s0">;</span>
      <span class="s5">// Value</span>
      <span class="s0">let </span><span class="s1">value = undefined</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s4">/^[\t\r\n\f ]*=/</span><span class="s1">.test(context.source)) {</span>
          <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
          <span class="s1">value = parseAttributeValue(context)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!value) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">13 </span><span class="s5">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; </span><span class="s4">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span><span class="s1">.test(name)) {</span>
          <span class="s0">const </span><span class="s1">match = </span><span class="s4">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i</span><span class="s1">.exec(name)</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">isPropShorthand = startsWith(name</span><span class="s0">, </span><span class="s2">'.'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">dirName = match[</span><span class="s4">1</span><span class="s1">] ||</span>
              <span class="s1">(isPropShorthand || startsWith(name</span><span class="s0">, </span><span class="s2">':'</span><span class="s1">)</span>
                  <span class="s1">? </span><span class="s2">'bind'</span>
                  <span class="s1">: startsWith(name</span><span class="s0">, </span><span class="s2">'@'</span><span class="s1">)</span>
                      <span class="s1">? </span><span class="s2">'on'</span>
                      <span class="s1">: </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">arg</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(match[</span><span class="s4">2</span><span class="s1">]) {</span>
              <span class="s0">const </span><span class="s1">isSlot = dirName === </span><span class="s2">'slot'</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">startOffset = name.lastIndexOf(match[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">startOffset)</span><span class="s0">, </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">startOffset + match[</span><span class="s4">2</span><span class="s1">].length + ((isSlot &amp;&amp; match[</span><span class="s4">3</span><span class="s1">]) || </span><span class="s2">''</span><span class="s1">).length))</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">content = match[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">isStatic = </span><span class="s0">true;</span>
              <span class="s0">if </span><span class="s1">(content.startsWith(</span><span class="s2">'['</span><span class="s1">)) {</span>
                  <span class="s1">isStatic = </span><span class="s0">false;</span>
                  <span class="s0">if </span><span class="s1">(!content.endsWith(</span><span class="s2">']'</span><span class="s1">)) {</span>
                      <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">27 </span><span class="s5">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">content.length - </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(isSlot) {</span>
                  <span class="s5">// #1241 special case for v-slot: vuetify relies extensively on slot</span>
                  <span class="s5">// names containing dots. v-slot doesn't have any modifiers and Vue 2.x</span>
                  <span class="s5">// supports such usage so we are keeping it consistent with 2.x.</span>
                  <span class="s1">content += match[</span><span class="s4">3</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">arg = {</span>
                  <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
                  <span class="s1">content</span><span class="s0">,</span>
                  <span class="s1">isStatic</span><span class="s0">,</span>
                  <span class="s1">constType: isStatic</span>
                      <span class="s1">? </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span>
                      <span class="s1">: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
                  <span class="s1">loc</span>
              <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(value &amp;&amp; value.isQuoted) {</span>
              <span class="s0">const </span><span class="s1">valueLoc = value.loc</span><span class="s0">;</span>
              <span class="s1">valueLoc.start.offset++</span><span class="s0">;</span>
              <span class="s1">valueLoc.start.column++</span><span class="s0">;</span>
              <span class="s1">valueLoc.end = advancePositionWithClone(valueLoc.start</span><span class="s0">, </span><span class="s1">value.content)</span><span class="s0">;</span>
              <span class="s1">valueLoc.source = valueLoc.source.slice(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">modifiers = match[</span><span class="s4">3</span><span class="s1">] ? match[</span><span class="s4">3</span><span class="s1">].slice(</span><span class="s4">1</span><span class="s1">).split(</span><span class="s2">'.'</span><span class="s1">) : []</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(isPropShorthand)</span>
              <span class="s1">modifiers.push(</span><span class="s2">'prop'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s5">// 2.x compat v-bind:foo.sync -&gt; v-model:foo</span>
          <span class="s0">if </span><span class="s1">(dirName === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; arg) {</span>
              <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'sync'</span><span class="s1">) &amp;&amp;</span>
                  <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">arg.loc.source)) {</span>
                  <span class="s1">dirName = </span><span class="s2">'model'</span><span class="s0">;</span>
                  <span class="s1">modifiers.splice(modifiers.indexOf(</span><span class="s2">'sync'</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'prop'</span><span class="s1">)) {</span>
                  <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">{</span>
              <span class="s1">type: </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s0">,</span>
              <span class="s1">name: dirName</span><span class="s0">,</span>
              <span class="s1">exp: value &amp;&amp; {</span>
                  <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
                  <span class="s1">content: value.content</span><span class="s0">,</span>
                  <span class="s1">isStatic: </span><span class="s0">false,</span>
                  <span class="s5">// Treat as non-constant by default. This can be potentially set to</span>
                  <span class="s5">// other values by `transformExpression` to make it eligible for hoisting.</span>
                  <span class="s1">constType: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
                  <span class="s1">loc: value.loc</span>
              <span class="s1">}</span><span class="s0">,</span>
              <span class="s1">arg</span><span class="s0">,</span>
              <span class="s1">modifiers</span><span class="s0">,</span>
              <span class="s1">loc</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// missing directive name or illegal directive name</span>
      <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(name</span><span class="s0">, </span><span class="s2">'v-'</span><span class="s1">)) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">26 </span><span class="s5">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s0">,</span>
          <span class="s1">name</span><span class="s0">,</span>
          <span class="s1">value: value &amp;&amp; {</span>
              <span class="s1">type: </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s0">,</span>
              <span class="s1">content: value.content</span><span class="s0">,</span>
              <span class="s1">loc: value.loc</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">loc</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseAttributeValue(context) {</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">quote = context.source[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isQuoted = quote === </span><span class="s2">`&quot;` </span><span class="s1">|| quote === </span><span class="s2">`'`</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isQuoted) {</span>
          <span class="s5">// Quoted value.</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">endIndex = context.source.indexOf(quote)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(endIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">context.source.length</span><span class="s0">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">endIndex</span><span class="s0">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// Unquoted</span>
          <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f &gt;]+/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!match) {</span>
              <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">unexpectedChars = </span><span class="s4">/[&quot;'&lt;=`]/g</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">m</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">((m = unexpectedChars.exec(match[</span><span class="s4">0</span><span class="s1">]))) {</span>
              <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">18 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s0">, </span><span class="s1">m.index)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s0">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{ content</span><span class="s0">, </span><span class="s1">isQuoted</span><span class="s0">, </span><span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start) }</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseInterpolation(context</span><span class="s0">, </span><span class="s1">mode) {</span>
      <span class="s0">const </span><span class="s1">[open</span><span class="s0">, </span><span class="s1">close] = context.options.delimiters</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">closeIndex = context.source.indexOf(close</span><span class="s0">, </span><span class="s1">open.length)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">25 </span><span class="s5">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">open.length)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">innerStart = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">innerEnd = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">rawContentLength = closeIndex - open.length</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">rawContent = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">rawContentLength)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">preTrimContent = parseTextData(context</span><span class="s0">, </span><span class="s1">rawContentLength</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">content = preTrimContent.trim()</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">startOffset = preTrimContent.indexOf(content)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(startOffset &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">advancePositionWithMutation(innerStart</span><span class="s0">, </span><span class="s1">rawContent</span><span class="s0">, </span><span class="s1">startOffset)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</span><span class="s0">;</span>
      <span class="s1">advancePositionWithMutation(innerEnd</span><span class="s0">, </span><span class="s1">rawContent</span><span class="s0">, </span><span class="s1">endOffset)</span><span class="s0">;</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">close.length)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s0">,</span>
          <span class="s1">content: {</span>
              <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
              <span class="s1">isStatic: </span><span class="s0">false,</span>
              <span class="s5">// Set `isConstant` to false by default and will decide in transformExpression</span>
              <span class="s1">constType: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
              <span class="s1">content</span><span class="s0">,</span>
              <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">innerStart</span><span class="s0">, </span><span class="s1">innerEnd)</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseText(context</span><span class="s0">, </span><span class="s1">mode) {</span>
      <span class="s0">const </span><span class="s1">endTokens = mode === </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */ </span><span class="s1">? [</span><span class="s2">']]&gt;'</span><span class="s1">] : [</span><span class="s2">'&lt;'</span><span class="s0">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">endIndex = context.source.length</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; endTokens.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">index = context.source.indexOf(endTokens[i]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(index !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; endIndex &gt; index) {</span>
              <span class="s1">endIndex = index</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">endIndex</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s0">,</span>
          <span class="s1">content</span><span class="s0">,</span>
          <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s3">/**</span>
   <span class="s3">* Get text data with a given length from the current location.</span>
   <span class="s3">* This translates HTML entities in the text data.</span>
   <span class="s3">*/</span>
  <span class="s0">function </span><span class="s1">parseTextData(context</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">mode) {</span>
      <span class="s0">const </span><span class="s1">rawText = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>
      <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(mode === </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */ </span><span class="s1">||</span>
          <span class="s1">mode === </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */ </span><span class="s1">||</span>
          <span class="s1">!rawText.includes(</span><span class="s2">'&amp;'</span><span class="s1">)) {</span>
          <span class="s0">return </span><span class="s1">rawText</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.</span>
          <span class="s0">return </span><span class="s1">context.options.decodeEntities(rawText</span><span class="s0">, </span><span class="s1">mode === </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getCursor(context) {</span>
      <span class="s0">const </span><span class="s1">{ column</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">offset } = context</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{ column</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">offset }</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end) {</span>
      <span class="s1">end = end || getCursor(context)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">start</span><span class="s0">,</span>
          <span class="s1">end</span><span class="s0">,</span>
          <span class="s1">source: context.originalSource.slice(start.offset</span><span class="s0">, </span><span class="s1">end.offset)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">last(xs) {</span>
      <span class="s0">return </span><span class="s1">xs[xs.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">startsWith(source</span><span class="s0">, </span><span class="s1">searchString) {</span>
      <span class="s0">return </span><span class="s1">source.startsWith(searchString)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">numberOfCharacters) {</span>
      <span class="s0">const </span><span class="s1">{ source } = context</span><span class="s0">;</span>
      <span class="s1">advancePositionWithMutation(context</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
      <span class="s1">context.source = source.slice(numberOfCharacters)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">advanceSpaces(context) {</span>
      <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[\t\r\n\f ]+/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(match) {</span>
          <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">numberOfCharacters) {</span>
      <span class="s0">return </span><span class="s1">advancePositionWithClone(start</span><span class="s0">, </span><span class="s1">context.originalSource.slice(start.offset</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">emitError(context</span><span class="s0">, </span><span class="s1">code</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">loc = getCursor(context)) {</span>
      <span class="s0">if </span><span class="s1">(offset) {</span>
          <span class="s1">loc.offset += offset</span><span class="s0">;</span>
          <span class="s1">loc.column += offset</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">context.options.onError(createCompilerError(code</span><span class="s0">, </span><span class="s1">{</span>
          <span class="s1">start: loc</span><span class="s0">,</span>
          <span class="s1">end: loc</span><span class="s0">,</span>
          <span class="s1">source: </span><span class="s2">''</span>
      <span class="s1">}))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isEnd(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors) {</span>
      <span class="s0">const </span><span class="s1">s = context.source</span><span class="s0">;</span>
      <span class="s0">switch </span><span class="s1">(mode) {</span>
          <span class="s0">case </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;/'</span><span class="s1">)) {</span>
                  <span class="s5">// TODO: probably bad performance</span>
                  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = ancestors.length - </span><span class="s4">1</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s0">; </span><span class="s1">--i) {</span>
                      <span class="s0">if </span><span class="s1">(startsWithEndTagOpen(s</span><span class="s0">, </span><span class="s1">ancestors[i].tag)) {</span>
                          <span class="s0">return true;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */</span><span class="s1">: {</span>
              <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(parent &amp;&amp; startsWithEndTagOpen(s</span><span class="s0">, </span><span class="s1">parent.tag)) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s1">}</span>
          <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">']]&gt;'</span><span class="s1">)) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">!s</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">startsWithEndTagOpen(source</span><span class="s0">, </span><span class="s1">tag) {</span>
      <span class="s0">return </span><span class="s1">(startsWith(source</span><span class="s0">, </span><span class="s2">'&lt;/'</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">source.slice(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2 </span><span class="s1">+ tag.length).toLowerCase() === tag.toLowerCase() &amp;&amp;</span>
          <span class="s4">/[\t\r\n\f /&gt;]/</span><span class="s1">.test(source[</span><span class="s4">2 </span><span class="s1">+ tag.length] || </span><span class="s2">'&gt;'</span><span class="s1">))</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">function </span><span class="s1">hoistStatic(root</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s1">walk(root</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
      <span class="s5">// Root node is unfortunately non-hoistable due to potential parent</span>
      <span class="s5">// fallthrough attributes.</span>
      <span class="s1">isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">root.children[</span><span class="s4">0</span><span class="s1">]))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">child) {</span>
      <span class="s0">const </span><span class="s1">{ children } = root</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
          <span class="s1">child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!isSlotOutlet(child))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">walk(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">doNotHoistNode = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">{ children } = node</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">originalCount = children.length</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">hoistedCount = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
          <span class="s5">// only plain elements &amp; text calls are eligible for hoisting.</span>
          <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">child.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">constantType = doNotHoistNode</span>
                  <span class="s1">? </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span>
                  <span class="s1">: getConstantType(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(constantType &gt; </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                  <span class="s0">if </span><span class="s1">(constantType &gt;= </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                      <span class="s1">child.codegenNode.patchFlag =</span>
                          <span class="s1">-</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */ </span><span class="s1">+ (</span><span class="s2">` /* HOISTED */` </span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">child.codegenNode = context.hoist(child.codegenNode)</span><span class="s0">;</span>
                      <span class="s1">hoistedCount++</span><span class="s0">;</span>
                      <span class="s0">continue;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s5">// node may contain dynamic children, but its props may be eligible for</span>
                  <span class="s5">// hoisting.</span>
                  <span class="s0">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                      <span class="s0">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">((!flag ||</span>
                          <span class="s1">flag === </span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */ </span><span class="s1">||</span>
                          <span class="s1">flag === </span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">) &amp;&amp;</span>
                          <span class="s1">getGeneratedPropsConstantType(child</span><span class="s0">, </span><span class="s1">context) &gt;=</span>
                              <span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                          <span class="s0">const </span><span class="s1">props = getNodeProps(child)</span><span class="s0">;</span>
                          <span class="s0">if </span><span class="s1">(props) {</span>
                              <span class="s1">codegenNode.props = context.hoist(props)</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                      <span class="s0">if </span><span class="s1">(codegenNode.dynamicProps) {</span>
                          <span class="s1">codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s5">// walk further</span>
          <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">isComponent = child.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(isComponent) {</span>
                  <span class="s1">context.scopes.vSlot++</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">walk(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(isComponent) {</span>
                  <span class="s1">context.scopes.vSlot--</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">) {</span>
              <span class="s5">// Do not hoist v-for single child because it has to be a block</span>
              <span class="s1">walk(child</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">child.children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; child.branches.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s5">// Do not hoist v-if single child because it has to be a block</span>
                  <span class="s1">walk(child.branches[i]</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">child.branches[i].children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(hoistedCount &amp;&amp; context.transformHoist) {</span>
          <span class="s1">context.transformHoist(children</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// all children were hoisted - the entire children array is hoistable.</span>
      <span class="s0">if </span><span class="s1">(hoistedCount &amp;&amp;</span>
          <span class="s1">hoistedCount === originalCount &amp;&amp;</span>
          <span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">node.codegenNode &amp;&amp;</span>
          <span class="s1">node.codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">isArray(node.codegenNode.children)) {</span>
          <span class="s1">node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children))</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getConstantType(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ constantCache } = context</span><span class="s0">;</span>
      <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(node.tagType !== </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">cached = constantCache.get(node)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(cached !== undefined) {</span>
                  <span class="s0">return </span><span class="s1">cached</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(codegenNode.type !== </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(codegenNode.isBlock &amp;&amp;</span>
                  <span class="s1">node.tag !== </span><span class="s2">'svg' </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">node.tag !== </span><span class="s2">'foreignObject'</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(!flag) {</span>
                  <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
                  <span class="s5">// Element itself has no patch flag. However we still need to check:</span>
                  <span class="s5">// 1. Even for a node with no patch flag, it is possible for it to contain</span>
                  <span class="s5">// non-hoistable expressions that refers to scope variables, e.g. compiler</span>
                  <span class="s5">// injected keys or cached event handlers. Therefore we need to always</span>
                  <span class="s5">// check the codegenNode's props to be sure.</span>
                  <span class="s0">const </span><span class="s1">generatedPropsType = getGeneratedPropsConstantType(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(generatedPropsType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                      <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(generatedPropsType &lt; returnType) {</span>
                      <span class="s1">returnType = generatedPropsType</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s5">// 2. its children.</span>
                  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                      <span class="s0">const </span><span class="s1">childType = getConstantType(node.children[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                          <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">if </span><span class="s1">(childType &lt; returnType) {</span>
                          <span class="s1">returnType = childType</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s5">// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
                  <span class="s5">// type, check if any of the props can cause the type to be lowered</span>
                  <span class="s5">// we can skip can_patch because it's guaranteed by the absence of a</span>
                  <span class="s5">// patchFlag.</span>
                  <span class="s0">if </span><span class="s1">(returnType &gt; </span><span class="s4">1 </span><span class="s5">/* ConstantTypes.CAN_SKIP_PATCH */</span><span class="s1">) {</span>
                      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                          <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; p.exp) {</span>
                              <span class="s0">const </span><span class="s1">expType = getConstantType(p.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                              <span class="s0">if </span><span class="s1">(expType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                                  <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                                  <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                              <span class="s1">}</span>
                              <span class="s0">if </span><span class="s1">(expType &lt; returnType) {</span>
                                  <span class="s1">returnType = expType</span><span class="s0">;</span>
                              <span class="s1">}</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s5">// only svg/foreignObject could be block here, however if they are</span>
                  <span class="s5">// static then they don't need to be blocks since there will be no</span>
                  <span class="s5">// nested updates.</span>
                  <span class="s0">if </span><span class="s1">(codegenNode.isBlock) {</span>
                      <span class="s5">// except set custom directives.</span>
                      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                          <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                              <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                              <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                      <span class="s1">context.removeHelper(OPEN_BLOCK)</span><span class="s0">;</span>
                      <span class="s1">context.removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">codegenNode.isComponent))</span><span class="s0">;</span>
                      <span class="s1">codegenNode.isBlock = </span><span class="s0">false;</span>
                      <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">codegenNode.isComponent))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s1">returnType)</span><span class="s0">;</span>
                  <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s0">case </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">getConstantType(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s1">node.constType</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isString(child) || isSymbol(child)) {</span>
                      <span class="s0">continue;</span>
                  <span class="s1">}</span>
                  <span class="s0">const </span><span class="s1">childType = getConstantType(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                      <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(childType &lt; returnType) {</span>
                      <span class="s1">returnType = childType</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
          <span class="s0">default</span><span class="s1">:</span>
              <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">allowHoistedHelperSet = </span><span class="s0">new </span><span class="s1">Set([</span>
      <span class="s1">NORMALIZE_CLASS</span><span class="s0">,</span>
      <span class="s1">NORMALIZE_STYLE</span><span class="s0">,</span>
      <span class="s1">NORMALIZE_PROPS</span><span class="s0">,</span>
      <span class="s1">GUARD_REACTIVE_PROPS</span>
  <span class="s1">])</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">getConstantTypeOfHelperCall(value</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!isString(value.callee) &amp;&amp;</span>
          <span class="s1">allowHoistedHelperSet.has(value.callee)) {</span>
          <span class="s0">const </span><span class="s1">arg = value.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s0">return </span><span class="s1">getConstantType(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(arg.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s5">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
              <span class="s0">return </span><span class="s1">getConstantTypeOfHelperCall(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getGeneratedPropsConstantType(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">props = getNodeProps(node)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(props &amp;&amp; props.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">{ properties } = props</span><span class="s0">;</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s0">const </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value } = properties[i]</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">keyType = getConstantType(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(keyType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s1">keyType</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(keyType &lt; returnType) {</span>
                  <span class="s1">returnType = keyType</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">let </span><span class="s1">valueType</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
                  <span class="s1">valueType = getConstantType(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
                  <span class="s5">// some helper calls can be hoisted,</span>
                  <span class="s5">// such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
                  <span class="s5">// in this case we need to respect the ConstantType of the helper's arguments</span>
                  <span class="s1">valueType = getConstantTypeOfHelperCall(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">valueType = </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(valueType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s1">valueType</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(valueType &lt; returnType) {</span>
                  <span class="s1">returnType = valueType</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getNodeProps(node) {</span>
      <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">codegenNode.props</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getPatchFlag(node) {</span>
      <span class="s0">const </span><span class="s1">flag = node.patchFlag</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">flag ? parseInt(flag</span><span class="s0">, </span><span class="s4">10</span><span class="s1">) : undefined</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">function </span><span class="s1">createTransformContext(root</span><span class="s0">, </span><span class="s1">{ filename = </span><span class="s2">''</span><span class="s0">, </span><span class="s1">prefixIdentifiers = </span><span class="s0">false, </span><span class="s1">hoistStatic = </span><span class="s0">false, </span><span class="s1">cacheHandlers = </span><span class="s0">false, </span><span class="s1">nodeTransforms = []</span><span class="s0">, </span><span class="s1">directiveTransforms = {}</span><span class="s0">, </span><span class="s1">transformHoist = </span><span class="s0">null, </span><span class="s1">isBuiltInComponent = NOOP</span><span class="s0">, </span><span class="s1">isCustomElement = NOOP</span><span class="s0">, </span><span class="s1">expressionPlugins = []</span><span class="s0">, </span><span class="s1">scopeId = </span><span class="s0">null, </span><span class="s1">slotted = </span><span class="s0">true, </span><span class="s1">ssr = </span><span class="s0">false, </span><span class="s1">inSSR = </span><span class="s0">false, </span><span class="s1">ssrCssVars = </span><span class="s2">``</span><span class="s0">, </span><span class="s1">bindingMetadata = EMPTY_OBJ</span><span class="s0">, </span><span class="s1">inline = </span><span class="s0">false, </span><span class="s1">isTS = </span><span class="s0">false, </span><span class="s1">onError = defaultOnError</span><span class="s0">, </span><span class="s1">onWarn = defaultOnWarn</span><span class="s0">, </span><span class="s1">compatConfig }) {</span>
      <span class="s0">const </span><span class="s1">nameMatch = filename.replace(</span><span class="s4">/\?.*$/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">context = {</span>
          <span class="s5">// options</span>
          <span class="s1">selfName: nameMatch &amp;&amp; capitalize(camelize(nameMatch[</span><span class="s4">1</span><span class="s1">]))</span><span class="s0">,</span>
          <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
          <span class="s1">hoistStatic</span><span class="s0">,</span>
          <span class="s1">cacheHandlers</span><span class="s0">,</span>
          <span class="s1">nodeTransforms</span><span class="s0">,</span>
          <span class="s1">directiveTransforms</span><span class="s0">,</span>
          <span class="s1">transformHoist</span><span class="s0">,</span>
          <span class="s1">isBuiltInComponent</span><span class="s0">,</span>
          <span class="s1">isCustomElement</span><span class="s0">,</span>
          <span class="s1">expressionPlugins</span><span class="s0">,</span>
          <span class="s1">scopeId</span><span class="s0">,</span>
          <span class="s1">slotted</span><span class="s0">,</span>
          <span class="s1">ssr</span><span class="s0">,</span>
          <span class="s1">inSSR</span><span class="s0">,</span>
          <span class="s1">ssrCssVars</span><span class="s0">,</span>
          <span class="s1">bindingMetadata</span><span class="s0">,</span>
          <span class="s1">inline</span><span class="s0">,</span>
          <span class="s1">isTS</span><span class="s0">,</span>
          <span class="s1">onError</span><span class="s0">,</span>
          <span class="s1">onWarn</span><span class="s0">,</span>
          <span class="s1">compatConfig</span><span class="s0">,</span>
          <span class="s5">// state</span>
          <span class="s1">root</span><span class="s0">,</span>
          <span class="s1">helpers: </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">,</span>
          <span class="s1">components: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
          <span class="s1">directives: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
          <span class="s1">hoists: []</span><span class="s0">,</span>
          <span class="s1">imports: []</span><span class="s0">,</span>
          <span class="s1">constantCache: </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">,</span>
          <span class="s1">temps: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">cached: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">identifiers: Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">,</span>
          <span class="s1">scopes: {</span>
              <span class="s1">vFor: </span><span class="s4">0</span><span class="s0">,</span>
              <span class="s1">vSlot: </span><span class="s4">0</span><span class="s0">,</span>
              <span class="s1">vPre: </span><span class="s4">0</span><span class="s0">,</span>
              <span class="s1">vOnce: </span><span class="s4">0</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">parent: </span><span class="s0">null,</span>
          <span class="s1">currentNode: root</span><span class="s0">,</span>
          <span class="s1">childIndex: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">inVOnce: </span><span class="s0">false,</span>
          <span class="s5">// methods</span>
          <span class="s1">helper(name) {</span>
              <span class="s0">const </span><span class="s1">count = context.helpers.get(name) || </span><span class="s4">0</span><span class="s0">;</span>
              <span class="s1">context.helpers.set(name</span><span class="s0">, </span><span class="s1">count + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s0">return </span><span class="s1">name</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">removeHelper(name) {</span>
              <span class="s0">const </span><span class="s1">count = context.helpers.get(name)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(count) {</span>
                  <span class="s0">const </span><span class="s1">currentCount = count - </span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(!currentCount) {</span>
                      <span class="s1">context.helpers.delete(name)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">context.helpers.set(name</span><span class="s0">, </span><span class="s1">currentCount)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">helperString(name) {</span>
              <span class="s0">return </span><span class="s2">`_</span><span class="s1">${helperNameMap[context.helper(name)]}</span><span class="s2">`</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">replaceNode(node) {</span>
              <span class="s5">/* istanbul ignore if */</span>
              <span class="s1">{</span>
                  <span class="s0">if </span><span class="s1">(!context.currentNode) {</span>
                      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Node being replaced is already removed.`</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(!context.parent) {</span>
                      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Cannot replace root node.`</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s1">context.parent.children[context.childIndex] = context.currentNode = node</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">removeNode(node) {</span>
              <span class="s0">if </span><span class="s1">(!context.parent) {</span>
                  <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Cannot remove root node.`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">list = context.parent.children</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">removalIndex = node</span>
                  <span class="s1">? list.indexOf(node)</span>
                  <span class="s1">: context.currentNode</span>
                      <span class="s1">? context.childIndex</span>
                      <span class="s1">: -</span><span class="s4">1</span><span class="s0">;</span>
              <span class="s5">/* istanbul ignore if */</span>
              <span class="s0">if </span><span class="s1">(removalIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                  <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`node being removed is not a child of current parent`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(!node || node === context.currentNode) {</span>
                  <span class="s5">// current node removed</span>
                  <span class="s1">context.currentNode = </span><span class="s0">null;</span>
                  <span class="s1">context.onNodeRemoved()</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s5">// sibling node removed</span>
                  <span class="s0">if </span><span class="s1">(context.childIndex &gt; removalIndex) {</span>
                      <span class="s1">context.childIndex--</span><span class="s0">;</span>
                      <span class="s1">context.onNodeRemoved()</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s1">context.parent.children.splice(removalIndex</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">onNodeRemoved: () =&gt; { }</span><span class="s0">,</span>
          <span class="s1">addIdentifiers(exp) {</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">removeIdentifiers(exp) {</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">hoist(exp) {</span>
              <span class="s0">if </span><span class="s1">(isString(exp))</span>
                  <span class="s1">exp = createSimpleExpression(exp)</span><span class="s0">;</span>
              <span class="s1">context.hoists.push(exp)</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">identifier = createSimpleExpression(</span><span class="s2">`_hoisted_</span><span class="s1">${context.hoists.length}</span><span class="s2">`</span><span class="s0">, false, </span><span class="s1">exp.loc</span><span class="s0">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">identifier.hoisted = exp</span><span class="s0">;</span>
              <span class="s0">return </span><span class="s1">identifier</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">cache(exp</span><span class="s0">, </span><span class="s1">isVNode = </span><span class="s0">false</span><span class="s1">) {</span>
              <span class="s0">return </span><span class="s1">createCacheExpression(context.cached++</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">isVNode)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">context.filters = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">context</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">transform(root</span><span class="s0">, </span><span class="s1">options) {</span>
      <span class="s0">const </span><span class="s1">context = createTransformContext(root</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
      <span class="s1">traverseNode(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(options.hoistStatic) {</span>
          <span class="s1">hoistStatic(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!options.ssr) {</span>
          <span class="s1">createRootCodegen(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// finalize meta information</span>
      <span class="s1">root.helpers = </span><span class="s0">new </span><span class="s1">Set([...context.helpers.keys()])</span><span class="s0">;</span>
      <span class="s1">root.components = [...context.components]</span><span class="s0">;</span>
      <span class="s1">root.directives = [...context.directives]</span><span class="s0">;</span>
      <span class="s1">root.imports = context.imports</span><span class="s0">;</span>
      <span class="s1">root.hoists = context.hoists</span><span class="s0">;</span>
      <span class="s1">root.temps = context.temps</span><span class="s0">;</span>
      <span class="s1">root.cached = context.cached</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">root.filters = [...context.filters]</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createRootCodegen(root</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ helper } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ children } = root</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(children.length === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s5">// if the single child is an element, turn it into a block.</span>
          <span class="s0">if </span><span class="s1">(isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">child) &amp;&amp; child.codegenNode) {</span>
              <span class="s5">// single element root is never hoisted so codegenNode will never be</span>
              <span class="s5">// SimpleExpressionNode</span>
              <span class="s0">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                  <span class="s1">makeBlock(codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">root.codegenNode = codegenNode</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// - single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
              <span class="s5">// - single text node: always patched.</span>
              <span class="s5">// root codegen falls through via genNode()</span>
              <span class="s1">root.codegenNode = child</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s5">// root has multiple nodes - return a fragment block.</span>
          <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s5">// check if the fragment actually contains a single valid child with</span>
          <span class="s5">// the rest being comments</span>
          <span class="s0">if </span><span class="s1">(children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s0">;</span>
              <span class="s1">patchFlagText += </span><span class="s2">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s2">`</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">root.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">root.children</span><span class="s0">, </span><span class="s1">patchFlag + (</span><span class="s2">` /* </span><span class="s1">${patchFlagText} </span><span class="s2">*/` </span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, </span><span class="s1">undefined</span><span class="s0">, false </span><span class="s5">/* isComponent */</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else ;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">traverseChildren(parent</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">nodeRemoved = () =&gt; {</span>
          <span class="s1">i--</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">; </span><span class="s1">i &lt; parent.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">child = parent.children[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(isString(child))</span>
              <span class="s0">continue;</span>
          <span class="s1">context.parent = parent</span><span class="s0">;</span>
          <span class="s1">context.childIndex = i</span><span class="s0">;</span>
          <span class="s1">context.onNodeRemoved = nodeRemoved</span><span class="s0">;</span>
          <span class="s1">traverseNode(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">traverseNode(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s1">context.currentNode = node</span><span class="s0">;</span>
      <span class="s5">// apply transform plugins</span>
      <span class="s0">const </span><span class="s1">{ nodeTransforms } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">exitFns = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodeTransforms.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">onExit = nodeTransforms[i](node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(onExit) {</span>
              <span class="s0">if </span><span class="s1">(isArray(onExit)) {</span>
                  <span class="s1">exitFns.push(...onExit)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">exitFns.push(onExit)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(!context.currentNode) {</span>
              <span class="s5">// node was removed</span>
              <span class="s0">return;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// node may have been replaced</span>
              <span class="s1">node = context.currentNode</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(!context.ssr) {</span>
                  <span class="s5">// inject import for the Comment symbol, which is needed for creating</span>
                  <span class="s5">// comment nodes with `createVNode`</span>
                  <span class="s1">context.helper(CREATE_COMMENT)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
              <span class="s5">// no need to traverse, but we need to inject toString helper</span>
              <span class="s0">if </span><span class="s1">(!context.ssr) {</span>
                  <span class="s1">context.helper(TO_DISPLAY_STRING)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s5">// for container types, further traverse downwards</span>
          <span class="s0">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.branches.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s1">traverseNode(node.branches[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */</span><span class="s1">:</span>
              <span class="s1">traverseChildren(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s5">// exit transforms</span>
      <span class="s1">context.currentNode = node</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">i = exitFns.length</span><span class="s0">;</span>
      <span class="s0">while </span><span class="s1">(i--) {</span>
          <span class="s1">exitFns[i]()</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createStructuralDirectiveTransform(name</span><span class="s0">, </span><span class="s1">fn) {</span>
      <span class="s0">const </span><span class="s1">matches = isString(name)</span>
          <span class="s1">? (n) =&gt; n === name</span>
          <span class="s1">: (n) =&gt; name.test(n)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">{ props } = node</span><span class="s0">;</span>
              <span class="s5">// structural directive transforms are not concerned with slots</span>
              <span class="s5">// as they are handled separately in vSlot.ts</span>
              <span class="s0">if </span><span class="s1">(node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */ </span><span class="s1">&amp;&amp; props.some(isVSlot)) {</span>
                  <span class="s0">return;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">exitFns = []</span><span class="s0">;</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s0">const </span><span class="s1">prop = props[i]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; matches(prop.name)) {</span>
                      <span class="s5">// structural directives are removed to avoid infinite recursion</span>
                      <span class="s5">// also we remove them *before* applying so that it can further</span>
                      <span class="s5">// traverse itself in case it moves the node around</span>
                      <span class="s1">props.splice(i</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">i--</span><span class="s0">;</span>
                      <span class="s0">const </span><span class="s1">onExit = fn(node</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(onExit)</span>
                          <span class="s1">exitFns.push(onExit)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">exitFns</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">PURE_ANNOTATION = </span><span class="s2">`/*#__PURE__*/`</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">aliasHelper = (s) =&gt; </span><span class="s2">`</span><span class="s1">${helperNameMap[s]}</span><span class="s2">: _</span><span class="s1">${helperNameMap[s]}</span><span class="s2">`</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">createCodegenContext(ast</span><span class="s0">, </span><span class="s1">{ mode = </span><span class="s2">'function'</span><span class="s0">, </span><span class="s1">prefixIdentifiers = mode === </span><span class="s2">'module'</span><span class="s0">, </span><span class="s1">sourceMap = </span><span class="s0">false, </span><span class="s1">filename = </span><span class="s2">`template.vue.html`</span><span class="s0">, </span><span class="s1">scopeId = </span><span class="s0">null, </span><span class="s1">optimizeImports = </span><span class="s0">false, </span><span class="s1">runtimeGlobalName = </span><span class="s2">`Vue`</span><span class="s0">, </span><span class="s1">runtimeModuleName = </span><span class="s2">`vue`</span><span class="s0">, </span><span class="s1">ssrRuntimeModuleName = </span><span class="s2">'vue/server-renderer'</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false, </span><span class="s1">isTS = </span><span class="s0">false, </span><span class="s1">inSSR = </span><span class="s0">false </span><span class="s1">}) {</span>
      <span class="s0">const </span><span class="s1">context = {</span>
          <span class="s1">mode</span><span class="s0">,</span>
          <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
          <span class="s1">sourceMap</span><span class="s0">,</span>
          <span class="s1">filename</span><span class="s0">,</span>
          <span class="s1">scopeId</span><span class="s0">,</span>
          <span class="s1">optimizeImports</span><span class="s0">,</span>
          <span class="s1">runtimeGlobalName</span><span class="s0">,</span>
          <span class="s1">runtimeModuleName</span><span class="s0">,</span>
          <span class="s1">ssrRuntimeModuleName</span><span class="s0">,</span>
          <span class="s1">ssr</span><span class="s0">,</span>
          <span class="s1">isTS</span><span class="s0">,</span>
          <span class="s1">inSSR</span><span class="s0">,</span>
          <span class="s1">source: ast.loc.source</span><span class="s0">,</span>
          <span class="s1">code: </span><span class="s2">``</span><span class="s0">,</span>
          <span class="s1">column: </span><span class="s4">1</span><span class="s0">,</span>
          <span class="s1">line: </span><span class="s4">1</span><span class="s0">,</span>
          <span class="s1">offset: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">indentLevel: </span><span class="s4">0</span><span class="s0">,</span>
          <span class="s1">pure: </span><span class="s0">false,</span>
          <span class="s1">map: undefined</span><span class="s0">,</span>
          <span class="s1">helper(key) {</span>
              <span class="s0">return </span><span class="s2">`_</span><span class="s1">${helperNameMap[key]}</span><span class="s2">`</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">push(code</span><span class="s0">, </span><span class="s1">node) {</span>
              <span class="s1">context.code += code</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">indent() {</span>
              <span class="s1">newline(++context.indentLevel)</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">deindent(withoutNewLine = </span><span class="s0">false</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(withoutNewLine) {</span>
                  <span class="s1">--context.indentLevel</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">newline(--context.indentLevel)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">,</span>
          <span class="s1">newline() {</span>
              <span class="s1">newline(context.indentLevel)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">function </span><span class="s1">newline(n) {</span>
          <span class="s1">context.push(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">`  `</span><span class="s1">.repeat(n))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">context</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">generate(ast</span><span class="s0">, </span><span class="s1">options = {}) {</span>
      <span class="s0">const </span><span class="s1">context = createCodegenContext(ast</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(options.onContextCreated)</span>
          <span class="s1">options.onContextCreated(context)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ mode</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">prefixIdentifiers</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">scopeId</span><span class="s0">, </span><span class="s1">ssr } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">hasHelpers = helpers.length &gt; </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">useWithBlock = !prefixIdentifiers &amp;&amp; mode !== </span><span class="s2">'module'</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isSetupInlined = !</span><span class="s0">true ;</span>
      <span class="s5">// preambles</span>
      <span class="s5">// in setup() inline mode, the preamble is generated in a sub context</span>
      <span class="s5">// and returned separately.</span>
      <span class="s0">const </span><span class="s1">preambleContext = isSetupInlined</span>
          <span class="s1">? createCodegenContext(ast</span><span class="s0">, </span><span class="s1">options)</span>
          <span class="s1">: context</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">genFunctionPreamble(ast</span><span class="s0">, </span><span class="s1">preambleContext)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// enter render function</span>
      <span class="s0">const </span><span class="s1">functionName = ssr ? </span><span class="s2">`ssrRender` </span><span class="s1">: </span><span class="s2">`render`</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">args = ssr ? [</span><span class="s2">'_ctx'</span><span class="s0">, </span><span class="s2">'_push'</span><span class="s0">, </span><span class="s2">'_parent'</span><span class="s0">, </span><span class="s2">'_attrs'</span><span class="s1">] : [</span><span class="s2">'_ctx'</span><span class="s0">, </span><span class="s2">'_cache'</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">signature = args.join(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">push(</span><span class="s2">`function </span><span class="s1">${functionName}</span><span class="s2">(</span><span class="s1">${signature}</span><span class="s2">) {`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">indent()</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(useWithBlock) {</span>
          <span class="s1">push(</span><span class="s2">`with (_ctx) {`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">indent()</span><span class="s0">;</span>
          <span class="s5">// function mode const declarations should be inside with block</span>
          <span class="s5">// also they should be renamed to avoid collision with user properties</span>
          <span class="s0">if </span><span class="s1">(hasHelpers) {</span>
              <span class="s1">push(</span><span class="s2">`const { </span><span class="s1">${helpers.map(aliasHelper).join(</span><span class="s2">', '</span><span class="s1">)} </span><span class="s2">} = _Vue`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">push(</span><span class="s2">`</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s5">// generate asset resolution statements</span>
      <span class="s0">if </span><span class="s1">(ast.components.length) {</span>
          <span class="s1">genAssets(ast.components</span><span class="s0">, </span><span class="s2">'component'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(ast.directives.length || ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(ast.directives.length) {</span>
          <span class="s1">genAssets(ast.directives</span><span class="s0">, </span><span class="s2">'directive'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(ast.filters &amp;&amp; ast.filters.length) {</span>
          <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">genAssets(ast.filters</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">newline()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">push(</span><span class="s2">`let `</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; ast.temps</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s1">push(</span><span class="s2">`</span><span class="s1">${i &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">`, ` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">_temp</span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(ast.components.length || ast.directives.length || ast.temps) {</span>
          <span class="s1">push(</span><span class="s2">`</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">newline()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// generate the VNode tree expression</span>
      <span class="s0">if </span><span class="s1">(!ssr) {</span>
          <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(ast.codegenNode) {</span>
          <span class="s1">genNode(ast.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">push(</span><span class="s2">`null`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(useWithBlock) {</span>
          <span class="s1">deindent()</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">deindent()</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">ast</span><span class="s0">,</span>
          <span class="s1">code: context.code</span><span class="s0">,</span>
          <span class="s1">preamble: isSetupInlined ? preambleContext.code : </span><span class="s2">``</span><span class="s0">,</span>
          <span class="s5">// SourceMapGenerator does have toJSON() method but it's not in the types</span>
          <span class="s1">map: context.map ? context.map.toJSON() : undefined</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genFunctionPreamble(ast</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ ssr</span><span class="s0">, </span><span class="s1">prefixIdentifiers</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">runtimeModuleName</span><span class="s0">, </span><span class="s1">runtimeGlobalName</span><span class="s0">, </span><span class="s1">ssrRuntimeModuleName } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">VueBinding = runtimeGlobalName</span><span class="s0">;</span>
      <span class="s5">// Generate const declaration for helpers</span>
      <span class="s5">// In prefix mode, we place the const declaration at top so it's done</span>
      <span class="s5">// only once; But if we not prefixing, we place the declaration inside the</span>
      <span class="s5">// with block so it doesn't incur the `in` check cost for every helper access.</span>
      <span class="s0">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(helpers.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">{</span>
              <span class="s5">// &quot;with&quot; mode.</span>
              <span class="s5">// save Vue in a separate variable to avoid collision</span>
              <span class="s1">push(</span><span class="s2">`const _Vue = </span><span class="s1">${VueBinding}</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s5">// in &quot;with&quot; mode, helpers are declared inside the with block to avoid</span>
              <span class="s5">// has check cost, but hoists are lifted out of the function - we need</span>
              <span class="s5">// to provide the helper here.</span>
              <span class="s0">if </span><span class="s1">(ast.hoists.length) {</span>
                  <span class="s0">const </span><span class="s1">staticHelpers = [</span>
                      <span class="s1">CREATE_VNODE</span><span class="s0">,</span>
                      <span class="s1">CREATE_ELEMENT_VNODE</span><span class="s0">,</span>
                      <span class="s1">CREATE_COMMENT</span><span class="s0">,</span>
                      <span class="s1">CREATE_TEXT</span><span class="s0">,</span>
                      <span class="s1">CREATE_STATIC</span>
                  <span class="s1">]</span>
                      <span class="s1">.filter(helper =&gt; helpers.includes(helper))</span>
                      <span class="s1">.map(aliasHelper)</span>
                      <span class="s1">.join(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">push(</span><span class="s2">`const { </span><span class="s1">${staticHelpers} </span><span class="s2">} = _Vue</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">genHoists(ast.hoists</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">newline()</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genAssets(assets</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">isTS }) {</span>
      <span class="s0">const </span><span class="s1">resolver = helper(type === </span><span class="s2">'filter'</span>
          <span class="s1">? RESOLVE_FILTER</span>
          <span class="s1">: type === </span><span class="s2">'component'</span>
              <span class="s1">? RESOLVE_COMPONENT</span>
              <span class="s1">: RESOLVE_DIRECTIVE)</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; assets.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">let </span><span class="s1">id = assets[i]</span><span class="s0">;</span>
          <span class="s5">// potential component implicit self-reference inferred from SFC filename</span>
          <span class="s0">const </span><span class="s1">maybeSelfReference = id.endsWith(</span><span class="s2">'__self'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(maybeSelfReference) {</span>
              <span class="s1">id = id.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">6</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">push(</span><span class="s2">`const </span><span class="s1">${toValidAssetId(id</span><span class="s0">, </span><span class="s1">type)} </span><span class="s2">= </span><span class="s1">${resolver}</span><span class="s2">(</span><span class="s1">${JSON.stringify(id)}${maybeSelfReference ? </span><span class="s2">`, true` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">)</span><span class="s1">${isTS ? </span><span class="s2">`!` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(i &lt; assets.length - </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genHoists(hoists</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">if </span><span class="s1">(!hoists.length) {</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s1">context.pure = </span><span class="s0">true;</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">scopeId</span><span class="s0">, </span><span class="s1">mode } = context</span><span class="s0">;</span>
      <span class="s1">newline()</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; hoists.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">exp = hoists[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(exp) {</span>
              <span class="s1">push(</span><span class="s2">`const _hoisted_</span><span class="s1">${i + </span><span class="s4">1</span><span class="s1">} </span><span class="s2">= </span><span class="s1">${</span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">genNode(exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">context.pure = </span><span class="s0">false;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isText(n) {</span>
      <span class="s0">return </span><span class="s1">(isString(n) ||</span>
          <span class="s1">n.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
          <span class="s1">n.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">||</span>
          <span class="s1">n.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
          <span class="s1">n.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genNodeListAsArray(nodes</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">multilines = nodes.length &gt; </span><span class="s4">3 </span><span class="s1">||</span>
          <span class="s1">(nodes.some(n =&gt; isArray(n) || !isText(n)))</span><span class="s0">;</span>
      <span class="s1">context.push(</span><span class="s2">`[`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">multilines &amp;&amp; context.indent()</span><span class="s0">;</span>
      <span class="s1">genNodeList(nodes</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">multilines)</span><span class="s0">;</span>
      <span class="s1">multilines &amp;&amp; context.deindent()</span><span class="s0">;</span>
      <span class="s1">context.push(</span><span class="s2">`]`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genNodeList(nodes</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">multilines = </span><span class="s0">false, </span><span class="s1">comma = </span><span class="s0">true</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodes.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">node = nodes[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(isString(node)) {</span>
              <span class="s1">push(node)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isArray(node)) {</span>
              <span class="s1">genNodeListAsArray(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">genNode(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(i &lt; nodes.length - </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(multilines) {</span>
                  <span class="s1">comma &amp;&amp; push(</span><span class="s2">','</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">newline()</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">comma &amp;&amp; push(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genNode(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">if </span><span class="s1">(isString(node)) {</span>
          <span class="s1">context.push(node)</span><span class="s0">;</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(isSymbol(node)) {</span>
          <span class="s1">context.push(context.helper(node))</span><span class="s0">;</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
              <span class="s1">assert(node.codegenNode != </span><span class="s0">null, </span><span class="s2">`Codegen node is missing for element/if/for node. ` </span><span class="s1">+</span>
                      <span class="s2">`Apply appropriate transforms first.`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">genNode(node.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">:</span>
              <span class="s1">genText(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
              <span class="s1">genInterpolation(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
              <span class="s1">genNode(node.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
              <span class="s1">genComment(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">:</span>
              <span class="s1">genVNodeCall(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genCallExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genObjectExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genArrayExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">18 </span><span class="s5">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genFunctionExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genConditionalExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">:</span>
              <span class="s1">genCacheExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">21 </span><span class="s5">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s1">:</span>
              <span class="s1">genNodeList(node.body</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true, false</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s5">// SSR only types</span>
          <span class="s0">case </span><span class="s4">22 </span><span class="s5">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s1">:</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">23 </span><span class="s5">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s1">:</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">24 </span><span class="s5">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">25 </span><span class="s5">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s1">:</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s4">26 </span><span class="s5">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s1">:</span>
              <span class="s0">break;</span>
          <span class="s5">/* istanbul ignore next */</span>
          <span class="s0">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
              <span class="s5">// noop</span>
              <span class="s0">break;</span>
          <span class="s0">default</span><span class="s1">:</span>
              <span class="s1">{</span>
                  <span class="s1">assert(</span><span class="s0">false, </span><span class="s2">`unhandled codegen node type: </span><span class="s1">${node.type}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s5">// make sure we exhaust all possible types</span>
                  <span class="s0">const </span><span class="s1">exhaustiveCheck = node</span><span class="s0">;</span>
                  <span class="s0">return </span><span class="s1">exhaustiveCheck</span><span class="s0">;</span>
              <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genText(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s1">context.push(JSON.stringify(node.content)</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ content</span><span class="s0">, </span><span class="s1">isStatic } = node</span><span class="s0">;</span>
      <span class="s1">context.push(isStatic ? JSON.stringify(content) : content</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genInterpolation(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(pure)</span>
          <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(TO_DISPLAY_STRING)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">genNode(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(isString(child)) {</span>
              <span class="s1">context.push(child)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">genNode(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genExpressionAsPropertyKey(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push } = context</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s1">push(</span><span class="s2">`[`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`]`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(node.isStatic) {</span>
          <span class="s5">// only quote keys if necessary</span>
          <span class="s0">const </span><span class="s1">text = isSimpleIdentifier(node.content)</span>
              <span class="s1">? node.content</span>
              <span class="s1">: JSON.stringify(node.content)</span><span class="s0">;</span>
          <span class="s1">push(text</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">push(</span><span class="s2">`[</span><span class="s1">${node.content}</span><span class="s2">]`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genComment(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(pure) {</span>
          <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(CREATE_COMMENT)}</span><span class="s2">(</span><span class="s1">${JSON.stringify(node.content)}</span><span class="s2">)`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genVNodeCall(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps</span><span class="s0">, </span><span class="s1">directives</span><span class="s0">, </span><span class="s1">isBlock</span><span class="s0">, </span><span class="s1">disableTracking</span><span class="s0">, </span><span class="s1">isComponent } = node</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(directives) {</span>
          <span class="s1">push(helper(WITH_DIRECTIVES) + </span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(isBlock) {</span>
          <span class="s1">push(</span><span class="s2">`(</span><span class="s1">${helper(OPEN_BLOCK)}</span><span class="s2">(</span><span class="s1">${disableTracking ? </span><span class="s2">`true` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">), `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(pure) {</span>
          <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">callHelper = isBlock</span>
          <span class="s1">? getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent)</span>
          <span class="s1">: getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent)</span><span class="s0">;</span>
      <span class="s1">push(helper(callHelper) + </span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s1">genNodeList(genNullableArgs([tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps])</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isBlock) {</span>
          <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(directives) {</span>
          <span class="s1">push(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">genNode(directives</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genNullableArgs(args) {</span>
      <span class="s0">let </span><span class="s1">i = args.length</span><span class="s0">;</span>
      <span class="s0">while </span><span class="s1">(i--) {</span>
          <span class="s0">if </span><span class="s1">(args[i] != </span><span class="s0">null</span><span class="s1">)</span>
              <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">args.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">).map(arg =&gt; arg || </span><span class="s2">`null`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s5">// JavaScript</span>
  <span class="s0">function </span><span class="s1">genCallExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">callee = isString(node.callee) ? node.callee : helper(node.callee)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(pure) {</span>
          <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(callee + </span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s1">genNodeList(node.arguments</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genObjectExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ properties } = node</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!properties.length) {</span>
          <span class="s1">push(</span><span class="s2">`{}`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">multilines = properties.length &gt; </span><span class="s4">1 </span><span class="s1">||</span>
          <span class="s1">(properties.some(p =&gt; p.value.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s1">push(multilines ? </span><span class="s2">`{` </span><span class="s1">: </span><span class="s2">`{ `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">multilines &amp;&amp; indent()</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value } = properties[i]</span><span class="s0">;</span>
          <span class="s5">// key</span>
          <span class="s1">genExpressionAsPropertyKey(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`: `</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s5">// value</span>
          <span class="s1">genNode(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(i &lt; properties.length - </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s5">// will only reach this if it's multilines</span>
              <span class="s1">push(</span><span class="s2">`,`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">multilines &amp;&amp; deindent()</span><span class="s0">;</span>
      <span class="s1">push(multilines ? </span><span class="s2">`}` </span><span class="s1">: </span><span class="s2">` }`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genArrayExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s1">genNodeListAsArray(node.elements</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genFunctionExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ params</span><span class="s0">, </span><span class="s1">returns</span><span class="s0">, </span><span class="s1">body</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">isSlot } = node</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isSlot) {</span>
          <span class="s5">// wrap slot functions with owner context</span>
          <span class="s1">push(</span><span class="s2">`_</span><span class="s1">${helperNameMap[WITH_CTX]}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(</span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isArray(params)) {</span>
          <span class="s1">genNodeList(params</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(params) {</span>
          <span class="s1">genNode(params</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(</span><span class="s2">`) =&gt; `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(newline || body) {</span>
          <span class="s1">push(</span><span class="s2">`{`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">indent()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(returns) {</span>
          <span class="s0">if </span><span class="s1">(newline) {</span>
              <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(isArray(returns)) {</span>
              <span class="s1">genNodeListAsArray(returns</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">genNode(returns</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(body) {</span>
          <span class="s1">genNode(body</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(newline || body) {</span>
          <span class="s1">deindent()</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(isSlot) {</span>
          <span class="s0">if </span><span class="s1">(node.isNonScopedSlot) {</span>
              <span class="s1">push(</span><span class="s2">`, undefined, true`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genConditionalExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate</span><span class="s0">, </span><span class="s1">newline: needNewline } = node</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(test.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">needsParens = !isSimpleIdentifier(test.content)</span><span class="s0">;</span>
          <span class="s1">needsParens &amp;&amp; push(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">genExpression(test</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">needsParens &amp;&amp; push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">push(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">genNode(test</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">needNewline &amp;&amp; indent()</span><span class="s0">;</span>
      <span class="s1">context.indentLevel++</span><span class="s0">;</span>
      <span class="s1">needNewline || push(</span><span class="s2">` `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`? `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">genNode(consequent</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">context.indentLevel--</span><span class="s0">;</span>
      <span class="s1">needNewline &amp;&amp; newline()</span><span class="s0">;</span>
      <span class="s1">needNewline || push(</span><span class="s2">` `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`: `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isNested = alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!isNested) {</span>
          <span class="s1">context.indentLevel++</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">genNode(alternate</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!isNested) {</span>
          <span class="s1">context.indentLevel--</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">needNewline &amp;&amp; deindent(</span><span class="s0">true </span><span class="s5">/* without newline */</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">genCacheExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
      <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">] || (`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(node.isVNode) {</span>
          <span class="s1">indent()</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s2">(-1),`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">newline()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">] = `</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">genNode(node.value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(node.isVNode) {</span>
          <span class="s1">push(</span><span class="s2">`,`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s2">(1),`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">newline()</span><span class="s0">;</span>
          <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">]`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">deindent()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">function </span><span class="s1">walkIdentifiers(root</span><span class="s0">, </span><span class="s1">onIdentifier</span><span class="s0">, </span><span class="s1">includeAll = </span><span class="s0">false, </span><span class="s1">parentStack = []</span><span class="s0">, </span><span class="s1">knownIds = Object.create(</span><span class="s0">null</span><span class="s1">)) {</span>
      <span class="s1">{</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isReferencedIdentifier(id</span><span class="s0">, </span><span class="s1">parent</span><span class="s0">, </span><span class="s1">parentStack) {</span>
      <span class="s1">{</span>
          <span class="s0">return false;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isInDestructureAssignment(parent</span><span class="s0">, </span><span class="s1">parentStack) {</span>
      <span class="s0">if </span><span class="s1">(parent &amp;&amp;</span>
          <span class="s1">(parent.type === </span><span class="s2">'ObjectProperty' </span><span class="s1">|| parent.type === </span><span class="s2">'ArrayPattern'</span><span class="s1">)) {</span>
          <span class="s0">let </span><span class="s1">i = parentStack.length</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">(i--) {</span>
              <span class="s0">const </span><span class="s1">p = parentStack[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(p.type === </span><span class="s2">'AssignmentExpression'</span><span class="s1">) {</span>
                  <span class="s0">return true;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(p.type !== </span><span class="s2">'ObjectProperty' </span><span class="s1">&amp;&amp; !p.type.endsWith(</span><span class="s2">'Pattern'</span><span class="s1">)) {</span>
                  <span class="s0">break;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return false;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">walkFunctionParams(node</span><span class="s0">, </span><span class="s1">onIdent) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">p of node.params) {</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">id of extractIdentifiers(p)) {</span>
              <span class="s1">onIdent(id)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">walkBlockDeclarations(block</span><span class="s0">, </span><span class="s1">onIdent) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">stmt of block.body) {</span>
          <span class="s0">if </span><span class="s1">(stmt.type === </span><span class="s2">'VariableDeclaration'</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(stmt.declare)</span>
                  <span class="s0">continue;</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">decl of stmt.declarations) {</span>
                  <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">id of extractIdentifiers(decl.id)) {</span>
                      <span class="s1">onIdent(id)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(stmt.type === </span><span class="s2">'FunctionDeclaration' </span><span class="s1">||</span>
              <span class="s1">stmt.type === </span><span class="s2">'ClassDeclaration'</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(stmt.declare || !stmt.id)</span>
                  <span class="s0">continue;</span>
              <span class="s1">onIdent(stmt.id)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">extractIdentifiers(param</span><span class="s0">, </span><span class="s1">nodes = []) {</span>
      <span class="s0">switch </span><span class="s1">(param.type) {</span>
          <span class="s0">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
              <span class="s1">nodes.push(param)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
              <span class="s0">let </span><span class="s1">object = param</span><span class="s0">;</span>
              <span class="s0">while </span><span class="s1">(object.type === </span><span class="s2">'MemberExpression'</span><span class="s1">) {</span>
                  <span class="s1">object = object.object</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">nodes.push(object)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s2">'ObjectPattern'</span><span class="s1">:</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">prop of param.properties) {</span>
                  <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s2">'RestElement'</span><span class="s1">) {</span>
                      <span class="s1">extractIdentifiers(prop.argument</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">extractIdentifiers(prop.value</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s2">'ArrayPattern'</span><span class="s1">:</span>
              <span class="s1">param.elements.forEach(element =&gt; {</span>
                  <span class="s0">if </span><span class="s1">(element)</span>
                      <span class="s1">extractIdentifiers(element</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s2">'RestElement'</span><span class="s1">:</span>
              <span class="s1">extractIdentifiers(param.argument</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s0">case </span><span class="s2">'AssignmentPattern'</span><span class="s1">:</span>
              <span class="s1">extractIdentifiers(param.left</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
              <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">nodes</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">isFunctionType = (node) =&gt; {</span>
      <span class="s0">return </span><span class="s4">/Function(?:Expression|Declaration)$|Method$/</span><span class="s1">.test(node.type)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isStaticProperty = (node) =&gt; node &amp;&amp;</span>
      <span class="s1">(node.type === </span><span class="s2">'ObjectProperty' </span><span class="s1">|| node.type === </span><span class="s2">'ObjectMethod'</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">!node.computed</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isStaticPropertyKey = (node</span><span class="s0">, </span><span class="s1">parent) =&gt; isStaticProperty(parent) &amp;&amp; parent.key === node</span><span class="s0">;</span>

  <span class="s5">// these keywords should not appear inside expressions, but operators like</span>
  <span class="s5">// 'typeof', 'instanceof', and 'in' are allowed</span>
  <span class="s0">const </span><span class="s1">prohibitedKeywordRE = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">b' </span><span class="s1">+</span>
      <span class="s1">(</span><span class="s2">'arguments,await,break,case,catch,class,const,continue,debugger,default,' </span><span class="s1">+</span>
          <span class="s2">'delete,do,else,export,extends,finally,for,function,if,import,let,new,' </span><span class="s1">+</span>
          <span class="s2">'return,super,switch,throw,try,var,void,while,with,yield'</span><span class="s1">)</span>
          <span class="s1">.split(</span><span class="s2">','</span><span class="s1">)</span>
          <span class="s1">.join(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">b|</span><span class="s0">\\</span><span class="s2">b'</span><span class="s1">) +</span>
      <span class="s2">'</span><span class="s0">\\</span><span class="s2">b'</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s5">// strip strings in expressions</span>
  <span class="s0">const </span><span class="s1">stripStringRE = </span><span class="s4">/'(?:[^'\\]|\\.)*'|&quot;(?:[^&quot;\\]|\\.)*&quot;|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g</span><span class="s0">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Validate a non-prefixed expression.</span>
   <span class="s3">* This is only called when using the in-browser runtime compiler since it</span>
   <span class="s3">* doesn't prefix expressions.</span>
   <span class="s3">*/</span>
  <span class="s0">function </span><span class="s1">validateBrowserExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">asParams = </span><span class="s0">false, </span><span class="s1">asRawStatements = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">exp = node.content</span><span class="s0">;</span>
      <span class="s5">// empty expressions are validated per-directive since some directives</span>
      <span class="s5">// do allow empty expressions.</span>
      <span class="s0">if </span><span class="s1">(!exp.trim()) {</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">try </span><span class="s1">{</span>
          <span class="s0">new </span><span class="s1">Function(asRawStatements</span>
              <span class="s1">? </span><span class="s2">` </span><span class="s1">${exp} </span><span class="s2">`</span>
              <span class="s1">: </span><span class="s2">`return </span><span class="s1">${asParams ? </span><span class="s2">`(</span><span class="s1">${exp}</span><span class="s2">) =&gt; {}` </span><span class="s1">: </span><span class="s2">`(</span><span class="s1">${exp}</span><span class="s2">)`</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">catch </span><span class="s1">(e) {</span>
          <span class="s0">let </span><span class="s1">message = e.message</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">keywordMatch = exp</span>
              <span class="s1">.replace(stripStringRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
              <span class="s1">.match(prohibitedKeywordRE)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(keywordMatch) {</span>
              <span class="s1">message = </span><span class="s2">`avoid using JavaScript keyword as property name: &quot;</span><span class="s1">${keywordMatch[</span><span class="s4">0</span><span class="s1">]}</span><span class="s2">&quot;`</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">45 </span><span class="s5">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s0">, </span><span class="s1">node.loc</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">message))</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">transformExpression = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
          <span class="s1">node.content = processExpression(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
          <span class="s5">// handle directives on element</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s0">const </span><span class="s1">dir = node.props[i]</span><span class="s0">;</span>
              <span class="s5">// do not process for v-on &amp; v-for since they are special handled</span>
              <span class="s0">if </span><span class="s1">(dir.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; dir.name !== </span><span class="s2">'for'</span><span class="s1">) {</span>
                  <span class="s0">const </span><span class="s1">exp = dir.exp</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">arg = dir.arg</span><span class="s0">;</span>
                  <span class="s5">// do not process exp if this is v-on:arg - we need special handling</span>
                  <span class="s5">// for wrapping inline statements.</span>
                  <span class="s0">if </span><span class="s1">(exp &amp;&amp;</span>
                      <span class="s1">exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">!(dir.name === </span><span class="s2">'on' </span><span class="s1">&amp;&amp; arg)) {</span>
                      <span class="s1">dir.exp = processExpression(exp</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
                      <span class="s5">// slot args must be processed as function params</span>
                      <span class="s1">dir.name === </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(arg &amp;&amp; arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !arg.isStatic) {</span>
                      <span class="s1">dir.arg = processExpression(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s5">// Important: since this function uses Node.js only dependencies, it should</span>
  <span class="s5">// always be used with a leading !true check so that it can be</span>
  <span class="s5">// tree-shaken from the browser build.</span>
  <span class="s0">function </span><span class="s1">processExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
  <span class="s5">// some expressions like v-slot props &amp; v-for aliases should be parsed as</span>
  <span class="s5">// function params</span>
  <span class="s1">asParams = </span><span class="s0">false, </span>
  <span class="s5">// v-on handler values may contain multiple statements</span>
  <span class="s1">asRawStatements = </span><span class="s0">false, </span><span class="s1">localVars = Object.create(context.identifiers)) {</span>
      <span class="s1">{</span>
          <span class="s1">{</span>
              <span class="s5">// simple in-browser validation (same logic in 2.x)</span>
              <span class="s1">validateBrowserExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">asParams</span><span class="s0">, </span><span class="s1">asRawStatements)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">stringifyExpression(exp) {</span>
      <span class="s0">if </span><span class="s1">(isString(exp)) {</span>
          <span class="s0">return </span><span class="s1">exp</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">exp.content</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">return </span><span class="s1">exp.children</span>
              <span class="s1">.map(stringifyExpression)</span>
              <span class="s1">.join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">transformIf = createStructuralDirectiveTransform(</span><span class="s4">/^(if|else|else-if)$/</span><span class="s0">, </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">return </span><span class="s1">processIf(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">(ifNode</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, </span><span class="s1">isRoot) =&gt; {</span>
          <span class="s5">// #1587: We need to dynamically increment the key based on the current</span>
          <span class="s5">// node's sibling nodes, since chained v-if/else branches are</span>
          <span class="s5">// rendered at the same depth</span>
          <span class="s0">const </span><span class="s1">siblings = context.parent.children</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">i = siblings.indexOf(ifNode)</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">key = </span><span class="s4">0</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">(i-- &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">sibling = siblings[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
                  <span class="s1">key += sibling.branches.length</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s5">// Exit callback. Complete the codegenNode when all children have been</span>
          <span class="s5">// transformed.</span>
          <span class="s0">return </span><span class="s1">() =&gt; {</span>
              <span class="s0">if </span><span class="s1">(isRoot) {</span>
                  <span class="s1">ifNode.codegenNode = createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s5">// attach this branch's codegen node to the v-if root.</span>
                  <span class="s0">const </span><span class="s1">parentCondition = getParentCondition(ifNode.codegenNode)</span><span class="s0">;</span>
                  <span class="s1">parentCondition.alternate = createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">key + ifNode.branches.length - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s5">// target-agnostic transform used for both Client and SSR</span>
  <span class="s0">function </span><span class="s1">processIf(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">processCodegen) {</span>
      <span class="s0">if </span><span class="s1">(dir.name !== </span><span class="s2">'else' </span><span class="s1">&amp;&amp;</span>
          <span class="s1">(!dir.exp || !dir.exp.content.trim())) {</span>
          <span class="s0">const </span><span class="s1">loc = dir.exp ? dir.exp.loc : node.loc</span><span class="s0">;</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">28 </span><span class="s5">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
          <span class="s1">dir.exp = createSimpleExpression(</span><span class="s2">`true`</span><span class="s0">, false, </span><span class="s1">loc)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(dir.exp) {</span>
          <span class="s1">validateBrowserExpression(dir.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(dir.name === </span><span class="s2">'if'</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">branch = createIfBranch(node</span><span class="s0">, </span><span class="s1">dir)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">ifNode = {</span>
              <span class="s1">type: </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s0">,</span>
              <span class="s1">loc: node.loc</span><span class="s0">,</span>
              <span class="s1">branches: [branch]</span>
          <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">context.replaceNode(ifNode)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(processCodegen) {</span>
              <span class="s0">return </span><span class="s1">processCodegen(ifNode</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// locate the adjacent v-if</span>
          <span class="s0">const </span><span class="s1">siblings = context.parent.children</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">comments = []</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">i = siblings.indexOf(node)</span><span class="s0">;</span>
          <span class="s0">while </span><span class="s1">(i-- &gt;= -</span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">sibling = siblings[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                  <span class="s1">context.removeNode(sibling)</span><span class="s0">;</span>
                  <span class="s1">comments.unshift(sibling)</span><span class="s0">;</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(sibling &amp;&amp;</span>
                  <span class="s1">sibling.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">!sibling.content.trim().length) {</span>
                  <span class="s1">context.removeNode(sibling)</span><span class="s0">;</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
                  <span class="s5">// Check if v-else was followed by v-else-if</span>
                  <span class="s0">if </span><span class="s1">(dir.name === </span><span class="s2">'else-if' </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">sibling.branches[sibling.branches.length - </span><span class="s4">1</span><span class="s1">].condition === undefined) {</span>
                      <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">node.loc))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s5">// move the node to the if node's branches</span>
                  <span class="s1">context.removeNode()</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">branch = createIfBranch(node</span><span class="s0">, </span><span class="s1">dir)</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(comments.length &amp;&amp;</span>
                      <span class="s5">// #3619 ignore comments if the v-if is direct child of &lt;transition&gt;</span>
                      <span class="s1">!(context.parent &amp;&amp;</span>
                          <span class="s1">context.parent.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                          <span class="s1">isBuiltInType(context.parent.tag</span><span class="s0">, </span><span class="s2">'transition'</span><span class="s1">))) {</span>
                      <span class="s1">branch.children = [...comments</span><span class="s0">, </span><span class="s1">...branch.children]</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s5">// check if user is forcing same key on different branches</span>
                  <span class="s1">{</span>
                      <span class="s0">const </span><span class="s1">key = branch.userKey</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(key) {</span>
                          <span class="s1">sibling.branches.forEach(({ userKey }) =&gt; {</span>
                              <span class="s0">if </span><span class="s1">(isSameKey(userKey</span><span class="s0">, </span><span class="s1">key)) {</span>
                                  <span class="s1">context.onError(createCompilerError(</span><span class="s4">29 </span><span class="s5">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s0">, </span><span class="s1">branch.userKey.loc))</span><span class="s0">;</span>
                              <span class="s1">}</span>
                          <span class="s1">})</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s1">sibling.branches.push(branch)</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(sibling</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s5">// since the branch was removed, it will not be traversed.</span>
                  <span class="s5">// make sure to traverse here.</span>
                  <span class="s1">traverseNode(branch</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s5">// call on exit</span>
                  <span class="s0">if </span><span class="s1">(onExit)</span>
                      <span class="s1">onExit()</span><span class="s0">;</span>
                  <span class="s5">// make sure to reset currentNode after traversal to indicate this</span>
                  <span class="s5">// node has been removed.</span>
                  <span class="s1">context.currentNode = </span><span class="s0">null;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">node.loc))</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">break;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createIfBranch(node</span><span class="s0">, </span><span class="s1">dir) {</span>
      <span class="s0">const </span><span class="s1">isTemplateIf = node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">type: </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s0">,</span>
          <span class="s1">loc: node.loc</span><span class="s0">,</span>
          <span class="s1">condition: dir.name === </span><span class="s2">'else' </span><span class="s1">? undefined : dir.exp</span><span class="s0">,</span>
          <span class="s1">children: isTemplateIf &amp;&amp; !findDir(node</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">) ? node.children : [node]</span><span class="s0">,</span>
          <span class="s1">userKey: findProp(node</span><span class="s0">, </span><span class="s2">`key`</span><span class="s1">)</span><span class="s0">,</span>
          <span class="s1">isTemplateIf</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">if </span><span class="s1">(branch.condition) {</span>
          <span class="s0">return </span><span class="s1">createConditionalExpression(branch.condition</span><span class="s0">, </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">, </span>
          <span class="s5">// make sure to pass in asBlock: true so that the comment node call</span>
          <span class="s5">// closes the current block.</span>
          <span class="s1">createCallExpression(context.helper(CREATE_COMMENT)</span><span class="s0">, </span><span class="s1">[</span>
              <span class="s2">'&quot;v-if&quot;' </span><span class="s0">,</span>
              <span class="s2">'true'</span>
          <span class="s1">]))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">return </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">{ helper } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">keyProperty = createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`</span><span class="s1">${keyIndex}</span><span class="s2">`</span><span class="s0">, false, </span><span class="s1">locStub</span><span class="s0">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ children } = branch</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">firstChild = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| firstChild.type !== </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(needFragmentWrapper) {</span>
          <span class="s0">if </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; firstChild.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">) {</span>
              <span class="s5">// optimize away nested fragments when child is a ForNode</span>
              <span class="s0">const </span><span class="s1">vnodeCall = firstChild.codegenNode</span><span class="s0">;</span>
              <span class="s1">injectProp(vnodeCall</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">return </span><span class="s1">vnodeCall</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s0">;</span>
              <span class="s5">// check if the fragment actually contains a single valid child with</span>
              <span class="s5">// the rest being comments</span>
              <span class="s0">if </span><span class="s1">(!branch.isTemplateIf &amp;&amp;</span>
                  <span class="s1">children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
                  <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s0">;</span>
                  <span class="s1">patchFlagText += </span><span class="s2">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s2">`</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">createObjectExpression([keyProperty])</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag + (</span><span class="s2">` /* </span><span class="s1">${patchFlagText} </span><span class="s2">*/` </span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, false, false </span><span class="s5">/* isComponent */</span><span class="s0">, </span><span class="s1">branch.loc)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">const </span><span class="s1">ret = firstChild.codegenNode</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">vnodeCall = getMemoedVNodeCall(ret)</span><span class="s0">;</span>
          <span class="s5">// Change createVNode to createBlock.</span>
          <span class="s0">if </span><span class="s1">(vnodeCall.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
              <span class="s1">makeBlock(vnodeCall</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s5">// inject branch key</span>
          <span class="s1">injectProp(vnodeCall</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isSameKey(a</span><span class="s0">, </span><span class="s1">b) {</span>
      <span class="s0">if </span><span class="s1">(!a || a.type !== b.type) {</span>
          <span class="s0">return false;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(a.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(a.value.content !== b.value.content) {</span>
              <span class="s0">return false;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// directive</span>
          <span class="s0">const </span><span class="s1">exp = a.exp</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">branchExp = b.exp</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(exp.type !== branchExp.type) {</span>
              <span class="s0">return false;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(exp.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
              <span class="s1">exp.isStatic !== branchExp.isStatic ||</span>
              <span class="s1">exp.content !== branchExp.content) {</span>
              <span class="s0">return false;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return true;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">getParentCondition(node) {</span>
      <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(node.alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                  <span class="s1">node = node.alternate</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s1">node = node.value</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">transformFor = createStructuralDirectiveTransform(</span><span class="s2">'for'</span><span class="s0">, </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">removeHelper } = context</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">processFor(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">forNode =&gt; {</span>
          <span class="s5">// create the loop render function expression now, and add the</span>
          <span class="s5">// iterator on exit after all children have been traversed</span>
          <span class="s0">const </span><span class="s1">renderExp = createCallExpression(helper(RENDER_LIST)</span><span class="s0">, </span><span class="s1">[</span>
              <span class="s1">forNode.source</span>
          <span class="s1">])</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">isTemplate = isTemplateNode(node)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">memo = findDir(node</span><span class="s0">, </span><span class="s2">'memo'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">keyProp = findProp(node</span><span class="s0">, </span><span class="s2">`key`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">keyExp = keyProp &amp;&amp;</span>
              <span class="s1">(keyProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span>
                  <span class="s1">? createSimpleExpression(keyProp.value.content</span><span class="s0">, true</span><span class="s1">)</span>
                  <span class="s1">: keyProp.exp)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">keyProperty = keyProp ? createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">keyExp) : </span><span class="s0">null;</span>
          <span class="s0">const </span><span class="s1">isStableFragment = forNode.source.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">forNode.source.constType &gt; </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">fragmentFlag = isStableFragment</span>
              <span class="s1">? </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span>
              <span class="s1">: keyProp</span>
                  <span class="s1">? </span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span>
                  <span class="s1">: </span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s0">;</span>
          <span class="s1">forNode.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">renderExp</span><span class="s0">, </span><span class="s1">fragmentFlag +</span>
              <span class="s1">(</span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[fragmentFlag]} </span><span class="s2">*/` </span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true </span><span class="s5">/* isBlock */</span><span class="s0">, </span><span class="s1">!isStableFragment </span><span class="s5">/* disableTracking */</span><span class="s0">, false </span><span class="s5">/* isComponent */</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">() =&gt; {</span>
              <span class="s5">// finish the codegen now that all children have been traversed</span>
              <span class="s0">let </span><span class="s1">childBlock</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">{ children } = forNode</span><span class="s0">;</span>
              <span class="s5">// check &lt;template v-for&gt; key placement</span>
              <span class="s0">if </span><span class="s1">(isTemplate) {</span>
                  <span class="s1">node.children.some(c =&gt; {</span>
                      <span class="s0">if </span><span class="s1">(c.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
                          <span class="s0">const </span><span class="s1">key = findProp(c</span><span class="s0">, </span><span class="s2">'key'</span><span class="s1">)</span><span class="s0">;</span>
                          <span class="s0">if </span><span class="s1">(key) {</span>
                              <span class="s1">context.onError(createCompilerError(</span><span class="s4">33 </span><span class="s5">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s0">, </span><span class="s1">key.loc))</span><span class="s0">;</span>
                              <span class="s0">return true;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                  <span class="s1">})</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| children[</span><span class="s4">0</span><span class="s1">].type !== </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">slotOutlet = isSlotOutlet(node)</span>
                  <span class="s1">? node</span>
                  <span class="s1">: isTemplate &amp;&amp;</span>
                      <span class="s1">node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">isSlotOutlet(node.children[</span><span class="s4">0</span><span class="s1">])</span>
                      <span class="s1">? node.children[</span><span class="s4">0</span><span class="s1">] </span><span class="s5">// api-extractor somehow fails to infer this</span>
                      <span class="s1">: </span><span class="s0">null;</span>
              <span class="s0">if </span><span class="s1">(slotOutlet) {</span>
                  <span class="s5">// &lt;slot v-for=&quot;...&quot;&gt; or &lt;template v-for=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                  <span class="s1">childBlock = slotOutlet.codegenNode</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                      <span class="s5">// &lt;template v-for=&quot;...&quot; :key=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                      <span class="s5">// we need to inject the key to the renderSlot() call.</span>
                      <span class="s5">// the props for renderSlot is passed as the 3rd argument.</span>
                      <span class="s1">injectProp(childBlock</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(needFragmentWrapper) {</span>
                  <span class="s5">// &lt;template v-for=&quot;...&quot;&gt; with text or multi-elements</span>
                  <span class="s5">// should generate a fragment block for each loop</span>
                  <span class="s1">childBlock = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">keyProperty ? createObjectExpression([keyProperty]) : undefined</span><span class="s0">, </span><span class="s1">node.children</span><span class="s0">, </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s1">+</span>
                      <span class="s1">(</span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]} </span><span class="s2">*/`</span>
                          <span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, </span><span class="s1">undefined</span><span class="s0">, false </span><span class="s5">/* isComponent */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s5">// Normal element v-for. Directly use the child's codegenNode</span>
                  <span class="s5">// but mark it as a block.</span>
                  <span class="s1">childBlock = children[</span><span class="s4">0</span><span class="s1">]</span>
                      <span class="s1">.codegenNode</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                      <span class="s1">injectProp(childBlock</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(childBlock.isBlock !== !isStableFragment) {</span>
                      <span class="s0">if </span><span class="s1">(childBlock.isBlock) {</span>
                          <span class="s5">// switch from block to vnode</span>
                          <span class="s1">removeHelper(OPEN_BLOCK)</span><span class="s0">;</span>
                          <span class="s1">removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else </span><span class="s1">{</span>
                          <span class="s5">// switch from vnode to block</span>
                          <span class="s1">removeHelper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s1">childBlock.isBlock = !isStableFragment</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(childBlock.isBlock) {</span>
                      <span class="s1">helper(OPEN_BLOCK)</span><span class="s0">;</span>
                      <span class="s1">helper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(memo) {</span>
                  <span class="s0">const </span><span class="s1">loop = createFunctionExpression(createForLoopParams(forNode.parseResult</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">createSimpleExpression(</span><span class="s2">`_cached`</span><span class="s1">)</span>
                  <span class="s1">]))</span><span class="s0">;</span>
                  <span class="s1">loop.body = createBlockStatement([</span>
                      <span class="s1">createCompoundExpression([</span><span class="s2">`const _memo = (`</span><span class="s0">, </span><span class="s1">memo.exp</span><span class="s0">, </span><span class="s2">`)`</span><span class="s1">])</span><span class="s0">,</span>
                      <span class="s1">createCompoundExpression([</span>
                          <span class="s2">`if (_cached`</span><span class="s0">,</span>
                          <span class="s1">...(keyExp ? [</span><span class="s2">` &amp;&amp; _cached.key === `</span><span class="s0">, </span><span class="s1">keyExp] : [])</span><span class="s0">,</span>
                          <span class="s2">` &amp;&amp; </span><span class="s1">${context.helperString(IS_MEMO_SAME)}</span><span class="s2">(_cached, _memo)) return _cached`</span>
                      <span class="s1">])</span><span class="s0">,</span>
                      <span class="s1">createCompoundExpression([</span><span class="s2">`const _item = `</span><span class="s0">, </span><span class="s1">childBlock])</span><span class="s0">,</span>
                      <span class="s1">createSimpleExpression(</span><span class="s2">`_item.memo = _memo`</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">createSimpleExpression(</span><span class="s2">`return _item`</span><span class="s1">)</span>
                  <span class="s1">])</span><span class="s0">;</span>
                  <span class="s1">renderExp.arguments.push(loop</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`_cache`</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(String(context.cached++)))</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult)</span><span class="s0">, </span><span class="s1">childBlock</span><span class="s0">, true </span><span class="s5">/* force newline */</span><span class="s1">))</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s5">// target-agnostic transform used for both Client and SSR</span>
  <span class="s0">function </span><span class="s1">processFor(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">processCodegen) {</span>
      <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">31 </span><span class="s5">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">parseResult = parseForExpression(</span>
      <span class="s5">// can only be simple expression because vFor transform is applied</span>
      <span class="s5">// before expression transform.</span>
      <span class="s1">dir.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!parseResult) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">{ addIdentifiers</span><span class="s0">, </span><span class="s1">removeIdentifiers</span><span class="s0">, </span><span class="s1">scopes } = context</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ source</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index } = parseResult</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">forNode = {</span>
          <span class="s1">type: </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s0">,</span>
          <span class="s1">loc: dir.loc</span><span class="s0">,</span>
          <span class="s1">source</span><span class="s0">,</span>
          <span class="s1">valueAlias: value</span><span class="s0">,</span>
          <span class="s1">keyAlias: key</span><span class="s0">,</span>
          <span class="s1">objectIndexAlias: index</span><span class="s0">,</span>
          <span class="s1">parseResult</span><span class="s0">,</span>
          <span class="s1">children: isTemplateNode(node) ? node.children : [node]</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">context.replaceNode(forNode)</span><span class="s0">;</span>
      <span class="s5">// bookkeeping</span>
      <span class="s1">scopes.vFor++</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(forNode)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">() =&gt; {</span>
          <span class="s1">scopes.vFor--</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(onExit)</span>
              <span class="s1">onExit()</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">forAliasRE = </span><span class="s4">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span><span class="s0">;</span>
  <span class="s5">// This regex doesn't cover the case if key or index aliases have destructuring,</span>
  <span class="s5">// but those do not make sense in the first place, so this works in practice.</span>
  <span class="s0">const </span><span class="s1">forIteratorRE = </span><span class="s4">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">stripParensRE = </span><span class="s4">/^\(|\)$/g</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">parseForExpression(input</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">loc = input.loc</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">exp = input.content</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">inMatch = exp.match(forAliasRE)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!inMatch)</span>
          <span class="s0">return;</span>
      <span class="s0">const </span><span class="s1">[</span><span class="s0">, </span><span class="s1">LHS</span><span class="s0">, </span><span class="s1">RHS] = inMatch</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">result = {</span>
          <span class="s1">source: createAliasExpression(loc</span><span class="s0">, </span><span class="s1">RHS.trim()</span><span class="s0">, </span><span class="s1">exp.indexOf(RHS</span><span class="s0">, </span><span class="s1">LHS.length))</span><span class="s0">,</span>
          <span class="s1">value: undefined</span><span class="s0">,</span>
          <span class="s1">key: undefined</span><span class="s0">,</span>
          <span class="s1">index: undefined</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">validateBrowserExpression(result.source</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">valueContent = LHS.trim().replace(stripParensRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).trim()</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">trimmedOffset = LHS.indexOf(valueContent)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">iteratorMatch = valueContent.match(forIteratorRE)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(iteratorMatch) {</span>
          <span class="s1">valueContent = valueContent.replace(forIteratorRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).trim()</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">keyContent = iteratorMatch[</span><span class="s4">1</span><span class="s1">].trim()</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">keyOffset</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(keyContent) {</span>
              <span class="s1">keyOffset = exp.indexOf(keyContent</span><span class="s0">, </span><span class="s1">trimmedOffset + valueContent.length)</span><span class="s0">;</span>
              <span class="s1">result.key = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">keyContent</span><span class="s0">, </span><span class="s1">keyOffset)</span><span class="s0">;</span>
              <span class="s1">{</span>
                  <span class="s1">validateBrowserExpression(result.key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(iteratorMatch[</span><span class="s4">2</span><span class="s1">]) {</span>
              <span class="s0">const </span><span class="s1">indexContent = iteratorMatch[</span><span class="s4">2</span><span class="s1">].trim()</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(indexContent) {</span>
                  <span class="s1">result.index = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">indexContent</span><span class="s0">, </span><span class="s1">exp.indexOf(indexContent</span><span class="s0">, </span><span class="s1">result.key</span>
                      <span class="s1">? keyOffset + keyContent.length</span>
                      <span class="s1">: trimmedOffset + valueContent.length))</span><span class="s0">;</span>
                  <span class="s1">{</span>
                      <span class="s1">validateBrowserExpression(result.index</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(valueContent) {</span>
          <span class="s1">result.value = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">valueContent</span><span class="s0">, </span><span class="s1">trimmedOffset)</span><span class="s0">;</span>
          <span class="s1">{</span>
              <span class="s1">validateBrowserExpression(result.value</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createAliasExpression(range</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">offset) {</span>
      <span class="s0">return </span><span class="s1">createSimpleExpression(content</span><span class="s0">, false, </span><span class="s1">getInnerRange(range</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">content.length))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createForLoopParams({ value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index }</span><span class="s0">, </span><span class="s1">memoArgs = []) {</span>
      <span class="s0">return </span><span class="s1">createParamsList([value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">...memoArgs])</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">createParamsList(args) {</span>
      <span class="s0">let </span><span class="s1">i = args.length</span><span class="s0">;</span>
      <span class="s0">while </span><span class="s1">(i--) {</span>
          <span class="s0">if </span><span class="s1">(args[i])</span>
              <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">args</span>
          <span class="s1">.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">)</span>
          <span class="s1">.map((arg</span><span class="s0">, </span><span class="s1">i) =&gt; arg || createSimpleExpression(</span><span class="s2">`_`</span><span class="s1">.repeat(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, false</span><span class="s1">))</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">defaultFallback = createSimpleExpression(</span><span class="s2">`undefined`</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s5">// A NodeTransform that:</span>
  <span class="s5">// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
  <span class="s5">//    by transformExpression. This is only applied in non-browser builds with</span>
  <span class="s5">//    { prefixIdentifiers: true }.</span>
  <span class="s5">// 2. Track v-slot depths so that we know a slot is inside another slot.</span>
  <span class="s5">//    Note the exit callback is executed before buildSlots() on the same node,</span>
  <span class="s5">//    so only nested slots see positive numbers.</span>
  <span class="s0">const </span><span class="s1">trackSlotScopes = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">(node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */ </span><span class="s1">||</span>
              <span class="s1">node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s1">)) {</span>
          <span class="s5">// We are only checking non-empty v-slot here</span>
          <span class="s5">// since we only care about slots that introduce scope variables.</span>
          <span class="s0">const </span><span class="s1">vSlot = findDir(node</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(vSlot) {</span>
              <span class="s1">vSlot.exp</span><span class="s0">;</span>
              <span class="s1">context.scopes.vSlot++</span><span class="s0">;</span>
              <span class="s0">return </span><span class="s1">() =&gt; {</span>
                  <span class="s1">context.scopes.vSlot--</span><span class="s0">;</span>
              <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s5">// A NodeTransform that tracks scope identifiers for scoped slots with v-for.</span>
  <span class="s5">// This transform is only applied in non-browser builds with { prefixIdentifiers: true }</span>
  <span class="s0">const </span><span class="s1">trackVForSlotScopes = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">let </span><span class="s1">vFor</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isTemplateNode(node) &amp;&amp;</span>
          <span class="s1">node.props.some(isVSlot) &amp;&amp;</span>
          <span class="s1">(vFor = findDir(node</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">))) {</span>
          <span class="s0">const </span><span class="s1">result = (vFor.parseResult = parseForExpression(vFor.exp</span><span class="s0">, </span><span class="s1">context))</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(result) {</span>
              <span class="s0">const </span><span class="s1">{ value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index } = result</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">{ addIdentifiers</span><span class="s0">, </span><span class="s1">removeIdentifiers } = context</span><span class="s0">;</span>
              <span class="s1">value &amp;&amp; addIdentifiers(value)</span><span class="s0">;</span>
              <span class="s1">key &amp;&amp; addIdentifiers(key)</span><span class="s0">;</span>
              <span class="s1">index &amp;&amp; addIdentifiers(index)</span><span class="s0">;</span>
              <span class="s0">return </span><span class="s1">() =&gt; {</span>
                  <span class="s1">value &amp;&amp; removeIdentifiers(value)</span><span class="s0">;</span>
                  <span class="s1">key &amp;&amp; removeIdentifiers(key)</span><span class="s0">;</span>
                  <span class="s1">index &amp;&amp; removeIdentifiers(index)</span><span class="s0">;</span>
              <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">buildClientSlotFn = (props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc) =&gt; createFunctionExpression(props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, false </span><span class="s5">/* newline */</span><span class="s0">, true </span><span class="s5">/* isSlot */</span><span class="s0">, </span><span class="s1">children.length ? children[</span><span class="s4">0</span><span class="s1">].loc : loc)</span><span class="s0">;</span>
  <span class="s5">// Instead of being a DirectiveTransform, v-slot processing is called during</span>
  <span class="s5">// transformElement to build the slots object for a component.</span>
  <span class="s0">function </span><span class="s1">buildSlots(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">buildSlotFn = buildClientSlotFn) {</span>
      <span class="s1">context.helper(WITH_CTX)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">{ children</span><span class="s0">, </span><span class="s1">loc } = node</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">slotsProperties = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">dynamicSlots = []</span><span class="s0">;</span>
      <span class="s5">// If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
      <span class="s5">// since it likely uses a scope variable.</span>
      <span class="s0">let </span><span class="s1">hasDynamicSlots = context.scopes.vSlot &gt; </span><span class="s4">0 </span><span class="s1">|| context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s5">// 1. Check for slot with slotProps on component itself.</span>
      <span class="s5">//    &lt;Comp v-slot=&quot;{ prop }&quot;/&gt;</span>
      <span class="s0">const </span><span class="s1">onComponentSlot = findDir(node</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(onComponentSlot) {</span>
          <span class="s0">const </span><span class="s1">{ arg</span><span class="s0">, </span><span class="s1">exp } = onComponentSlot</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(arg &amp;&amp; !isStaticExp(arg)) {</span>
              <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
          <span class="s1">}</span>
          <span class="s1">slotsProperties.push(createObjectProperty(arg || createSimpleExpression(</span><span class="s2">'default'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">buildSlotFn(exp</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc)))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// 2. Iterate through children and check for template slots</span>
      <span class="s5">//    &lt;template v-slot:foo=&quot;{ prop }&quot;&gt;</span>
      <span class="s0">let </span><span class="s1">hasTemplateSlots = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasNamedDefaultSlot = </span><span class="s0">false;</span>
      <span class="s0">const </span><span class="s1">implicitDefaultChildren = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">seenSlotNames = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">conditionalBranchIndex = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">slotElement = children[i]</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">slotDir</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!isTemplateNode(slotElement) ||</span>
              <span class="s1">!(slotDir = findDir(slotElement</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s0">, true</span><span class="s1">))) {</span>
              <span class="s5">// not a &lt;template v-slot&gt;, skip.</span>
              <span class="s0">if </span><span class="s1">(slotElement.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                  <span class="s1">implicitDefaultChildren.push(slotElement)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">continue;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(onComponentSlot) {</span>
              <span class="s5">// already has on-component slot - this is incorrect usage.</span>
              <span class="s1">context.onError(createCompilerError(</span><span class="s4">37 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s0">, </span><span class="s1">slotDir.loc))</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s1">}</span>
          <span class="s1">hasTemplateSlots = </span><span class="s0">true;</span>
          <span class="s0">const </span><span class="s1">{ children: slotChildren</span><span class="s0">, </span><span class="s1">loc: slotLoc } = slotElement</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">{ arg: slotName = createSimpleExpression(</span><span class="s2">`default`</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp: slotProps</span><span class="s0">, </span><span class="s1">loc: dirLoc } = slotDir</span><span class="s0">;</span>
          <span class="s5">// check if name is dynamic.</span>
          <span class="s0">let </span><span class="s1">staticSlotName</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(isStaticExp(slotName)) {</span>
              <span class="s1">staticSlotName = slotName ? slotName.content : </span><span class="s2">`default`</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">slotFunction = buildSlotFn(slotProps</span><span class="s0">, </span><span class="s1">slotChildren</span><span class="s0">, </span><span class="s1">slotLoc)</span><span class="s0">;</span>
          <span class="s5">// check if this slot is conditional (v-if/v-for)</span>
          <span class="s0">let </span><span class="s1">vIf</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vElse</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vFor</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">((vIf = findDir(slotElement</span><span class="s0">, </span><span class="s2">'if'</span><span class="s1">))) {</span>
              <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
              <span class="s1">dynamicSlots.push(createConditionalExpression(vIf.exp</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">, </span><span class="s1">defaultFallback))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">((vElse = findDir(slotElement</span><span class="s0">, </span><span class="s4">/^else(-if)?$/</span><span class="s0">, true </span><span class="s5">/* allowEmpty */</span><span class="s1">))) {</span>
              <span class="s5">// find adjacent v-if</span>
              <span class="s0">let </span><span class="s1">j = i</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">prev</span><span class="s0">;</span>
              <span class="s0">while </span><span class="s1">(j--) {</span>
                  <span class="s1">prev = children[j]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(prev.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                      <span class="s0">break;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(prev &amp;&amp; isTemplateNode(prev) &amp;&amp; findDir(prev</span><span class="s0">, </span><span class="s2">'if'</span><span class="s1">)) {</span>
                  <span class="s5">// remove node</span>
                  <span class="s1">children.splice(i</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">i--</span><span class="s0">;</span>
                  <span class="s5">// attach this slot to previous conditional</span>
                  <span class="s0">let </span><span class="s1">conditional = dynamicSlots[dynamicSlots.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                  <span class="s0">while </span><span class="s1">(conditional.alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                      <span class="s1">conditional = conditional.alternate</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s1">conditional.alternate = vElse.exp</span>
                      <span class="s1">? createConditionalExpression(vElse.exp</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">, </span><span class="s1">defaultFallback)</span>
                      <span class="s1">: buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">vElse.loc))</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">((vFor = findDir(slotElement</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">))) {</span>
              <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
              <span class="s0">const </span><span class="s1">parseResult = vFor.parseResult ||</span>
                  <span class="s1">parseForExpression(vFor.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(parseResult) {</span>
                  <span class="s5">// Render the dynamic slots as an array and add it to the createSlot()</span>
                  <span class="s5">// args. The runtime knows how to handle it appropriately.</span>
                  <span class="s1">dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST)</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">parseResult.source</span><span class="s0">,</span>
                      <span class="s1">createFunctionExpression(createForLoopParams(parseResult)</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction)</span><span class="s0">, true </span><span class="s5">/* force newline */</span><span class="s1">)</span>
                  <span class="s1">]))</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">vFor.loc))</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// check duplicate static names</span>
              <span class="s0">if </span><span class="s1">(staticSlotName) {</span>
                  <span class="s0">if </span><span class="s1">(seenSlotNames.has(staticSlotName)) {</span>
                      <span class="s1">context.onError(createCompilerError(</span><span class="s4">38 </span><span class="s5">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s0">, </span><span class="s1">dirLoc))</span><span class="s0">;</span>
                      <span class="s0">continue;</span>
                  <span class="s1">}</span>
                  <span class="s1">seenSlotNames.add(staticSlotName)</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(staticSlotName === </span><span class="s2">'default'</span><span class="s1">) {</span>
                      <span class="s1">hasNamedDefaultSlot = </span><span class="s0">true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s1">slotsProperties.push(createObjectProperty(slotName</span><span class="s0">, </span><span class="s1">slotFunction))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!onComponentSlot) {</span>
          <span class="s0">const </span><span class="s1">buildDefaultSlotProperty = (props</span><span class="s0">, </span><span class="s1">children) =&gt; {</span>
              <span class="s0">const </span><span class="s1">fn = buildSlotFn(props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(context.compatConfig) {</span>
                  <span class="s1">fn.isNonScopedSlot = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">return </span><span class="s1">createObjectProperty(</span><span class="s2">`default`</span><span class="s0">, </span><span class="s1">fn)</span><span class="s0">;</span>
          <span class="s1">}</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!hasTemplateSlots) {</span>
              <span class="s5">// implicit default slot (on component)</span>
              <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s0">, </span><span class="s1">children))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(implicitDefaultChildren.length &amp;&amp;</span>
              <span class="s5">// #3766</span>
              <span class="s5">// with whitespace: 'preserve', whitespaces between slots will end up in</span>
              <span class="s5">// implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
              <span class="s1">implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))) {</span>
              <span class="s5">// implicit default slot (mixed with named slots)</span>
              <span class="s0">if </span><span class="s1">(hasNamedDefaultSlot) {</span>
                  <span class="s1">context.onError(createCompilerError(</span><span class="s4">39 </span><span class="s5">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s0">, </span><span class="s1">implicitDefaultChildren[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s0">, </span><span class="s1">implicitDefaultChildren))</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">slotFlag = hasDynamicSlots</span>
          <span class="s1">? </span><span class="s4">2 </span><span class="s5">/* SlotFlags.DYNAMIC */</span>
          <span class="s1">: hasForwardedSlots(node.children)</span>
              <span class="s1">? </span><span class="s4">3 </span><span class="s5">/* SlotFlags.FORWARDED */</span>
              <span class="s1">: </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">slots = createObjectExpression(slotsProperties.concat(createObjectProperty(</span><span class="s2">`_`</span><span class="s0">, </span>
      <span class="s5">// 2 = compiled but dynamic = can skip normalization, but must run diff</span>
      <span class="s5">// 1 = compiled and static = can skip normalization AND diff as optimized</span>
      <span class="s1">createSimpleExpression(slotFlag + (</span><span class="s2">` /* </span><span class="s1">${slotFlagsText[slotFlag]} </span><span class="s2">*/` </span><span class="s1">)</span><span class="s0">, false</span><span class="s1">)))</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(dynamicSlots.length) {</span>
          <span class="s1">slots = createCallExpression(context.helper(CREATE_SLOTS)</span><span class="s0">, </span><span class="s1">[</span>
              <span class="s1">slots</span><span class="s0">,</span>
              <span class="s1">createArrayExpression(dynamicSlots)</span>
          <span class="s1">])</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">slots</span><span class="s0">,</span>
          <span class="s1">hasDynamicSlots</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">buildDynamicSlot(name</span><span class="s0">, </span><span class="s1">fn</span><span class="s0">, </span><span class="s1">index) {</span>
      <span class="s0">const </span><span class="s1">props = [</span>
          <span class="s1">createObjectProperty(</span><span class="s2">`name`</span><span class="s0">, </span><span class="s1">name)</span><span class="s0">,</span>
          <span class="s1">createObjectProperty(</span><span class="s2">`fn`</span><span class="s0">, </span><span class="s1">fn)</span>
      <span class="s1">]</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(index != </span><span class="s0">null</span><span class="s1">) {</span>
          <span class="s1">props.push(createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">createSimpleExpression(String(index)</span><span class="s0">, true</span><span class="s1">)))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">createObjectExpression(props)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">hasForwardedSlots(children) {</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
          <span class="s0">switch </span><span class="s1">(child.type) {</span>
              <span class="s0">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(child.tagType === </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */ </span><span class="s1">||</span>
                      <span class="s1">hasForwardedSlots(child.children)) {</span>
                      <span class="s0">return true;</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(hasForwardedSlots(child.branches))</span>
                      <span class="s0">return true;</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
              <span class="s0">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
                  <span class="s0">if </span><span class="s1">(hasForwardedSlots(child.children))</span>
                      <span class="s0">return true;</span>
                  <span class="s0">break;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return false;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isNonWhitespaceContent(node) {</span>
      <span class="s0">if </span><span class="s1">(node.type !== </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp; node.type !== </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">)</span>
          <span class="s0">return true;</span>
      <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span>
          <span class="s1">? !!node.content.trim()</span>
          <span class="s1">: isNonWhitespaceContent(node.content)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s5">// some directive transforms (e.g. v-model) may return a symbol for runtime</span>
  <span class="s5">// import, which should be used instead of a resolveDirective call.</span>
  <span class="s0">const </span><span class="s1">directiveImportMap = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">;</span>
  <span class="s5">// generate a JavaScript AST for this element's codegen</span>
  <span class="s0">const </span><span class="s1">transformElement = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s5">// perform the work on exit, after all child expressions have been</span>
      <span class="s5">// processed and merged.</span>
      <span class="s0">return function </span><span class="s1">postTransformElement() {</span>
          <span class="s1">node = context.currentNode</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">(node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                  <span class="s1">node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">))) {</span>
              <span class="s0">return;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">props } = node</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">isComponent = node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
          <span class="s5">// The goal of the transform is to create a codegenNode implementing the</span>
          <span class="s5">// VNodeCall interface.</span>
          <span class="s0">let </span><span class="s1">vnodeTag = isComponent</span>
              <span class="s1">? resolveComponentType(node</span><span class="s0">, </span><span class="s1">context)</span>
              <span class="s1">: </span><span class="s2">`&quot;</span><span class="s1">${tag}</span><span class="s2">&quot;`</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">isDynamicComponent = isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vnodeProps</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vnodeChildren</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vnodePatchFlag</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vnodeDynamicProps</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">dynamicPropNames</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">vnodeDirectives</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">shouldUseBlock = </span>
          <span class="s5">// dynamic component may resolve to plain elements</span>
          <span class="s1">isDynamicComponent ||</span>
              <span class="s1">vnodeTag === TELEPORT ||</span>
              <span class="s1">vnodeTag === SUSPENSE ||</span>
              <span class="s1">(!isComponent &amp;&amp;</span>
                  <span class="s5">// &lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
                  <span class="s5">// updates inside get proper isSVG flag at runtime. (#639, #643)</span>
                  <span class="s5">// This is technically web-specific, but splitting the logic out of core</span>
                  <span class="s5">// leads to too much unnecessary complexity.</span>
                  <span class="s1">(tag === </span><span class="s2">'svg' </span><span class="s1">|| tag === </span><span class="s2">'foreignObject'</span><span class="s1">))</span><span class="s0">;</span>
          <span class="s5">// props</span>
          <span class="s0">if </span><span class="s1">(props.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">propsBuildResult = buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">isDynamicComponent)</span><span class="s0">;</span>
              <span class="s1">vnodeProps = propsBuildResult.props</span><span class="s0">;</span>
              <span class="s1">patchFlag = propsBuildResult.patchFlag</span><span class="s0">;</span>
              <span class="s1">dynamicPropNames = propsBuildResult.dynamicPropNames</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">directives = propsBuildResult.directives</span><span class="s0">;</span>
              <span class="s1">vnodeDirectives =</span>
                  <span class="s1">directives &amp;&amp; directives.length</span>
                      <span class="s1">? createArrayExpression(directives.map(dir =&gt; buildDirectiveArgs(dir</span><span class="s0">, </span><span class="s1">context)))</span>
                      <span class="s1">: undefined</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(propsBuildResult.shouldUseBlock) {</span>
                  <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s5">// children</span>
          <span class="s0">if </span><span class="s1">(node.children.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(vnodeTag === KEEP_ALIVE) {</span>
                  <span class="s5">// Although a built-in component, we compile KeepAlive with raw children</span>
                  <span class="s5">// instead of slot functions so that it can be used inside Transition</span>
                  <span class="s5">// or other Transition-wrapping HOCs.</span>
                  <span class="s5">// To ensure correct updates with block optimizations, we need to:</span>
                  <span class="s5">// 1. Force keep-alive into a block. This avoids its children being</span>
                  <span class="s5">//    collected by a parent block.</span>
                  <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
                  <span class="s5">// 2. Force keep-alive to always be updated, since it uses raw children.</span>
                  <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(node.children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                      <span class="s1">context.onError(createCompilerError(</span><span class="s4">46 </span><span class="s5">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s0">, </span><span class="s1">{</span>
                          <span class="s1">start: node.children[</span><span class="s4">0</span><span class="s1">].loc.start</span><span class="s0">,</span>
                          <span class="s1">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s1">].loc.end</span><span class="s0">,</span>
                          <span class="s1">source: </span><span class="s2">''</span>
                      <span class="s1">}))</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">shouldBuildAsSlots = isComponent &amp;&amp;</span>
                  <span class="s5">// Teleport is not a real component and has dedicated runtime handling</span>
                  <span class="s1">vnodeTag !== TELEPORT &amp;&amp;</span>
                  <span class="s5">// explained above.</span>
                  <span class="s1">vnodeTag !== KEEP_ALIVE</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(shouldBuildAsSlots) {</span>
                  <span class="s0">const </span><span class="s1">{ slots</span><span class="s0">, </span><span class="s1">hasDynamicSlots } = buildSlots(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">vnodeChildren = slots</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(hasDynamicSlots) {</span>
                      <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; vnodeTag !== TELEPORT) {</span>
                  <span class="s0">const </span><span class="s1">child = node.children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">type = child.type</span><span class="s0">;</span>
                  <span class="s5">// check for dynamic text children</span>
                  <span class="s0">const </span><span class="s1">hasDynamicTextChild = type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
                      <span class="s1">type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(hasDynamicTextChild &amp;&amp;</span>
                      <span class="s1">getConstantType(child</span><span class="s0">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                      <span class="s1">patchFlag |= </span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s5">// pass directly if the only child is a text node</span>
                  <span class="s5">// (plain / interpolation / expression)</span>
                  <span class="s0">if </span><span class="s1">(hasDynamicTextChild || type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                      <span class="s1">vnodeChildren = child</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">vnodeChildren = node.children</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">vnodeChildren = node.children</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s5">// patchFlag &amp; dynamicPropNames</span>
          <span class="s0">if </span><span class="s1">(patchFlag !== </span><span class="s4">0</span><span class="s1">) {</span>
              <span class="s1">{</span>
                  <span class="s0">if </span><span class="s1">(patchFlag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                      <span class="s5">// special flags (negative and mutually exclusive)</span>
                      <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[patchFlag]} </span><span class="s2">*/`</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s5">// bitwise flags</span>
                      <span class="s0">const </span><span class="s1">flagNames = Object.keys(PatchFlagNames)</span>
                          <span class="s1">.map(Number)</span>
                          <span class="s1">.filter(n =&gt; n &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; n)</span>
                          <span class="s1">.map(n =&gt; PatchFlagNames[n])</span>
                          <span class="s1">.join(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
                      <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s2">` /* </span><span class="s1">${flagNames} </span><span class="s2">*/`</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(dynamicPropNames &amp;&amp; dynamicPropNames.length) {</span>
                  <span class="s1">vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s1">node.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">vnodeTag</span><span class="s0">, </span><span class="s1">vnodeProps</span><span class="s0">, </span><span class="s1">vnodeChildren</span><span class="s0">, </span><span class="s1">vnodePatchFlag</span><span class="s0">, </span><span class="s1">vnodeDynamicProps</span><span class="s0">, </span><span class="s1">vnodeDirectives</span><span class="s0">, </span><span class="s1">!!shouldUseBlock</span><span class="s0">, false </span><span class="s5">/* disableTracking */</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">resolveComponentType(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">let </span><span class="s1">{ tag } = node</span><span class="s0">;</span>
      <span class="s5">// 1. dynamic component</span>
      <span class="s0">const </span><span class="s1">isExplicitDynamic = isComponentTag(tag)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isProp = findProp(node</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isProp) {</span>
          <span class="s0">if </span><span class="s1">(isExplicitDynamic ||</span>
              <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context))) {</span>
              <span class="s0">const </span><span class="s1">exp = isProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span>
                  <span class="s1">? isProp.value &amp;&amp; createSimpleExpression(isProp.value.content</span><span class="s0">, true</span><span class="s1">)</span>
                  <span class="s1">: isProp.exp</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(exp) {</span>
                  <span class="s0">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">exp</span>
                  <span class="s1">])</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
              <span class="s1">isProp.value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
              <span class="s5">// &lt;button is=&quot;vue:xxx&quot;&gt;</span>
              <span class="s5">// if not &lt;component&gt;, only is value that starts with &quot;vue:&quot; will be</span>
              <span class="s5">// treated as component by the parse phase and reach here, unless it's</span>
              <span class="s5">// compat mode where all is values are considered components</span>
              <span class="s1">tag = isProp.value.content.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s5">// 1.5 v-is (TODO: Deprecate)</span>
      <span class="s0">const </span><span class="s1">isDir = !isExplicitDynamic &amp;&amp; findDir(node</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(isDir &amp;&amp; isDir.exp) {</span>
          <span class="s0">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s0">, </span><span class="s1">[</span>
              <span class="s1">isDir.exp</span>
          <span class="s1">])</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
      <span class="s0">const </span><span class="s1">builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(builtIn) {</span>
          <span class="s5">// built-ins are simply fallthroughs / have special handling during ssr</span>
          <span class="s5">// so we don't need to import their runtime equivalents</span>
          <span class="s0">if </span><span class="s1">(!ssr)</span>
              <span class="s1">context.helper(builtIn)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">builtIn</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// 5. user component (resolve)</span>
      <span class="s1">context.helper(RESOLVE_COMPONENT)</span><span class="s0">;</span>
      <span class="s1">context.components.add(tag)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">toValidAssetId(tag</span><span class="s0">, </span><span class="s2">`component`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">props = node.props</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">isDynamicComponent</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">loc: elementLoc</span><span class="s0">, </span><span class="s1">children } = node</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">properties = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">mergeArgs = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">runtimeDirectives = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">hasChildren = children.length &gt; </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">shouldUseBlock = </span><span class="s0">false;</span>
      <span class="s5">// patchFlag analysis</span>
      <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">hasRef = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasClassBinding = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasStyleBinding = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasHydrationEventBinding = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasDynamicKeys = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">hasVnodeHook = </span><span class="s0">false;</span>
      <span class="s0">const </span><span class="s1">dynamicPropNames = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">pushMergeArg = (arg) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(properties.length) {</span>
              <span class="s1">mergeArgs.push(createObjectExpression(dedupeProperties(properties)</span><span class="s0">, </span><span class="s1">elementLoc))</span><span class="s0">;</span>
              <span class="s1">properties = []</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(arg)</span>
              <span class="s1">mergeArgs.push(arg)</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">analyzePatchFlag = ({ key</span><span class="s0">, </span><span class="s1">value }) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(isStaticExp(key)) {</span>
              <span class="s0">const </span><span class="s1">name = key.content</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">isEventHandler = isOn(name)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(isEventHandler &amp;&amp;</span>
                  <span class="s1">(!isComponent || isDynamicComponent) &amp;&amp;</span>
                  <span class="s5">// omit the flag for click handlers because hydration gives click</span>
                  <span class="s5">// dedicated fast path.</span>
                  <span class="s1">name.toLowerCase() !== </span><span class="s2">'onclick' </span><span class="s1">&amp;&amp;</span>
                  <span class="s5">// omit v-model handlers</span>
                  <span class="s1">name !== </span><span class="s2">'onUpdate:modelValue' </span><span class="s1">&amp;&amp;</span>
                  <span class="s5">// omit onVnodeXXX hooks</span>
                  <span class="s1">!isReservedProp(name)) {</span>
                  <span class="s1">hasHydrationEventBinding = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(isEventHandler &amp;&amp; isReservedProp(name)) {</span>
                  <span class="s1">hasVnodeHook = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */ </span><span class="s1">||</span>
                  <span class="s1">((value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
                      <span class="s1">value.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) &amp;&amp;</span>
                      <span class="s1">getConstantType(value</span><span class="s0">, </span><span class="s1">context) &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
                  <span class="s5">// skip if the prop is a cached handler or has constant value</span>
                  <span class="s0">return;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'ref'</span><span class="s1">) {</span>
                  <span class="s1">hasRef = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(name === </span><span class="s2">'class'</span><span class="s1">) {</span>
                  <span class="s1">hasClassBinding = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(name === </span><span class="s2">'style'</span><span class="s1">) {</span>
                  <span class="s1">hasStyleBinding = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(name !== </span><span class="s2">'key' </span><span class="s1">&amp;&amp; !dynamicPropNames.includes(name)) {</span>
                  <span class="s1">dynamicPropNames.push(name)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s5">// treat the dynamic class and style binding of the component as dynamic props</span>
              <span class="s0">if </span><span class="s1">(isComponent &amp;&amp;</span>
                  <span class="s1">(name === </span><span class="s2">'class' </span><span class="s1">|| name === </span><span class="s2">'style'</span><span class="s1">) &amp;&amp;</span>
                  <span class="s1">!dynamicPropNames.includes(name)) {</span>
                  <span class="s1">dynamicPropNames.push(name)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">hasDynamicKeys = </span><span class="s0">true;</span>
          <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s5">// static attribute</span>
          <span class="s0">const </span><span class="s1">prop = props[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
              <span class="s0">const </span><span class="s1">{ loc</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value } = prop</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">isStatic = </span><span class="s0">true;</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'ref'</span><span class="s1">) {</span>
                  <span class="s1">hasRef = </span><span class="s0">true;</span>
                  <span class="s0">if </span><span class="s1">(context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                      <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s2">'ref_for'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">'true'</span><span class="s1">)))</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s5">// skip is on &lt;component&gt;, or is=&quot;vue:xxx&quot;</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'is' </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">(isComponentTag(tag) ||</span>
                      <span class="s1">(value &amp;&amp; value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) ||</span>
                      <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context)))) {</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s1">properties.push(createObjectProperty(createSimpleExpression(name</span><span class="s0">, true, </span><span class="s1">getInnerRange(loc</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">name.length))</span><span class="s0">, </span><span class="s1">createSimpleExpression(value ? value.content : </span><span class="s2">''</span><span class="s0">, </span><span class="s1">isStatic</span><span class="s0">, </span><span class="s1">value ? value.loc : loc)))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// directives</span>
              <span class="s0">const </span><span class="s1">{ name</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">loc } = prop</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">isVBind = name === </span><span class="s2">'bind'</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">isVOn = name === </span><span class="s2">'on'</span><span class="s0">;</span>
              <span class="s5">// skip v-slot - it is handled by its dedicated transform.</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'slot'</span><span class="s1">) {</span>
                  <span class="s0">if </span><span class="s1">(!isComponent) {</span>
                      <span class="s1">context.onError(createCompilerError(</span><span class="s4">40 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s5">// skip v-once/v-memo - they are handled by dedicated transforms.</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'once' </span><span class="s1">|| name === </span><span class="s2">'memo'</span><span class="s1">) {</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s5">// skip v-is and :is on &lt;component&gt;</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'is' </span><span class="s1">||</span>
                  <span class="s1">(isVBind &amp;&amp;</span>
                      <span class="s1">isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">) &amp;&amp;</span>
                      <span class="s1">(isComponentTag(tag) ||</span>
                          <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context))))) {</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s5">// skip v-on in SSR compilation</span>
              <span class="s0">if </span><span class="s1">(isVOn &amp;&amp; ssr) {</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(</span>
              <span class="s5">// #938: elements with dynamic keys should be forced into blocks</span>
              <span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'key'</span><span class="s1">)) ||</span>
                  <span class="s5">// inline before-update hooks need to force block so that it is invoked</span>
                  <span class="s5">// before children</span>
                  <span class="s1">(isVOn &amp;&amp; hasChildren &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'vue:before-update'</span><span class="s1">))) {</span>
                  <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'ref'</span><span class="s1">) &amp;&amp; context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                  <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s2">'ref_for'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">'true'</span><span class="s1">)))</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s5">// special case for v-bind and v-on with no argument</span>
              <span class="s0">if </span><span class="s1">(!arg &amp;&amp; (isVBind || isVOn)) {</span>
                  <span class="s1">hasDynamicKeys = </span><span class="s0">true;</span>
                  <span class="s0">if </span><span class="s1">(exp) {</span>
                      <span class="s0">if </span><span class="s1">(isVBind) {</span>
                          <span class="s5">// have to merge early for compat build check</span>
                          <span class="s1">pushMergeArg()</span><span class="s0">;</span>
                          <span class="s1">{</span>
                              <span class="s5">// 2.x v-bind object order compat</span>
                              <span class="s1">{</span>
                                  <span class="s0">const </span><span class="s1">hasOverridableKeys = mergeArgs.some(arg =&gt; {</span>
                                      <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
                                          <span class="s0">return </span><span class="s1">arg.properties.some(({ key }) =&gt; {</span>
                                              <span class="s0">if </span><span class="s1">(key.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
                                                  <span class="s1">!key.isStatic) {</span>
                                                  <span class="s0">return true;</span>
                                              <span class="s1">}</span>
                                              <span class="s0">return </span><span class="s1">(key.content !== </span><span class="s2">'class' </span><span class="s1">&amp;&amp;</span>
                                                  <span class="s1">key.content !== </span><span class="s2">'style' </span><span class="s1">&amp;&amp;</span>
                                                  <span class="s1">!isOn(key.content))</span><span class="s0">;</span>
                                          <span class="s1">})</span><span class="s0">;</span>
                                      <span class="s1">}</span>
                                      <span class="s0">else </span><span class="s1">{</span>
                                          <span class="s5">// dynamic expression</span>
                                          <span class="s0">return true;</span>
                                      <span class="s1">}</span>
                                  <span class="s1">})</span><span class="s0">;</span>
                                  <span class="s0">if </span><span class="s1">(hasOverridableKeys) {</span>
                                      <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
                                  <span class="s1">}</span>
                              <span class="s1">}</span>
                              <span class="s0">if </span><span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s0">, </span><span class="s1">context)) {</span>
                                  <span class="s1">mergeArgs.unshift(exp)</span><span class="s0">;</span>
                                  <span class="s0">continue;</span>
                              <span class="s1">}</span>
                          <span class="s1">}</span>
                          <span class="s1">mergeArgs.push(exp)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else </span><span class="s1">{</span>
                          <span class="s5">// v-on=&quot;obj&quot; -&gt; toHandlers(obj)</span>
                          <span class="s1">pushMergeArg({</span>
                              <span class="s1">type: </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s0">,</span>
                              <span class="s1">loc</span><span class="s0">,</span>
                              <span class="s1">callee: context.helper(TO_HANDLERS)</span><span class="s0">,</span>
                              <span class="s1">arguments: isComponent ? [exp] : [exp</span><span class="s0">, </span><span class="s2">`true`</span><span class="s1">]</span>
                          <span class="s1">})</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">context.onError(createCompilerError(isVBind</span>
                          <span class="s1">? </span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span>
                          <span class="s1">: </span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">continue;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">directiveTransform = context.directiveTransforms[name]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(directiveTransform) {</span>
                  <span class="s5">// has built-in directive transform.</span>
                  <span class="s0">const </span><span class="s1">{ props</span><span class="s0">, </span><span class="s1">needRuntime } = directiveTransform(prop</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">!ssr &amp;&amp; props.forEach(analyzePatchFlag)</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isVOn &amp;&amp; arg &amp;&amp; !isStaticExp(arg)) {</span>
                      <span class="s1">pushMergeArg(createObjectExpression(props</span><span class="s0">, </span><span class="s1">elementLoc))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">properties.push(...props)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(needRuntime) {</span>
                      <span class="s1">runtimeDirectives.push(prop)</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(isSymbol(needRuntime)) {</span>
                          <span class="s1">directiveImportMap.set(prop</span><span class="s0">, </span><span class="s1">needRuntime)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(!isBuiltInDirective(name)) {</span>
                  <span class="s5">// no built-in transform, this is a user custom directive.</span>
                  <span class="s1">runtimeDirectives.push(prop)</span><span class="s0">;</span>
                  <span class="s5">// custom dirs may use beforeUpdate so they need to force blocks</span>
                  <span class="s5">// to ensure before-update gets called before children update</span>
                  <span class="s0">if </span><span class="s1">(hasChildren) {</span>
                      <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">propsExpression = undefined</span><span class="s0">;</span>
      <span class="s5">// has v-bind=&quot;object&quot; or v-on=&quot;object&quot;, wrap with mergeProps</span>
      <span class="s0">if </span><span class="s1">(mergeArgs.length) {</span>
          <span class="s5">// close up any not-yet-merged props</span>
          <span class="s1">pushMergeArg()</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(mergeArgs.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">propsExpression = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">mergeArgs</span><span class="s0">, </span><span class="s1">elementLoc)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// single v-bind with nothing else - no need for a mergeProps call</span>
              <span class="s1">propsExpression = mergeArgs[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(properties.length) {</span>
          <span class="s1">propsExpression = createObjectExpression(dedupeProperties(properties)</span><span class="s0">, </span><span class="s1">elementLoc)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// patchFlag analysis</span>
      <span class="s0">if </span><span class="s1">(hasDynamicKeys) {</span>
          <span class="s1">patchFlag |= </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(hasClassBinding &amp;&amp; !isComponent) {</span>
              <span class="s1">patchFlag |= </span><span class="s4">2 </span><span class="s5">/* PatchFlags.CLASS */</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(hasStyleBinding &amp;&amp; !isComponent) {</span>
              <span class="s1">patchFlag |= </span><span class="s4">4 </span><span class="s5">/* PatchFlags.STYLE */</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(dynamicPropNames.length) {</span>
              <span class="s1">patchFlag |= </span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(hasHydrationEventBinding) {</span>
              <span class="s1">patchFlag |= </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!shouldUseBlock &amp;&amp;</span>
          <span class="s1">(patchFlag === </span><span class="s4">0 </span><span class="s1">|| patchFlag === </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">) &amp;&amp;</span>
          <span class="s1">(hasRef || hasVnodeHook || runtimeDirectives.length &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
          <span class="s1">patchFlag |= </span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// pre-normalize props, SSR is skipped for now</span>
      <span class="s0">if </span><span class="s1">(!context.inSSR &amp;&amp; propsExpression) {</span>
          <span class="s0">switch </span><span class="s1">(propsExpression.type) {</span>
              <span class="s0">case </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
                  <span class="s5">// means that there is no v-bind,</span>
                  <span class="s5">// but still need to deal with dynamic key binding</span>
                  <span class="s0">let </span><span class="s1">classKeyIndex = -</span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s0">let </span><span class="s1">styleKeyIndex = -</span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s0">let </span><span class="s1">hasDynamicKey = </span><span class="s0">false;</span>
                  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; propsExpression.properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                      <span class="s0">const </span><span class="s1">key = propsExpression.properties[i].key</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(isStaticExp(key)) {</span>
                          <span class="s0">if </span><span class="s1">(key.content === </span><span class="s2">'class'</span><span class="s1">) {</span>
                              <span class="s1">classKeyIndex = i</span><span class="s0">;</span>
                          <span class="s1">}</span>
                          <span class="s0">else if </span><span class="s1">(key.content === </span><span class="s2">'style'</span><span class="s1">) {</span>
                              <span class="s1">styleKeyIndex = i</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                      <span class="s0">else if </span><span class="s1">(!key.isHandlerKey) {</span>
                          <span class="s1">hasDynamicKey = </span><span class="s0">true;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">const </span><span class="s1">classProp = propsExpression.properties[classKeyIndex]</span><span class="s0">;</span>
                  <span class="s0">const </span><span class="s1">styleProp = propsExpression.properties[styleKeyIndex]</span><span class="s0">;</span>
                  <span class="s5">// no dynamic key</span>
                  <span class="s0">if </span><span class="s1">(!hasDynamicKey) {</span>
                      <span class="s0">if </span><span class="s1">(classProp &amp;&amp; !isStaticExp(classProp.value)) {</span>
                          <span class="s1">classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS)</span><span class="s0">, </span><span class="s1">[classProp.value])</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">if </span><span class="s1">(styleProp &amp;&amp;</span>
                          <span class="s5">// the static style is compiled into an object,</span>
                          <span class="s5">// so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
                          <span class="s1">(hasStyleBinding ||</span>
                              <span class="s1">(styleProp.value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                                  <span class="s1">styleProp.value.content.trim()[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">`[`</span><span class="s1">) ||</span>
                              <span class="s5">// v-bind:style and style both exist,</span>
                              <span class="s5">// v-bind:style with static literal object</span>
                              <span class="s1">styleProp.value.type === </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">)) {</span>
                          <span class="s1">styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE)</span><span class="s0">, </span><span class="s1">[styleProp.value])</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s5">// dynamic key binding, wrap with `normalizeProps`</span>
                      <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s0">, </span><span class="s1">[propsExpression])</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">break;</span>
              <span class="s0">case </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
                  <span class="s5">// mergeProps call, do nothing</span>
                  <span class="s0">break;</span>
              <span class="s0">default</span><span class="s1">:</span>
                  <span class="s5">// single v-bind</span>
                  <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">createCallExpression(context.helper(GUARD_REACTIVE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                          <span class="s1">propsExpression</span>
                      <span class="s1">])</span>
                  <span class="s1">])</span><span class="s0">;</span>
                  <span class="s0">break;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">props: propsExpression</span><span class="s0">,</span>
          <span class="s1">directives: runtimeDirectives</span><span class="s0">,</span>
          <span class="s1">patchFlag</span><span class="s0">,</span>
          <span class="s1">dynamicPropNames</span><span class="s0">,</span>
          <span class="s1">shouldUseBlock</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s5">// Dedupe props in an object literal.</span>
  <span class="s5">// Literal duplicated attributes would have been warned during the parse phase,</span>
  <span class="s5">// however, it's possible to encounter duplicated `onXXX` handlers with different</span>
  <span class="s5">// modifiers. We also need to merge static and dynamic class / style attributes.</span>
  <span class="s5">// - onXXX handlers / style: merge into array</span>
  <span class="s5">// - class: merge into single expression with concatenation</span>
  <span class="s0">function </span><span class="s1">dedupeProperties(properties) {</span>
      <span class="s0">const </span><span class="s1">knownProps = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">deduped = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">prop = properties[i]</span><span class="s0">;</span>
          <span class="s5">// dynamic keys are always allowed</span>
          <span class="s0">if </span><span class="s1">(prop.key.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */ </span><span class="s1">|| !prop.key.isStatic) {</span>
              <span class="s1">deduped.push(prop)</span><span class="s0">;</span>
              <span class="s0">continue;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">name = prop.key.content</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">existing = knownProps.get(name)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(existing) {</span>
              <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'style' </span><span class="s1">|| name === </span><span class="s2">'class' </span><span class="s1">|| isOn(name)) {</span>
                  <span class="s1">mergeAsArray(existing</span><span class="s0">, </span><span class="s1">prop)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s5">// unexpected duplicate, should have emitted error during parse</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">knownProps.set(name</span><span class="s0">, </span><span class="s1">prop)</span><span class="s0">;</span>
              <span class="s1">deduped.push(prop)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">deduped</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">mergeAsArray(existing</span><span class="s0">, </span><span class="s1">incoming) {</span>
      <span class="s0">if </span><span class="s1">(existing.value.type === </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s1">existing.value.elements.push(incoming.value)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">existing.value = createArrayExpression([existing.value</span><span class="s0">, </span><span class="s1">incoming.value]</span><span class="s0">, </span><span class="s1">existing.loc)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">buildDirectiveArgs(dir</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">dirArgs = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">runtime = directiveImportMap.get(dir)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(runtime) {</span>
          <span class="s5">// built-in directive with runtime</span>
          <span class="s1">dirArgs.push(context.helperString(runtime))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">{</span>
              <span class="s5">// inject statement for resolving directive</span>
              <span class="s1">context.helper(RESOLVE_DIRECTIVE)</span><span class="s0">;</span>
              <span class="s1">context.directives.add(dir.name)</span><span class="s0">;</span>
              <span class="s1">dirArgs.push(toValidAssetId(dir.name</span><span class="s0">, </span><span class="s2">`directive`</span><span class="s1">))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">{ loc } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(dir.exp)</span>
          <span class="s1">dirArgs.push(dir.exp)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(dir.arg) {</span>
          <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
              <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">dirArgs.push(dir.arg)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(Object.keys(dir.modifiers).length) {</span>
          <span class="s0">if </span><span class="s1">(!dir.arg) {</span>
              <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
                  <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">const </span><span class="s1">trueExpression = createSimpleExpression(</span><span class="s2">`true`</span><span class="s0">, false, </span><span class="s1">loc)</span><span class="s0">;</span>
          <span class="s1">dirArgs.push(createObjectExpression(dir.modifiers.map(modifier =&gt; createObjectProperty(modifier</span><span class="s0">, </span><span class="s1">trueExpression))</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">createArrayExpression(dirArgs</span><span class="s0">, </span><span class="s1">dir.loc)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">stringifyDynamicPropNames(props) {</span>
      <span class="s0">let </span><span class="s1">propsNamesString = </span><span class="s2">`[`</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">, </span><span class="s1">l = props.length</span><span class="s0">; </span><span class="s1">i &lt; l</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s1">propsNamesString += JSON.stringify(props[i])</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(i &lt; l - </span><span class="s4">1</span><span class="s1">)</span>
              <span class="s1">propsNamesString += </span><span class="s2">', '</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">propsNamesString + </span><span class="s2">`]`</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">isComponentTag(tag) {</span>
      <span class="s0">return </span><span class="s1">tag === </span><span class="s2">'component' </span><span class="s1">|| tag === </span><span class="s2">'Component'</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">transformSlotOutlet = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(isSlotOutlet(node)) {</span>
          <span class="s0">const </span><span class="s1">{ children</span><span class="s0">, </span><span class="s1">loc } = node</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">{ slotName</span><span class="s0">, </span><span class="s1">slotProps } = processSlotOutlet(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">slotArgs = [</span>
              <span class="s1">context.prefixIdentifiers ? </span><span class="s2">`_ctx.$slots` </span><span class="s1">: </span><span class="s2">`$slots`</span><span class="s0">,</span>
              <span class="s1">slotName</span><span class="s0">,</span>
              <span class="s2">'{}'</span><span class="s0">,</span>
              <span class="s2">'undefined'</span><span class="s0">,</span>
              <span class="s2">'true'</span>
          <span class="s1">]</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">expectedLen = </span><span class="s4">2</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(slotProps) {</span>
              <span class="s1">slotArgs[</span><span class="s4">2</span><span class="s1">] = slotProps</span><span class="s0">;</span>
              <span class="s1">expectedLen = </span><span class="s4">3</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(children.length) {</span>
              <span class="s1">slotArgs[</span><span class="s4">3</span><span class="s1">] = createFunctionExpression([]</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, false, false, </span><span class="s1">loc)</span><span class="s0">;</span>
              <span class="s1">expectedLen = </span><span class="s4">4</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(context.scopeId &amp;&amp; !context.slotted) {</span>
              <span class="s1">expectedLen = </span><span class="s4">5</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">slotArgs.splice(expectedLen)</span><span class="s0">; </span><span class="s5">// remove unused arguments</span>
          <span class="s1">node.codegenNode = createCallExpression(context.helper(RENDER_SLOT)</span><span class="s0">, </span><span class="s1">slotArgs</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">processSlotOutlet(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">let </span><span class="s1">slotName = </span><span class="s2">`&quot;default&quot;`</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">slotProps = undefined</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">nonNameProps = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(p.value) {</span>
                  <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'name'</span><span class="s1">) {</span>
                      <span class="s1">slotName = JSON.stringify(p.value.content)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">p.name = camelize(p.name)</span><span class="s0">;</span>
                      <span class="s1">nonNameProps.push(p)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s2">'name'</span><span class="s1">)) {</span>
                  <span class="s0">if </span><span class="s1">(p.exp)</span>
                      <span class="s1">slotName = p.exp</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; p.arg &amp;&amp; isStaticExp(p.arg)) {</span>
                      <span class="s1">p.arg.content = camelize(p.arg.content)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s1">nonNameProps.push(p)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(nonNameProps.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">{ props</span><span class="s0">, </span><span class="s1">directives } = buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">nonNameProps</span><span class="s0">, false, false</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">slotProps = props</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(directives.length) {</span>
              <span class="s1">context.onError(createCompilerError(</span><span class="s4">36 </span><span class="s5">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s0">, </span><span class="s1">directives[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">slotName</span><span class="s0">,</span>
          <span class="s1">slotProps</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">fnExpRE = </span><span class="s4">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformOn$1 = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">augmentor) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ loc</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">arg } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!dir.exp &amp;&amp; !modifiers.length) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">eventName</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
              <span class="s0">let </span><span class="s1">rawName = arg.content</span><span class="s0">;</span>
              <span class="s5">// TODO deprecate @vnodeXXX usage</span>
              <span class="s0">if </span><span class="s1">(rawName.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
                  <span class="s1">rawName = </span><span class="s2">`vnode-</span><span class="s1">${rawName.slice(</span><span class="s4">4</span><span class="s1">)}</span><span class="s2">`</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">const </span><span class="s1">eventString = node.tagType !== </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                  <span class="s1">rawName.startsWith(</span><span class="s2">'vnode'</span><span class="s1">) ||</span>
                  <span class="s1">!</span><span class="s4">/[A-Z]/</span><span class="s1">.test(rawName)</span>
                  <span class="s1">? </span><span class="s5">// for non-element and vnode lifecycle event listeners, auto convert</span>
                      <span class="s5">// it to camelCase. See issue #2249</span>
                      <span class="s1">toHandlerKey(camelize(rawName))</span>
                  <span class="s1">: </span><span class="s5">// preserve case for plain element listeners that have uppercase</span>
                      <span class="s5">// letters, as these may be custom elements' custom events</span>
                      <span class="s2">`on:</span><span class="s1">${rawName}</span><span class="s2">`</span><span class="s0">;</span>
              <span class="s1">eventName = createSimpleExpression(eventString</span><span class="s0">, true, </span><span class="s1">arg.loc)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// #2388</span>
              <span class="s1">eventName = createCompoundExpression([</span>
                  <span class="s2">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s2">(`</span><span class="s0">,</span>
                  <span class="s1">arg</span><span class="s0">,</span>
                  <span class="s2">`)`</span>
              <span class="s1">])</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s5">// already a compound expression.</span>
          <span class="s1">eventName = arg</span><span class="s0">;</span>
          <span class="s1">eventName.children.unshift(</span><span class="s2">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">eventName.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// handler processing</span>
      <span class="s0">let </span><span class="s1">exp = dir.exp</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(exp &amp;&amp; !exp.content.trim()) {</span>
          <span class="s1">exp = undefined</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">shouldCache = context.cacheHandlers &amp;&amp; !exp &amp;&amp; !context.inVOnce</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(exp) {</span>
          <span class="s0">const </span><span class="s1">isMemberExp = isMemberExpression(exp.content)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">hasMultipleStatements = exp.content.includes(</span><span class="s2">`;`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">{</span>
              <span class="s1">validateBrowserExpression(exp</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, false, </span><span class="s1">hasMultipleStatements)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(isInlineStatement || (shouldCache &amp;&amp; isMemberExp)) {</span>
              <span class="s5">// wrap inline statement in a function expression</span>
              <span class="s1">exp = createCompoundExpression([</span>
                  <span class="s2">`</span><span class="s1">${isInlineStatement</span>
                    <span class="s1">? </span><span class="s2">`$event`</span>
                    <span class="s1">: </span><span class="s2">`</span><span class="s1">${</span><span class="s2">``</span><span class="s1">}</span><span class="s2">(...args)`</span><span class="s1">} </span><span class="s2">=&gt; </span><span class="s1">${hasMultipleStatements ? </span><span class="s2">`{` </span><span class="s1">: </span><span class="s2">`(`</span><span class="s1">}</span><span class="s2">`</span><span class="s0">,</span>
                  <span class="s1">exp</span><span class="s0">,</span>
                  <span class="s1">hasMultipleStatements ? </span><span class="s2">`}` </span><span class="s1">: </span><span class="s2">`)`</span>
              <span class="s1">])</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">let </span><span class="s1">ret = {</span>
          <span class="s1">props: [</span>
              <span class="s1">createObjectProperty(eventName</span><span class="s0">, </span><span class="s1">exp || createSimpleExpression(</span><span class="s2">`() =&gt; {}`</span><span class="s0">, false, </span><span class="s1">loc))</span>
          <span class="s1">]</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s5">// apply extended compiler augmentor</span>
      <span class="s0">if </span><span class="s1">(augmentor) {</span>
          <span class="s1">ret = augmentor(ret)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(shouldCache) {</span>
          <span class="s5">// cache handlers so that it's always the same handler being passed down.</span>
          <span class="s5">// this avoids unnecessary re-renders when users use inline handlers on</span>
          <span class="s5">// components.</span>
          <span class="s1">ret.props[</span><span class="s4">0</span><span class="s1">].value = context.cache(ret.props[</span><span class="s4">0</span><span class="s1">].value)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// mark the key as handler for props normalization check</span>
      <span class="s1">ret.props.forEach(p =&gt; (p.key.isHandlerKey = </span><span class="s0">true</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s5">// v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
  <span class="s5">// codegen for the entire props object. This transform here is only for v-bind</span>
  <span class="s5">// *with* args.</span>
  <span class="s0">const </span><span class="s1">transformBind = (dir</span><span class="s0">, </span><span class="s1">_node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">loc } = dir</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">arg = dir.arg</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(arg.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s1">arg.children.unshift(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">arg.children.push(</span><span class="s2">`) || &quot;&quot;`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(!arg.isStatic) {</span>
          <span class="s1">arg.content = </span><span class="s2">`</span><span class="s1">${arg.content} </span><span class="s2">|| &quot;&quot;`</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// .sync is replaced by v-model:arg</span>
      <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'camel'</span><span class="s1">)) {</span>
          <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
                  <span class="s1">arg.content = camelize(arg.content)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">arg.content = </span><span class="s2">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s2">(</span><span class="s1">${arg.content}</span><span class="s2">)`</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">arg.children.unshift(</span><span class="s2">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">arg.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!context.inSSR) {</span>
          <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'prop'</span><span class="s1">)) {</span>
              <span class="s1">injectPrefix(arg</span><span class="s0">, </span><span class="s2">'.'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'attr'</span><span class="s1">)) {</span>
              <span class="s1">injectPrefix(arg</span><span class="s0">, </span><span class="s2">'^'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!exp ||</span>
          <span class="s1">(exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !exp.content.trim())) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">{</span>
              <span class="s1">props: [createObjectProperty(arg</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">''</span><span class="s0">, true, </span><span class="s1">loc))]</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">props: [createObjectProperty(arg</span><span class="s0">, </span><span class="s1">exp)]</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">injectPrefix = (arg</span><span class="s0">, </span><span class="s1">prefix) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
              <span class="s1">arg.content = prefix + arg.content</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s1">arg.content = </span><span class="s2">`</span><span class="s0">\`</span><span class="s1">${prefix}</span><span class="s0">\$</span><span class="s2">{</span><span class="s1">${arg.content}</span><span class="s2">}</span><span class="s0">\`</span><span class="s2">`</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">arg.children.unshift(</span><span class="s2">`'</span><span class="s1">${prefix}</span><span class="s2">' + (`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">arg.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s5">// Merge adjacent text nodes and expressions into a single expression</span>
  <span class="s5">// e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
  <span class="s0">const </span><span class="s1">transformText = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
          <span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">||</span>
          <span class="s1">node.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */ </span><span class="s1">||</span>
          <span class="s1">node.type === </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">) {</span>
          <span class="s5">// perform the transform on node exit so that all expressions have already</span>
          <span class="s5">// been processed.</span>
          <span class="s0">return </span><span class="s1">() =&gt; {</span>
              <span class="s0">const </span><span class="s1">children = node.children</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">currentContainer = undefined</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">hasText = </span><span class="s0">false;</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isText$1(child)) {</span>
                      <span class="s1">hasText = </span><span class="s0">true;</span>
                      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s0">; </span><span class="s1">j &lt; children.length</span><span class="s0">; </span><span class="s1">j++) {</span>
                          <span class="s0">const </span><span class="s1">next = children[j]</span><span class="s0">;</span>
                          <span class="s0">if </span><span class="s1">(isText$1(next)) {</span>
                              <span class="s0">if </span><span class="s1">(!currentContainer) {</span>
                                  <span class="s1">currentContainer = children[i] = createCompoundExpression([child]</span><span class="s0">, </span><span class="s1">child.loc)</span><span class="s0">;</span>
                              <span class="s1">}</span>
                              <span class="s5">// merge adjacent text node into current</span>
                              <span class="s1">currentContainer.children.push(</span><span class="s2">` + `</span><span class="s0">, </span><span class="s1">next)</span><span class="s0">;</span>
                              <span class="s1">children.splice(j</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                              <span class="s1">j--</span><span class="s0">;</span>
                          <span class="s1">}</span>
                          <span class="s0">else </span><span class="s1">{</span>
                              <span class="s1">currentContainer = undefined</span><span class="s0">;</span>
                              <span class="s0">break;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(!hasText ||</span>
                  <span class="s5">// if this is a plain element with a single text child, leave it</span>
                  <span class="s5">// as-is since the runtime has dedicated fast path for this by directly</span>
                  <span class="s5">// setting textContent of the element.</span>
                  <span class="s5">// for component root it's always normalized anyway.</span>
                  <span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">(node.type === </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
                          <span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                              <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                              <span class="s5">// #3756</span>
                              <span class="s5">// custom directives can potentially add DOM elements arbitrarily,</span>
                              <span class="s5">// we need to avoid setting textContent of the element at runtime</span>
                              <span class="s5">// to avoid accidentally overwriting the DOM elements added</span>
                              <span class="s5">// by the user through custom directives.</span>
                              <span class="s1">!node.props.find(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                                  <span class="s1">!context.directiveTransforms[p.name]) &amp;&amp;</span>
                              <span class="s5">// in compat mode, &lt;template&gt; tags with no special directives</span>
                              <span class="s5">// will be rendered as a fragment so its children must be</span>
                              <span class="s5">// converted into vnodes.</span>
                              <span class="s1">!(node.tag === </span><span class="s2">'template'</span><span class="s1">))))) {</span>
                  <span class="s0">return;</span>
              <span class="s1">}</span>
              <span class="s5">// pre-convert text nodes into createTextVNode(text) calls to avoid</span>
              <span class="s5">// runtime normalization.</span>
              <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                  <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(isText$1(child) || child.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
                      <span class="s0">const </span><span class="s1">callArgs = []</span><span class="s0">;</span>
                      <span class="s5">// createTextVNode defaults to single whitespace, so if it is a</span>
                      <span class="s5">// single space the code could be an empty call to save bytes.</span>
                      <span class="s0">if </span><span class="s1">(child.type !== </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">|| child.content !== </span><span class="s2">' '</span><span class="s1">) {</span>
                          <span class="s1">callArgs.push(child)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s5">// mark dynamic text with flag so it gets patched inside a block</span>
                      <span class="s0">if </span><span class="s1">(!context.ssr &amp;&amp;</span>
                          <span class="s1">getConstantType(child</span><span class="s0">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                          <span class="s1">callArgs.push(</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */ </span><span class="s1">+</span>
                              <span class="s1">(</span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">]} </span><span class="s2">*/` </span><span class="s1">))</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s1">children[i] = {</span>
                          <span class="s1">type: </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s0">,</span>
                          <span class="s1">content: child</span><span class="s0">,</span>
                          <span class="s1">loc: child.loc</span><span class="s0">,</span>
                          <span class="s1">codegenNode: createCallExpression(context.helper(CREATE_TEXT)</span><span class="s0">, </span><span class="s1">callArgs)</span>
                      <span class="s1">}</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">seen$1 = </span><span class="s0">new </span><span class="s1">WeakSet()</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformOnce = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; findDir(node</span><span class="s0">, </span><span class="s2">'once'</span><span class="s0">, true</span><span class="s1">)) {</span>
          <span class="s0">if </span><span class="s1">(seen$1.has(node) || context.inVOnce) {</span>
              <span class="s0">return;</span>
          <span class="s1">}</span>
          <span class="s1">seen$1.add(node)</span><span class="s0">;</span>
          <span class="s1">context.inVOnce = </span><span class="s0">true;</span>
          <span class="s1">context.helper(SET_BLOCK_TRACKING)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">() =&gt; {</span>
              <span class="s1">context.inVOnce = </span><span class="s0">false;</span>
              <span class="s0">const </span><span class="s1">cur = context.currentNode</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(cur.codegenNode) {</span>
                  <span class="s1">cur.codegenNode = context.cache(cur.codegenNode</span><span class="s0">, true </span><span class="s5">/* isVNode */</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformModel$1 = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">arg } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!exp) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">41 </span><span class="s5">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">rawExp = exp.loc.source</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">expString = exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">? exp.content : rawExp</span><span class="s0">;</span>
      <span class="s5">// im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
      <span class="s5">// _unref(exp)</span>
      <span class="s0">const </span><span class="s1">bindingType = context.bindingMetadata[rawExp]</span><span class="s0">;</span>
      <span class="s5">// check props</span>
      <span class="s0">if </span><span class="s1">(bindingType === </span><span class="s2">&quot;props&quot; </span><span class="s5">/* BindingTypes.PROPS */ </span><span class="s1">||</span>
          <span class="s1">bindingType === </span><span class="s2">&quot;props-aliased&quot; </span><span class="s5">/* BindingTypes.PROPS_ALIASED */</span><span class="s1">) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">44 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s0">, </span><span class="s1">exp.loc))</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">maybeRef = !</span><span class="s0">true  ;</span>
      <span class="s0">if </span><span class="s1">(!expString.trim() ||</span>
          <span class="s1">(!isMemberExpression(expString) &amp;&amp; !maybeRef)) {</span>
          <span class="s1">context.onError(createCompilerError(</span><span class="s4">42 </span><span class="s5">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">exp.loc))</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">propName = arg ? arg : createSimpleExpression(</span><span class="s2">'modelValue'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">eventName = arg</span>
          <span class="s1">? isStaticExp(arg)</span>
              <span class="s1">? </span><span class="s2">`onUpdate:</span><span class="s1">${camelize(arg.content)}</span><span class="s2">`</span>
              <span class="s1">: createCompoundExpression([</span><span class="s2">'&quot;onUpdate:&quot; + '</span><span class="s0">, </span><span class="s1">arg])</span>
          <span class="s1">: </span><span class="s2">`onUpdate:modelValue`</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">assignmentExp</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">eventArg = context.isTS ? </span><span class="s2">`($event: any)` </span><span class="s1">: </span><span class="s2">`$event`</span><span class="s0">;</span>
      <span class="s1">{</span>
          <span class="s1">assignmentExp = createCompoundExpression([</span>
              <span class="s2">`</span><span class="s1">${eventArg} </span><span class="s2">=&gt; ((`</span><span class="s0">,</span>
              <span class="s1">exp</span><span class="s0">,</span>
              <span class="s2">`) = $event)`</span>
          <span class="s1">])</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">props = [</span>
          <span class="s5">// modelValue: foo</span>
          <span class="s1">createObjectProperty(propName</span><span class="s0">, </span><span class="s1">dir.exp)</span><span class="s0">,</span>
          <span class="s5">// &quot;onUpdate:modelValue&quot;: $event =&gt; (foo = $event)</span>
          <span class="s1">createObjectProperty(eventName</span><span class="s0">, </span><span class="s1">assignmentExp)</span>
      <span class="s1">]</span><span class="s0">;</span>
      <span class="s5">// modelModifiers: { foo: true, &quot;bar-baz&quot;: true }</span>
      <span class="s0">if </span><span class="s1">(dir.modifiers.length &amp;&amp; node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">modifiers = dir.modifiers</span>
              <span class="s1">.map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + </span><span class="s2">`: true`</span><span class="s1">)</span>
              <span class="s1">.join(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">modifiersKey = arg</span>
              <span class="s1">? isStaticExp(arg)</span>
                  <span class="s1">? </span><span class="s2">`</span><span class="s1">${arg.content}</span><span class="s2">Modifiers`</span>
                  <span class="s1">: createCompoundExpression([arg</span><span class="s0">, </span><span class="s2">' + &quot;Modifiers&quot;'</span><span class="s1">])</span>
              <span class="s1">: </span><span class="s2">`modelModifiers`</span><span class="s0">;</span>
          <span class="s1">props.push(createObjectProperty(modifiersKey</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`{ </span><span class="s1">${modifiers} </span><span class="s2">}`</span><span class="s0">, false, </span><span class="s1">dir.loc</span><span class="s0">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">createTransformProps(props)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">createTransformProps(props = []) {</span>
      <span class="s0">return </span><span class="s1">{ props }</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">validDivisionCharRE = </span><span class="s4">/[\w).+\-_$\]]/</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformFilter = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(!isCompatEnabled(</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s0">, </span><span class="s1">context)) {</span>
          <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
          <span class="s5">// filter rewrite is applied before expression transform so only</span>
          <span class="s5">// simple expressions are possible at this stage</span>
          <span class="s1">rewriteFilter(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
          <span class="s1">node.props.forEach((prop) =&gt; {</span>
              <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">prop.name !== </span><span class="s2">'for' </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">prop.exp) {</span>
                  <span class="s1">rewriteFilter(prop.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">rewriteFilter(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
          <span class="s1">parseFilter(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">child !== </span><span class="s2">'object'</span><span class="s1">)</span>
                  <span class="s0">continue;</span>
              <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
                  <span class="s1">parseFilter(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
                  <span class="s1">rewriteFilter(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
                  <span class="s1">rewriteFilter(child.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parseFilter(node</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s0">const </span><span class="s1">exp = node.content</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">inSingle = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">inDouble = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">inTemplateString = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">inRegex = </span><span class="s0">false;</span>
      <span class="s0">let </span><span class="s1">curly = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">square = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">paren = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">lastFilterIndex = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s0">let </span><span class="s1">c</span><span class="s0">, </span><span class="s1">prev</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">expression</span><span class="s0">, </span><span class="s1">filters = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; exp.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s1">prev = c</span><span class="s0">;</span>
          <span class="s1">c = exp.charCodeAt(i)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(inSingle) {</span>
              <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x27 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                  <span class="s1">inSingle = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(inDouble) {</span>
              <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x22 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                  <span class="s1">inDouble = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(inTemplateString) {</span>
              <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x60 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                  <span class="s1">inTemplateString = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(inRegex) {</span>
              <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x2f </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                  <span class="s1">inRegex = </span><span class="s0">false;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(c === </span><span class="s4">0x7c </span><span class="s1">&amp;&amp; </span><span class="s5">// pipe</span>
              <span class="s1">exp.charCodeAt(i + </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0x7c </span><span class="s1">&amp;&amp;</span>
              <span class="s1">exp.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0x7c </span><span class="s1">&amp;&amp;</span>
              <span class="s1">!curly &amp;&amp;</span>
              <span class="s1">!square &amp;&amp;</span>
              <span class="s1">!paren) {</span>
              <span class="s0">if </span><span class="s1">(expression === undefined) {</span>
                  <span class="s5">// first filter, end of expression</span>
                  <span class="s1">lastFilterIndex = i + </span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s1">expression = exp.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i).trim()</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s1">pushFilter()</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s0">switch </span><span class="s1">(c) {</span>
                  <span class="s0">case </span><span class="s4">0x22</span><span class="s1">:</span>
                      <span class="s1">inDouble = </span><span class="s0">true;</span>
                      <span class="s0">break; </span><span class="s5">// &quot;</span>
                  <span class="s0">case </span><span class="s4">0x27</span><span class="s1">:</span>
                      <span class="s1">inSingle = </span><span class="s0">true;</span>
                      <span class="s0">break; </span><span class="s5">// '</span>
                  <span class="s0">case </span><span class="s4">0x60</span><span class="s1">:</span>
                      <span class="s1">inTemplateString = </span><span class="s0">true;</span>
                      <span class="s0">break; </span><span class="s5">// `</span>
                  <span class="s0">case </span><span class="s4">0x28</span><span class="s1">:</span>
                      <span class="s1">paren++</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// (</span>
                  <span class="s0">case </span><span class="s4">0x29</span><span class="s1">:</span>
                      <span class="s1">paren--</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// )</span>
                  <span class="s0">case </span><span class="s4">0x5b</span><span class="s1">:</span>
                      <span class="s1">square++</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// [</span>
                  <span class="s0">case </span><span class="s4">0x5d</span><span class="s1">:</span>
                      <span class="s1">square--</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// ]</span>
                  <span class="s0">case </span><span class="s4">0x7b</span><span class="s1">:</span>
                      <span class="s1">curly++</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// {</span>
                  <span class="s0">case </span><span class="s4">0x7d</span><span class="s1">:</span>
                      <span class="s1">curly--</span><span class="s0">;</span>
                      <span class="s0">break; </span><span class="s5">// }</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x2f</span><span class="s1">) {</span>
                  <span class="s5">// /</span>
                  <span class="s0">let </span><span class="s1">j = i - </span><span class="s4">1</span><span class="s0">;</span>
                  <span class="s0">let </span><span class="s1">p</span><span class="s0">;</span>
                  <span class="s5">// find first non-whitespace prev char</span>
                  <span class="s0">for </span><span class="s1">(</span><span class="s0">; </span><span class="s1">j &gt;= </span><span class="s4">0</span><span class="s0">; </span><span class="s1">j--) {</span>
                      <span class="s1">p = exp.charAt(j)</span><span class="s0">;</span>
                      <span class="s0">if </span><span class="s1">(p !== </span><span class="s2">' '</span><span class="s1">)</span>
                          <span class="s0">break;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(!p || !validDivisionCharRE.test(p)) {</span>
                      <span class="s1">inRegex = </span><span class="s0">true;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(expression === undefined) {</span>
          <span class="s1">expression = exp.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i).trim()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else if </span><span class="s1">(lastFilterIndex !== </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">pushFilter()</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">function </span><span class="s1">pushFilter() {</span>
          <span class="s1">filters.push(exp.slice(lastFilterIndex</span><span class="s0">, </span><span class="s1">i).trim())</span><span class="s0">;</span>
          <span class="s1">lastFilterIndex = i + </span><span class="s4">1</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(filters.length) {</span>
          <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
          <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; filters.length</span><span class="s0">; </span><span class="s1">i++) {</span>
              <span class="s1">expression = wrapFilter(expression</span><span class="s0">, </span><span class="s1">filters[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s1">node.content = expression</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">wrapFilter(exp</span><span class="s0">, </span><span class="s1">filter</span><span class="s0">, </span><span class="s1">context) {</span>
      <span class="s1">context.helper(RESOLVE_FILTER)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">i = filter.indexOf(</span><span class="s2">'('</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(i &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">context.filters.add(filter)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s2">`</span><span class="s1">${toValidAssetId(filter</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s1">)}</span><span class="s2">(</span><span class="s1">${exp}</span><span class="s2">)`</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s0">const </span><span class="s1">name = filter.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">args = filter.slice(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">context.filters.add(name)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s2">`</span><span class="s1">${toValidAssetId(name</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s1">)}</span><span class="s2">(</span><span class="s1">${exp}${args !== </span><span class="s2">')' </span><span class="s1">? </span><span class="s2">',' </span><span class="s1">+ args : args}</span><span class="s2">`</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">seen = </span><span class="s0">new </span><span class="s1">WeakSet()</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformMemo = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">dir = findDir(node</span><span class="s0">, </span><span class="s2">'memo'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!dir || seen.has(node)) {</span>
              <span class="s0">return;</span>
          <span class="s1">}</span>
          <span class="s1">seen.add(node)</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">() =&gt; {</span>
              <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode ||</span>
                  <span class="s1">context.currentNode.codegenNode</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(codegenNode &amp;&amp; codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                  <span class="s5">// non-component sub tree should be turned into a block</span>
                  <span class="s0">if </span><span class="s1">(node.tagType !== </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
                      <span class="s1">makeBlock(codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s1">node.codegenNode = createCallExpression(context.helper(WITH_MEMO)</span><span class="s0">, </span><span class="s1">[</span>
                      <span class="s1">dir.exp</span><span class="s0">,</span>
                      <span class="s1">createFunctionExpression(undefined</span><span class="s0">, </span><span class="s1">codegenNode)</span><span class="s0">,</span>
                      <span class="s2">`_cache`</span><span class="s0">,</span>
                      <span class="s1">String(context.cached++)</span>
                  <span class="s1">])</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">function </span><span class="s1">getBaseTransformPreset(prefixIdentifiers) {</span>
      <span class="s0">return </span><span class="s1">[</span>
          <span class="s1">[</span>
              <span class="s1">transformOnce</span><span class="s0">,</span>
              <span class="s1">transformIf</span><span class="s0">,</span>
              <span class="s1">transformMemo</span><span class="s0">,</span>
              <span class="s1">transformFor</span><span class="s0">,</span>
              <span class="s1">...([transformFilter] )</span><span class="s0">,</span>
              <span class="s1">...([transformExpression]</span>
                      <span class="s1">)</span><span class="s0">,</span>
              <span class="s1">transformSlotOutlet</span><span class="s0">,</span>
              <span class="s1">transformElement</span><span class="s0">,</span>
              <span class="s1">trackSlotScopes</span><span class="s0">,</span>
              <span class="s1">transformText</span>
          <span class="s1">]</span><span class="s0">,</span>
          <span class="s1">{</span>
              <span class="s1">on: transformOn$1</span><span class="s0">,</span>
              <span class="s1">bind: transformBind</span><span class="s0">,</span>
              <span class="s1">model: transformModel$1</span>
          <span class="s1">}</span>
      <span class="s1">]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s5">// we name it `baseCompile` so that higher order compilers like</span>
  <span class="s5">// @vue/compiler-dom can export `compile` while re-exporting everything else.</span>
  <span class="s0">function </span><span class="s1">baseCompile(template</span><span class="s0">, </span><span class="s1">options = {}) {</span>
      <span class="s0">const </span><span class="s1">onError = options.onError || defaultOnError</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isModuleMode = options.mode === </span><span class="s2">'module'</span><span class="s0">;</span>
      <span class="s5">/* istanbul ignore if */</span>
      <span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(options.prefixIdentifiers === </span><span class="s0">true</span><span class="s1">) {</span>
              <span class="s1">onError(createCompilerError(</span><span class="s4">47 </span><span class="s5">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isModuleMode) {</span>
              <span class="s1">onError(createCompilerError(</span><span class="s4">48 </span><span class="s5">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">prefixIdentifiers = !</span><span class="s0">true ;</span>
      <span class="s0">if </span><span class="s1">(options.cacheHandlers) {</span>
          <span class="s1">onError(createCompilerError(</span><span class="s4">49 </span><span class="s5">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(options.scopeId &amp;&amp; !isModuleMode) {</span>
          <span class="s1">onError(createCompilerError(</span><span class="s4">50 </span><span class="s5">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">ast = isString(template) ? baseParse(template</span><span class="s0">, </span><span class="s1">options) : template</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">[nodeTransforms</span><span class="s0">, </span><span class="s1">directiveTransforms] = getBaseTransformPreset()</span><span class="s0">;</span>
      <span class="s1">transform(ast</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">{</span>
          <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
          <span class="s1">nodeTransforms: [</span>
              <span class="s1">...nodeTransforms</span><span class="s0">,</span>
              <span class="s1">...(options.nodeTransforms || []) </span><span class="s5">// user transforms</span>
          <span class="s1">]</span><span class="s0">,</span>
          <span class="s1">directiveTransforms: extend({}</span><span class="s0">, </span><span class="s1">directiveTransforms</span><span class="s0">, </span><span class="s1">options.directiveTransforms || {} </span><span class="s5">// user transforms</span>
          <span class="s1">)</span>
      <span class="s1">}))</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">generate(ast</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">{</span>
          <span class="s1">prefixIdentifiers</span>
      <span class="s1">}))</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">noopDirectiveTransform = () =&gt; ({ props: [] })</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">V_MODEL_RADIO = Symbol(</span><span class="s2">`vModelRadio` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_MODEL_CHECKBOX = Symbol(</span><span class="s2">`vModelCheckbox` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_MODEL_TEXT = Symbol(</span><span class="s2">`vModelText` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_MODEL_SELECT = Symbol(</span><span class="s2">`vModelSelect` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_MODEL_DYNAMIC = Symbol(</span><span class="s2">`vModelDynamic` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_ON_WITH_MODIFIERS = Symbol(</span><span class="s2">`vOnModifiersGuard` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_ON_WITH_KEYS = Symbol(</span><span class="s2">`vOnKeysGuard` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">V_SHOW = Symbol(</span><span class="s2">`vShow` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TRANSITION = Symbol(</span><span class="s2">`Transition` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">TRANSITION_GROUP = Symbol(</span><span class="s2">`TransitionGroup` </span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">registerRuntimeHelpers({</span>
      <span class="s1">[V_MODEL_RADIO]: </span><span class="s2">`vModelRadio`</span><span class="s0">,</span>
      <span class="s1">[V_MODEL_CHECKBOX]: </span><span class="s2">`vModelCheckbox`</span><span class="s0">,</span>
      <span class="s1">[V_MODEL_TEXT]: </span><span class="s2">`vModelText`</span><span class="s0">,</span>
      <span class="s1">[V_MODEL_SELECT]: </span><span class="s2">`vModelSelect`</span><span class="s0">,</span>
      <span class="s1">[V_MODEL_DYNAMIC]: </span><span class="s2">`vModelDynamic`</span><span class="s0">,</span>
      <span class="s1">[V_ON_WITH_MODIFIERS]: </span><span class="s2">`withModifiers`</span><span class="s0">,</span>
      <span class="s1">[V_ON_WITH_KEYS]: </span><span class="s2">`withKeys`</span><span class="s0">,</span>
      <span class="s1">[V_SHOW]: </span><span class="s2">`vShow`</span><span class="s0">,</span>
      <span class="s1">[TRANSITION]: </span><span class="s2">`Transition`</span><span class="s0">,</span>
      <span class="s1">[TRANSITION_GROUP]: </span><span class="s2">`TransitionGroup`</span>
  <span class="s1">})</span><span class="s0">;</span>

  <span class="s5">/* eslint-disable no-restricted-globals */</span>
  <span class="s0">let </span><span class="s1">decoder</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">decodeHtmlBrowser(raw</span><span class="s0">, </span><span class="s1">asAttr = </span><span class="s0">false</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(!decoder) {</span>
          <span class="s1">decoder = document.createElement(</span><span class="s2">'div'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(asAttr) {</span>
          <span class="s1">decoder.innerHTML = </span><span class="s2">`&lt;div foo=&quot;</span><span class="s1">${raw.replace(</span><span class="s4">/&quot;/g</span><span class="s0">, </span><span class="s2">'&amp;quot;'</span><span class="s1">)}</span><span class="s2">&quot;&gt;`</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">decoder.children[</span><span class="s4">0</span><span class="s1">].getAttribute(</span><span class="s2">'foo'</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">decoder.innerHTML = raw</span><span class="s0">;</span>
          <span class="s0">return </span><span class="s1">decoder.textContent</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">isRawTextContainer = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">'style,iframe,script,noscript'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">parserOptions = {</span>
      <span class="s1">isVoidTag</span><span class="s0">,</span>
      <span class="s1">isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag)</span><span class="s0">,</span>
      <span class="s1">isPreTag: tag =&gt; tag === </span><span class="s2">'pre'</span><span class="s0">,</span>
      <span class="s1">decodeEntities: decodeHtmlBrowser </span><span class="s0">,</span>
      <span class="s1">isBuiltInComponent: (tag) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">`Transition`</span><span class="s1">)) {</span>
              <span class="s0">return </span><span class="s1">TRANSITION</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">`TransitionGroup`</span><span class="s1">)) {</span>
              <span class="s0">return </span><span class="s1">TRANSITION_GROUP</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher</span>
      <span class="s1">getNamespace(tag</span><span class="s0">, </span><span class="s1">parent) {</span>
          <span class="s0">let </span><span class="s1">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(parent &amp;&amp; ns === </span><span class="s4">2 </span><span class="s5">/* DOMNamespaces.MATH_ML */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(parent.tag === </span><span class="s2">'annotation-xml'</span><span class="s1">) {</span>
                  <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'svg'</span><span class="s1">) {</span>
                      <span class="s0">return </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">if </span><span class="s1">(parent.props.some(a =&gt; a.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">a.name === </span><span class="s2">'encoding' </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">a.value != </span><span class="s0">null </span><span class="s1">&amp;&amp;</span>
                      <span class="s1">(a.value.content === </span><span class="s2">'text/html' </span><span class="s1">||</span>
                          <span class="s1">a.value.content === </span><span class="s2">'application/xhtml+xml'</span><span class="s1">))) {</span>
                      <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(</span><span class="s4">/^m(?:[ions]|text)$/</span><span class="s1">.test(parent.tag) &amp;&amp;</span>
                  <span class="s1">tag !== </span><span class="s2">'mglyph' </span><span class="s1">&amp;&amp;</span>
                  <span class="s1">tag !== </span><span class="s2">'malignmark'</span><span class="s1">) {</span>
                  <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(parent &amp;&amp; ns === </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(parent.tag === </span><span class="s2">'foreignObject' </span><span class="s1">||</span>
                  <span class="s1">parent.tag === </span><span class="s2">'desc' </span><span class="s1">||</span>
                  <span class="s1">parent.tag === </span><span class="s2">'title'</span><span class="s1">) {</span>
                  <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(ns === </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'svg'</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'math'</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">2 </span><span class="s5">/* DOMNamespaces.MATH_ML */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">ns</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments</span>
      <span class="s1">getTextMode({ tag</span><span class="s0">, </span><span class="s1">ns }) {</span>
          <span class="s0">if </span><span class="s1">(ns === </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'textarea' </span><span class="s1">|| tag === </span><span class="s2">'title'</span><span class="s1">) {</span>
                  <span class="s0">return </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">if </span><span class="s1">(isRawTextContainer(tag)) {</span>
                  <span class="s0">return </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s5">// Parse inline CSS strings for static style attributes into an object.</span>
  <span class="s5">// This is a NodeTransform since it works on the static `style` attribute and</span>
  <span class="s5">// converts it into a dynamic equivalent:</span>
  <span class="s5">// style=&quot;color: red&quot; -&gt; :style='{ &quot;color&quot;: &quot;red&quot; }'</span>
  <span class="s5">// It is then processed by `transformElement` and included in the generated</span>
  <span class="s5">// props.</span>
  <span class="s0">const </span><span class="s1">transformStyle = node =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
          <span class="s1">node.props.forEach((p</span><span class="s0">, </span><span class="s1">i) =&gt; {</span>
              <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'style' </span><span class="s1">&amp;&amp; p.value) {</span>
                  <span class="s5">// replace p with an expression node</span>
                  <span class="s1">node.props[i] = {</span>
                      <span class="s1">type: </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s0">,</span>
                      <span class="s1">name: </span><span class="s2">`bind`</span><span class="s0">,</span>
                      <span class="s1">arg: createSimpleExpression(</span><span class="s2">`style`</span><span class="s0">, true, </span><span class="s1">p.loc)</span><span class="s0">,</span>
                      <span class="s1">exp: parseInlineCSS(p.value.content</span><span class="s0">, </span><span class="s1">p.loc)</span><span class="s0">,</span>
                      <span class="s1">modifiers: []</span><span class="s0">,</span>
                      <span class="s1">loc: p.loc</span>
                  <span class="s1">}</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">parseInlineCSS = (cssText</span><span class="s0">, </span><span class="s1">loc) =&gt; {</span>
      <span class="s0">const </span><span class="s1">normalized = parseStringStyle(cssText)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">createSimpleExpression(JSON.stringify(normalized)</span><span class="s0">, false, </span><span class="s1">loc</span><span class="s0">, </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">function </span><span class="s1">createDOMCompilerError(code</span><span class="s0">, </span><span class="s1">loc) {</span>
      <span class="s0">return </span><span class="s1">createCompilerError(code</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">DOMErrorMessages )</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">DOMErrorMessages = {</span>
      <span class="s1">[</span><span class="s4">51 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-html is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">52 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */</span><span class="s1">]: </span><span class="s2">`v-html will override element children.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">53 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-text is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">54 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */</span><span class="s1">]: </span><span class="s2">`v-text will override element children.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">55 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */</span><span class="s1">]: </span><span class="s2">`v-model can only be used on &lt;input&gt;, &lt;textarea&gt; and &lt;select&gt; elements.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">56 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */</span><span class="s1">]: </span><span class="s2">`v-model argument is not supported on plain elements.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">57 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */</span><span class="s1">]: </span><span class="s2">`v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">58 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */</span><span class="s1">]: </span><span class="s2">`Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">59 </span><span class="s5">/* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-show is missing expression.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">60 </span><span class="s5">/* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */</span><span class="s1">]: </span><span class="s2">`&lt;Transition&gt; expects exactly one child element or component.`</span><span class="s0">,</span>
      <span class="s1">[</span><span class="s4">61 </span><span class="s5">/* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */</span><span class="s1">]: </span><span class="s2">`Tags with side effect (&lt;script&gt; and &lt;style&gt;) are ignored in client component templates.`</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformVHtml = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">loc } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!exp) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">51 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.children.length) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">52 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
          <span class="s1">node.children.length = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">props: [</span>
              <span class="s1">createObjectProperty(createSimpleExpression(</span><span class="s2">`innerHTML`</span><span class="s0">, true, </span><span class="s1">loc)</span><span class="s0">, </span><span class="s1">exp || createSimpleExpression(</span><span class="s2">''</span><span class="s0">, true</span><span class="s1">))</span>
          <span class="s1">]</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformVText = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">loc } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!exp) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">53 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.children.length) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">54 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
          <span class="s1">node.children.length = </span><span class="s4">0</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">props: [</span>
              <span class="s1">createObjectProperty(createSimpleExpression(</span><span class="s2">`textContent`</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp</span>
                  <span class="s1">? getConstantType(exp</span><span class="s0">, </span><span class="s1">context) &gt; </span><span class="s4">0</span>
                      <span class="s1">? exp</span>
                      <span class="s1">: createCallExpression(context.helperString(TO_DISPLAY_STRING)</span><span class="s0">, </span><span class="s1">[exp]</span><span class="s0">, </span><span class="s1">loc)</span>
                  <span class="s1">: createSimpleExpression(</span><span class="s2">''</span><span class="s0">, true</span><span class="s1">))</span>
          <span class="s1">]</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformModel = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">baseResult = transformModel$1(dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
      <span class="s5">// base transform has errors OR component v-model (only need props)</span>
      <span class="s0">if </span><span class="s1">(!baseResult.props.length || node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">baseResult</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(dir.arg) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">56 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">dir.arg.loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">function </span><span class="s1">checkDuplicatedValue() {</span>
          <span class="s0">const </span><span class="s1">value = findProp(node</span><span class="s0">, </span><span class="s2">'value'</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(value) {</span>
              <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">58 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */</span><span class="s0">, </span><span class="s1">value.loc))</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">{ tag } = node</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">isCustomElement = context.isCustomElement(tag)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'input' </span><span class="s1">||</span>
          <span class="s1">tag === </span><span class="s2">'textarea' </span><span class="s1">||</span>
          <span class="s1">tag === </span><span class="s2">'select' </span><span class="s1">||</span>
          <span class="s1">isCustomElement) {</span>
          <span class="s0">let </span><span class="s1">directiveToUse = V_MODEL_TEXT</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">isInvalidType = </span><span class="s0">false;</span>
          <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'input' </span><span class="s1">|| isCustomElement) {</span>
              <span class="s0">const </span><span class="s1">type = findProp(node</span><span class="s0">, </span><span class="s2">`type`</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s0">if </span><span class="s1">(type) {</span>
                  <span class="s0">if </span><span class="s1">(type.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                      <span class="s5">// :type=&quot;foo&quot;</span>
                      <span class="s1">directiveToUse = V_MODEL_DYNAMIC</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else if </span><span class="s1">(type.value) {</span>
                      <span class="s0">switch </span><span class="s1">(type.value.content) {</span>
                          <span class="s0">case </span><span class="s2">'radio'</span><span class="s1">:</span>
                              <span class="s1">directiveToUse = V_MODEL_RADIO</span><span class="s0">;</span>
                              <span class="s0">break;</span>
                          <span class="s0">case </span><span class="s2">'checkbox'</span><span class="s1">:</span>
                              <span class="s1">directiveToUse = V_MODEL_CHECKBOX</span><span class="s0">;</span>
                              <span class="s0">break;</span>
                          <span class="s0">case </span><span class="s2">'file'</span><span class="s1">:</span>
                              <span class="s1">isInvalidType = </span><span class="s0">true;</span>
                              <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">57 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
                              <span class="s0">break;</span>
                          <span class="s0">default</span><span class="s1">:</span>
                              <span class="s5">// text type</span>
                              <span class="s1">checkDuplicatedValue()</span><span class="s0">;</span>
                              <span class="s0">break;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else if </span><span class="s1">(hasDynamicKeyVBind(node)) {</span>
                  <span class="s5">// element has bindings with dynamic keys, which can possibly contain</span>
                  <span class="s5">// &quot;type&quot;.</span>
                  <span class="s1">directiveToUse = V_MODEL_DYNAMIC</span><span class="s0">;</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s5">// text type</span>
                  <span class="s1">checkDuplicatedValue()</span><span class="s0">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(tag === </span><span class="s2">'select'</span><span class="s1">) {</span>
              <span class="s1">directiveToUse = V_MODEL_SELECT</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// textarea</span>
              <span class="s1">checkDuplicatedValue()</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s5">// inject runtime directive</span>
          <span class="s5">// by returning the helper symbol via needRuntime</span>
          <span class="s5">// the import will replaced a resolveDirective call.</span>
          <span class="s0">if </span><span class="s1">(!isInvalidType) {</span>
              <span class="s1">baseResult.needRuntime = context.helper(directiveToUse)</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">else </span><span class="s1">{</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">55 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s5">// native vmodel doesn't need the `modelValue` props since they are also</span>
      <span class="s5">// passed to the runtime as `binding.value`. removing it reduces code size.</span>
      <span class="s1">baseResult.props = baseResult.props.filter(p =&gt; !(p.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">p.key.content === </span><span class="s2">'modelValue'</span><span class="s1">))</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">baseResult</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">isEventOptionModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">`passive,once,capture`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isNonKeyModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span>
  <span class="s5">// event propagation management</span>
<span class="s2">`stop,prevent,self,`   </span><span class="s1">+</span>
      <span class="s5">// system modifiers + exact</span>
      <span class="s2">`ctrl,shift,alt,meta,exact,` </span><span class="s1">+</span>
      <span class="s5">// mouse</span>
      <span class="s2">`middle`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s5">// left &amp; right could be mouse or key modifiers based on event type</span>
  <span class="s0">const </span><span class="s1">maybeKeyModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">'left,right'</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">isKeyboardEvent = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">`onkeyup,onkeydown,onkeypress`</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">resolveModifiers = (key</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc) =&gt; {</span>
      <span class="s0">const </span><span class="s1">keyModifiers = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">nonKeyModifiers = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">eventOptionModifiers = []</span><span class="s0">;</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; modifiers.length</span><span class="s0">; </span><span class="s1">i++) {</span>
          <span class="s0">const </span><span class="s1">modifier = modifiers[i]</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(modifier === </span><span class="s2">'native' </span><span class="s1">&amp;&amp;</span>
              <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_ON_NATIVE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc)) {</span>
              <span class="s1">eventOptionModifiers.push(modifier)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else if </span><span class="s1">(isEventOptionModifier(modifier)) {</span>
              <span class="s5">// eventOptionModifiers: modifiers for addEventListener() options,</span>
              <span class="s5">// e.g. .passive &amp; .capture</span>
              <span class="s1">eventOptionModifiers.push(modifier)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">else </span><span class="s1">{</span>
              <span class="s5">// runtimeModifiers: modifiers that needs runtime guards</span>
              <span class="s0">if </span><span class="s1">(maybeKeyModifier(modifier)) {</span>
                  <span class="s0">if </span><span class="s1">(isStaticExp(key)) {</span>
                      <span class="s0">if </span><span class="s1">(isKeyboardEvent(key.content)) {</span>
                          <span class="s1">keyModifiers.push(modifier)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                      <span class="s0">else </span><span class="s1">{</span>
                          <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s0">;</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">keyModifiers.push(modifier)</span><span class="s0">;</span>
                      <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
              <span class="s0">else </span><span class="s1">{</span>
                  <span class="s0">if </span><span class="s1">(isNonKeyModifier(modifier)) {</span>
                      <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s0">else </span><span class="s1">{</span>
                      <span class="s1">keyModifiers.push(modifier)</span><span class="s0">;</span>
                  <span class="s1">}</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">keyModifiers</span><span class="s0">,</span>
          <span class="s1">nonKeyModifiers</span><span class="s0">,</span>
          <span class="s1">eventOptionModifiers</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformClick = (key</span><span class="s0">, </span><span class="s1">event) =&gt; {</span>
      <span class="s0">const </span><span class="s1">isStaticClick = isStaticExp(key) &amp;&amp; key.content.toLowerCase() === </span><span class="s2">'onclick'</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">isStaticClick</span>
          <span class="s1">? createSimpleExpression(event</span><span class="s0">, true</span><span class="s1">)</span>
          <span class="s1">: key.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span>
              <span class="s1">? createCompoundExpression([</span>
                  <span class="s2">`(`</span><span class="s0">,</span>
                  <span class="s1">key</span><span class="s0">,</span>
                  <span class="s2">`) === &quot;onClick&quot; ? &quot;</span><span class="s1">${event}</span><span class="s2">&quot; : (`</span><span class="s0">,</span>
                  <span class="s1">key</span><span class="s0">,</span>
                  <span class="s2">`)`</span>
              <span class="s1">])</span>
              <span class="s1">: key</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">transformOn = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">return </span><span class="s1">transformOn$1(dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">baseResult =&gt; {</span>
          <span class="s0">const </span><span class="s1">{ modifiers } = dir</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(!modifiers.length)</span>
              <span class="s0">return </span><span class="s1">baseResult</span><span class="s0">;</span>
          <span class="s0">let </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value: handlerExp } = baseResult.props[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">{ keyModifiers</span><span class="s0">, </span><span class="s1">nonKeyModifiers</span><span class="s0">, </span><span class="s1">eventOptionModifiers } = resolveModifiers(key</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">dir.loc)</span><span class="s0">;</span>
          <span class="s5">// normalize click.right and click.middle since they don't actually fire</span>
          <span class="s0">if </span><span class="s1">(nonKeyModifiers.includes(</span><span class="s2">'right'</span><span class="s1">)) {</span>
              <span class="s1">key = transformClick(key</span><span class="s0">, </span><span class="s2">`onContextmenu`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(nonKeyModifiers.includes(</span><span class="s2">'middle'</span><span class="s1">)) {</span>
              <span class="s1">key = transformClick(key</span><span class="s0">, </span><span class="s2">`onMouseup`</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(nonKeyModifiers.length) {</span>
              <span class="s1">handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS)</span><span class="s0">, </span><span class="s1">[</span>
                  <span class="s1">handlerExp</span><span class="s0">,</span>
                  <span class="s1">JSON.stringify(nonKeyModifiers)</span>
              <span class="s1">])</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(keyModifiers.length &amp;&amp;</span>
              <span class="s5">// if event name is dynamic, always wrap with keys guard</span>
              <span class="s1">(!isStaticExp(key) || isKeyboardEvent(key.content))) {</span>
              <span class="s1">handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS)</span><span class="s0">, </span><span class="s1">[</span>
                  <span class="s1">handlerExp</span><span class="s0">,</span>
                  <span class="s1">JSON.stringify(keyModifiers)</span>
              <span class="s1">])</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">if </span><span class="s1">(eventOptionModifiers.length) {</span>
              <span class="s0">const </span><span class="s1">modifierPostfix = eventOptionModifiers.map(capitalize).join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">key = isStaticExp(key)</span>
                  <span class="s1">? createSimpleExpression(</span><span class="s2">`</span><span class="s1">${key.content}${modifierPostfix}</span><span class="s2">`</span><span class="s0">, true</span><span class="s1">)</span>
                  <span class="s1">: createCompoundExpression([</span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s2">`) + &quot;</span><span class="s1">${modifierPostfix}</span><span class="s2">&quot;`</span><span class="s1">])</span><span class="s0">;</span>
          <span class="s1">}</span>
          <span class="s0">return </span><span class="s1">{</span>
              <span class="s1">props: [createObjectProperty(key</span><span class="s0">, </span><span class="s1">handlerExp)]</span>
          <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformShow = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">loc } = dir</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!exp) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">59 </span><span class="s5">/* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">{</span>
          <span class="s1">props: []</span><span class="s0">,</span>
          <span class="s1">needRuntime: context.helper(V_SHOW)</span>
      <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">transformTransition = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
          <span class="s0">const </span><span class="s1">component = context.isBuiltInComponent(node.tag)</span><span class="s0">;</span>
          <span class="s0">if </span><span class="s1">(component === TRANSITION) {</span>
              <span class="s0">return </span><span class="s1">() =&gt; {</span>
                  <span class="s0">if </span><span class="s1">(!node.children.length) {</span>
                      <span class="s0">return;</span>
                  <span class="s1">}</span>
                  <span class="s5">// warn multiple transition children</span>
                  <span class="s0">if </span><span class="s1">(hasMultipleChildren(node)) {</span>
                      <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">60 </span><span class="s5">/* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */</span><span class="s0">, </span><span class="s1">{</span>
                          <span class="s1">start: node.children[</span><span class="s4">0</span><span class="s1">].loc.start</span><span class="s0">,</span>
                          <span class="s1">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s1">].loc.end</span><span class="s0">,</span>
                          <span class="s1">source: </span><span class="s2">''</span>
                      <span class="s1">}))</span><span class="s0">;</span>
                  <span class="s1">}</span>
                  <span class="s5">// check if it's s single child w/ v-show</span>
                  <span class="s5">// if yes, inject &quot;persisted: true&quot; to the transition props</span>
                  <span class="s0">const </span><span class="s1">child = node.children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
                  <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
                      <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">p of child.props) {</span>
                          <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'show'</span><span class="s1">) {</span>
                              <span class="s1">node.props.push({</span>
                                  <span class="s1">type: </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s0">,</span>
                                  <span class="s1">name: </span><span class="s2">'persisted'</span><span class="s0">,</span>
                                  <span class="s1">value: undefined</span><span class="s0">,</span>
                                  <span class="s1">loc: node.loc</span>
                              <span class="s1">})</span><span class="s0">;</span>
                          <span class="s1">}</span>
                      <span class="s1">}</span>
                  <span class="s1">}</span>
              <span class="s1">}</span><span class="s0">;</span>
          <span class="s1">}</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">hasMultipleChildren(node) {</span>
      <span class="s5">// #1352 filter out potential comment nodes.</span>
      <span class="s0">const </span><span class="s1">children = (node.children = node.children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">!(c.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp; !c.content.trim())))</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">(children.length !== </span><span class="s4">1 </span><span class="s1">||</span>
          <span class="s1">child.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */ </span><span class="s1">||</span>
          <span class="s1">(child.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */ </span><span class="s1">&amp;&amp; child.branches.some(hasMultipleChildren)))</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">ignoreSideEffectTags = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
          <span class="s1">(node.tag === </span><span class="s2">'script' </span><span class="s1">|| node.tag === </span><span class="s2">'style'</span><span class="s1">)) {</span>
          <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">61 </span><span class="s5">/* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */</span><span class="s0">, </span><span class="s1">node.loc))</span><span class="s0">;</span>
          <span class="s1">context.removeNode()</span><span class="s0">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">DOMNodeTransforms = [</span>
      <span class="s1">transformStyle</span><span class="s0">,</span>
      <span class="s1">...([transformTransition] )</span>
  <span class="s1">]</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">DOMDirectiveTransforms = {</span>
      <span class="s1">cloak: noopDirectiveTransform</span><span class="s0">,</span>
      <span class="s1">html: transformVHtml</span><span class="s0">,</span>
      <span class="s1">text: transformVText</span><span class="s0">,</span>
      <span class="s1">model: transformModel</span><span class="s0">,</span>
      <span class="s1">on: transformOn</span><span class="s0">,</span>
      <span class="s1">show: transformShow</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">function </span><span class="s1">compile(template</span><span class="s0">, </span><span class="s1">options = {}) {</span>
      <span class="s0">return </span><span class="s1">baseCompile(template</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">parserOptions</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">{</span>
          <span class="s1">nodeTransforms: [</span>
              <span class="s5">// ignore &lt;script&gt; and &lt;tag&gt;</span>
              <span class="s5">// this is not put inside DOMNodeTransforms because that list is used</span>
              <span class="s5">// by compiler-ssr to generate vnode fallback branches</span>
              <span class="s1">ignoreSideEffectTags</span><span class="s0">,</span>
              <span class="s1">...DOMNodeTransforms</span><span class="s0">,</span>
              <span class="s1">...(options.nodeTransforms || [])</span>
          <span class="s1">]</span><span class="s0">,</span>
          <span class="s1">directiveTransforms: extend({}</span><span class="s0">, </span><span class="s1">DOMDirectiveTransforms</span><span class="s0">, </span><span class="s1">options.directiveTransforms || {})</span><span class="s0">,</span>
          <span class="s1">transformHoist: </span><span class="s0">null </span>
      <span class="s1">}))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">function </span><span class="s1">parse(template</span><span class="s0">, </span><span class="s1">options = {}) {</span>
      <span class="s0">return </span><span class="s1">baseParse(template</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">parserOptions</span><span class="s0">, </span><span class="s1">options))</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">exports.BASE_TRANSITION = BASE_TRANSITION</span><span class="s0">;</span>
  <span class="s1">exports.CAMELIZE = CAMELIZE</span><span class="s0">;</span>
  <span class="s1">exports.CAPITALIZE = CAPITALIZE</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_BLOCK = CREATE_BLOCK</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_COMMENT = CREATE_COMMENT</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_SLOTS = CREATE_SLOTS</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_STATIC = CREATE_STATIC</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_TEXT = CREATE_TEXT</span><span class="s0">;</span>
  <span class="s1">exports.CREATE_VNODE = CREATE_VNODE</span><span class="s0">;</span>
  <span class="s1">exports.DOMDirectiveTransforms = DOMDirectiveTransforms</span><span class="s0">;</span>
  <span class="s1">exports.DOMNodeTransforms = DOMNodeTransforms</span><span class="s0">;</span>
  <span class="s1">exports.FRAGMENT = FRAGMENT</span><span class="s0">;</span>
  <span class="s1">exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS</span><span class="s0">;</span>
  <span class="s1">exports.IS_MEMO_SAME = IS_MEMO_SAME</span><span class="s0">;</span>
  <span class="s1">exports.IS_REF = IS_REF</span><span class="s0">;</span>
  <span class="s1">exports.KEEP_ALIVE = KEEP_ALIVE</span><span class="s0">;</span>
  <span class="s1">exports.MERGE_PROPS = MERGE_PROPS</span><span class="s0">;</span>
  <span class="s1">exports.NORMALIZE_CLASS = NORMALIZE_CLASS</span><span class="s0">;</span>
  <span class="s1">exports.NORMALIZE_PROPS = NORMALIZE_PROPS</span><span class="s0">;</span>
  <span class="s1">exports.NORMALIZE_STYLE = NORMALIZE_STYLE</span><span class="s0">;</span>
  <span class="s1">exports.OPEN_BLOCK = OPEN_BLOCK</span><span class="s0">;</span>
  <span class="s1">exports.POP_SCOPE_ID = POP_SCOPE_ID</span><span class="s0">;</span>
  <span class="s1">exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID</span><span class="s0">;</span>
  <span class="s1">exports.RENDER_LIST = RENDER_LIST</span><span class="s0">;</span>
  <span class="s1">exports.RENDER_SLOT = RENDER_SLOT</span><span class="s0">;</span>
  <span class="s1">exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT</span><span class="s0">;</span>
  <span class="s1">exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE</span><span class="s0">;</span>
  <span class="s1">exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT</span><span class="s0">;</span>
  <span class="s1">exports.RESOLVE_FILTER = RESOLVE_FILTER</span><span class="s0">;</span>
  <span class="s1">exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING</span><span class="s0">;</span>
  <span class="s1">exports.SUSPENSE = SUSPENSE</span><span class="s0">;</span>
  <span class="s1">exports.TELEPORT = TELEPORT</span><span class="s0">;</span>
  <span class="s1">exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING</span><span class="s0">;</span>
  <span class="s1">exports.TO_HANDLERS = TO_HANDLERS</span><span class="s0">;</span>
  <span class="s1">exports.TO_HANDLER_KEY = TO_HANDLER_KEY</span><span class="s0">;</span>
  <span class="s1">exports.TRANSITION = TRANSITION</span><span class="s0">;</span>
  <span class="s1">exports.TRANSITION_GROUP = TRANSITION_GROUP</span><span class="s0">;</span>
  <span class="s1">exports.UNREF = UNREF</span><span class="s0">;</span>
  <span class="s1">exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX</span><span class="s0">;</span>
  <span class="s1">exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC</span><span class="s0">;</span>
  <span class="s1">exports.V_MODEL_RADIO = V_MODEL_RADIO</span><span class="s0">;</span>
  <span class="s1">exports.V_MODEL_SELECT = V_MODEL_SELECT</span><span class="s0">;</span>
  <span class="s1">exports.V_MODEL_TEXT = V_MODEL_TEXT</span><span class="s0">;</span>
  <span class="s1">exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS</span><span class="s0">;</span>
  <span class="s1">exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS</span><span class="s0">;</span>
  <span class="s1">exports.V_SHOW = V_SHOW</span><span class="s0">;</span>
  <span class="s1">exports.WITH_CTX = WITH_CTX</span><span class="s0">;</span>
  <span class="s1">exports.WITH_DIRECTIVES = WITH_DIRECTIVES</span><span class="s0">;</span>
  <span class="s1">exports.WITH_MEMO = WITH_MEMO</span><span class="s0">;</span>
  <span class="s1">exports.advancePositionWithClone = advancePositionWithClone</span><span class="s0">;</span>
  <span class="s1">exports.advancePositionWithMutation = advancePositionWithMutation</span><span class="s0">;</span>
  <span class="s1">exports.assert = assert</span><span class="s0">;</span>
  <span class="s1">exports.baseCompile = baseCompile</span><span class="s0">;</span>
  <span class="s1">exports.baseParse = baseParse</span><span class="s0">;</span>
  <span class="s1">exports.buildDirectiveArgs = buildDirectiveArgs</span><span class="s0">;</span>
  <span class="s1">exports.buildProps = buildProps</span><span class="s0">;</span>
  <span class="s1">exports.buildSlots = buildSlots</span><span class="s0">;</span>
  <span class="s1">exports.checkCompatEnabled = checkCompatEnabled</span><span class="s0">;</span>
  <span class="s1">exports.compile = compile</span><span class="s0">;</span>
  <span class="s1">exports.createArrayExpression = createArrayExpression</span><span class="s0">;</span>
  <span class="s1">exports.createAssignmentExpression = createAssignmentExpression</span><span class="s0">;</span>
  <span class="s1">exports.createBlockStatement = createBlockStatement</span><span class="s0">;</span>
  <span class="s1">exports.createCacheExpression = createCacheExpression</span><span class="s0">;</span>
  <span class="s1">exports.createCallExpression = createCallExpression</span><span class="s0">;</span>
  <span class="s1">exports.createCompilerError = createCompilerError</span><span class="s0">;</span>
  <span class="s1">exports.createCompoundExpression = createCompoundExpression</span><span class="s0">;</span>
  <span class="s1">exports.createConditionalExpression = createConditionalExpression</span><span class="s0">;</span>
  <span class="s1">exports.createDOMCompilerError = createDOMCompilerError</span><span class="s0">;</span>
  <span class="s1">exports.createForLoopParams = createForLoopParams</span><span class="s0">;</span>
  <span class="s1">exports.createFunctionExpression = createFunctionExpression</span><span class="s0">;</span>
  <span class="s1">exports.createIfStatement = createIfStatement</span><span class="s0">;</span>
  <span class="s1">exports.createInterpolation = createInterpolation</span><span class="s0">;</span>
  <span class="s1">exports.createObjectExpression = createObjectExpression</span><span class="s0">;</span>
  <span class="s1">exports.createObjectProperty = createObjectProperty</span><span class="s0">;</span>
  <span class="s1">exports.createReturnStatement = createReturnStatement</span><span class="s0">;</span>
  <span class="s1">exports.createRoot = createRoot</span><span class="s0">;</span>
  <span class="s1">exports.createSequenceExpression = createSequenceExpression</span><span class="s0">;</span>
  <span class="s1">exports.createSimpleExpression = createSimpleExpression</span><span class="s0">;</span>
  <span class="s1">exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform</span><span class="s0">;</span>
  <span class="s1">exports.createTemplateLiteral = createTemplateLiteral</span><span class="s0">;</span>
  <span class="s1">exports.createTransformContext = createTransformContext</span><span class="s0">;</span>
  <span class="s1">exports.createVNodeCall = createVNodeCall</span><span class="s0">;</span>
  <span class="s1">exports.extractIdentifiers = extractIdentifiers</span><span class="s0">;</span>
  <span class="s1">exports.findDir = findDir</span><span class="s0">;</span>
  <span class="s1">exports.findProp = findProp</span><span class="s0">;</span>
  <span class="s1">exports.generate = generate</span><span class="s0">;</span>
  <span class="s1">exports.generateCodeFrame = generateCodeFrame</span><span class="s0">;</span>
  <span class="s1">exports.getBaseTransformPreset = getBaseTransformPreset</span><span class="s0">;</span>
  <span class="s1">exports.getConstantType = getConstantType</span><span class="s0">;</span>
  <span class="s1">exports.getInnerRange = getInnerRange</span><span class="s0">;</span>
  <span class="s1">exports.getMemoedVNodeCall = getMemoedVNodeCall</span><span class="s0">;</span>
  <span class="s1">exports.getVNodeBlockHelper = getVNodeBlockHelper</span><span class="s0">;</span>
  <span class="s1">exports.getVNodeHelper = getVNodeHelper</span><span class="s0">;</span>
  <span class="s1">exports.hasDynamicKeyVBind = hasDynamicKeyVBind</span><span class="s0">;</span>
  <span class="s1">exports.hasScopeRef = hasScopeRef</span><span class="s0">;</span>
  <span class="s1">exports.helperNameMap = helperNameMap</span><span class="s0">;</span>
  <span class="s1">exports.injectProp = injectProp</span><span class="s0">;</span>
  <span class="s1">exports.isBuiltInType = isBuiltInType</span><span class="s0">;</span>
  <span class="s1">exports.isCoreComponent = isCoreComponent</span><span class="s0">;</span>
  <span class="s1">exports.isFunctionType = isFunctionType</span><span class="s0">;</span>
  <span class="s1">exports.isInDestructureAssignment = isInDestructureAssignment</span><span class="s0">;</span>
  <span class="s1">exports.isMemberExpression = isMemberExpression</span><span class="s0">;</span>
  <span class="s1">exports.isMemberExpressionBrowser = isMemberExpressionBrowser</span><span class="s0">;</span>
  <span class="s1">exports.isMemberExpressionNode = isMemberExpressionNode</span><span class="s0">;</span>
  <span class="s1">exports.isReferencedIdentifier = isReferencedIdentifier</span><span class="s0">;</span>
  <span class="s1">exports.isSimpleIdentifier = isSimpleIdentifier</span><span class="s0">;</span>
  <span class="s1">exports.isSlotOutlet = isSlotOutlet</span><span class="s0">;</span>
  <span class="s1">exports.isStaticArgOf = isStaticArgOf</span><span class="s0">;</span>
  <span class="s1">exports.isStaticExp = isStaticExp</span><span class="s0">;</span>
  <span class="s1">exports.isStaticProperty = isStaticProperty</span><span class="s0">;</span>
  <span class="s1">exports.isStaticPropertyKey = isStaticPropertyKey</span><span class="s0">;</span>
  <span class="s1">exports.isTemplateNode = isTemplateNode</span><span class="s0">;</span>
  <span class="s1">exports.isText = isText$1</span><span class="s0">;</span>
  <span class="s1">exports.isVSlot = isVSlot</span><span class="s0">;</span>
  <span class="s1">exports.locStub = locStub</span><span class="s0">;</span>
  <span class="s1">exports.makeBlock = makeBlock</span><span class="s0">;</span>
  <span class="s1">exports.noopDirectiveTransform = noopDirectiveTransform</span><span class="s0">;</span>
  <span class="s1">exports.parse = parse</span><span class="s0">;</span>
  <span class="s1">exports.parserOptions = parserOptions</span><span class="s0">;</span>
  <span class="s1">exports.processExpression = processExpression</span><span class="s0">;</span>
  <span class="s1">exports.processFor = processFor</span><span class="s0">;</span>
  <span class="s1">exports.processIf = processIf</span><span class="s0">;</span>
  <span class="s1">exports.processSlotOutlet = processSlotOutlet</span><span class="s0">;</span>
  <span class="s1">exports.registerRuntimeHelpers = registerRuntimeHelpers</span><span class="s0">;</span>
  <span class="s1">exports.resolveComponentType = resolveComponentType</span><span class="s0">;</span>
  <span class="s1">exports.stringifyExpression = stringifyExpression</span><span class="s0">;</span>
  <span class="s1">exports.toValidAssetId = toValidAssetId</span><span class="s0">;</span>
  <span class="s1">exports.trackSlotScopes = trackSlotScopes</span><span class="s0">;</span>
  <span class="s1">exports.trackVForSlotScopes = trackVForSlotScopes</span><span class="s0">;</span>
  <span class="s1">exports.transform = transform</span><span class="s0">;</span>
  <span class="s1">exports.transformBind = transformBind</span><span class="s0">;</span>
  <span class="s1">exports.transformElement = transformElement</span><span class="s0">;</span>
  <span class="s1">exports.transformExpression = transformExpression</span><span class="s0">;</span>
  <span class="s1">exports.transformModel = transformModel$1</span><span class="s0">;</span>
  <span class="s1">exports.transformOn = transformOn$1</span><span class="s0">;</span>
  <span class="s1">exports.transformStyle = transformStyle</span><span class="s0">;</span>
  <span class="s1">exports.traverseNode = traverseNode</span><span class="s0">;</span>
  <span class="s1">exports.walkBlockDeclarations = walkBlockDeclarations</span><span class="s0">;</span>
  <span class="s1">exports.walkFunctionParams = walkFunctionParams</span><span class="s0">;</span>
  <span class="s1">exports.walkIdentifiers = walkIdentifiers</span><span class="s0">;</span>
  <span class="s1">exports.warnDeprecation = warnDeprecation</span><span class="s0">;</span>

  <span class="s1">Object.defineProperty(exports</span><span class="s0">, </span><span class="s2">'__esModule'</span><span class="s0">, </span><span class="s1">{ value: </span><span class="s0">true </span><span class="s1">})</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">exports</span><span class="s0">;</span>

<span class="s1">})({})</span><span class="s0">;</span>
</pre>
</body>
</html>