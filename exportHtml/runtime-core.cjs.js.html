<html>
<head>
<title>runtime-core.cjs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime-core.cjs.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">Object.defineProperty(exports</span><span class="s1">, </span><span class="s0">'__esModule'</span><span class="s1">, </span><span class="s2">{ value: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">reactivity = require(</span><span class="s0">'@vue/reactivity'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">shared = require(</span><span class="s0">'@vue/shared'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">stack = []</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">pushWarningContext(vnode) {</span>
    <span class="s2">stack.push(vnode)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">popWarningContext() {</span>
    <span class="s2">stack.pop()</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">warn(msg</span><span class="s1">, </span><span class="s2">...args) {</span>
    <span class="s3">// avoid props formatting or warn handler tracking deps that might be mutated</span>
    <span class="s3">// during patch, leading to infinite recursion.</span>
    <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">instance = stack.length ? stack[stack.length - </span><span class="s4">1</span><span class="s2">].component : </span><span class="s1">null;</span>
    <span class="s1">const </span><span class="s2">appWarnHandler = instance &amp;&amp; instance.appContext.config.warnHandler</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">trace = getComponentTrace()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(appWarnHandler) {</span>
        <span class="s2">callWithErrorHandling(appWarnHandler</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">11 </span><span class="s3">/* ErrorCodes.APP_WARN_HANDLER */</span><span class="s1">, </span><span class="s2">[</span>
            <span class="s2">msg + args.join(</span><span class="s0">''</span><span class="s2">)</span><span class="s1">,</span>
            <span class="s2">instance &amp;&amp; instance.proxy</span><span class="s1">,</span>
            <span class="s2">trace</span>
                <span class="s2">.map(({ vnode }) =&gt; </span><span class="s0">`at &lt;</span><span class="s2">${formatComponentName(instance</span><span class="s1">, </span><span class="s2">vnode.type)}</span><span class="s0">&gt;`</span><span class="s2">)</span>
                <span class="s2">.join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">,</span>
            <span class="s2">trace</span>
        <span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">warnArgs = [</span><span class="s0">`[Vue warn]: </span><span class="s2">${msg}</span><span class="s0">`</span><span class="s1">, </span><span class="s2">...args]</span><span class="s1">;</span>
        <span class="s3">/* istanbul ignore if */</span>
        <span class="s1">if </span><span class="s2">(trace.length &amp;&amp;</span>
            <span class="s3">// avoid spamming console during tests</span>
            <span class="s2">!</span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s2">warnArgs.push(</span><span class="s0">`</span><span class="s1">\n</span><span class="s0">`</span><span class="s1">, </span><span class="s2">...formatTrace(trace))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">console.warn(...warnArgs)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getComponentTrace() {</span>
    <span class="s1">let </span><span class="s2">currentVNode = stack[stack.length - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!currentVNode) {</span>
        <span class="s1">return </span><span class="s2">[]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// we can't just use the stack because it will be incomplete during updates</span>
    <span class="s3">// that did not start from the root. Re-construct the parent chain using</span>
    <span class="s3">// instance parent pointers.</span>
    <span class="s1">const </span><span class="s2">normalizedStack = []</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(currentVNode) {</span>
        <span class="s1">const </span><span class="s2">last = normalizedStack[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(last &amp;&amp; last.vnode === currentVNode) {</span>
            <span class="s2">last.recurseCount++</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">normalizedStack.push({</span>
                <span class="s2">vnode: currentVNode</span><span class="s1">,</span>
                <span class="s2">recurseCount: </span><span class="s4">0</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">parentInstance = currentVNode.component &amp;&amp; currentVNode.component.parent</span><span class="s1">;</span>
        <span class="s2">currentVNode = parentInstance &amp;&amp; parentInstance.vnode</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">normalizedStack</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/* istanbul ignore next */</span>
<span class="s1">function </span><span class="s2">formatTrace(trace) {</span>
    <span class="s1">const </span><span class="s2">logs = []</span><span class="s1">;</span>
    <span class="s2">trace.forEach((entry</span><span class="s1">, </span><span class="s2">i) =&gt; {</span>
        <span class="s2">logs.push(...(i === </span><span class="s4">0 </span><span class="s2">? [] : [</span><span class="s0">`</span><span class="s1">\n</span><span class="s0">`</span><span class="s2">])</span><span class="s1">, </span><span class="s2">...formatTraceEntry(entry))</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">logs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">formatTraceEntry({ vnode</span><span class="s1">, </span><span class="s2">recurseCount }) {</span>
    <span class="s1">const </span><span class="s2">postfix = recurseCount &gt; </span><span class="s4">0 </span><span class="s2">? </span><span class="s0">`... (</span><span class="s2">${recurseCount} </span><span class="s0">recursive calls)` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isRoot = vnode.component ? vnode.component.parent == </span><span class="s1">null </span><span class="s2">: </span><span class="s1">false;</span>
    <span class="s1">const </span><span class="s2">open = </span><span class="s0">` at &lt;</span><span class="s2">${formatComponentName(vnode.component</span><span class="s1">, </span><span class="s2">vnode.type</span><span class="s1">, </span><span class="s2">isRoot)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">close = </span><span class="s0">`&gt;` </span><span class="s2">+ postfix</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">vnode.props</span>
        <span class="s2">? [open</span><span class="s1">, </span><span class="s2">...formatProps(vnode.props)</span><span class="s1">, </span><span class="s2">close]</span>
        <span class="s2">: [open + close]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/* istanbul ignore next */</span>
<span class="s1">function </span><span class="s2">formatProps(props) {</span>
    <span class="s1">const </span><span class="s2">res = []</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">keys = Object.keys(props)</span><span class="s1">;</span>
    <span class="s2">keys.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">3</span><span class="s2">).forEach(key =&gt; {</span>
        <span class="s2">res.push(...formatProp(key</span><span class="s1">, </span><span class="s2">props[key]))</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(keys.length &gt; </span><span class="s4">3</span><span class="s2">) {</span>
        <span class="s2">res.push(</span><span class="s0">` ...`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/* istanbul ignore next */</span>
<span class="s1">function </span><span class="s2">formatProp(key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">raw) {</span>
    <span class="s1">if </span><span class="s2">(shared.isString(value)) {</span>
        <span class="s2">value = JSON.stringify(value)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">raw ? value : [</span><span class="s0">`</span><span class="s2">${key}</span><span class="s0">=</span><span class="s2">${value}</span><span class="s0">`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">value === </span><span class="s0">'number' </span><span class="s2">||</span>
        <span class="s1">typeof </span><span class="s2">value === </span><span class="s0">'boolean' </span><span class="s2">||</span>
        <span class="s2">value == </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">raw ? value : [</span><span class="s0">`</span><span class="s2">${key}</span><span class="s0">=</span><span class="s2">${value}</span><span class="s0">`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(reactivity.isRef(value)) {</span>
        <span class="s2">value = formatProp(key</span><span class="s1">, </span><span class="s2">reactivity.toRaw(value.value)</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">raw ? value : [</span><span class="s0">`</span><span class="s2">${key}</span><span class="s0">=Ref&lt;`</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s0">`&gt;`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(value)) {</span>
        <span class="s1">return </span><span class="s2">[</span><span class="s0">`</span><span class="s2">${key}</span><span class="s0">=fn</span><span class="s2">${value.name ? </span><span class="s0">`&lt;</span><span class="s2">${value.name}</span><span class="s0">&gt;` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">value = reactivity.toRaw(value)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">raw ? value : [</span><span class="s0">`</span><span class="s2">${key}</span><span class="s0">=`</span><span class="s1">, </span><span class="s2">value]</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@internal</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">assertNumber(val</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">if </span><span class="s2">(val === undefined) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">val !== </span><span class="s0">'number'</span><span class="s2">) {</span>
        <span class="s2">warn(</span><span class="s0">`</span><span class="s2">${type} </span><span class="s0">is not a valid number - ` </span><span class="s2">+ </span><span class="s0">`got </span><span class="s2">${JSON.stringify(val)}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(isNaN(val)) {</span>
        <span class="s2">warn(</span><span class="s0">`</span><span class="s2">${type} </span><span class="s0">is NaN - ` </span><span class="s2">+ </span><span class="s0">'the duration expression might be incorrect.'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">ErrorTypeStrings = {</span>
    <span class="s2">[</span><span class="s0">&quot;sp&quot; </span><span class="s3">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s2">]: </span><span class="s0">'serverPrefetch hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;bc&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_CREATE */</span><span class="s2">]: </span><span class="s0">'beforeCreate hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;c&quot; </span><span class="s3">/* LifecycleHooks.CREATED */</span><span class="s2">]: </span><span class="s0">'created hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;bm&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_MOUNT */</span><span class="s2">]: </span><span class="s0">'beforeMount hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;m&quot; </span><span class="s3">/* LifecycleHooks.MOUNTED */</span><span class="s2">]: </span><span class="s0">'mounted hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;bu&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_UPDATE */</span><span class="s2">]: </span><span class="s0">'beforeUpdate hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;u&quot; </span><span class="s3">/* LifecycleHooks.UPDATED */</span><span class="s2">]: </span><span class="s0">'updated'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;bum&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_UNMOUNT */</span><span class="s2">]: </span><span class="s0">'beforeUnmount hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;um&quot; </span><span class="s3">/* LifecycleHooks.UNMOUNTED */</span><span class="s2">]: </span><span class="s0">'unmounted hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;a&quot; </span><span class="s3">/* LifecycleHooks.ACTIVATED */</span><span class="s2">]: </span><span class="s0">'activated hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;da&quot; </span><span class="s3">/* LifecycleHooks.DEACTIVATED */</span><span class="s2">]: </span><span class="s0">'deactivated hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;ec&quot; </span><span class="s3">/* LifecycleHooks.ERROR_CAPTURED */</span><span class="s2">]: </span><span class="s0">'errorCaptured hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;rtc&quot; </span><span class="s3">/* LifecycleHooks.RENDER_TRACKED */</span><span class="s2">]: </span><span class="s0">'renderTracked hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s0">&quot;rtg&quot; </span><span class="s3">/* LifecycleHooks.RENDER_TRIGGERED */</span><span class="s2">]: </span><span class="s0">'renderTriggered hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">0 </span><span class="s3">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">]: </span><span class="s0">'setup function'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">1 </span><span class="s3">/* ErrorCodes.RENDER_FUNCTION */</span><span class="s2">]: </span><span class="s0">'render function'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">2 </span><span class="s3">/* ErrorCodes.WATCH_GETTER */</span><span class="s2">]: </span><span class="s0">'watcher getter'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">3 </span><span class="s3">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s2">]: </span><span class="s0">'watcher callback'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">4 </span><span class="s3">/* ErrorCodes.WATCH_CLEANUP */</span><span class="s2">]: </span><span class="s0">'watcher cleanup function'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">5 </span><span class="s3">/* ErrorCodes.NATIVE_EVENT_HANDLER */</span><span class="s2">]: </span><span class="s0">'native event handler'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">6 </span><span class="s3">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s2">]: </span><span class="s0">'component event handler'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">7 </span><span class="s3">/* ErrorCodes.VNODE_HOOK */</span><span class="s2">]: </span><span class="s0">'vnode hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">8 </span><span class="s3">/* ErrorCodes.DIRECTIVE_HOOK */</span><span class="s2">]: </span><span class="s0">'directive hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">9 </span><span class="s3">/* ErrorCodes.TRANSITION_HOOK */</span><span class="s2">]: </span><span class="s0">'transition hook'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">10 </span><span class="s3">/* ErrorCodes.APP_ERROR_HANDLER */</span><span class="s2">]: </span><span class="s0">'app errorHandler'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">11 </span><span class="s3">/* ErrorCodes.APP_WARN_HANDLER */</span><span class="s2">]: </span><span class="s0">'app warnHandler'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">12 </span><span class="s3">/* ErrorCodes.FUNCTION_REF */</span><span class="s2">]: </span><span class="s0">'ref function'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">13 </span><span class="s3">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span><span class="s2">]: </span><span class="s0">'async component loader'</span><span class="s1">,</span>
    <span class="s2">[</span><span class="s4">14 </span><span class="s3">/* ErrorCodes.SCHEDULER */</span><span class="s2">]: </span><span class="s0">'scheduler flush. This is likely a Vue internals bug. ' </span><span class="s2">+</span>
        <span class="s0">'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args) {</span>
    <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s2">res = args ? fn(...args) : fn()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">(err) {</span>
        <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">callWithAsyncErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(fn)) {</span>
        <span class="s1">const </span><span class="s2">res = callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(res &amp;&amp; shared.isPromise(res)) {</span>
            <span class="s2">res.catch(err =&gt; {</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">values = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; fn.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">values.push(callWithAsyncErrorHandling(fn[i]</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">values</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">throwInDev = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">contextVNode = instance ? instance.vnode : </span><span class="s1">null;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s1">let </span><span class="s2">cur = instance.parent</span><span class="s1">;</span>
        <span class="s3">// the exposed instance is the render proxy to keep it consistent with 2.x</span>
        <span class="s1">const </span><span class="s2">exposedInstance = instance.proxy</span><span class="s1">;</span>
        <span class="s3">// in production the hook receives only the error code</span>
        <span class="s1">const </span><span class="s2">errorInfo = ErrorTypeStrings[type] </span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(cur) {</span>
            <span class="s1">const </span><span class="s2">errorCapturedHooks = cur.ec</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(errorCapturedHooks) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; errorCapturedHooks.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">if </span><span class="s2">(errorCapturedHooks[i](err</span><span class="s1">, </span><span class="s2">exposedInstance</span><span class="s1">, </span><span class="s2">errorInfo) === </span><span class="s1">false</span><span class="s2">) {</span>
                        <span class="s1">return;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">cur = cur.parent</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// app-level handling</span>
        <span class="s1">const </span><span class="s2">appErrorHandler = instance.appContext.config.errorHandler</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(appErrorHandler) {</span>
            <span class="s2">callWithErrorHandling(appErrorHandler</span><span class="s1">, null, </span><span class="s4">10 </span><span class="s3">/* ErrorCodes.APP_ERROR_HANDLER */</span><span class="s1">, </span><span class="s2">[err</span><span class="s1">, </span><span class="s2">exposedInstance</span><span class="s1">, </span><span class="s2">errorInfo])</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">logError(err</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">contextVNode</span><span class="s1">, </span><span class="s2">throwInDev)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">logError(err</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">contextVNode</span><span class="s1">, </span><span class="s2">throwInDev = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">info = ErrorTypeStrings[type]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(contextVNode) {</span>
            <span class="s2">pushWarningContext(contextVNode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">warn(</span><span class="s0">`Unhandled error</span><span class="s2">${info ? </span><span class="s0">` during execution of </span><span class="s2">${info}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(contextVNode) {</span>
            <span class="s2">popWarningContext()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// crash in dev by default so it's more noticeable</span>
        <span class="s1">if </span><span class="s2">(throwInDev) {</span>
            <span class="s1">throw </span><span class="s2">err</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">console.error(err)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">let </span><span class="s2">isFlushing = </span><span class="s1">false;</span>
<span class="s1">let </span><span class="s2">isFlushPending = </span><span class="s1">false;</span>
<span class="s1">const </span><span class="s2">queue = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">flushIndex = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">pendingPostFlushCbs = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">activePostFlushCbs = </span><span class="s1">null;</span>
<span class="s1">let </span><span class="s2">postFlushIndex = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">resolvedPromise = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">Promise.resolve()</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">currentFlushPromise = </span><span class="s1">null;</span>
<span class="s1">const </span><span class="s2">RECURSION_LIMIT = </span><span class="s4">100</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">nextTick(fn) {</span>
    <span class="s1">const </span><span class="s2">p = currentFlushPromise || resolvedPromise</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">fn ? p.then(</span><span class="s1">this </span><span class="s2">? fn.bind(</span><span class="s1">this</span><span class="s2">) : fn) : p</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// #2768</span>
<span class="s3">// Use binary-search to find a suitable position in the queue,</span>
<span class="s3">// so that the queue maintains the increasing order of job's id,</span>
<span class="s3">// which can prevent the job from being skipped and also can avoid repeated patching.</span>
<span class="s1">function </span><span class="s2">findInsertionIndex(id) {</span>
    <span class="s3">// the start index should be `flushIndex + 1`</span>
    <span class="s1">let </span><span class="s2">start = flushIndex + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">end = queue.length</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(start &lt; end) {</span>
        <span class="s1">const </span><span class="s2">middle = (start + end) &gt;&gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">middleJobId = getId(queue[middle])</span><span class="s1">;</span>
        <span class="s2">middleJobId &lt; id ? (start = middle + </span><span class="s4">1</span><span class="s2">) : (end = middle)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">start</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueJob(job) {</span>
    <span class="s3">// the dedupe search uses the startIndex argument of Array.includes()</span>
    <span class="s3">// by default the search index includes the current job that is being run</span>
    <span class="s3">// so it cannot recursively trigger itself again.</span>
    <span class="s3">// if the job is a watch() callback, the search will start with a +1 index to</span>
    <span class="s3">// allow it recursively trigger itself - it is the user's responsibility to</span>
    <span class="s3">// ensure it doesn't end up in an infinite loop.</span>
    <span class="s1">if </span><span class="s2">(!queue.length ||</span>
        <span class="s2">!queue.includes(job</span><span class="s1">, </span><span class="s2">isFlushing &amp;&amp; job.allowRecurse ? flushIndex + </span><span class="s4">1 </span><span class="s2">: flushIndex)) {</span>
        <span class="s1">if </span><span class="s2">(job.id == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">queue.push(job)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">queue.splice(findInsertionIndex(job.id)</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s2">job)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">queueFlush()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueFlush() {</span>
    <span class="s1">if </span><span class="s2">(!isFlushing &amp;&amp; !isFlushPending) {</span>
        <span class="s2">isFlushPending = </span><span class="s1">true;</span>
        <span class="s2">currentFlushPromise = resolvedPromise.then(flushJobs)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invalidateJob(job) {</span>
    <span class="s1">const </span><span class="s2">i = queue.indexOf(job)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(i &gt; flushIndex) {</span>
        <span class="s2">queue.splice(i</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queuePostFlushCb(cb) {</span>
    <span class="s1">if </span><span class="s2">(!shared.isArray(cb)) {</span>
        <span class="s1">if </span><span class="s2">(!activePostFlushCbs ||</span>
            <span class="s2">!activePostFlushCbs.includes(cb</span><span class="s1">, </span><span class="s2">cb.allowRecurse ? postFlushIndex + </span><span class="s4">1 </span><span class="s2">: postFlushIndex)) {</span>
            <span class="s2">pendingPostFlushCbs.push(cb)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// if cb is an array, it is a component lifecycle hook which can only be</span>
        <span class="s3">// triggered by a job, which is already deduped in the main queue, so</span>
        <span class="s3">// we can skip duplicate check here to improve perf</span>
        <span class="s2">pendingPostFlushCbs.push(...cb)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">queueFlush()</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">flushPreFlushCbs(seen</span><span class="s1">, </span>
<span class="s3">// if currently flushing, skip the current job itself</span>
<span class="s2">i = isFlushing ? flushIndex + </span><span class="s4">1 </span><span class="s2">: </span><span class="s4">0</span><span class="s2">) {</span>
    <span class="s2">{</span>
        <span class="s2">seen = seen || </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">; </span><span class="s2">i &lt; queue.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">cb = queue[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(cb &amp;&amp; cb.pre) {</span>
            <span class="s1">if </span><span class="s2">(checkRecursiveUpdates(seen</span><span class="s1">, </span><span class="s2">cb)) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s2">queue.splice(i</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">i--</span><span class="s1">;</span>
            <span class="s2">cb()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">flushPostFlushCbs(seen) {</span>
    <span class="s1">if </span><span class="s2">(pendingPostFlushCbs.length) {</span>
        <span class="s1">const </span><span class="s2">deduped = [...</span><span class="s1">new </span><span class="s2">Set(pendingPostFlushCbs)]</span><span class="s1">;</span>
        <span class="s2">pendingPostFlushCbs.length = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">// #1947 already has active queue, nested flushPostFlushCbs call</span>
        <span class="s1">if </span><span class="s2">(activePostFlushCbs) {</span>
            <span class="s2">activePostFlushCbs.push(...deduped)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">activePostFlushCbs = deduped</span><span class="s1">;</span>
        <span class="s2">{</span>
            <span class="s2">seen = seen || </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">activePostFlushCbs.sort((a</span><span class="s1">, </span><span class="s2">b) =&gt; getId(a) - getId(b))</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(postFlushIndex = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">postFlushIndex &lt; activePostFlushCbs.length</span><span class="s1">; </span><span class="s2">postFlushIndex++) {</span>
            <span class="s1">if </span><span class="s2">(checkRecursiveUpdates(seen</span><span class="s1">, </span><span class="s2">activePostFlushCbs[postFlushIndex])) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s2">activePostFlushCbs[postFlushIndex]()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">activePostFlushCbs = </span><span class="s1">null;</span>
        <span class="s2">postFlushIndex = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">getId = (job) =&gt; job.id == </span><span class="s1">null </span><span class="s2">? Infinity : job.id</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">comparator = (a</span><span class="s1">, </span><span class="s2">b) =&gt; {</span>
    <span class="s1">const </span><span class="s2">diff = getId(a) - getId(b)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(diff === </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(a.pre &amp;&amp; !b.pre)</span>
            <span class="s1">return </span><span class="s2">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(b.pre &amp;&amp; !a.pre)</span>
            <span class="s1">return </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">diff</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">flushJobs(seen) {</span>
    <span class="s2">isFlushPending = </span><span class="s1">false;</span>
    <span class="s2">isFlushing = </span><span class="s1">true;</span>
    <span class="s2">{</span>
        <span class="s2">seen = seen || </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// Sort queue before flush.</span>
    <span class="s3">// This ensures that:</span>
    <span class="s3">// 1. Components are updated from parent to child. (because parent is always</span>
    <span class="s3">//    created before the child so its render effect will have smaller</span>
    <span class="s3">//    priority number)</span>
    <span class="s3">// 2. If a component is unmounted during a parent component's update,</span>
    <span class="s3">//    its update can be skipped.</span>
    <span class="s2">queue.sort(comparator)</span><span class="s1">;</span>
    <span class="s3">// conditional usage of checkRecursiveUpdate must be determined out of</span>
    <span class="s3">// try ... catch block since Rollup by default de-optimizes treeshaking</span>
    <span class="s3">// inside try-catch. This can leave all warning code unshaked. Although</span>
    <span class="s3">// they would get eventually shaken by a minifier like terser, some minifiers</span>
    <span class="s3">// would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)</span>
    <span class="s1">const </span><span class="s2">check = (job) =&gt; checkRecursiveUpdates(seen</span><span class="s1">, </span><span class="s2">job)</span>
        <span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s1">for </span><span class="s2">(flushIndex = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">flushIndex &lt; queue.length</span><span class="s1">; </span><span class="s2">flushIndex++) {</span>
            <span class="s1">const </span><span class="s2">job = queue[flushIndex]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(job &amp;&amp; job.active !== </span><span class="s1">false</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(</span><span class="s1">true </span><span class="s2">&amp;&amp; check(job)) {</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s3">// console.log(`running:`, job.id)</span>
                <span class="s2">callWithErrorHandling(job</span><span class="s1">, null, </span><span class="s4">14 </span><span class="s3">/* ErrorCodes.SCHEDULER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">finally </span><span class="s2">{</span>
        <span class="s2">flushIndex = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">queue.length = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs(seen)</span><span class="s1">;</span>
        <span class="s2">isFlushing = </span><span class="s1">false;</span>
        <span class="s2">currentFlushPromise = </span><span class="s1">null;</span>
        <span class="s3">// some postFlushCb queued jobs!</span>
        <span class="s3">// keep flushing until it drains.</span>
        <span class="s1">if </span><span class="s2">(queue.length || pendingPostFlushCbs.length) {</span>
            <span class="s2">flushJobs(seen)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">checkRecursiveUpdates(seen</span><span class="s1">, </span><span class="s2">fn) {</span>
    <span class="s1">if </span><span class="s2">(!seen.has(fn)) {</span>
        <span class="s2">seen.set(fn</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">count = seen.get(fn)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(count &gt; RECURSION_LIMIT) {</span>
            <span class="s1">const </span><span class="s2">instance = fn.ownerInstance</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">componentName = instance &amp;&amp; getComponentName(instance.type)</span><span class="s1">;</span>
            <span class="s2">warn(</span><span class="s0">`Maximum recursive updates exceeded</span><span class="s2">${componentName ? </span><span class="s0">` in component &lt;</span><span class="s2">${componentName}</span><span class="s0">&gt;` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">. ` </span><span class="s2">+</span>
                <span class="s0">`This means you have a reactive effect that is mutating its own ` </span><span class="s2">+</span>
                <span class="s0">`dependencies and thus recursively triggering itself. Possible sources ` </span><span class="s2">+</span>
                <span class="s0">`include component template, render function, updated hook or ` </span><span class="s2">+</span>
                <span class="s0">`watcher source function.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">seen.set(fn</span><span class="s1">, </span><span class="s2">count + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">/* eslint-disable no-restricted-globals */</span>
<span class="s1">let </span><span class="s2">isHmrUpdating = </span><span class="s1">false;</span>
<span class="s1">const </span><span class="s2">hmrDirtyComponents = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
<span class="s3">// Expose the HMR runtime on the global object</span>
<span class="s3">// This makes it entirely tree-shakable without polluting the exports and makes</span>
<span class="s3">// it easier to be used in toolings like vue-loader</span>
<span class="s3">// Note: for a component to be eligible for HMR it also needs the __hmrId option</span>
<span class="s3">// to be set so that its instances can be registered / removed.</span>
<span class="s2">{</span>
    <span class="s2">shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {</span>
        <span class="s2">createRecord: tryWrap(createRecord)</span><span class="s1">,</span>
        <span class="s2">rerender: tryWrap(rerender)</span><span class="s1">,</span>
        <span class="s2">reload: tryWrap(reload)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">map = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">registerHMR(instance) {</span>
    <span class="s1">const </span><span class="s2">id = instance.type.__hmrId</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">record = map.get(id)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!record) {</span>
        <span class="s2">createRecord(id</span><span class="s1">, </span><span class="s2">instance.type)</span><span class="s1">;</span>
        <span class="s2">record = map.get(id)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">record.instances.add(instance)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">unregisterHMR(instance) {</span>
    <span class="s2">map.get(instance.type.__hmrId).instances.delete(instance)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createRecord(id</span><span class="s1">, </span><span class="s2">initialDef) {</span>
    <span class="s1">if </span><span class="s2">(map.has(id)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s2">map.set(id</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">initialDef: normalizeClassComponent(initialDef)</span><span class="s1">,</span>
        <span class="s2">instances: </span><span class="s1">new </span><span class="s2">Set()</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeClassComponent(component) {</span>
    <span class="s1">return </span><span class="s2">isClassComponent(component) ? component.__vccOpts : component</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">rerender(id</span><span class="s1">, </span><span class="s2">newRender) {</span>
    <span class="s1">const </span><span class="s2">record = map.get(id)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!record) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s3">// update initial record (for not-yet-rendered component)</span>
    <span class="s2">record.initialDef.render = newRender</span><span class="s1">;</span>
    <span class="s2">[...record.instances].forEach(instance =&gt; {</span>
        <span class="s1">if </span><span class="s2">(newRender) {</span>
            <span class="s2">instance.render = newRender</span><span class="s1">;</span>
            <span class="s2">normalizeClassComponent(instance.type).render = newRender</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">instance.renderCache = []</span><span class="s1">;</span>
        <span class="s3">// this flag forces child components with slot content to update</span>
        <span class="s2">isHmrUpdating = </span><span class="s1">true;</span>
        <span class="s2">instance.update()</span><span class="s1">;</span>
        <span class="s2">isHmrUpdating = </span><span class="s1">false;</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">reload(id</span><span class="s1">, </span><span class="s2">newComp) {</span>
    <span class="s1">const </span><span class="s2">record = map.get(id)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!record)</span>
        <span class="s1">return;</span>
    <span class="s2">newComp = normalizeClassComponent(newComp)</span><span class="s1">;</span>
    <span class="s3">// update initial def (for not-yet-rendered components)</span>
    <span class="s2">updateComponentDef(record.initialDef</span><span class="s1">, </span><span class="s2">newComp)</span><span class="s1">;</span>
    <span class="s3">// create a snapshot which avoids the set being mutated during updates</span>
    <span class="s1">const </span><span class="s2">instances = [...record.instances]</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">instance of instances) {</span>
        <span class="s1">const </span><span class="s2">oldComp = normalizeClassComponent(instance.type)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!hmrDirtyComponents.has(oldComp)) {</span>
            <span class="s3">// 1. Update existing comp definition to match new one</span>
            <span class="s1">if </span><span class="s2">(oldComp !== record.initialDef) {</span>
                <span class="s2">updateComponentDef(oldComp</span><span class="s1">, </span><span class="s2">newComp)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// 2. mark definition dirty. This forces the renderer to replace the</span>
            <span class="s3">// component on patch.</span>
            <span class="s2">hmrDirtyComponents.add(oldComp)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// 3. invalidate options resolution cache</span>
        <span class="s2">instance.appContext.optionsCache.delete(instance.type)</span><span class="s1">;</span>
        <span class="s3">// 4. actually update</span>
        <span class="s1">if </span><span class="s2">(instance.ceReload) {</span>
            <span class="s3">// custom element</span>
            <span class="s2">hmrDirtyComponents.add(oldComp)</span><span class="s1">;</span>
            <span class="s2">instance.ceReload(newComp.styles)</span><span class="s1">;</span>
            <span class="s2">hmrDirtyComponents.delete(oldComp)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(instance.parent) {</span>
            <span class="s3">// 4. Force the parent instance to re-render. This will cause all updated</span>
            <span class="s3">// components to be unmounted and re-mounted. Queue the update so that we</span>
            <span class="s3">// don't end up forcing the same parent to re-render multiple times.</span>
            <span class="s2">queueJob(instance.parent.update)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(instance.appContext.reload) {</span>
            <span class="s3">// root instance mounted via createApp() has a reload method</span>
            <span class="s2">instance.appContext.reload()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined'</span><span class="s2">) {</span>
            <span class="s3">// root instance inside tree created via raw render(). Force reload.</span>
            <span class="s2">window.location.reload()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">console.warn(</span><span class="s0">'[HMR] Root or manually mounted instance modified. Full reload required.'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// 5. make sure to cleanup dirty hmr components after update</span>
    <span class="s2">queuePostFlushCb(() =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">instance of instances) {</span>
            <span class="s2">hmrDirtyComponents.delete(normalizeClassComponent(instance.type))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">updateComponentDef(oldComp</span><span class="s1">, </span><span class="s2">newComp) {</span>
    <span class="s2">shared.extend(oldComp</span><span class="s1">, </span><span class="s2">newComp)</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">oldComp) {</span>
        <span class="s1">if </span><span class="s2">(key !== </span><span class="s0">'__file' </span><span class="s2">&amp;&amp; !(key </span><span class="s1">in </span><span class="s2">newComp)) {</span>
            <span class="s1">delete </span><span class="s2">oldComp[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">tryWrap(fn) {</span>
    <span class="s1">return </span><span class="s2">(id</span><span class="s1">, </span><span class="s2">arg) =&gt; {</span>
        <span class="s1">try </span><span class="s2">{</span>
            <span class="s1">return </span><span class="s2">fn(id</span><span class="s1">, </span><span class="s2">arg)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">catch </span><span class="s2">(e) {</span>
            <span class="s2">console.error(e)</span><span class="s1">;</span>
            <span class="s2">console.warn(</span><span class="s0">`[HMR] Something went wrong during Vue component hot-reload. ` </span><span class="s2">+</span>
                <span class="s0">`Full reload required.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">exports.devtools = </span><span class="s1">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">buffer = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">devtoolsNotInstalled = </span><span class="s1">false;</span>
<span class="s1">function </span><span class="s2">emit$1(event</span><span class="s1">, </span><span class="s2">...args) {</span>
    <span class="s1">if </span><span class="s2">(exports.devtools) {</span>
        <span class="s2">exports.devtools.emit(event</span><span class="s1">, </span><span class="s2">...args)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(!devtoolsNotInstalled) {</span>
        <span class="s2">buffer.push({ event</span><span class="s1">, </span><span class="s2">args })</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setDevtoolsHook(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s1">var </span><span class="s2">_a</span><span class="s1">, </span><span class="s2">_b</span><span class="s1">;</span>
    <span class="s2">exports.devtools = hook</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(exports.devtools) {</span>
        <span class="s2">exports.devtools.enabled = </span><span class="s1">true;</span>
        <span class="s2">buffer.forEach(({ event</span><span class="s1">, </span><span class="s2">args }) =&gt; exports.devtools.emit(event</span><span class="s1">, </span><span class="s2">...args))</span><span class="s1">;</span>
        <span class="s2">buffer = []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span>
    <span class="s3">// handle late devtools injection - only do this if we are in an actual</span>
    <span class="s3">// browser environment to avoid the timer handle stalling test runner exit</span>
    <span class="s3">// (#4815)</span>
    <span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp;</span>
        <span class="s3">// some envs mock window but not fully</span>
        <span class="s2">window.HTMLElement &amp;&amp;</span>
        <span class="s3">// also exclude jsdom</span>
        <span class="s2">!((_b = (_a = window.navigator) === </span><span class="s1">null </span><span class="s2">|| _a === </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">: _a.userAgent) === </span><span class="s1">null </span><span class="s2">|| _b === </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">: _b.includes(</span><span class="s0">'jsdom'</span><span class="s2">))) {</span>
        <span class="s1">const </span><span class="s2">replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =</span>
            <span class="s2">target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [])</span><span class="s1">;</span>
        <span class="s2">replay.push((newHook) =&gt; {</span>
            <span class="s2">setDevtoolsHook(newHook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">// clear buffer after 3s - the user probably doesn't have devtools installed</span>
        <span class="s3">// at all, and keeping the buffer will cause memory leaks (#4738)</span>
        <span class="s2">setTimeout(() =&gt; {</span>
            <span class="s1">if </span><span class="s2">(!exports.devtools) {</span>
                <span class="s2">target.__VUE_DEVTOOLS_HOOK_REPLAY__ = </span><span class="s1">null;</span>
                <span class="s2">devtoolsNotInstalled = </span><span class="s1">true;</span>
                <span class="s2">buffer = []</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">, </span><span class="s4">3000</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// non-browser env, assume not installed</span>
        <span class="s2">devtoolsNotInstalled = </span><span class="s1">true;</span>
        <span class="s2">buffer = []</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">devtoolsInitApp(app</span><span class="s1">, </span><span class="s2">version) {</span>
    <span class="s2">emit$1(</span><span class="s0">&quot;app:init&quot; </span><span class="s3">/* DevtoolsHooks.APP_INIT */</span><span class="s1">, </span><span class="s2">app</span><span class="s1">, </span><span class="s2">version</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">Fragment</span><span class="s1">,</span>
        <span class="s2">Text</span><span class="s1">,</span>
        <span class="s2">Comment</span><span class="s1">,</span>
        <span class="s2">Static</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">devtoolsUnmountApp(app) {</span>
    <span class="s2">emit$1(</span><span class="s0">&quot;app:unmount&quot; </span><span class="s3">/* DevtoolsHooks.APP_UNMOUNT */</span><span class="s1">, </span><span class="s2">app)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">devtoolsComponentAdded = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">createDevtoolsComponentHook(</span><span class="s0">&quot;component:added&quot; </span><span class="s3">/* DevtoolsHooks.COMPONENT_ADDED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">devtoolsComponentUpdated = </span>
<span class="s3">/*#__PURE__*/ </span><span class="s2">createDevtoolsComponentHook(</span><span class="s0">&quot;component:updated&quot; </span><span class="s3">/* DevtoolsHooks.COMPONENT_UPDATED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">_devtoolsComponentRemoved = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">createDevtoolsComponentHook(</span><span class="s0">&quot;component:removed&quot; </span><span class="s3">/* DevtoolsHooks.COMPONENT_REMOVED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">devtoolsComponentRemoved = (component) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(exports.devtools &amp;&amp;</span>
        <span class="s1">typeof </span><span class="s2">exports.devtools.cleanupBuffer === </span><span class="s0">'function' </span><span class="s2">&amp;&amp;</span>
        <span class="s3">// remove the component if it wasn't buffered</span>
        <span class="s2">!exports.devtools.cleanupBuffer(component)) {</span>
        <span class="s2">_devtoolsComponentRemoved(component)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createDevtoolsComponentHook(hook) {</span>
    <span class="s1">return </span><span class="s2">(component) =&gt; {</span>
        <span class="s2">emit$1(hook</span><span class="s1">, </span><span class="s2">component.appContext.app</span><span class="s1">, </span><span class="s2">component.uid</span><span class="s1">, </span><span class="s2">component.parent ? component.parent.uid : undefined</span><span class="s1">, </span><span class="s2">component)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">devtoolsPerfStart = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">createDevtoolsPerformanceHook(</span><span class="s0">&quot;perf:start&quot; </span><span class="s3">/* DevtoolsHooks.PERFORMANCE_START */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">devtoolsPerfEnd = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">createDevtoolsPerformanceHook(</span><span class="s0">&quot;perf:end&quot; </span><span class="s3">/* DevtoolsHooks.PERFORMANCE_END */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createDevtoolsPerformanceHook(hook) {</span>
    <span class="s1">return </span><span class="s2">(component</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">time) =&gt; {</span>
        <span class="s2">emit$1(hook</span><span class="s1">, </span><span class="s2">component.appContext.app</span><span class="s1">, </span><span class="s2">component.uid</span><span class="s1">, </span><span class="s2">component</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">time)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">devtoolsComponentEmit(component</span><span class="s1">, </span><span class="s2">event</span><span class="s1">, </span><span class="s2">params) {</span>
    <span class="s2">emit$1(</span><span class="s0">&quot;component:emit&quot; </span><span class="s3">/* DevtoolsHooks.COMPONENT_EMIT */</span><span class="s1">, </span><span class="s2">component.appContext.app</span><span class="s1">, </span><span class="s2">component</span><span class="s1">, </span><span class="s2">event</span><span class="s1">, </span><span class="s2">params)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">emit(instance</span><span class="s1">, </span><span class="s2">event</span><span class="s1">, </span><span class="s2">...rawArgs) {</span>
    <span class="s1">if </span><span class="s2">(instance.isUnmounted)</span>
        <span class="s1">return;</span>
    <span class="s1">const </span><span class="s2">props = instance.vnode.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">{ emitsOptions</span><span class="s1">, </span><span class="s2">propsOptions: [propsOptions] } = instance</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(emitsOptions) {</span>
            <span class="s1">if </span><span class="s2">(!(event </span><span class="s1">in </span><span class="s2">emitsOptions) &amp;&amp;</span>
                <span class="s2">!(</span><span class="s1">false </span><span class="s2">)) {</span>
                <span class="s1">if </span><span class="s2">(!propsOptions || !(shared.toHandlerKey(event) </span><span class="s1">in </span><span class="s2">propsOptions)) {</span>
                    <span class="s2">warn(</span><span class="s0">`Component emitted event &quot;</span><span class="s2">${event}</span><span class="s0">&quot; but it is neither declared in ` </span><span class="s2">+</span>
                        <span class="s0">`the emits option nor as an &quot;</span><span class="s2">${shared.toHandlerKey(event)}</span><span class="s0">&quot; prop.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">const </span><span class="s2">validator = emitsOptions[event]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(shared.isFunction(validator)) {</span>
                    <span class="s1">const </span><span class="s2">isValid = validator(...rawArgs)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(!isValid) {</span>
                        <span class="s2">warn(</span><span class="s0">`Invalid event arguments: event validation failed for event &quot;</span><span class="s2">${event}</span><span class="s0">&quot;.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">args = rawArgs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isModelListener = event.startsWith(</span><span class="s0">'update:'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">// for v-model update:xxx events, apply modifiers on args</span>
    <span class="s1">const </span><span class="s2">modelArg = isModelListener &amp;&amp; event.slice(</span><span class="s4">7</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(modelArg &amp;&amp; modelArg </span><span class="s1">in </span><span class="s2">props) {</span>
        <span class="s1">const </span><span class="s2">modifiersKey = </span><span class="s0">`</span><span class="s2">${modelArg === </span><span class="s0">'modelValue' </span><span class="s2">? </span><span class="s0">'model' </span><span class="s2">: modelArg}</span><span class="s0">Modifiers`</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ number</span><span class="s1">, </span><span class="s2">trim } = props[modifiersKey] || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trim) {</span>
            <span class="s2">args = rawArgs.map(a =&gt; (shared.isString(a) ? a.trim() : a))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(number) {</span>
            <span class="s2">args = rawArgs.map(shared.looseToNumber)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s2">devtoolsComponentEmit(instance</span><span class="s1">, </span><span class="s2">event</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">lowerCaseEvent = event.toLowerCase()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(lowerCaseEvent !== event &amp;&amp; props[shared.toHandlerKey(lowerCaseEvent)]) {</span>
            <span class="s2">warn(</span><span class="s0">`Event &quot;</span><span class="s2">${lowerCaseEvent}</span><span class="s0">&quot; is emitted in component ` </span><span class="s2">+</span>
                <span class="s0">`</span><span class="s2">${formatComponentName(instance</span><span class="s1">, </span><span class="s2">instance.type)} </span><span class="s0">but the handler is registered for &quot;</span><span class="s2">${event}</span><span class="s0">&quot;. ` </span><span class="s2">+</span>
                <span class="s0">`Note that HTML attributes are case-insensitive and you cannot use ` </span><span class="s2">+</span>
                <span class="s0">`v-on to listen to camelCase events when using in-DOM templates. ` </span><span class="s2">+</span>
                <span class="s0">`You should probably use &quot;</span><span class="s2">${shared.hyphenate(event)}</span><span class="s0">&quot; instead of &quot;</span><span class="s2">${event}</span><span class="s0">&quot;.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">handlerName</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">handler = props[(handlerName = shared.toHandlerKey(event))] ||</span>
        <span class="s3">// also try camelCase event handler (#2249)</span>
        <span class="s2">props[(handlerName = shared.toHandlerKey(shared.camelize(event)))]</span><span class="s1">;</span>
    <span class="s3">// for v-model update:xxx events, also trigger kebab-case equivalent</span>
    <span class="s3">// for props passed via kebab-case</span>
    <span class="s1">if </span><span class="s2">(!handler &amp;&amp; isModelListener) {</span>
        <span class="s2">handler = props[(handlerName = shared.toHandlerKey(shared.hyphenate(event)))]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(handler) {</span>
        <span class="s2">callWithAsyncErrorHandling(handler</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">6 </span><span class="s3">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">onceHandler = props[handlerName + </span><span class="s0">`Once`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(onceHandler) {</span>
        <span class="s1">if </span><span class="s2">(!instance.emitted) {</span>
            <span class="s2">instance.emitted = {}</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(instance.emitted[handlerName]) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">instance.emitted[handlerName] = </span><span class="s1">true;</span>
        <span class="s2">callWithAsyncErrorHandling(onceHandler</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">6 </span><span class="s3">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeEmitsOptions(comp</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">cache = appContext.emitsCache</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(comp)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached !== undefined) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">raw = comp.emits</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">normalized = {}</span><span class="s1">;</span>
    <span class="s3">// apply mixin/extends props</span>
    <span class="s1">let </span><span class="s2">hasExtends = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(!shared.isFunction(comp)) {</span>
        <span class="s1">const </span><span class="s2">extendEmits = (raw) =&gt; {</span>
            <span class="s1">const </span><span class="s2">normalizedFromExtend = normalizeEmitsOptions(raw</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(normalizedFromExtend) {</span>
                <span class="s2">hasExtends = </span><span class="s1">true;</span>
                <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">normalizedFromExtend)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s2">appContext.mixins.forEach(extendEmits)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.extends) {</span>
            <span class="s2">extendEmits(comp.extends)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.mixins) {</span>
            <span class="s2">comp.mixins.forEach(extendEmits)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
            <span class="s2">cache.set(comp</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return null;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s2">raw.forEach(key =&gt; (normalized[key] = </span><span class="s1">null</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
        <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">normalized)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">normalized</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// Check if an incoming prop key is a declared emit event listener.</span>
<span class="s3">// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are</span>
<span class="s3">// both considered matched listeners.</span>
<span class="s1">function </span><span class="s2">isEmitListener(options</span><span class="s1">, </span><span class="s2">key) {</span>
    <span class="s1">if </span><span class="s2">(!options || !shared.isOn(key)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s2">key = key.slice(</span><span class="s4">2</span><span class="s2">).replace(</span><span class="s4">/Once$/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(shared.hasOwn(options</span><span class="s1">, </span><span class="s2">key[</span><span class="s4">0</span><span class="s2">].toLowerCase() + key.slice(</span><span class="s4">1</span><span class="s2">)) ||</span>
        <span class="s2">shared.hasOwn(options</span><span class="s1">, </span><span class="s2">shared.hyphenate(key)) ||</span>
        <span class="s2">shared.hasOwn(options</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* mark the current rendering instance for asset resolution (e.g.</span>
 <span class="s5">* resolveComponent, resolveDirective) during render</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">currentRenderingInstance = </span><span class="s1">null;</span>
<span class="s1">let </span><span class="s2">currentScopeId = </span><span class="s1">null;</span>
<span class="s5">/**</span>
 <span class="s5">* Note: rendering calls maybe nested. The function returns the parent rendering</span>
 <span class="s5">* instance if present, which should be restored after the render is done:</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* const prev = setCurrentRenderingInstance(i)</span>
 <span class="s5">* // ...render</span>
 <span class="s5">* setCurrentRenderingInstance(prev)</span>
 <span class="s5">* ```</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">setCurrentRenderingInstance(instance) {</span>
    <span class="s1">const </span><span class="s2">prev = currentRenderingInstance</span><span class="s1">;</span>
    <span class="s2">currentRenderingInstance = instance</span><span class="s1">;</span>
    <span class="s2">currentScopeId = (instance &amp;&amp; instance.type.__scopeId) || </span><span class="s1">null;</span>
    <span class="s1">return </span><span class="s2">prev</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Set scope id when creating hoisted vnodes.</span>
 <span class="s5">* </span><span class="s6">@private </span><span class="s5">compiler helper</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">pushScopeId(id) {</span>
    <span class="s2">currentScopeId = id</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Technically we no longer need this after 3.0.8 but we need to keep the same</span>
 <span class="s5">* API for backwards compat w/ code generated by compilers.</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">popScopeId() {</span>
    <span class="s2">currentScopeId = </span><span class="s1">null;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Only for backwards compat</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">withScopeId = (_id) =&gt; withCtx</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Wrap a slot function to memoize current rendering instance</span>
 <span class="s5">* </span><span class="s6">@private </span><span class="s5">compiler helper</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">withCtx(fn</span><span class="s1">, </span><span class="s2">ctx = currentRenderingInstance</span><span class="s1">, </span><span class="s2">isNonScopedSlot </span><span class="s3">// false only</span>
<span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(!ctx)</span>
        <span class="s1">return </span><span class="s2">fn</span><span class="s1">;</span>
    <span class="s3">// already normalized</span>
    <span class="s1">if </span><span class="s2">(fn._n) {</span>
        <span class="s1">return </span><span class="s2">fn</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">renderFnWithContext = (...args) =&gt; {</span>
        <span class="s3">// If a user calls a compiled slot inside a template expression (#1745), it</span>
        <span class="s3">// can mess up block tracking, so by default we disable block tracking and</span>
        <span class="s3">// force bail out when invoking a compiled slot (indicated by the ._d flag).</span>
        <span class="s3">// This isn't necessary if rendering a compiled `&lt;slot&gt;`, so we flip the</span>
        <span class="s3">// ._d flag off when invoking the wrapped fn inside `renderSlot`.</span>
        <span class="s1">if </span><span class="s2">(renderFnWithContext._d) {</span>
            <span class="s2">setBlockTracking(-</span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">prevInstance = setCurrentRenderingInstance(ctx)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
        <span class="s1">try </span><span class="s2">{</span>
            <span class="s2">res = fn(...args)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">finally </span><span class="s2">{</span>
            <span class="s2">setCurrentRenderingInstance(prevInstance)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(renderFnWithContext._d) {</span>
                <span class="s2">setBlockTracking(</span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">{</span>
            <span class="s2">devtoolsComponentUpdated(ctx)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// mark normalized to avoid duplicated wrapping</span>
    <span class="s2">renderFnWithContext._n = </span><span class="s1">true;</span>
    <span class="s3">// mark this as compiled by default</span>
    <span class="s3">// this is used in vnode.ts -&gt; normalizeChildren() to set the slot</span>
    <span class="s3">// rendering flag.</span>
    <span class="s2">renderFnWithContext._c = </span><span class="s1">true;</span>
    <span class="s3">// disable block tracking by default</span>
    <span class="s2">renderFnWithContext._d = </span><span class="s1">true;</span>
    <span class="s1">return </span><span class="s2">renderFnWithContext</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* dev only flag to track whether $attrs was used during render.</span>
 <span class="s5">* If $attrs was used during render then the warning for failed attrs</span>
 <span class="s5">* fallthrough can be suppressed.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">accessedAttrs = </span><span class="s1">false;</span>
<span class="s1">function </span><span class="s2">markAttrsAccessed() {</span>
    <span class="s2">accessedAttrs = </span><span class="s1">true;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">renderComponentRoot(instance) {</span>
    <span class="s1">const </span><span class="s2">{ type: Component</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">proxy</span><span class="s1">, </span><span class="s2">withProxy</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">propsOptions: [propsOptions]</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">attrs</span><span class="s1">, </span><span class="s2">emit</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">renderCache</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">inheritAttrs } = instance</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">result</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">fallthroughAttrs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">prev = setCurrentRenderingInstance(instance)</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">accessedAttrs = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">) {</span>
            <span class="s3">// withProxy is a proxy with a different `has` trap only for</span>
            <span class="s3">// runtime-compiled render functions using `with` block.</span>
            <span class="s1">const </span><span class="s2">proxyToUse = withProxy || proxy</span><span class="s1">;</span>
            <span class="s2">result = normalizeVNode(render.call(proxyToUse</span><span class="s1">, </span><span class="s2">proxyToUse</span><span class="s1">, </span><span class="s2">renderCache</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">ctx))</span><span class="s1">;</span>
            <span class="s2">fallthroughAttrs = attrs</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// functional</span>
            <span class="s1">const </span><span class="s2">render = Component</span><span class="s1">;</span>
            <span class="s3">// in dev, mark attrs accessed if optional props (attrs === props)</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s1">true </span><span class="s2">&amp;&amp; attrs === props) {</span>
                <span class="s2">markAttrsAccessed()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">result = normalizeVNode(render.length &gt; </span><span class="s4">1</span>
                <span class="s2">? render(props</span><span class="s1">, true</span>
                    <span class="s2">? {</span>
                        <span class="s2">get attrs() {</span>
                            <span class="s2">markAttrsAccessed()</span><span class="s1">;</span>
                            <span class="s1">return </span><span class="s2">attrs</span><span class="s1">;</span>
                        <span class="s2">}</span><span class="s1">,</span>
                        <span class="s2">slots</span><span class="s1">,</span>
                        <span class="s2">emit</span>
                    <span class="s2">}</span>
                    <span class="s2">: { attrs</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">emit })</span>
                <span class="s2">: render(props</span><span class="s1">, null </span><span class="s3">/* we know it doesn't need it */</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s2">fallthroughAttrs = Component.props</span>
                <span class="s2">? attrs</span>
                <span class="s2">: getFunctionalFallthrough(attrs)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">(err) {</span>
        <span class="s2">blockStack.length = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* ErrorCodes.RENDER_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">result = createVNode(Comment)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// attr merging</span>
    <span class="s3">// in dev mode, comments are preserved, and it's possible for a template</span>
    <span class="s3">// to have comments along side the root element which makes it a fragment</span>
    <span class="s1">let </span><span class="s2">root = result</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">setRoot = undefined</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(result.patchFlag &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">result.patchFlag &amp; </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">) {</span>
        <span class="s2">[root</span><span class="s1">, </span><span class="s2">setRoot] = getChildRoot(result)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(fallthroughAttrs &amp;&amp; inheritAttrs !== </span><span class="s1">false</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">keys = Object.keys(fallthroughAttrs)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ shapeFlag } = root</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(keys.length) {</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">| </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">)) {</span>
                <span class="s1">if </span><span class="s2">(propsOptions &amp;&amp; keys.some(shared.isModelListener)) {</span>
                    <span class="s3">// If a v-model listener (onUpdate:xxx) has a corresponding declared</span>
                    <span class="s3">// prop, it indicates this component expects to handle v-model and</span>
                    <span class="s3">// it should not fallthrough.</span>
                    <span class="s3">// related: #1543, #1643, #1989</span>
                    <span class="s2">fallthroughAttrs = filterModelListeners(fallthroughAttrs</span><span class="s1">, </span><span class="s2">propsOptions)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">root = cloneVNode(root</span><span class="s1">, </span><span class="s2">fallthroughAttrs)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!accessedAttrs &amp;&amp; root.type !== Comment) {</span>
                <span class="s1">const </span><span class="s2">allAttrs = Object.keys(attrs)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">eventAttrs = []</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">extraAttrs = []</span><span class="s1">;</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">l = allAttrs.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">const </span><span class="s2">key = allAttrs[i]</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(shared.isOn(key)) {</span>
                        <span class="s3">// ignore v-model handlers when they fail to fallthrough</span>
                        <span class="s1">if </span><span class="s2">(!shared.isModelListener(key)) {</span>
                            <span class="s3">// remove `on`, lowercase first letter to reflect event casing</span>
                            <span class="s3">// accurately</span>
                            <span class="s2">eventAttrs.push(key[</span><span class="s4">2</span><span class="s2">].toLowerCase() + key.slice(</span><span class="s4">3</span><span class="s2">))</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">extraAttrs.push(key)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(extraAttrs.length) {</span>
                    <span class="s2">warn(</span><span class="s0">`Extraneous non-props attributes (` </span><span class="s2">+</span>
                        <span class="s0">`</span><span class="s2">${extraAttrs.join(</span><span class="s0">', '</span><span class="s2">)}</span><span class="s0">) ` </span><span class="s2">+</span>
                        <span class="s0">`were passed to component but could not be automatically inherited ` </span><span class="s2">+</span>
                        <span class="s0">`because component renders fragment or text root nodes.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(eventAttrs.length) {</span>
                    <span class="s2">warn(</span><span class="s0">`Extraneous non-emits event listeners (` </span><span class="s2">+</span>
                        <span class="s0">`</span><span class="s2">${eventAttrs.join(</span><span class="s0">', '</span><span class="s2">)}</span><span class="s0">) ` </span><span class="s2">+</span>
                        <span class="s0">`were passed to component but could not be automatically inherited ` </span><span class="s2">+</span>
                        <span class="s0">`because component renders fragment or text root nodes. ` </span><span class="s2">+</span>
                        <span class="s0">`If the listener is intended to be a component custom event listener only, ` </span><span class="s2">+</span>
                        <span class="s0">`declare it using the &quot;emits&quot; option.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// inherit directives</span>
    <span class="s1">if </span><span class="s2">(vnode.dirs) {</span>
        <span class="s1">if </span><span class="s2">(!isElementRoot(root)) {</span>
            <span class="s2">warn(</span><span class="s0">`Runtime directive used on component with non-element root node. ` </span><span class="s2">+</span>
                <span class="s0">`The directives will not function as intended.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// clone before mutating since the root may be a hoisted vnode</span>
        <span class="s2">root = cloneVNode(root)</span><span class="s1">;</span>
        <span class="s2">root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// inherit transition data</span>
    <span class="s1">if </span><span class="s2">(vnode.transition) {</span>
        <span class="s1">if </span><span class="s2">(!isElementRoot(root)) {</span>
            <span class="s2">warn(</span><span class="s0">`Component inside &lt;Transition&gt; renders non-element root node ` </span><span class="s2">+</span>
                <span class="s0">`that cannot be animated.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">root.transition = vnode.transition</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(setRoot) {</span>
        <span class="s2">setRoot(root)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">result = root</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">setCurrentRenderingInstance(prev)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">* In dev mode, template root level comments are rendered, which turns the</span>
 <span class="s5">* template into a fragment root, but we need to locate the single element</span>
 <span class="s5">* root for attrs and scope id processing.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">getChildRoot = (vnode) =&gt; {</span>
    <span class="s1">const </span><span class="s2">rawChildren = vnode.children</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">dynamicChildren = vnode.dynamicChildren</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">childRoot = filterSingleRoot(rawChildren)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!childRoot) {</span>
        <span class="s1">return </span><span class="s2">[vnode</span><span class="s1">, </span><span class="s2">undefined]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">index = rawChildren.indexOf(childRoot)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setRoot = (updatedRoot) =&gt; {</span>
        <span class="s2">rawChildren[index] = updatedRoot</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dynamicChildren) {</span>
            <span class="s1">if </span><span class="s2">(dynamicIndex &gt; -</span><span class="s4">1</span><span class="s2">) {</span>
                <span class="s2">dynamicChildren[dynamicIndex] = updatedRoot</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(updatedRoot.patchFlag &gt; </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s2">vnode.dynamicChildren = [...dynamicChildren</span><span class="s1">, </span><span class="s2">updatedRoot]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">[normalizeVNode(childRoot)</span><span class="s1">, </span><span class="s2">setRoot]</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">filterSingleRoot(children) {</span>
    <span class="s1">let </span><span class="s2">singleRoot</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isVNode(child)) {</span>
            <span class="s3">// ignore user comment</span>
            <span class="s1">if </span><span class="s2">(child.type !== Comment || child.children === </span><span class="s0">'v-if'</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(singleRoot) {</span>
                    <span class="s3">// has more than 1 non-comment child, return now</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">singleRoot = child</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">singleRoot</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">getFunctionalFallthrough = (attrs) =&gt; {</span>
    <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
        <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'class' </span><span class="s2">|| key === </span><span class="s0">'style' </span><span class="s2">|| shared.isOn(key)) {</span>
            <span class="s2">(res || (res = {}))[key] = attrs[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">filterModelListeners = (attrs</span><span class="s1">, </span><span class="s2">props) =&gt; {</span>
    <span class="s1">const </span><span class="s2">res = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isModelListener(key) || !(key.slice(</span><span class="s4">9</span><span class="s2">) </span><span class="s1">in </span><span class="s2">props)) {</span>
            <span class="s2">res[key] = attrs[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isElementRoot = (vnode) =&gt; {</span>
    <span class="s1">return </span><span class="s2">(vnode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */ </span><span class="s2">| </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */</span><span class="s2">) ||</span>
        <span class="s2">vnode.type === Comment </span><span class="s3">// potential v-if branch switch</span>
    <span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">shouldUpdateComponent(prevVNode</span><span class="s1">, </span><span class="s2">nextVNode</span><span class="s1">, </span><span class="s2">optimized) {</span>
    <span class="s1">const </span><span class="s2">{ props: prevProps</span><span class="s1">, </span><span class="s2">children: prevChildren</span><span class="s1">, </span><span class="s2">component } = prevVNode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ props: nextProps</span><span class="s1">, </span><span class="s2">children: nextChildren</span><span class="s1">, </span><span class="s2">patchFlag } = nextVNode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">emits = component.emitsOptions</span><span class="s1">;</span>
    <span class="s3">// Parent component's render function was hot-updated. Since this may have</span>
    <span class="s3">// caused the child component's slots content to have changed, we need to</span>
    <span class="s3">// force the child to update as well.</span>
    <span class="s1">if </span><span class="s2">((prevChildren || nextChildren) &amp;&amp; isHmrUpdating) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s3">// force child update for runtime directive or transition on component vnode.</span>
    <span class="s1">if </span><span class="s2">(nextVNode.dirs || nextVNode.transition) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(optimized &amp;&amp; patchFlag &gt;= </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s2">) {</span>
            <span class="s3">// slot content that references values that might have changed,</span>
            <span class="s3">// e.g. in a v-for</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(!prevProps) {</span>
                <span class="s1">return </span><span class="s2">!!nextProps</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// presence of this flag indicates props are always non-null</span>
            <span class="s1">return </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emits)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(patchFlag &amp; </span><span class="s4">8 </span><span class="s3">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">dynamicProps = nextVNode.dynamicProps</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; dynamicProps.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">key = dynamicProps[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
                    <span class="s2">!isEmitListener(emits</span><span class="s1">, </span><span class="s2">key)) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// this path is only taken by manually written render functions</span>
        <span class="s3">// so presence of any children leads to a forced update</span>
        <span class="s1">if </span><span class="s2">(prevChildren || nextChildren) {</span>
            <span class="s1">if </span><span class="s2">(!nextChildren || !nextChildren.$stable) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(prevProps === nextProps) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!prevProps) {</span>
            <span class="s1">return </span><span class="s2">!!nextProps</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!nextProps) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emits)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emitsOptions) {</span>
    <span class="s1">const </span><span class="s2">nextKeys = Object.keys(nextProps)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(nextKeys.length !== Object.keys(prevProps).length) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; nextKeys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">key = nextKeys[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
            <span class="s2">!isEmitListener(emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">updateHOCHostEl({ vnode</span><span class="s1">, </span><span class="s2">parent }</span><span class="s1">, </span><span class="s2">el </span><span class="s3">// HostNode</span>
<span class="s2">) {</span>
    <span class="s1">while </span><span class="s2">(parent &amp;&amp; parent.subTree === vnode) {</span>
        <span class="s2">(vnode = parent.vnode).el = el</span><span class="s1">;</span>
        <span class="s2">parent = parent.parent</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isSuspense = (type) =&gt; type.__isSuspense</span><span class="s1">;</span>
<span class="s3">// Suspense exposes a component-like API, and is treated like a component</span>
<span class="s3">// in the compiler, but internally it's a special built-in type that hooks</span>
<span class="s3">// directly into the renderer.</span>
<span class="s1">const </span><span class="s2">SuspenseImpl = {</span>
    <span class="s2">name: </span><span class="s0">'Suspense'</span><span class="s1">,</span>
    <span class="s3">// In order to make Suspense tree-shakable, we need to avoid importing it</span>
    <span class="s3">// directly in the renderer. The renderer checks for the __isSuspense flag</span>
    <span class="s3">// on a vnode's type and calls the `process` method, passing in renderer</span>
    <span class="s3">// internals.</span>
    <span class="s2">__isSuspense: </span><span class="s1">true,</span>
    <span class="s2">process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span>
    <span class="s3">// platform-specific impl passed from renderer</span>
    <span class="s2">rendererInternals) {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">mountSuspense(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patchSuspense(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">hydrate: hydrateSuspense</span><span class="s1">,</span>
    <span class="s2">create: createSuspenseBoundary</span><span class="s1">,</span>
    <span class="s2">normalize: normalizeSuspenseChildren</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">// Force-casted public typing for h and TSX props inference</span>
<span class="s1">const </span><span class="s2">Suspense = (SuspenseImpl</span>
    <span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">const </span><span class="s2">eventListener = vnode.props &amp;&amp; vnode.props[name]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(eventListener)) {</span>
        <span class="s2">eventListener()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mountSuspense(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals) {</span>
    <span class="s1">const </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">o: { createElement } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hiddenContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals))</span><span class="s1">;</span>
    <span class="s3">// start mounting the content subtree in an off-dom container</span>
    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">(suspense.pendingBranch = vnode.ssContent)</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
    <span class="s3">// now check if we have encountered any async deps</span>
    <span class="s1">if </span><span class="s2">(suspense.deps &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s3">// has async</span>
        <span class="s3">// invoke @fallback event</span>
        <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onPending'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onFallback'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s3">// mount the fallback tree</span>
        <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode.ssFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s3">// fallback tree will not have suspense context</span>
        <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
        <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">vnode.ssFallback)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// Suspense has no async deps. Just resolve.</span>
        <span class="s2">suspense.resolve()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">patchSuspense(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">um: unmount</span><span class="s1">, </span><span class="s2">o: { createElement } }) {</span>
    <span class="s1">const </span><span class="s2">suspense = (n2.suspense = n1.suspense)</span><span class="s1">;</span>
    <span class="s2">suspense.vnode = n2</span><span class="s1">;</span>
    <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">newBranch = n2.ssContent</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">newFallback = n2.ssFallback</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ activeBranch</span><span class="s1">, </span><span class="s2">pendingBranch</span><span class="s1">, </span><span class="s2">isInFallback</span><span class="s1">, </span><span class="s2">isHydrating } = suspense</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(pendingBranch) {</span>
        <span class="s2">suspense.pendingBranch = newBranch</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">pendingBranch)) {</span>
            <span class="s3">// same root type but content may have changed.</span>
            <span class="s2">patch(pendingBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s2">suspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(isInFallback) {</span>
                <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s3">// fallback tree will not have suspense context</span>
                <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newFallback)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// toggled before pending tree is resolved</span>
            <span class="s2">suspense.pendingId++</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isHydrating) {</span>
                <span class="s3">// if toggled before hydration is finished, the current DOM tree is</span>
                <span class="s3">// no longer valid. set it as the active branch so it will be unmounted</span>
                <span class="s3">// when resolved</span>
                <span class="s2">suspense.isHydrating = </span><span class="s1">false;</span>
                <span class="s2">suspense.activeBranch = pendingBranch</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">unmount(pendingBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// increment pending ID. this is used to invalidate async callbacks</span>
            <span class="s3">// reset suspense state</span>
            <span class="s2">suspense.deps = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">// discard effects from pending branch</span>
            <span class="s2">suspense.effects.length = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">// discard previous container</span>
            <span class="s2">suspense.hiddenContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isInFallback) {</span>
                <span class="s3">// already in fallback state</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s3">// fallback tree will not have suspense context</span>
                    <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newFallback)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">activeBranch)) {</span>
                <span class="s3">// toggled &quot;back&quot; to current active branch</span>
                <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s3">// force resolve</span>
                <span class="s2">suspense.resolve(</span><span class="s1">true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// switched to a 3rd branch</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">activeBranch)) {</span>
            <span class="s3">// root did not change, just normal patch</span>
            <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newBranch)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// root node toggled</span>
            <span class="s3">// invoke @pending event</span>
            <span class="s2">triggerEvent(n2</span><span class="s1">, </span><span class="s0">'onPending'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s3">// mount pending branch in off-dom container</span>
            <span class="s2">suspense.pendingBranch = newBranch</span><span class="s1">;</span>
            <span class="s2">suspense.pendingId++</span><span class="s1">;</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s3">// incoming branch has no async deps, resolve now.</span>
                <span class="s2">suspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">const </span><span class="s2">{ timeout</span><span class="s1">, </span><span class="s2">pendingId } = suspense</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(timeout &gt; </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">setTimeout(() =&gt; {</span>
                        <span class="s1">if </span><span class="s2">(suspense.pendingId === pendingId) {</span>
                            <span class="s2">suspense.fallback(newFallback)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">, </span><span class="s2">timeout)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(timeout === </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.fallback(newFallback)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">hasWarned = </span><span class="s1">false;</span>
<span class="s1">function </span><span class="s2">createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">isHydrating = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s3">/* istanbul ignore if */</span>
    <span class="s1">if </span><span class="s2">(!hasWarned) {</span>
        <span class="s2">hasWarned = </span><span class="s1">true;</span>
        <span class="s3">// @ts-ignore `console.info` cannot be null error</span>
        <span class="s2">console[console.info ? </span><span class="s0">'info' </span><span class="s2">: </span><span class="s0">'log'</span><span class="s2">](</span><span class="s0">`&lt;Suspense&gt; is an experimental feature and its API will likely change.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">m: move</span><span class="s1">, </span><span class="s2">um: unmount</span><span class="s1">, </span><span class="s2">n: next</span><span class="s1">, </span><span class="s2">o: { parentNode</span><span class="s1">, </span><span class="s2">remove } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : undefined</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">assertNumber(timeout</span><span class="s1">, </span><span class="s0">`Suspense timeout`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">suspense = {</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">parent</span><span class="s1">,</span>
        <span class="s2">parentComponent</span><span class="s1">,</span>
        <span class="s2">isSVG</span><span class="s1">,</span>
        <span class="s2">container</span><span class="s1">,</span>
        <span class="s2">hiddenContainer</span><span class="s1">,</span>
        <span class="s2">anchor</span><span class="s1">,</span>
        <span class="s2">deps: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">pendingId: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">timeout: </span><span class="s1">typeof </span><span class="s2">timeout === </span><span class="s0">'number' </span><span class="s2">? timeout : -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s2">activeBranch: </span><span class="s1">null,</span>
        <span class="s2">pendingBranch: </span><span class="s1">null,</span>
        <span class="s2">isInFallback: </span><span class="s1">true,</span>
        <span class="s2">isHydrating</span><span class="s1">,</span>
        <span class="s2">isUnmounted: </span><span class="s1">false,</span>
        <span class="s2">effects: []</span><span class="s1">,</span>
        <span class="s2">resolve(resume = </span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s2">{</span>
                <span class="s1">if </span><span class="s2">(!resume &amp;&amp; !suspense.pendingBranch) {</span>
                    <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`suspense.resolve() is called without a pending branch.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(suspense.isUnmounted) {</span>
                    <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`suspense.resolve() is called on an already unmounted suspense boundary.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">activeBranch</span><span class="s1">, </span><span class="s2">pendingBranch</span><span class="s1">, </span><span class="s2">pendingId</span><span class="s1">, </span><span class="s2">effects</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container } = suspense</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.isHydrating) {</span>
                <span class="s2">suspense.isHydrating = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!resume) {</span>
                <span class="s1">const </span><span class="s2">delayEnter = activeBranch &amp;&amp;</span>
                    <span class="s2">pendingBranch.transition &amp;&amp;</span>
                    <span class="s2">pendingBranch.transition.mode === </span><span class="s0">'out-in'</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(delayEnter) {</span>
                    <span class="s2">activeBranch.transition.afterLeave = () =&gt; {</span>
                        <span class="s1">if </span><span class="s2">(pendingId === suspense.pendingId) {</span>
                            <span class="s2">move(pendingBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* MoveType.ENTER */</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// this is initial anchor on mount</span>
                <span class="s1">let </span><span class="s2">{ anchor } = suspense</span><span class="s1">;</span>
                <span class="s3">// unmount current active tree</span>
                <span class="s1">if </span><span class="s2">(activeBranch) {</span>
                    <span class="s3">// if the fallback tree was mounted, it may have been moved</span>
                    <span class="s3">// as part of a parent suspense. get the latest anchor for insertion</span>
                    <span class="s2">anchor = next(activeBranch)</span><span class="s1">;</span>
                    <span class="s2">unmount(activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!delayEnter) {</span>
                    <span class="s3">// move content from off-dom container to actual container</span>
                    <span class="s2">move(pendingBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* MoveType.ENTER */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">pendingBranch)</span><span class="s1">;</span>
            <span class="s2">suspense.pendingBranch = </span><span class="s1">null;</span>
            <span class="s2">suspense.isInFallback = </span><span class="s1">false;</span>
            <span class="s3">// flush buffered effects</span>
            <span class="s3">// check if there is a pending parent suspense</span>
            <span class="s1">let </span><span class="s2">parent = suspense.parent</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">hasUnresolvedAncestor = </span><span class="s1">false;</span>
            <span class="s1">while </span><span class="s2">(parent) {</span>
                <span class="s1">if </span><span class="s2">(parent.pendingBranch) {</span>
                    <span class="s3">// found a pending parent suspense, merge buffered post jobs</span>
                    <span class="s3">// into that parent</span>
                    <span class="s2">parent.effects.push(...effects)</span><span class="s1">;</span>
                    <span class="s2">hasUnresolvedAncestor = </span><span class="s1">true;</span>
                    <span class="s1">break;</span>
                <span class="s2">}</span>
                <span class="s2">parent = parent.parent</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// no pending parent suspense, flush all jobs</span>
            <span class="s1">if </span><span class="s2">(!hasUnresolvedAncestor) {</span>
                <span class="s2">queuePostFlushCb(effects)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">suspense.effects = []</span><span class="s1">;</span>
            <span class="s3">// invoke @resolve event</span>
            <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onResolve'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">fallback(fallbackVNode) {</span>
            <span class="s1">if </span><span class="s2">(!suspense.pendingBranch) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG } = suspense</span><span class="s1">;</span>
            <span class="s3">// invoke @fallback event</span>
            <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onFallback'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">anchor = next(activeBranch)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mountFallback = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(!suspense.isInFallback) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s3">// mount the fallback tree</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">fallbackVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s3">// fallback tree will not have suspense context</span>
                <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">fallbackVNode)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">delayEnter = fallbackVNode.transition &amp;&amp; fallbackVNode.transition.mode === </span><span class="s0">'out-in'</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delayEnter) {</span>
                <span class="s2">activeBranch.transition.afterLeave = mountFallback</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">suspense.isInFallback = </span><span class="s1">true;</span>
            <span class="s3">// unmount current active branch</span>
            <span class="s2">unmount(activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s3">// no suspense so unmount hooks fire now</span>
            <span class="s1">true </span><span class="s3">// shouldRemove</span>
            <span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!delayEnter) {</span>
                <span class="s2">mountFallback()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">move(container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">type) {</span>
            <span class="s2">suspense.activeBranch &amp;&amp;</span>
                <span class="s2">move(suspense.activeBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
            <span class="s2">suspense.container = container</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">next() {</span>
            <span class="s1">return </span><span class="s2">suspense.activeBranch &amp;&amp; next(suspense.activeBranch)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">registerDep(instance</span><span class="s1">, </span><span class="s2">setupRenderEffect) {</span>
            <span class="s1">const </span><span class="s2">isInPendingSuspense = !!suspense.pendingBranch</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isInPendingSuspense) {</span>
                <span class="s2">suspense.deps++</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">hydratedEl = instance.vnode.el</span><span class="s1">;</span>
            <span class="s2">instance</span>
                <span class="s2">.asyncDep.catch(err =&gt; {</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">})</span>
                <span class="s2">.then(asyncSetupResult =&gt; {</span>
                <span class="s3">// retry when the setup() promise resolves.</span>
                <span class="s3">// component may have been unmounted before resolve.</span>
                <span class="s1">if </span><span class="s2">(instance.isUnmounted ||</span>
                    <span class="s2">suspense.isUnmounted ||</span>
                    <span class="s2">suspense.pendingId !== instance.suspenseId) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s3">// retry from this component</span>
                <span class="s2">instance.asyncResolved = </span><span class="s1">true;</span>
                <span class="s1">const </span><span class="s2">{ vnode } = instance</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">pushWarningContext(vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">asyncSetupResult</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(hydratedEl) {</span>
                    <span class="s3">// vnode may have been replaced if an update happened before the</span>
                    <span class="s3">// async dep is resolved.</span>
                    <span class="s2">vnode.el = hydratedEl</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">placeholder = !hydratedEl &amp;&amp; instance.subTree.el</span><span class="s1">;</span>
                <span class="s2">setupRenderEffect(instance</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span>
                <span class="s3">// component may have been moved before resolve.</span>
                <span class="s3">// if this is not a hydration, instance.subTree will be the comment</span>
                <span class="s3">// placeholder.</span>
                <span class="s2">parentNode(hydratedEl || instance.subTree.el)</span><span class="s1">, </span>
                <span class="s3">// anchor will not be used if this is hydration, so only need to</span>
                <span class="s3">// consider the comment placeholder case.</span>
                <span class="s2">hydratedEl ? </span><span class="s1">null </span><span class="s2">: next(instance.subTree)</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(placeholder) {</span>
                    <span class="s2">remove(placeholder)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">updateHOCHostEl(instance</span><span class="s1">, </span><span class="s2">vnode.el)</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">popWarningContext()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// only decrease deps count if suspense is not already resolved</span>
                <span class="s1">if </span><span class="s2">(isInPendingSuspense &amp;&amp; --suspense.deps === </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">unmount(parentSuspense</span><span class="s1">, </span><span class="s2">doRemove) {</span>
            <span class="s2">suspense.isUnmounted = </span><span class="s1">true;</span>
            <span class="s1">if </span><span class="s2">(suspense.activeBranch) {</span>
                <span class="s2">unmount(suspense.activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(suspense.pendingBranch) {</span>
                <span class="s2">unmount(suspense.pendingBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">suspense</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hydrateSuspense(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateNode) {</span>
    <span class="s3">/* eslint-disable no-restricted-globals */</span>
    <span class="s1">const </span><span class="s2">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">node.parentNode</span><span class="s1">, </span><span class="s2">document.createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">, null, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, true </span><span class="s3">/* hydrating */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s3">// there are two possible scenarios for server-rendered suspense:</span>
    <span class="s3">// - success: ssr content should be fully resolved</span>
    <span class="s3">// - failure: ssr content should be the fallback branch.</span>
    <span class="s3">// however, on the client we don't really know if it has failed or not</span>
    <span class="s3">// attempt to hydrate the DOM assuming it has succeeded, but we still</span>
    <span class="s3">// need to construct a suspense boundary first</span>
    <span class="s1">const </span><span class="s2">result = hydrateNode(node</span><span class="s1">, </span><span class="s2">(suspense.pendingBranch = vnode.ssContent)</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(suspense.deps === </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">suspense.resolve()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
    <span class="s3">/* eslint-enable no-restricted-globals */</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeSuspenseChildren(vnode) {</span>
    <span class="s1">const </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isSlotChildren = shapeFlag &amp; </span><span class="s4">32 </span><span class="s3">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children)</span><span class="s1">;</span>
    <span class="s2">vnode.ssFallback = isSlotChildren</span>
        <span class="s2">? normalizeSuspenseSlot(children.fallback)</span>
        <span class="s2">: createVNode(Comment)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeSuspenseSlot(s) {</span>
    <span class="s1">let </span><span class="s2">block</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(s)) {</span>
        <span class="s1">const </span><span class="s2">trackBlock = isBlockTreeEnabled &amp;&amp; s._c</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trackBlock) {</span>
            <span class="s3">// disableTracking: false</span>
            <span class="s3">// allow block tracking for compiled slots</span>
            <span class="s3">// (see ./componentRenderContext.ts)</span>
            <span class="s2">s._d = </span><span class="s1">false;</span>
            <span class="s2">openBlock()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">s = s()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trackBlock) {</span>
            <span class="s2">s._d = </span><span class="s1">true;</span>
            <span class="s2">block = currentBlock</span><span class="s1">;</span>
            <span class="s2">closeBlock()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(s)) {</span>
        <span class="s1">const </span><span class="s2">singleChild = filterSingleRoot(s)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!singleChild) {</span>
            <span class="s2">warn(</span><span class="s0">`&lt;Suspense&gt; slots expect a single root node.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">s = singleChild</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">s = normalizeVNode(s)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(block &amp;&amp; !s.dynamicChildren) {</span>
        <span class="s2">s.dynamicChildren = block.filter(c =&gt; c !== s)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">s</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueEffectWithSuspense(fn</span><span class="s1">, </span><span class="s2">suspense) {</span>
    <span class="s1">if </span><span class="s2">(suspense &amp;&amp; suspense.pendingBranch) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(fn)) {</span>
            <span class="s2">suspense.effects.push(...fn)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">suspense.effects.push(fn)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">queuePostFlushCb(fn)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">branch) {</span>
    <span class="s2">suspense.activeBranch = branch</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">parentComponent } = suspense</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">el = (vnode.el = branch.el)</span><span class="s1">;</span>
    <span class="s3">// in case suspense is the root node of a component,</span>
    <span class="s3">// recursively update the HOC el</span>
    <span class="s1">if </span><span class="s2">(parentComponent &amp;&amp; parentComponent.subTree === vnode) {</span>
        <span class="s2">parentComponent.vnode.el = el</span><span class="s1">;</span>
        <span class="s2">updateHOCHostEl(parentComponent</span><span class="s1">, </span><span class="s2">el)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">provide(key</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s1">if </span><span class="s2">(!currentInstance) {</span>
        <span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">`provide() can only be used inside setup().`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">let </span><span class="s2">provides = currentInstance.provides</span><span class="s1">;</span>
        <span class="s3">// by default an instance inherits its parent's provides object</span>
        <span class="s3">// but when it needs to provide values of its own, it creates its</span>
        <span class="s3">// own provides object using parent provides object as prototype.</span>
        <span class="s3">// this way in `inject` we can simply look up injections from direct</span>
        <span class="s3">// parent and let the prototype chain do the work.</span>
        <span class="s1">const </span><span class="s2">parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(parentProvides === provides) {</span>
            <span class="s2">provides = currentInstance.provides = Object.create(parentProvides)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// TS doesn't allow symbol as index type</span>
        <span class="s2">provides[key] = value</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">inject(key</span><span class="s1">, </span><span class="s2">defaultValue</span><span class="s1">, </span><span class="s2">treatDefaultAsFactory = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s3">// fallback to `currentRenderingInstance` so that this can be called in</span>
    <span class="s3">// a functional component</span>
    <span class="s1">const </span><span class="s2">instance = currentInstance || currentRenderingInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s3">// #2400</span>
        <span class="s3">// to support `app.use` plugins,</span>
        <span class="s3">// fallback to appContext's `provides` if the instance is at root</span>
        <span class="s1">const </span><span class="s2">provides = instance.parent == </span><span class="s1">null</span>
            <span class="s2">? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span>
            <span class="s2">: instance.parent.provides</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(provides &amp;&amp; key </span><span class="s1">in </span><span class="s2">provides) {</span>
            <span class="s3">// TS doesn't allow symbol as index type</span>
            <span class="s1">return </span><span class="s2">provides[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(arguments.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">treatDefaultAsFactory &amp;&amp; shared.isFunction(defaultValue)</span>
                <span class="s2">? defaultValue.call(instance.proxy)</span>
                <span class="s2">: defaultValue</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">`injection &quot;</span><span class="s2">${String(key)}</span><span class="s0">&quot; not found.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">warn(</span><span class="s0">`inject() can only be used inside setup() or functional components.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">// Simple effect.</span>
<span class="s1">function </span><span class="s2">watchEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">watchPostEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">{ ...options</span><span class="s1">, </span><span class="s2">flush: </span><span class="s0">'post' </span><span class="s2">} )</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">watchSyncEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">{ ...options</span><span class="s1">, </span><span class="s2">flush: </span><span class="s0">'sync' </span><span class="s2">} )</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// initial value for watchers to trigger on undefined initial values</span>
<span class="s1">const </span><span class="s2">INITIAL_WATCHER_VALUE = {}</span><span class="s1">;</span>
<span class="s3">// implementation</span>
<span class="s1">function </span><span class="s2">watch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">if </span><span class="s2">(!shared.isFunction(cb)) {</span>
        <span class="s2">warn(</span><span class="s0">`</span><span class="s1">\`</span><span class="s0">watch(fn, options?)</span><span class="s1">\` </span><span class="s0">signature has been moved to a separate API. ` </span><span class="s2">+</span>
            <span class="s0">`Use </span><span class="s1">\`</span><span class="s0">watchEffect(fn, options?)</span><span class="s1">\` </span><span class="s0">instead. </span><span class="s1">\`</span><span class="s0">watch</span><span class="s1">\` </span><span class="s0">now only ` </span><span class="s2">+</span>
            <span class="s0">`supports </span><span class="s1">\`</span><span class="s0">watch(source, cb, options?) signature.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">doWatch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">doWatch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">{ immediate</span><span class="s1">, </span><span class="s2">deep</span><span class="s1">, </span><span class="s2">flush</span><span class="s1">, </span><span class="s2">onTrack</span><span class="s1">, </span><span class="s2">onTrigger } = shared.EMPTY_OBJ) {</span>
    <span class="s1">if </span><span class="s2">(!cb) {</span>
        <span class="s1">if </span><span class="s2">(immediate !== undefined) {</span>
            <span class="s2">warn(</span><span class="s0">`watch() &quot;immediate&quot; option is only respected when using the ` </span><span class="s2">+</span>
                <span class="s0">`watch(source, callback, options?) signature.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(deep !== undefined) {</span>
            <span class="s2">warn(</span><span class="s0">`watch() &quot;deep&quot; option is only respected when using the ` </span><span class="s2">+</span>
                <span class="s0">`watch(source, callback, options?) signature.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">warnInvalidSource = (s) =&gt; {</span>
        <span class="s2">warn(</span><span class="s0">`Invalid watch source: `</span><span class="s1">, </span><span class="s2">s</span><span class="s1">, </span><span class="s0">`A watch source can only be a getter/effect function, a ref, ` </span><span class="s2">+</span>
            <span class="s0">`a reactive object, or an array of these types.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">instance = reactivity.getCurrentScope() === (currentInstance === </span><span class="s1">null </span><span class="s2">|| currentInstance === </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">: currentInstance.scope) ? currentInstance : </span><span class="s1">null;</span>
    <span class="s3">// const instance = currentInstance</span>
    <span class="s1">let </span><span class="s2">getter</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">forceTrigger = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">isMultiSource = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(reactivity.isRef(source)) {</span>
        <span class="s2">getter = () =&gt; source.value</span><span class="s1">;</span>
        <span class="s2">forceTrigger = reactivity.isShallow(source)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(reactivity.isReactive(source)) {</span>
        <span class="s2">getter = () =&gt; source</span><span class="s1">;</span>
        <span class="s2">deep = </span><span class="s1">true;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(source)) {</span>
        <span class="s2">isMultiSource = </span><span class="s1">true;</span>
        <span class="s2">forceTrigger = source.some(s =&gt; reactivity.isReactive(s) || reactivity.isShallow(s))</span><span class="s1">;</span>
        <span class="s2">getter = () =&gt; source.map(s =&gt; {</span>
            <span class="s1">if </span><span class="s2">(reactivity.isRef(s)) {</span>
                <span class="s1">return </span><span class="s2">s.value</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(reactivity.isReactive(s)) {</span>
                <span class="s1">return </span><span class="s2">traverse(s)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shared.isFunction(s)) {</span>
                <span class="s1">return </span><span class="s2">callWithErrorHandling(s</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ErrorCodes.WATCH_GETTER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">warnInvalidSource(s)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(source)) {</span>
        <span class="s1">if </span><span class="s2">(cb) {</span>
            <span class="s3">// getter with cb</span>
            <span class="s2">getter = () =&gt; callWithErrorHandling(source</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* ErrorCodes.WATCH_GETTER */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// no cb -&gt; simple effect</span>
            <span class="s2">getter = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(instance &amp;&amp; instance.isUnmounted) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(cleanup) {</span>
                    <span class="s2">cleanup()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">callWithAsyncErrorHandling(source</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">3 </span><span class="s3">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[onCleanup])</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">getter = shared.NOOP</span><span class="s1">;</span>
        <span class="s2">warnInvalidSource(source)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(cb &amp;&amp; deep) {</span>
        <span class="s1">const </span><span class="s2">baseGetter = getter</span><span class="s1">;</span>
        <span class="s2">getter = () =&gt; traverse(baseGetter())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">cleanup</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">onCleanup = (fn) =&gt; {</span>
        <span class="s2">cleanup = effect.onStop = () =&gt; {</span>
            <span class="s2">callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">4 </span><span class="s3">/* ErrorCodes.WATCH_CLEANUP */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// in SSR there is no need to setup an actual effect, and it should be noop</span>
    <span class="s3">// unless it's eager or sync flush</span>
    <span class="s1">let </span><span class="s2">ssrCleanup</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isInSSRComponentSetup) {</span>
        <span class="s3">// we will also not call the invalidate callback (+ runner is not set up)</span>
        <span class="s2">onCleanup = shared.NOOP</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!cb) {</span>
            <span class="s2">getter()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(immediate) {</span>
            <span class="s2">callWithAsyncErrorHandling(cb</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">3 </span><span class="s3">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[</span>
                <span class="s2">getter()</span><span class="s1">,</span>
                <span class="s2">isMultiSource ? [] : undefined</span><span class="s1">,</span>
                <span class="s2">onCleanup</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(flush === </span><span class="s0">'sync'</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">ctx = useSSRContext()</span><span class="s1">;</span>
            <span class="s2">ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = [])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">return </span><span class="s2">shared.NOOP</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">oldValue = isMultiSource</span>
        <span class="s2">? </span><span class="s1">new </span><span class="s2">Array(source.length).fill(INITIAL_WATCHER_VALUE)</span>
        <span class="s2">: INITIAL_WATCHER_VALUE</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">job = () =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!effect.active) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(cb) {</span>
            <span class="s3">// watch(source, cb)</span>
            <span class="s1">const </span><span class="s2">newValue = effect.run()</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(deep ||</span>
                <span class="s2">forceTrigger ||</span>
                <span class="s2">(isMultiSource</span>
                    <span class="s2">? newValue.some((v</span><span class="s1">, </span><span class="s2">i) =&gt; shared.hasChanged(v</span><span class="s1">, </span><span class="s2">oldValue[i]))</span>
                    <span class="s2">: shared.hasChanged(newValue</span><span class="s1">, </span><span class="s2">oldValue)) ||</span>
                <span class="s2">(</span><span class="s1">false  </span><span class="s2">)) {</span>
                <span class="s3">// cleanup before running cb again</span>
                <span class="s1">if </span><span class="s2">(cleanup) {</span>
                    <span class="s2">cleanup()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">callWithAsyncErrorHandling(cb</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">3 </span><span class="s3">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">newValue</span><span class="s1">,</span>
                    <span class="s3">// pass undefined as the old value when it's changed for the first time</span>
                    <span class="s2">oldValue === INITIAL_WATCHER_VALUE</span>
                        <span class="s2">? undefined</span>
                        <span class="s2">: isMultiSource &amp;&amp; oldValue[</span><span class="s4">0</span><span class="s2">] === INITIAL_WATCHER_VALUE</span>
                            <span class="s2">? []</span>
                            <span class="s2">: oldValue</span><span class="s1">,</span>
                    <span class="s2">onCleanup</span>
                <span class="s2">])</span><span class="s1">;</span>
                <span class="s2">oldValue = newValue</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// watchEffect</span>
            <span class="s2">effect.run()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// important: mark the job as a watcher callback so that scheduler knows</span>
    <span class="s3">// it is allowed to self-trigger (#1727)</span>
    <span class="s2">job.allowRecurse = !!cb</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">scheduler</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(flush === </span><span class="s0">'sync'</span><span class="s2">) {</span>
        <span class="s2">scheduler = job</span><span class="s1">; </span><span class="s3">// the scheduler function gets called directly</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(flush === </span><span class="s0">'post'</span><span class="s2">) {</span>
        <span class="s2">scheduler = () =&gt; queuePostRenderEffect(job</span><span class="s1">, </span><span class="s2">instance &amp;&amp; instance.suspense)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// default: 'pre'</span>
        <span class="s2">job.pre = </span><span class="s1">true;</span>
        <span class="s1">if </span><span class="s2">(instance)</span>
            <span class="s2">job.id = instance.uid</span><span class="s1">;</span>
        <span class="s2">scheduler = () =&gt; queueJob(job)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">effect = </span><span class="s1">new </span><span class="s2">reactivity.ReactiveEffect(getter</span><span class="s1">, </span><span class="s2">scheduler)</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">effect.onTrack = onTrack</span><span class="s1">;</span>
        <span class="s2">effect.onTrigger = onTrigger</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// initial run</span>
    <span class="s1">if </span><span class="s2">(cb) {</span>
        <span class="s1">if </span><span class="s2">(immediate) {</span>
            <span class="s2">job()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">oldValue = effect.run()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(flush === </span><span class="s0">'post'</span><span class="s2">) {</span>
        <span class="s2">queuePostRenderEffect(effect.run.bind(effect)</span><span class="s1">, </span><span class="s2">instance &amp;&amp; instance.suspense)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">effect.run()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">unwatch = () =&gt; {</span>
        <span class="s2">effect.stop()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(instance &amp;&amp; instance.scope) {</span>
            <span class="s2">shared.remove(instance.scope.effects</span><span class="s1">, </span><span class="s2">effect)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(ssrCleanup)</span>
        <span class="s2">ssrCleanup.push(unwatch)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">unwatch</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// this.$watch</span>
<span class="s1">function </span><span class="s2">instanceWatch(source</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">const </span><span class="s2">publicThis = </span><span class="s1">this</span><span class="s2">.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">getter = shared.isString(source)</span>
        <span class="s2">? source.includes(</span><span class="s0">'.'</span><span class="s2">)</span>
            <span class="s2">? createPathGetter(publicThis</span><span class="s1">, </span><span class="s2">source)</span>
            <span class="s2">: () =&gt; publicThis[source]</span>
        <span class="s2">: source.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">cb</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(value)) {</span>
        <span class="s2">cb = value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">cb = value.handler</span><span class="s1">;</span>
        <span class="s2">options = value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">cur = currentInstance</span><span class="s1">;</span>
    <span class="s2">setCurrentInstance(</span><span class="s1">this</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">res = doWatch(getter</span><span class="s1">, </span><span class="s2">cb.bind(publicThis)</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cur) {</span>
        <span class="s2">setCurrentInstance(cur)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createPathGetter(ctx</span><span class="s1">, </span><span class="s2">path) {</span>
    <span class="s1">const </span><span class="s2">segments = path.split(</span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">() =&gt; {</span>
        <span class="s1">let </span><span class="s2">cur = ctx</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; segments.length &amp;&amp; cur</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">cur = cur[segments[i]]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">cur</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">traverse(value</span><span class="s1">, </span><span class="s2">seen) {</span>
    <span class="s1">if </span><span class="s2">(!shared.isObject(value) || value[</span><span class="s0">&quot;__v_skip&quot; </span><span class="s3">/* ReactiveFlags.SKIP */</span><span class="s2">]) {</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">seen = seen || </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(seen.has(value)) {</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">seen.add(value)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(reactivity.isRef(value)) {</span>
        <span class="s2">traverse(value.value</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(value)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; value.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">traverse(value[i]</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isSet(value) || shared.isMap(value)) {</span>
        <span class="s2">value.forEach((v) =&gt; {</span>
            <span class="s2">traverse(v</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isPlainObject(value)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">value) {</span>
            <span class="s2">traverse(value[key]</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">useTransitionState() {</span>
    <span class="s1">const </span><span class="s2">state = {</span>
        <span class="s2">isMounted: </span><span class="s1">false,</span>
        <span class="s2">isLeaving: </span><span class="s1">false,</span>
        <span class="s2">isUnmounting: </span><span class="s1">false,</span>
        <span class="s2">leavingVNodes: </span><span class="s1">new </span><span class="s2">Map()</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">onMounted(() =&gt; {</span>
        <span class="s2">state.isMounted = </span><span class="s1">true;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">onBeforeUnmount(() =&gt; {</span>
        <span class="s2">state.isUnmounting = </span><span class="s1">true;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">TransitionHookValidator = [Function</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">BaseTransitionImpl = {</span>
    <span class="s2">name: </span><span class="s0">`BaseTransition`</span><span class="s1">,</span>
    <span class="s2">props: {</span>
        <span class="s2">mode: String</span><span class="s1">,</span>
        <span class="s2">appear: Boolean</span><span class="s1">,</span>
        <span class="s2">persisted: Boolean</span><span class="s1">,</span>
        <span class="s3">// enter</span>
        <span class="s2">onBeforeEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onEnterCancelled: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s3">// leave</span>
        <span class="s2">onBeforeLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onLeaveCancelled: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s3">// appear</span>
        <span class="s2">onBeforeAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAppearCancelled: TransitionHookValidator</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">setup(props</span><span class="s1">, </span><span class="s2">{ slots }) {</span>
        <span class="s1">const </span><span class="s2">instance = getCurrentInstance()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">state = useTransitionState()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">prevTransitionKey</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s1">const </span><span class="s2">children = slots.default &amp;&amp; getTransitionRawChildren(slots.default()</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!children || !children.length) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">child = children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(children.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
                <span class="s1">let </span><span class="s2">hasFound = </span><span class="s1">false;</span>
                <span class="s3">// locate first non-comment child</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">c of children) {</span>
                    <span class="s1">if </span><span class="s2">(c.type !== Comment) {</span>
                        <span class="s1">if </span><span class="s2">(hasFound) {</span>
                            <span class="s3">// warn more than one non-comment child</span>
                            <span class="s2">warn(</span><span class="s0">'&lt;transition&gt; can only be used on a single element or component. ' </span><span class="s2">+</span>
                                <span class="s0">'Use &lt;transition-group&gt; for lists.'</span><span class="s2">)</span><span class="s1">;</span>
                            <span class="s1">break;</span>
                        <span class="s2">}</span>
                        <span class="s2">child = c</span><span class="s1">;</span>
                        <span class="s2">hasFound = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// there's no need to track reactivity for these props so use the raw</span>
            <span class="s3">// props for a bit better perf</span>
            <span class="s1">const </span><span class="s2">rawProps = reactivity.toRaw(props)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ mode } = rawProps</span><span class="s1">;</span>
            <span class="s3">// check mode</span>
            <span class="s1">if </span><span class="s2">(mode &amp;&amp;</span>
                <span class="s2">mode !== </span><span class="s0">'in-out' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">mode !== </span><span class="s0">'out-in' </span><span class="s2">&amp;&amp;</span>
                <span class="s2">mode !== </span><span class="s0">'default'</span><span class="s2">) {</span>
                <span class="s2">warn(</span><span class="s0">`invalid &lt;transition&gt; mode: </span><span class="s2">${mode}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(state.isLeaving) {</span>
                <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// in the case of &lt;transition&gt;&lt;keep-alive/&gt;&lt;/transition&gt;, we need to</span>
            <span class="s3">// compare the type of the kept-alive children.</span>
            <span class="s1">const </span><span class="s2">innerChild = getKeepAliveChild(child)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!innerChild) {</span>
                <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">enterHooks = resolveTransitionHooks(innerChild</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
            <span class="s2">setTransitionHooks(innerChild</span><span class="s1">, </span><span class="s2">enterHooks)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">oldChild = instance.subTree</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild)</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">transitionKeyChanged = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">{ getTransitionKey } = innerChild.type</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(getTransitionKey) {</span>
                <span class="s1">const </span><span class="s2">key = getTransitionKey()</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prevTransitionKey === undefined) {</span>
                    <span class="s2">prevTransitionKey = key</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(key !== prevTransitionKey) {</span>
                    <span class="s2">prevTransitionKey = key</span><span class="s1">;</span>
                    <span class="s2">transitionKeyChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// handle mode</span>
            <span class="s1">if </span><span class="s2">(oldInnerChild &amp;&amp;</span>
                <span class="s2">oldInnerChild.type !== Comment &amp;&amp;</span>
                <span class="s2">(!isSameVNodeType(innerChild</span><span class="s1">, </span><span class="s2">oldInnerChild) || transitionKeyChanged)) {</span>
                <span class="s1">const </span><span class="s2">leavingHooks = resolveTransitionHooks(oldInnerChild</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s3">// update old tree's hooks in case of dynamic transition</span>
                <span class="s2">setTransitionHooks(oldInnerChild</span><span class="s1">, </span><span class="s2">leavingHooks)</span><span class="s1">;</span>
                <span class="s3">// switching between different views</span>
                <span class="s1">if </span><span class="s2">(mode === </span><span class="s0">'out-in'</span><span class="s2">) {</span>
                    <span class="s2">state.isLeaving = </span><span class="s1">true;</span>
                    <span class="s3">// return placeholder node and queue update when leave finishes</span>
                    <span class="s2">leavingHooks.afterLeave = () =&gt; {</span>
                        <span class="s2">state.isLeaving = </span><span class="s1">false;</span>
                        <span class="s3">// #6835</span>
                        <span class="s3">// it also needs to be updated when active is undefined</span>
                        <span class="s1">if </span><span class="s2">(instance.update.active !== </span><span class="s1">false</span><span class="s2">) {</span>
                            <span class="s2">instance.update()</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(mode === </span><span class="s0">'in-out' </span><span class="s2">&amp;&amp; innerChild.type !== Comment) {</span>
                    <span class="s2">leavingHooks.delayLeave = (el</span><span class="s1">, </span><span class="s2">earlyRemove</span><span class="s1">, </span><span class="s2">delayedLeave) =&gt; {</span>
                        <span class="s1">const </span><span class="s2">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">oldInnerChild)</span><span class="s1">;</span>
                        <span class="s2">leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild</span><span class="s1">;</span>
                        <span class="s3">// early removal callback</span>
                        <span class="s2">el._leaveCb = () =&gt; {</span>
                            <span class="s2">earlyRemove()</span><span class="s1">;</span>
                            <span class="s2">el._leaveCb = undefined</span><span class="s1">;</span>
                            <span class="s1">delete </span><span class="s2">enterHooks.delayedLeave</span><span class="s1">;</span>
                        <span class="s2">}</span><span class="s1">;</span>
                        <span class="s2">enterHooks.delayedLeave = delayedLeave</span><span class="s1">;</span>
                    <span class="s2">}</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">child</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">// export the public type for h/tsx inference</span>
<span class="s3">// also to avoid inline import() in generated d.ts files</span>
<span class="s1">const </span><span class="s2">BaseTransition = BaseTransitionImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">vnode) {</span>
    <span class="s1">const </span><span class="s2">{ leavingVNodes } = state</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">leavingVNodesCache = leavingVNodes.get(vnode.type)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!leavingVNodesCache) {</span>
        <span class="s2">leavingVNodesCache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">leavingVNodes.set(vnode.type</span><span class="s1">, </span><span class="s2">leavingVNodesCache)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">leavingVNodesCache</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// The transition hooks are attached to the vnode as vnode.transition</span>
<span class="s3">// and will be called at appropriate timing in the renderer.</span>
<span class="s1">function </span><span class="s2">resolveTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance) {</span>
    <span class="s1">const </span><span class="s2">{ appear</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">persisted = </span><span class="s1">false, </span><span class="s2">onBeforeEnter</span><span class="s1">, </span><span class="s2">onEnter</span><span class="s1">, </span><span class="s2">onAfterEnter</span><span class="s1">, </span><span class="s2">onEnterCancelled</span><span class="s1">, </span><span class="s2">onBeforeLeave</span><span class="s1">, </span><span class="s2">onLeave</span><span class="s1">, </span><span class="s2">onAfterLeave</span><span class="s1">, </span><span class="s2">onLeaveCancelled</span><span class="s1">, </span><span class="s2">onBeforeAppear</span><span class="s1">, </span><span class="s2">onAppear</span><span class="s1">, </span><span class="s2">onAfterAppear</span><span class="s1">, </span><span class="s2">onAppearCancelled } = props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">key = String(vnode.key)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">callHook = (hook</span><span class="s1">, </span><span class="s2">args) =&gt; {</span>
        <span class="s2">hook &amp;&amp;</span>
            <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">9 </span><span class="s3">/* ErrorCodes.TRANSITION_HOOK */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">callAsyncHook = (hook</span><span class="s1">, </span><span class="s2">args) =&gt; {</span>
        <span class="s1">const </span><span class="s2">done = args[</span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(hook)) {</span>
            <span class="s1">if </span><span class="s2">(hook.every(hook =&gt; hook.length &lt;= </span><span class="s4">1</span><span class="s2">))</span>
                <span class="s2">done()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(hook.length &lt;= </span><span class="s4">1</span><span class="s2">) {</span>
            <span class="s2">done()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hooks = {</span>
        <span class="s2">mode</span><span class="s1">,</span>
        <span class="s2">persisted</span><span class="s1">,</span>
        <span class="s2">beforeEnter(el) {</span>
            <span class="s1">let </span><span class="s2">hook = onBeforeEnter</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!state.isMounted) {</span>
                <span class="s1">if </span><span class="s2">(appear) {</span>
                    <span class="s2">hook = onBeforeAppear || onBeforeEnter</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// for same element (v-show)</span>
            <span class="s1">if </span><span class="s2">(el._leaveCb) {</span>
                <span class="s2">el._leaveCb(</span><span class="s1">true </span><span class="s3">/* cancelled */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// for toggled element with same key (v-if)</span>
            <span class="s1">const </span><span class="s2">leavingVNode = leavingVNodesCache[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(leavingVNode &amp;&amp;</span>
                <span class="s2">isSameVNodeType(vnode</span><span class="s1">, </span><span class="s2">leavingVNode) &amp;&amp;</span>
                <span class="s2">leavingVNode.el._leaveCb) {</span>
                <span class="s3">// force early removal (not cancelled)</span>
                <span class="s2">leavingVNode.el._leaveCb()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">enter(el) {</span>
            <span class="s1">let </span><span class="s2">hook = onEnter</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">afterHook = onAfterEnter</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">cancelHook = onEnterCancelled</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!state.isMounted) {</span>
                <span class="s1">if </span><span class="s2">(appear) {</span>
                    <span class="s2">hook = onAppear || onEnter</span><span class="s1">;</span>
                    <span class="s2">afterHook = onAfterAppear || onAfterEnter</span><span class="s1">;</span>
                    <span class="s2">cancelHook = onAppearCancelled || onEnterCancelled</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">called = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">done = (el._enterCb = (cancelled) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(called)</span>
                    <span class="s1">return;</span>
                <span class="s2">called = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(cancelled) {</span>
                    <span class="s2">callHook(cancelHook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">callHook(afterHook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(hooks.delayedLeave) {</span>
                    <span class="s2">hooks.delayedLeave()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">el._enterCb = undefined</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(hook) {</span>
                <span class="s2">callAsyncHook(hook</span><span class="s1">, </span><span class="s2">[el</span><span class="s1">, </span><span class="s2">done])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">done()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">leave(el</span><span class="s1">, </span><span class="s2">remove) {</span>
            <span class="s1">const </span><span class="s2">key = String(vnode.key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(el._enterCb) {</span>
                <span class="s2">el._enterCb(</span><span class="s1">true </span><span class="s3">/* cancelled */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(state.isUnmounting) {</span>
                <span class="s1">return </span><span class="s2">remove()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">callHook(onBeforeLeave</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">called = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">done = (el._leaveCb = (cancelled) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(called)</span>
                    <span class="s1">return;</span>
                <span class="s2">called = </span><span class="s1">true;</span>
                <span class="s2">remove()</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(cancelled) {</span>
                    <span class="s2">callHook(onLeaveCancelled</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">callHook(onAfterLeave</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">el._leaveCb = undefined</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(leavingVNodesCache[key] === vnode) {</span>
                    <span class="s1">delete </span><span class="s2">leavingVNodesCache[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">leavingVNodesCache[key] = vnode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(onLeave) {</span>
                <span class="s2">callAsyncHook(onLeave</span><span class="s1">, </span><span class="s2">[el</span><span class="s1">, </span><span class="s2">done])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">done()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">clone(vnode) {</span>
            <span class="s1">return </span><span class="s2">resolveTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">hooks</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// the placeholder really only handles one special case: KeepAlive</span>
<span class="s3">// in the case of a KeepAlive in a leave phase we need to return a KeepAlive</span>
<span class="s3">// placeholder with empty content to avoid the KeepAlive instance from being</span>
<span class="s3">// unmounted.</span>
<span class="s1">function </span><span class="s2">emptyPlaceholder(vnode) {</span>
    <span class="s1">if </span><span class="s2">(isKeepAlive(vnode)) {</span>
        <span class="s2">vnode = cloneVNode(vnode)</span><span class="s1">;</span>
        <span class="s2">vnode.children = </span><span class="s1">null;</span>
        <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getKeepAliveChild(vnode) {</span>
    <span class="s1">return </span><span class="s2">isKeepAlive(vnode)</span>
        <span class="s2">? vnode.children</span>
            <span class="s2">? vnode.children[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s2">: undefined</span>
        <span class="s2">: vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">hooks) {</span>
    <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */ </span><span class="s2">&amp;&amp; vnode.component) {</span>
        <span class="s2">setTransitionHooks(vnode.component.subTree</span><span class="s1">, </span><span class="s2">hooks)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
        <span class="s2">vnode.ssContent.transition = hooks.clone(vnode.ssContent)</span><span class="s1">;</span>
        <span class="s2">vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">vnode.transition = hooks</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getTransitionRawChildren(children</span><span class="s1">, </span><span class="s2">keepComment = </span><span class="s1">false, </span><span class="s2">parentKey) {</span>
    <span class="s1">let </span><span class="s2">ret = []</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">keyedFragmentCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">let </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s3">// #5360 inherit parent key in case of &lt;template v-for&gt;</span>
        <span class="s1">const </span><span class="s2">key = parentKey == </span><span class="s1">null</span>
            <span class="s2">? child.key</span>
            <span class="s2">: String(parentKey) + String(child.key != </span><span class="s1">null </span><span class="s2">? child.key : i)</span><span class="s1">;</span>
        <span class="s3">// handle fragment children case, e.g. v-for</span>
        <span class="s1">if </span><span class="s2">(child.type === Fragment) {</span>
            <span class="s1">if </span><span class="s2">(child.patchFlag &amp; </span><span class="s4">128 </span><span class="s3">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s2">)</span>
                <span class="s2">keyedFragmentCount++</span><span class="s1">;</span>
            <span class="s2">ret = ret.concat(getTransitionRawChildren(child.children</span><span class="s1">, </span><span class="s2">keepComment</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// comment placeholders should be skipped, e.g. v-if</span>
        <span class="s1">else if </span><span class="s2">(keepComment || child.type !== Comment) {</span>
            <span class="s2">ret.push(key != </span><span class="s1">null </span><span class="s2">? cloneVNode(child</span><span class="s1">, </span><span class="s2">{ key }) : child)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// #1126 if a transition children list contains multiple sub fragments, these</span>
    <span class="s3">// fragments will be merged into a flat children array. Since each v-for</span>
    <span class="s3">// fragment may contain different static bindings inside, we need to de-op</span>
    <span class="s3">// these children to force full diffs to ensure correct behavior.</span>
    <span class="s1">if </span><span class="s2">(keyedFragmentCount &gt; </span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; ret.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i].patchFlag = -</span><span class="s4">2 </span><span class="s3">/* PatchFlags.BAIL */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">// implementation, close to no-op</span>
<span class="s1">function </span><span class="s2">defineComponent(options) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(options) ? { setup: options</span><span class="s1">, </span><span class="s2">name: options.name } : options</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isAsyncWrapper = (i) =&gt; !!i.type.__asyncLoader</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">defineAsyncComponent(source) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(source)) {</span>
        <span class="s2">source = { loader: source }</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ loader</span><span class="s1">, </span><span class="s2">loadingComponent</span><span class="s1">, </span><span class="s2">errorComponent</span><span class="s1">, </span><span class="s2">delay = </span><span class="s4">200</span><span class="s1">, </span><span class="s2">timeout</span><span class="s1">, </span><span class="s3">// undefined = never times out</span>
    <span class="s2">suspensible = </span><span class="s1">true, </span><span class="s2">onError: userOnError } = source</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">pendingRequest = </span><span class="s1">null;</span>
    <span class="s1">let </span><span class="s2">resolvedComp</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">retries = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">retry = () =&gt; {</span>
        <span class="s2">retries++</span><span class="s1">;</span>
        <span class="s2">pendingRequest = </span><span class="s1">null;</span>
        <span class="s1">return </span><span class="s2">load()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">load = () =&gt; {</span>
        <span class="s1">let </span><span class="s2">thisRequest</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">(pendingRequest ||</span>
            <span class="s2">(thisRequest = pendingRequest =</span>
                <span class="s2">loader()</span>
                    <span class="s2">.catch(err =&gt; {</span>
                    <span class="s2">err = err </span><span class="s1">instanceof </span><span class="s2">Error ? err : </span><span class="s1">new </span><span class="s2">Error(String(err))</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(userOnError) {</span>
                        <span class="s1">return new </span><span class="s2">Promise((resolve</span><span class="s1">, </span><span class="s2">reject) =&gt; {</span>
                            <span class="s1">const </span><span class="s2">userRetry = () =&gt; resolve(retry())</span><span class="s1">;</span>
                            <span class="s1">const </span><span class="s2">userFail = () =&gt; reject(err)</span><span class="s1">;</span>
                            <span class="s2">userOnError(err</span><span class="s1">, </span><span class="s2">userRetry</span><span class="s1">, </span><span class="s2">userFail</span><span class="s1">, </span><span class="s2">retries + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">})</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">throw </span><span class="s2">err</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">})</span>
                    <span class="s2">.then((comp) =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span>
                        <span class="s1">return </span><span class="s2">pendingRequest</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(!comp) {</span>
                        <span class="s2">warn(</span><span class="s0">`Async component loader resolved to undefined. ` </span><span class="s2">+</span>
                            <span class="s0">`If you are using retry(), make sure to return its return value.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s3">// interop module default</span>
                    <span class="s1">if </span><span class="s2">(comp &amp;&amp;</span>
                        <span class="s2">(comp.__esModule || comp[Symbol.toStringTag] === </span><span class="s0">'Module'</span><span class="s2">)) {</span>
                        <span class="s2">comp = comp.default</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(comp &amp;&amp; !shared.isObject(comp) &amp;&amp; !shared.isFunction(comp)) {</span>
                        <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`Invalid async component load result: </span><span class="s2">${comp}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">resolvedComp = comp</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">comp</span><span class="s1">;</span>
                <span class="s2">})))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">defineComponent({</span>
        <span class="s2">name: </span><span class="s0">'AsyncComponentWrapper'</span><span class="s1">,</span>
        <span class="s2">__asyncLoader: load</span><span class="s1">,</span>
        <span class="s2">get __asyncResolved() {</span>
            <span class="s1">return </span><span class="s2">resolvedComp</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">setup() {</span>
            <span class="s1">const </span><span class="s2">instance = currentInstance</span><span class="s1">;</span>
            <span class="s3">// already resolved</span>
            <span class="s1">if </span><span class="s2">(resolvedComp) {</span>
                <span class="s1">return </span><span class="s2">() =&gt; createInnerComp(resolvedComp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">onError = (err) =&gt; {</span>
                <span class="s2">pendingRequest = </span><span class="s1">null;</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">13 </span><span class="s3">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span><span class="s1">, </span><span class="s2">!errorComponent </span><span class="s3">/* do not throw in dev if user provided error component */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s3">// suspense-controlled or SSR.</span>
            <span class="s1">if </span><span class="s2">((suspensible &amp;&amp; instance.suspense) ||</span>
                <span class="s2">(isInSSRComponentSetup)) {</span>
                <span class="s1">return </span><span class="s2">load()</span>
                    <span class="s2">.then(comp =&gt; {</span>
                    <span class="s1">return </span><span class="s2">() =&gt; createInnerComp(comp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s2">})</span>
                    <span class="s2">.catch(err =&gt; {</span>
                    <span class="s2">onError(err)</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">() =&gt; errorComponent</span>
                        <span class="s2">? createVNode(errorComponent</span><span class="s1">, </span><span class="s2">{</span>
                            <span class="s2">error: err</span>
                        <span class="s2">})</span>
                        <span class="s2">: </span><span class="s1">null;</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">loaded = reactivity.ref(</span><span class="s1">false</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">error = reactivity.ref()</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">delayed = reactivity.ref(!!delay)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delay) {</span>
                <span class="s2">setTimeout(() =&gt; {</span>
                    <span class="s2">delayed.value = </span><span class="s1">false;</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">delay)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(timeout != </span><span class="s1">null</span><span class="s2">) {</span>
                <span class="s2">setTimeout(() =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(!loaded.value &amp;&amp; !error.value) {</span>
                        <span class="s1">const </span><span class="s2">err = </span><span class="s1">new </span><span class="s2">Error(</span><span class="s0">`Async component timed out after </span><span class="s2">${timeout}</span><span class="s0">ms.`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">onError(err)</span><span class="s1">;</span>
                        <span class="s2">error.value = err</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">timeout)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">load()</span>
                <span class="s2">.then(() =&gt; {</span>
                <span class="s2">loaded.value = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(instance.parent &amp;&amp; isKeepAlive(instance.parent.vnode)) {</span>
                    <span class="s3">// parent is keep-alive, force update so the loaded component's</span>
                    <span class="s3">// name is taken into account</span>
                    <span class="s2">queueJob(instance.parent.update)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span>
                <span class="s2">.catch(err =&gt; {</span>
                <span class="s2">onError(err)</span><span class="s1">;</span>
                <span class="s2">error.value = err</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s1">if </span><span class="s2">(loaded.value &amp;&amp; resolvedComp) {</span>
                    <span class="s1">return </span><span class="s2">createInnerComp(resolvedComp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(error.value &amp;&amp; errorComponent) {</span>
                    <span class="s1">return </span><span class="s2">createVNode(errorComponent</span><span class="s1">, </span><span class="s2">{</span>
                        <span class="s2">error: error.value</span>
                    <span class="s2">})</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(loadingComponent &amp;&amp; !delayed.value) {</span>
                    <span class="s1">return </span><span class="s2">createVNode(loadingComponent)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createInnerComp(comp</span><span class="s1">, </span><span class="s2">parent) {</span>
    <span class="s1">const </span><span class="s2">{ ref</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">ce } = parent.vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">vnode = createVNode(comp</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s3">// ensure inner component inherits the async wrapper's ref owner</span>
    <span class="s2">vnode.ref = ref</span><span class="s1">;</span>
    <span class="s3">// pass the custom element callback on to the inner comp</span>
    <span class="s3">// and remove it from the async wrapper</span>
    <span class="s2">vnode.ce = ce</span><span class="s1">;</span>
    <span class="s1">delete </span><span class="s2">parent.vnode.ce</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">KeepAliveImpl = {</span>
    <span class="s2">name: </span><span class="s0">`KeepAlive`</span><span class="s1">,</span>
    <span class="s3">// Marker for special handling inside the renderer. We are not using a ===</span>
    <span class="s3">// check directly on KeepAlive in the renderer, because importing it directly</span>
    <span class="s3">// would prevent it from being tree-shaken.</span>
    <span class="s2">__isKeepAlive: </span><span class="s1">true,</span>
    <span class="s2">props: {</span>
        <span class="s2">include: [String</span><span class="s1">, </span><span class="s2">RegExp</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">,</span>
        <span class="s2">exclude: [String</span><span class="s1">, </span><span class="s2">RegExp</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">,</span>
        <span class="s2">max: [String</span><span class="s1">, </span><span class="s2">Number]</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">setup(props</span><span class="s1">, </span><span class="s2">{ slots }) {</span>
        <span class="s1">const </span><span class="s2">instance = getCurrentInstance()</span><span class="s1">;</span>
        <span class="s3">// KeepAlive communicates with the instantiated renderer via the</span>
        <span class="s3">// ctx where the renderer passes in its internals,</span>
        <span class="s3">// and the KeepAlive instance exposes activate/deactivate implementations.</span>
        <span class="s3">// The whole point of this is to avoid importing KeepAlive directly in the</span>
        <span class="s3">// renderer to facilitate tree-shaking.</span>
        <span class="s1">const </span><span class="s2">sharedContext = instance.ctx</span><span class="s1">;</span>
        <span class="s3">// if the internal renderer is not registered, it indicates that this is server-side rendering,</span>
        <span class="s3">// for KeepAlive, we just need to render its children</span>
        <span class="s1">if </span><span class="s2">(!sharedContext.renderer) {</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s1">const </span><span class="s2">children = slots.default &amp;&amp; slots.default()</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">children &amp;&amp; children.length === </span><span class="s4">1 </span><span class="s2">? children[</span><span class="s4">0</span><span class="s2">] : children</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">cache = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keys = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">current = </span><span class="s1">null;</span>
        <span class="s2">{</span>
            <span class="s2">instance.__v_cache = cache</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">parentSuspense = instance.suspense</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ renderer: { p: patch</span><span class="s1">, </span><span class="s2">m: move</span><span class="s1">, </span><span class="s2">um: _unmount</span><span class="s1">, </span><span class="s2">o: { createElement } } } = sharedContext</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">storageContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">sharedContext.activate = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
            <span class="s1">const </span><span class="s2">instance = vnode.component</span><span class="s1">;</span>
            <span class="s2">move(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* MoveType.ENTER */</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s3">// in case props have changed</span>
            <span class="s2">patch(instance.vnode</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">instance.isDeactivated = </span><span class="s1">false;</span>
                <span class="s1">if </span><span class="s2">(instance.a) {</span>
                    <span class="s2">shared.invokeArrayFns(instance.a)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnodeHook) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">instance.parent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">{</span>
                <span class="s3">// Update components tree</span>
                <span class="s2">devtoolsComponentAdded(instance)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">sharedContext.deactivate = (vnode) =&gt; {</span>
            <span class="s1">const </span><span class="s2">instance = vnode.component</span><span class="s1">;</span>
            <span class="s2">move(vnode</span><span class="s1">, </span><span class="s2">storageContainer</span><span class="s1">, null, </span><span class="s4">1 </span><span class="s3">/* MoveType.LEAVE */</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">if </span><span class="s2">(instance.da) {</span>
                    <span class="s2">shared.invokeArrayFns(instance.da)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnodeHook) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">instance.parent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">instance.isDeactivated = </span><span class="s1">true;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">{</span>
                <span class="s3">// Update components tree</span>
                <span class="s2">devtoolsComponentAdded(instance)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">function </span><span class="s2">unmount(vnode) {</span>
            <span class="s3">// reset the shapeFlag so it can be properly unmounted</span>
            <span class="s2">resetShapeFlag(vnode)</span><span class="s1">;</span>
            <span class="s2">_unmount(vnode</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">function </span><span class="s2">pruneCache(filter) {</span>
            <span class="s2">cache.forEach((vnode</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
                <span class="s1">const </span><span class="s2">name = getComponentName(vnode.type)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(name &amp;&amp; (!filter || !filter(name))) {</span>
                    <span class="s2">pruneCacheEntry(key)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">function </span><span class="s2">pruneCacheEntry(key) {</span>
            <span class="s1">const </span><span class="s2">cached = cache.get(key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!current || !isSameVNodeType(cached</span><span class="s1">, </span><span class="s2">current)) {</span>
                <span class="s2">unmount(cached)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(current) {</span>
                <span class="s3">// current active instance should no longer be kept-alive.</span>
                <span class="s3">// we can't unmount it now but it might be later, so reset its flag now.</span>
                <span class="s2">resetShapeFlag(current)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">cache.delete(key)</span><span class="s1">;</span>
            <span class="s2">keys.delete(key)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// prune cache on include/exclude prop change</span>
        <span class="s2">watch(() =&gt; [props.include</span><span class="s1">, </span><span class="s2">props.exclude]</span><span class="s1">, </span><span class="s2">([include</span><span class="s1">, </span><span class="s2">exclude]) =&gt; {</span>
            <span class="s2">include &amp;&amp; pruneCache(name =&gt; matches(include</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
            <span class="s2">exclude &amp;&amp; pruneCache(name =&gt; !matches(exclude</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">, </span>
        <span class="s3">// prune post-render after `current` has been updated</span>
        <span class="s2">{ flush: </span><span class="s0">'post'</span><span class="s1">, </span><span class="s2">deep: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s3">// cache sub tree after render</span>
        <span class="s1">let </span><span class="s2">pendingCacheKey = </span><span class="s1">null;</span>
        <span class="s1">const </span><span class="s2">cacheSubtree = () =&gt; {</span>
            <span class="s3">// fix #1621, the pendingCacheKey could be 0</span>
            <span class="s1">if </span><span class="s2">(pendingCacheKey != </span><span class="s1">null</span><span class="s2">) {</span>
                <span class="s2">cache.set(pendingCacheKey</span><span class="s1">, </span><span class="s2">getInnerChild(instance.subTree))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">onMounted(cacheSubtree)</span><span class="s1">;</span>
        <span class="s2">onUpdated(cacheSubtree)</span><span class="s1">;</span>
        <span class="s2">onBeforeUnmount(() =&gt; {</span>
            <span class="s2">cache.forEach(cached =&gt; {</span>
                <span class="s1">const </span><span class="s2">{ subTree</span><span class="s1">, </span><span class="s2">suspense } = instance</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">vnode = getInnerChild(subTree)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(cached.type === vnode.type &amp;&amp; cached.key === vnode.key) {</span>
                    <span class="s3">// current instance will be unmounted as part of keep-alive's unmount</span>
                    <span class="s2">resetShapeFlag(vnode)</span><span class="s1">;</span>
                    <span class="s3">// but invoke its deactivated hook here</span>
                    <span class="s1">const </span><span class="s2">da = vnode.component.da</span><span class="s1">;</span>
                    <span class="s2">da &amp;&amp; queuePostRenderEffect(da</span><span class="s1">, </span><span class="s2">suspense)</span><span class="s1">;</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s2">unmount(cached)</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s2">pendingCacheKey = </span><span class="s1">null;</span>
            <span class="s1">if </span><span class="s2">(!slots.default) {</span>
                <span class="s1">return null;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">children = slots.default()</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">rawVNode = children[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(children.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
                <span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`KeepAlive should contain exactly one component child.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">current = </span><span class="s1">null;</span>
                <span class="s1">return </span><span class="s2">children</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!isVNode(rawVNode) ||</span>
                <span class="s2">(!(rawVNode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">) &amp;&amp;</span>
                    <span class="s2">!(rawVNode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">))) {</span>
                <span class="s2">current = </span><span class="s1">null;</span>
                <span class="s1">return </span><span class="s2">rawVNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">vnode = getInnerChild(rawVNode)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">comp = vnode.type</span><span class="s1">;</span>
            <span class="s3">// for async components, name check should be based in its loaded</span>
            <span class="s3">// inner component if available</span>
            <span class="s1">const </span><span class="s2">name = getComponentName(isAsyncWrapper(vnode)</span>
                <span class="s2">? vnode.type.__asyncResolved || {}</span>
                <span class="s2">: comp)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ include</span><span class="s1">, </span><span class="s2">exclude</span><span class="s1">, </span><span class="s2">max } = props</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">((include &amp;&amp; (!name || !matches(include</span><span class="s1">, </span><span class="s2">name))) ||</span>
                <span class="s2">(exclude &amp;&amp; name &amp;&amp; matches(exclude</span><span class="s1">, </span><span class="s2">name))) {</span>
                <span class="s2">current = vnode</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">rawVNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">key = vnode.key == </span><span class="s1">null </span><span class="s2">? comp : vnode.key</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">cachedVNode = cache.get(key)</span><span class="s1">;</span>
            <span class="s3">// clone vnode if it's reused because we are going to mutate it</span>
            <span class="s1">if </span><span class="s2">(vnode.el) {</span>
                <span class="s2">vnode = cloneVNode(vnode)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(rawVNode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">rawVNode.ssContent = vnode</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// #1513 it's possible for the returned vnode to be cloned due to attr</span>
            <span class="s3">// fallthrough or scopeId, so the vnode here may not be the final vnode</span>
            <span class="s3">// that is mounted. Instead of caching it directly, we store the pending</span>
            <span class="s3">// key and cache `instance.subTree` (the normalized vnode) in</span>
            <span class="s3">// beforeMount/beforeUpdate hooks.</span>
            <span class="s2">pendingCacheKey = key</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(cachedVNode) {</span>
                <span class="s3">// copy over mounted state</span>
                <span class="s2">vnode.el = cachedVNode.el</span><span class="s1">;</span>
                <span class="s2">vnode.component = cachedVNode.component</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnode.transition) {</span>
                    <span class="s3">// recursively update transition hooks on subTree</span>
                    <span class="s2">setTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">vnode.transition)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// avoid vnode being mounted as fresh</span>
                <span class="s2">vnode.shapeFlag |= </span><span class="s4">512 </span><span class="s3">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">;</span>
                <span class="s3">// make this key the freshest</span>
                <span class="s2">keys.delete(key)</span><span class="s1">;</span>
                <span class="s2">keys.add(key)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">keys.add(key)</span><span class="s1">;</span>
                <span class="s3">// prune oldest entry</span>
                <span class="s1">if </span><span class="s2">(max &amp;&amp; keys.size &gt; parseInt(max</span><span class="s1">, </span><span class="s4">10</span><span class="s2">)) {</span>
                    <span class="s2">pruneCacheEntry(keys.values().next().value)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// avoid vnode being unmounted</span>
            <span class="s2">vnode.shapeFlag |= </span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">;</span>
            <span class="s2">current = vnode</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">isSuspense(rawVNode.type) ? rawVNode : vnode</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">// export the public type for h/tsx inference</span>
<span class="s3">// also to avoid inline import() in generated d.ts files</span>
<span class="s1">const </span><span class="s2">KeepAlive = KeepAliveImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">matches(pattern</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.some((p) =&gt; matches(p</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isString(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.split(</span><span class="s0">','</span><span class="s2">).includes(name)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isRegExp(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.test(name)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">/* istanbul ignore next */</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">onActivated(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s0">&quot;a&quot; </span><span class="s3">/* LifecycleHooks.ACTIVATED */</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">onDeactivated(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s0">&quot;da&quot; </span><span class="s3">/* LifecycleHooks.DEACTIVATED */</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target = currentInstance) {</span>
    <span class="s3">// cache the deactivate branch check wrapper for injected hooks so the same</span>
    <span class="s3">// hook can be properly deduped by the scheduler. &quot;__wdc&quot; stands for &quot;with</span>
    <span class="s3">// deactivation check&quot;.</span>
    <span class="s1">const </span><span class="s2">wrappedHook = hook.__wdc ||</span>
        <span class="s2">(hook.__wdc = () =&gt; {</span>
            <span class="s3">// only fire the hook if the target instance is NOT in a deactivated branch.</span>
            <span class="s1">let </span><span class="s2">current = target</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(current) {</span>
                <span class="s1">if </span><span class="s2">(current.isDeactivated) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s2">current = current.parent</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">hook()</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">injectHook(type</span><span class="s1">, </span><span class="s2">wrappedHook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
    <span class="s3">// In addition to registering it on the target instance, we walk up the parent</span>
    <span class="s3">// chain and register it on all ancestor instances that are keep-alive roots.</span>
    <span class="s3">// This avoids the need to walk the entire component tree when invoking these</span>
    <span class="s3">// hooks, and more importantly, avoids the need to track child components in</span>
    <span class="s3">// arrays.</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s1">let </span><span class="s2">current = target.parent</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(current &amp;&amp; current.parent) {</span>
            <span class="s1">if </span><span class="s2">(isKeepAlive(current.parent.vnode)) {</span>
                <span class="s2">injectToKeepAliveRoot(wrappedHook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">current)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">current = current.parent</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">injectToKeepAliveRoot(hook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">keepAliveRoot) {</span>
    <span class="s3">// injectHook wraps the original for error handling, so make sure to remove</span>
    <span class="s3">// the wrapped version.</span>
    <span class="s1">const </span><span class="s2">injected = injectHook(type</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">keepAliveRoot</span><span class="s1">, true </span><span class="s3">/* prepend */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">onUnmounted(() =&gt; {</span>
        <span class="s2">shared.remove(keepAliveRoot[type]</span><span class="s1">, </span><span class="s2">injected)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resetShapeFlag(vnode) {</span>
    <span class="s3">// bitwise operations to remove keep alive flags</span>
    <span class="s2">vnode.shapeFlag &amp;= ~</span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">;</span>
    <span class="s2">vnode.shapeFlag &amp;= ~</span><span class="s4">512 </span><span class="s3">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getInnerChild(vnode) {</span>
    <span class="s1">return </span><span class="s2">vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */ </span><span class="s2">? vnode.ssContent : vnode</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">injectHook(type</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">target = currentInstance</span><span class="s1">, </span><span class="s2">prepend = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s1">const </span><span class="s2">hooks = target[type] || (target[type] = [])</span><span class="s1">;</span>
        <span class="s3">// cache the error handling wrapper for injected hooks so the same hook</span>
        <span class="s3">// can be properly deduped by the scheduler. &quot;__weh&quot; stands for &quot;with error</span>
        <span class="s3">// handling&quot;.</span>
        <span class="s1">const </span><span class="s2">wrappedHook = hook.__weh ||</span>
            <span class="s2">(hook.__weh = (...args) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(target.isUnmounted) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s3">// disable tracking inside all lifecycle hooks</span>
                <span class="s3">// since they can potentially be called inside effects.</span>
                <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
                <span class="s3">// Set currentInstance during hook invocation.</span>
                <span class="s3">// This assumes the hook does not synchronously trigger other hooks, which</span>
                <span class="s3">// can only be false when the user does something really funky.</span>
                <span class="s2">setCurrentInstance(target)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">res = callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
                <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
                <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(prepend) {</span>
            <span class="s2">hooks.unshift(wrappedHook)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hooks.push(wrappedHook)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">wrappedHook</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">apiName = shared.toHandlerKey(ErrorTypeStrings[type].replace(</span><span class="s4">/ hook$/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">warn(</span><span class="s0">`</span><span class="s2">${apiName} </span><span class="s0">is called when there is no active component instance to be ` </span><span class="s2">+</span>
            <span class="s0">`associated with. ` </span><span class="s2">+</span>
            <span class="s0">`Lifecycle injection APIs can only be used during execution of setup().` </span><span class="s2">+</span>
            <span class="s2">(</span><span class="s0">` If you are using async setup(), make sure to register lifecycle ` </span><span class="s2">+</span>
                    <span class="s0">`hooks before the first await statement.`</span>
                <span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createHook = (lifecycle) =&gt; (hook</span><span class="s1">, </span><span class="s2">target = currentInstance) =&gt; </span>
<span class="s3">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span>
<span class="s2">(!isInSSRComponentSetup || lifecycle === </span><span class="s0">&quot;sp&quot; </span><span class="s3">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s2">) &amp;&amp;</span>
    <span class="s2">injectHook(lifecycle</span><span class="s1">, </span><span class="s2">(...args) =&gt; hook(...args)</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeMount = createHook(</span><span class="s0">&quot;bm&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_MOUNT */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onMounted = createHook(</span><span class="s0">&quot;m&quot; </span><span class="s3">/* LifecycleHooks.MOUNTED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeUpdate = createHook(</span><span class="s0">&quot;bu&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_UPDATE */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onUpdated = createHook(</span><span class="s0">&quot;u&quot; </span><span class="s3">/* LifecycleHooks.UPDATED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeUnmount = createHook(</span><span class="s0">&quot;bum&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_UNMOUNT */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onUnmounted = createHook(</span><span class="s0">&quot;um&quot; </span><span class="s3">/* LifecycleHooks.UNMOUNTED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onServerPrefetch = createHook(</span><span class="s0">&quot;sp&quot; </span><span class="s3">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onRenderTriggered = createHook(</span><span class="s0">&quot;rtg&quot; </span><span class="s3">/* LifecycleHooks.RENDER_TRIGGERED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onRenderTracked = createHook(</span><span class="s0">&quot;rtc&quot; </span><span class="s3">/* LifecycleHooks.RENDER_TRACKED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">onErrorCaptured(hook</span><span class="s1">, </span><span class="s2">target = currentInstance) {</span>
    <span class="s2">injectHook(</span><span class="s0">&quot;ec&quot; </span><span class="s3">/* LifecycleHooks.ERROR_CAPTURED */</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
<span class="s5">Runtime helper for applying directives to a vnode. Example usage:</span>

<span class="s5">const comp = resolveComponent('comp')</span>
<span class="s5">const foo = resolveDirective('foo')</span>
<span class="s5">const bar = resolveDirective('bar')</span>

<span class="s5">return withDirectives(h(comp), [</span>
  <span class="s5">[foo, this.x],</span>
  <span class="s5">[bar, this.y]</span>
<span class="s5">])</span>
<span class="s5">*/</span>
<span class="s1">function </span><span class="s2">validateDirectiveName(name) {</span>
    <span class="s1">if </span><span class="s2">(shared.isBuiltInDirective(name)) {</span>
        <span class="s2">warn(</span><span class="s0">'Do not use built-in directive ids as custom directive id: ' </span><span class="s2">+ name)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Adds directives to a VNode.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">withDirectives(vnode</span><span class="s1">, </span><span class="s2">directives) {</span>
    <span class="s1">const </span><span class="s2">internalInstance = currentRenderingInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(internalInstance === </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">warn(</span><span class="s0">`withDirectives can only be used inside render functions.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">instance = getExposeProxy(internalInstance) ||</span>
        <span class="s2">internalInstance.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">bindings = vnode.dirs || (vnode.dirs = [])</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; directives.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">let </span><span class="s2">[dir</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">modifiers = shared.EMPTY_OBJ] = directives[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dir) {</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(dir)) {</span>
                <span class="s2">dir = {</span>
                    <span class="s2">mounted: dir</span><span class="s1">,</span>
                    <span class="s2">updated: dir</span>
                <span class="s2">}</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(dir.deep) {</span>
                <span class="s2">traverse(value)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">bindings.push({</span>
                <span class="s2">dir</span><span class="s1">,</span>
                <span class="s2">instance</span><span class="s1">,</span>
                <span class="s2">value</span><span class="s1">,</span>
                <span class="s2">oldValue: </span><span class="s1">void </span><span class="s4">0</span><span class="s1">,</span>
                <span class="s2">arg</span><span class="s1">,</span>
                <span class="s2">modifiers</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, </span><span class="s2">prevVNode</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">const </span><span class="s2">bindings = vnode.dirs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">oldBindings = prevVNode &amp;&amp; prevVNode.dirs</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; bindings.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">binding = bindings[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(oldBindings) {</span>
            <span class="s2">binding.oldValue = oldBindings[i].value</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">let </span><span class="s2">hook = binding.dir[name]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hook) {</span>
            <span class="s3">// disable tracking inside all lifecycle hooks</span>
            <span class="s3">// since they can potentially be called inside effects.</span>
            <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
            <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* ErrorCodes.DIRECTIVE_HOOK */</span><span class="s1">, </span><span class="s2">[</span>
                <span class="s2">vnode.el</span><span class="s1">,</span>
                <span class="s2">binding</span><span class="s1">,</span>
                <span class="s2">vnode</span><span class="s1">,</span>
                <span class="s2">prevVNode</span>
            <span class="s2">])</span><span class="s1">;</span>
            <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">COMPONENTS = </span><span class="s0">'components'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">DIRECTIVES = </span><span class="s0">'directives'</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">resolveComponent(name</span><span class="s1">, </span><span class="s2">maybeSelfReference) {</span>
    <span class="s1">return </span><span class="s2">resolveAsset(COMPONENTS</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, true, </span><span class="s2">maybeSelfReference) || name</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">NULL_DYNAMIC_COMPONENT = Symbol()</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">resolveDynamicComponent(component) {</span>
    <span class="s1">if </span><span class="s2">(shared.isString(component)) {</span>
        <span class="s1">return </span><span class="s2">resolveAsset(COMPONENTS</span><span class="s1">, </span><span class="s2">component</span><span class="s1">, false</span><span class="s2">) || component</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// invalid types will fallthrough to createVNode and raise warning</span>
        <span class="s1">return </span><span class="s2">(component || NULL_DYNAMIC_COMPONENT)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">resolveDirective(name) {</span>
    <span class="s1">return </span><span class="s2">resolveAsset(DIRECTIVES</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// implementation</span>
<span class="s1">function </span><span class="s2">resolveAsset(type</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">warnMissing = </span><span class="s1">true, </span><span class="s2">maybeSelfReference = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">instance = currentRenderingInstance || currentInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
        <span class="s3">// explicit self name has highest priority</span>
        <span class="s1">if </span><span class="s2">(type === COMPONENTS) {</span>
            <span class="s1">const </span><span class="s2">selfName = getComponentName(Component</span><span class="s1">, false </span><span class="s3">/* do not include inferred name to avoid breaking existing code */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(selfName &amp;&amp;</span>
                <span class="s2">(selfName === name ||</span>
                    <span class="s2">selfName === shared.camelize(name) ||</span>
                    <span class="s2">selfName === shared.capitalize(shared.camelize(name)))) {</span>
                <span class="s1">return </span><span class="s2">Component</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">res = </span>
        <span class="s3">// local registration</span>
        <span class="s3">// check instance[type] first which is resolved for options API</span>
        <span class="s2">resolve(instance[type] || Component[type]</span><span class="s1">, </span><span class="s2">name) ||</span>
            <span class="s3">// global registration</span>
            <span class="s2">resolve(instance.appContext[type]</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!res &amp;&amp; maybeSelfReference) {</span>
            <span class="s3">// fallback to implicit self-reference</span>
            <span class="s1">return </span><span class="s2">Component</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(warnMissing &amp;&amp; !res) {</span>
            <span class="s1">const </span><span class="s2">extra = type === COMPONENTS</span>
                <span class="s2">? </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">If this is a native custom element, make sure to exclude it from ` </span><span class="s2">+</span>
                    <span class="s0">`component resolution via compilerOptions.isCustomElement.`</span>
                <span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
            <span class="s2">warn(</span><span class="s0">`Failed to resolve </span><span class="s2">${type.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">-</span><span class="s4">1</span><span class="s2">)}</span><span class="s0">: </span><span class="s2">${name}${extra}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">warn(</span><span class="s0">`resolve</span><span class="s2">${shared.capitalize(type.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">-</span><span class="s4">1</span><span class="s2">))} </span><span class="s0">` </span><span class="s2">+</span>
            <span class="s0">`can only be used in render() or setup().`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolve(registry</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">return </span><span class="s2">(registry &amp;&amp;</span>
        <span class="s2">(registry[name] ||</span>
            <span class="s2">registry[shared.camelize(name)] ||</span>
            <span class="s2">registry[shared.capitalize(shared.camelize(name))]))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Actual implementation</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">renderList(source</span><span class="s1">, </span><span class="s2">renderItem</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">let </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = (cache &amp;&amp; cache[index])</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(source) || shared.isString(source)) {</span>
        <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(source.length)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">l = source.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i] = renderItem(source[i]</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">source === </span><span class="s0">'number'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(!Number.isInteger(source)) {</span>
            <span class="s2">warn(</span><span class="s0">`The v-for range expect an integer value but got </span><span class="s2">${source}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(source)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; source</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i] = renderItem(i + </span><span class="s4">1</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(source)) {</span>
        <span class="s1">if </span><span class="s2">(source[Symbol.iterator]) {</span>
            <span class="s2">ret = Array.from(source</span><span class="s1">, </span><span class="s2">(item</span><span class="s1">, </span><span class="s2">i) =&gt; renderItem(item</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i]))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">keys = Object.keys(source)</span><span class="s1">;</span>
            <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(keys.length)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">l = keys.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">key = keys[i]</span><span class="s1">;</span>
                <span class="s2">ret[i] = renderItem(source[key]</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">ret = []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(cache) {</span>
        <span class="s2">cache[index] = ret</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Compiler runtime helper for creating dynamic slots object</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createSlots(slots</span><span class="s1">, </span><span class="s2">dynamicSlots) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; dynamicSlots.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">slot = dynamicSlots[i]</span><span class="s1">;</span>
        <span class="s3">// array of dynamic slot generated by &lt;template v-for=&quot;...&quot; #[...]&gt;</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(slot)) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">j &lt; slot.length</span><span class="s1">; </span><span class="s2">j++) {</span>
                <span class="s2">slots[slot[j].name] = slot[j].fn</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(slot) {</span>
            <span class="s3">// conditional single slot generated by &lt;template v-if=&quot;...&quot; #foo&gt;</span>
            <span class="s2">slots[slot.name] = slot.key</span>
                <span class="s2">? (...args) =&gt; {</span>
                    <span class="s1">const </span><span class="s2">res = slot.fn(...args)</span><span class="s1">;</span>
                    <span class="s3">// attach branch key so each conditional branch is considered a</span>
                    <span class="s3">// different fragment</span>
                    <span class="s1">if </span><span class="s2">(res)</span>
                        <span class="s2">res.key = slot.key</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">: slot.fn</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">slots</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Compiler runtime helper for rendering `&lt;slot/&gt;`</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">renderSlot(slots</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">props = {}</span><span class="s1">, </span>
<span class="s3">// this is not a user-facing function, so the fallback is always generated by</span>
<span class="s3">// the compiler and guaranteed to be a function returning an array</span>
<span class="s2">fallback</span><span class="s1">, </span><span class="s2">noSlotted) {</span>
    <span class="s1">if </span><span class="s2">(currentRenderingInstance.isCE ||</span>
        <span class="s2">(currentRenderingInstance.parent &amp;&amp;</span>
            <span class="s2">isAsyncWrapper(currentRenderingInstance.parent) &amp;&amp;</span>
            <span class="s2">currentRenderingInstance.parent.isCE)) {</span>
        <span class="s1">if </span><span class="s2">(name !== </span><span class="s0">'default'</span><span class="s2">)</span>
            <span class="s2">props.name = name</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createVNode(</span><span class="s0">'slot'</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">fallback &amp;&amp; fallback())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">slot = slots[name]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(slot &amp;&amp; slot.length &gt; </span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s2">warn(</span><span class="s0">`SSR-optimized slot function detected in a non-SSR-optimized render ` </span><span class="s2">+</span>
            <span class="s0">`function. You need to mark this component with $dynamic-slots in the ` </span><span class="s2">+</span>
            <span class="s0">`parent template.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">slot = () =&gt; []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// a compiled slot disables block tracking by default to avoid manual</span>
    <span class="s3">// invocation interfering with template-based block tracking, but in</span>
    <span class="s3">// `renderSlot` we can be sure that it's template-based so we can force</span>
    <span class="s3">// enable it.</span>
    <span class="s1">if </span><span class="s2">(slot &amp;&amp; slot._c) {</span>
        <span class="s2">slot._d = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s2">openBlock()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props))</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rendered = createBlock(Fragment</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">key: props.key ||</span>
            <span class="s3">// slot content array of a dynamic conditional slot may have a branch</span>
            <span class="s3">// key attached in the `createSlots` helper, respect that</span>
            <span class="s2">(validSlotContent &amp;&amp; validSlotContent.key) ||</span>
            <span class="s0">`_</span><span class="s2">${name}</span><span class="s0">`</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">validSlotContent || (fallback ? fallback() : [])</span><span class="s1">, </span><span class="s2">validSlotContent &amp;&amp; slots._ === </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span>
        <span class="s2">? </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span>
        <span class="s2">: -</span><span class="s4">2 </span><span class="s3">/* PatchFlags.BAIL */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!noSlotted &amp;&amp; rendered.scopeId) {</span>
        <span class="s2">rendered.slotScopeIds = [rendered.scopeId + </span><span class="s0">'-s'</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(slot &amp;&amp; slot._c) {</span>
        <span class="s2">slot._d = </span><span class="s1">true;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">rendered</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">ensureValidVNode(vnodes) {</span>
    <span class="s1">return </span><span class="s2">vnodes.some(child =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!isVNode(child))</span>
            <span class="s1">return true;</span>
        <span class="s1">if </span><span class="s2">(child.type === Comment)</span>
            <span class="s1">return false;</span>
        <span class="s1">if </span><span class="s2">(child.type === Fragment &amp;&amp;</span>
            <span class="s2">!ensureValidVNode(child.children))</span>
            <span class="s1">return false;</span>
        <span class="s1">return true;</span>
    <span class="s2">})</span>
        <span class="s2">? vnodes</span>
        <span class="s2">: </span><span class="s1">null;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* For prefixing keys in v-on=&quot;obj&quot; with &quot;on&quot;</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">toHandlers(obj</span><span class="s1">, </span><span class="s2">preserveCaseIfNecessary) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!shared.isObject(obj)) {</span>
        <span class="s2">warn(</span><span class="s0">`v-on with no argument expects an object value.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">obj) {</span>
        <span class="s2">ret[preserveCaseIfNecessary &amp;&amp; </span><span class="s4">/[A-Z]/</span><span class="s2">.test(key)</span>
            <span class="s2">? </span><span class="s0">`on:</span><span class="s2">${key}</span><span class="s0">`</span>
            <span class="s2">: shared.toHandlerKey(key)] = obj[key]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* #2437 In Vue 3, functional components do not have a public instance proxy but</span>
 <span class="s5">* they exist in the internal parent chain. For code that relies on traversing</span>
 <span class="s5">* public $parent chains, skip functional ones and go to the parent instead.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">getPublicInstance = (i) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(!i)</span>
        <span class="s1">return null;</span>
    <span class="s1">if </span><span class="s2">(isStatefulComponent(i))</span>
        <span class="s1">return </span><span class="s2">getExposeProxy(i) || i.proxy</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">getPublicInstance(i.parent)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">publicPropertiesMap = </span>
<span class="s3">// Move PURE marker to new line to workaround compiler discarding it</span>
<span class="s3">// due to type annotation</span>
<span class="s3">/*#__PURE__*/ </span><span class="s2">shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">$: i =&gt; i</span><span class="s1">,</span>
    <span class="s2">$el: i =&gt; i.vnode.el</span><span class="s1">,</span>
    <span class="s2">$data: i =&gt; i.data</span><span class="s1">,</span>
    <span class="s2">$props: i =&gt; (reactivity.shallowReadonly(i.props) )</span><span class="s1">,</span>
    <span class="s2">$attrs: i =&gt; (reactivity.shallowReadonly(i.attrs) )</span><span class="s1">,</span>
    <span class="s2">$slots: i =&gt; (reactivity.shallowReadonly(i.slots) )</span><span class="s1">,</span>
    <span class="s2">$refs: i =&gt; (reactivity.shallowReadonly(i.refs) )</span><span class="s1">,</span>
    <span class="s2">$parent: i =&gt; getPublicInstance(i.parent)</span><span class="s1">,</span>
    <span class="s2">$root: i =&gt; getPublicInstance(i.root)</span><span class="s1">,</span>
    <span class="s2">$emit: i =&gt; i.emit</span><span class="s1">,</span>
    <span class="s2">$options: i =&gt; (resolveMergedOptions(i) )</span><span class="s1">,</span>
    <span class="s2">$forceUpdate: i =&gt; i.f || (i.f = () =&gt; queueJob(i.update))</span><span class="s1">,</span>
    <span class="s2">$nextTick: i =&gt; i.n || (i.n = nextTick.bind(i.proxy))</span><span class="s1">,</span>
    <span class="s2">$watch: i =&gt; (instanceWatch.bind(i) )</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isReservedPrefix = (key) =&gt; key === </span><span class="s0">'_' </span><span class="s2">|| key === </span><span class="s0">'$'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">hasSetupBinding = (state</span><span class="s1">, </span><span class="s2">key) =&gt; state !== shared.EMPTY_OBJ &amp;&amp; !state.__isScriptSetup &amp;&amp; shared.hasOwn(state</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">PublicInstanceProxyHandlers = {</span>
    <span class="s2">get({ _: instance }</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">const </span><span class="s2">{ ctx</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">accessCache</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">appContext } = instance</span><span class="s1">;</span>
        <span class="s3">// for internal formatters to know that this is a Vue instance</span>
        <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'__isVue'</span><span class="s2">) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s3">// data / props / ctx</span>
        <span class="s3">// This getter gets called for every property access on the render context</span>
        <span class="s3">// during render and is a major hotspot. The most expensive part of this</span>
        <span class="s3">// is the multiple hasOwn() calls. It's much faster to do a simple property</span>
        <span class="s3">// access on a plain object, so we use an accessCache object (with null</span>
        <span class="s3">// prototype) to memoize what access type a key corresponds to.</span>
        <span class="s1">let </span><span class="s2">normalizedProps</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(key[</span><span class="s4">0</span><span class="s2">] !== </span><span class="s0">'$'</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">n = accessCache[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(n !== undefined) {</span>
                <span class="s1">switch </span><span class="s2">(n) {</span>
                    <span class="s1">case </span><span class="s4">1 </span><span class="s3">/* AccessTypes.SETUP */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">setupState[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s4">2 </span><span class="s3">/* AccessTypes.DATA */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">data[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s4">4 </span><span class="s3">/* AccessTypes.CONTEXT */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s4">3 </span><span class="s3">/* AccessTypes.PROPS */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">props[key]</span><span class="s1">;</span>
                    <span class="s3">// default: just fallthrough</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s4">1 </span><span class="s3">/* AccessTypes.SETUP */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">setupState[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s4">2 </span><span class="s3">/* AccessTypes.DATA */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">data[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(</span>
            <span class="s3">// only cache other properties when instance has declared (thus stable)</span>
            <span class="s3">// props</span>
            <span class="s2">(normalizedProps = instance.propsOptions[</span><span class="s4">0</span><span class="s2">]) &amp;&amp;</span>
                <span class="s2">shared.hasOwn(normalizedProps</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s4">3 </span><span class="s3">/* AccessTypes.PROPS */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">props[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(ctx !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s4">4 </span><span class="s3">/* AccessTypes.CONTEXT */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shouldCacheAccess) {</span>
                <span class="s2">accessCache[key] = </span><span class="s4">0 </span><span class="s3">/* AccessTypes.OTHER */</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">publicGetter = publicPropertiesMap[key]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">cssModule</span><span class="s1">, </span><span class="s2">globalProperties</span><span class="s1">;</span>
        <span class="s3">// public $xxx properties</span>
        <span class="s1">if </span><span class="s2">(publicGetter) {</span>
            <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'$attrs'</span><span class="s2">) {</span>
                <span class="s2">reactivity.track(instance</span><span class="s1">, </span><span class="s0">&quot;get&quot; </span><span class="s3">/* TrackOpTypes.GET */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
                <span class="s2">markAttrsAccessed()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">publicGetter(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span>
        <span class="s3">// css module (injected by vue-loader)</span>
        <span class="s2">(cssModule = type.__cssModules) &amp;&amp;</span>
            <span class="s2">(cssModule = cssModule[key])) {</span>
            <span class="s1">return </span><span class="s2">cssModule</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(ctx !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s3">// user may set custom properties to `this` that start with `$`</span>
            <span class="s2">accessCache[key] = </span><span class="s4">4 </span><span class="s3">/* AccessTypes.CONTEXT */</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span>
        <span class="s3">// global properties</span>
        <span class="s2">((globalProperties = appContext.config.globalProperties)</span><span class="s1">,</span>
            <span class="s2">shared.hasOwn(globalProperties</span><span class="s1">, </span><span class="s2">key))) {</span>
            <span class="s2">{</span>
                <span class="s1">return </span><span class="s2">globalProperties[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(currentRenderingInstance &amp;&amp;</span>
            <span class="s2">(!shared.isString(key) ||</span>
                <span class="s3">// #1091 avoid internal isRef/isVNode checks on component instance leading</span>
                <span class="s3">// to infinite warning loop</span>
                <span class="s2">key.indexOf(</span><span class="s0">'__v'</span><span class="s2">) !== </span><span class="s4">0</span><span class="s2">)) {</span>
            <span class="s1">if </span><span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; isReservedPrefix(key[</span><span class="s4">0</span><span class="s2">]) &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">warn(</span><span class="s0">`Property </span><span class="s2">${JSON.stringify(key)} </span><span class="s0">must be accessed via $data because it starts with a reserved ` </span><span class="s2">+</span>
                    <span class="s0">`character (&quot;$&quot; or &quot;_&quot;) and is not proxied on the render context.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(instance === currentRenderingInstance) {</span>
                <span class="s2">warn(</span><span class="s0">`Property </span><span class="s2">${JSON.stringify(key)} </span><span class="s0">was accessed during render ` </span><span class="s2">+</span>
                    <span class="s0">`but is not defined on instance.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">set({ _: instance }</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">value) {</span>
        <span class="s1">const </span><span class="s2">{ data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">ctx } = instance</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">setupState[key] = value</span><span class="s1">;</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(setupState.__isScriptSetup &amp;&amp;</span>
            <span class="s2">shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">warn(</span><span class="s0">`Cannot mutate &lt;script setup&gt; binding &quot;</span><span class="s2">${key}</span><span class="s0">&quot; from Options API.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">data[key] = value</span><span class="s1">;</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.hasOwn(instance.props</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">warn(</span><span class="s0">`Attempting to mutate prop &quot;</span><span class="s2">${key}</span><span class="s0">&quot;. Props are readonly.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(key[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'$' </span><span class="s2">&amp;&amp; key.slice(</span><span class="s4">1</span><span class="s2">) </span><span class="s1">in </span><span class="s2">instance) {</span>
            <span class="s2">warn(</span><span class="s0">`Attempting to mutate public property &quot;</span><span class="s2">${key}</span><span class="s0">&quot;. ` </span><span class="s2">+</span>
                    <span class="s0">`Properties starting with $ are reserved and readonly.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">instance.appContext.config.globalProperties) {</span>
                <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                    <span class="s2">enumerable: </span><span class="s1">true,</span>
                    <span class="s2">configurable: </span><span class="s1">true,</span>
                    <span class="s2">value</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">ctx[key] = value</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">has({ _: { data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">accessCache</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">propsOptions } }</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">let </span><span class="s2">normalizedProps</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">(!!accessCache[key] ||</span>
            <span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) ||</span>
            <span class="s2">hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">((normalizedProps = propsOptions[</span><span class="s4">0</span><span class="s2">]) &amp;&amp; shared.hasOwn(normalizedProps</span><span class="s1">, </span><span class="s2">key)) ||</span>
            <span class="s2">shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">shared.hasOwn(publicPropertiesMap</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">shared.hasOwn(appContext.config.globalProperties</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">defineProperty(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor) {</span>
        <span class="s1">if </span><span class="s2">(descriptor.get != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s3">// invalidate key cache of a getter based property #5417</span>
            <span class="s2">target._.accessCache[key] = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.hasOwn(descriptor</span><span class="s1">, </span><span class="s0">'value'</span><span class="s2">)) {</span>
            <span class="s1">this</span><span class="s2">.set(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor.value</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">Reflect.defineProperty(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s2">{</span>
    <span class="s2">PublicInstanceProxyHandlers.ownKeys = (target) =&gt; {</span>
        <span class="s2">warn(</span><span class="s0">`Avoid app logic that relies on enumerating keys on a component instance. ` </span><span class="s2">+</span>
            <span class="s0">`The keys will be empty in production mode to avoid performance overhead.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">Reflect.ownKeys(target)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">RuntimeCompiledPublicInstanceProxyHandlers = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">shared.extend({}</span><span class="s1">, </span><span class="s2">PublicInstanceProxyHandlers</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s3">// fast path for unscopables when using `with` block</span>
        <span class="s1">if </span><span class="s2">(key === Symbol.unscopables) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">PublicInstanceProxyHandlers.get(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">has(_</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">const </span><span class="s2">has = key[</span><span class="s4">0</span><span class="s2">] !== </span><span class="s0">'_' </span><span class="s2">&amp;&amp; !shared.isGloballyWhitelisted(key)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!has &amp;&amp; PublicInstanceProxyHandlers.has(_</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">warn(</span><span class="s0">`Property </span><span class="s2">${JSON.stringify(key)} </span><span class="s0">should not start with _ which is a reserved prefix for Vue internals.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">has</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s3">// dev only</span>
<span class="s3">// In dev mode, the proxy target exposes the same properties as seen on `this`</span>
<span class="s3">// for easier console inspection. In prod mode it will be an empty object so</span>
<span class="s3">// these properties definitions can be skipped.</span>
<span class="s1">function </span><span class="s2">createDevRenderContext(instance) {</span>
    <span class="s1">const </span><span class="s2">target = {}</span><span class="s1">;</span>
    <span class="s3">// expose internal instance for proxy handlers</span>
    <span class="s2">Object.defineProperty(target</span><span class="s1">, </span><span class="s0">`_`</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">configurable: </span><span class="s1">true,</span>
        <span class="s2">enumerable: </span><span class="s1">false,</span>
        <span class="s2">get: () =&gt; instance</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s3">// expose public properties</span>
    <span class="s2">Object.keys(publicPropertiesMap).forEach(key =&gt; {</span>
        <span class="s2">Object.defineProperty(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">configurable: </span><span class="s1">true,</span>
            <span class="s2">enumerable: </span><span class="s1">false,</span>
            <span class="s2">get: () =&gt; publicPropertiesMap[key](instance)</span><span class="s1">,</span>
            <span class="s3">// intercepted by the proxy so no need for implementation,</span>
            <span class="s3">// but needed to prevent set errors</span>
            <span class="s2">set: shared.NOOP</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">target</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// dev only</span>
<span class="s1">function </span><span class="s2">exposePropsOnRenderContext(instance) {</span>
    <span class="s1">const </span><span class="s2">{ ctx</span><span class="s1">, </span><span class="s2">propsOptions: [propsOptions] } = instance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(propsOptions) {</span>
        <span class="s2">Object.keys(propsOptions).forEach(key =&gt; {</span>
            <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">configurable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; instance.props[key]</span><span class="s1">,</span>
                <span class="s2">set: shared.NOOP</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">// dev only</span>
<span class="s1">function </span><span class="s2">exposeSetupStateOnRenderContext(instance) {</span>
    <span class="s1">const </span><span class="s2">{ ctx</span><span class="s1">, </span><span class="s2">setupState } = instance</span><span class="s1">;</span>
    <span class="s2">Object.keys(reactivity.toRaw(setupState)).forEach(key =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!setupState.__isScriptSetup) {</span>
            <span class="s1">if </span><span class="s2">(isReservedPrefix(key[</span><span class="s4">0</span><span class="s2">])) {</span>
                <span class="s2">warn(</span><span class="s0">`setup() return property </span><span class="s2">${JSON.stringify(key)} </span><span class="s0">should not start with &quot;$&quot; or &quot;_&quot; ` </span><span class="s2">+</span>
                    <span class="s0">`which are reserved prefixes for Vue internals.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">configurable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; setupState[key]</span><span class="s1">,</span>
                <span class="s2">set: shared.NOOP</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">createDuplicateChecker() {</span>
    <span class="s1">const </span><span class="s2">cache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(type</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(cache[key]) {</span>
            <span class="s2">warn(</span><span class="s0">`</span><span class="s2">${type} </span><span class="s0">property &quot;</span><span class="s2">${key}</span><span class="s0">&quot; is already defined in </span><span class="s2">${cache[key]}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">cache[key] = type</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">shouldCacheAccess = </span><span class="s1">true;</span>
<span class="s1">function </span><span class="s2">applyOptions(instance) {</span>
    <span class="s1">const </span><span class="s2">options = resolveMergedOptions(instance)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">publicThis = instance.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ctx = instance.ctx</span><span class="s1">;</span>
    <span class="s3">// do not cache property access on public proxy during state initialization</span>
    <span class="s2">shouldCacheAccess = </span><span class="s1">false;</span>
    <span class="s3">// call beforeCreate first before accessing other options since</span>
    <span class="s3">// the hook may mutate resolved options (#2791)</span>
    <span class="s1">if </span><span class="s2">(options.beforeCreate) {</span>
        <span class="s2">callHook(options.beforeCreate</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s0">&quot;bc&quot; </span><span class="s3">/* LifecycleHooks.BEFORE_CREATE */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ </span>
    <span class="s3">// state</span>
    <span class="s2">data: dataOptions</span><span class="s1">, </span><span class="s2">computed: computedOptions</span><span class="s1">, </span><span class="s2">methods</span><span class="s1">, </span><span class="s2">watch: watchOptions</span><span class="s1">, </span><span class="s2">provide: provideOptions</span><span class="s1">, </span><span class="s2">inject: injectOptions</span><span class="s1">, </span>
    <span class="s3">// lifecycle</span>
    <span class="s2">created</span><span class="s1">, </span><span class="s2">beforeMount</span><span class="s1">, </span><span class="s2">mounted</span><span class="s1">, </span><span class="s2">beforeUpdate</span><span class="s1">, </span><span class="s2">updated</span><span class="s1">, </span><span class="s2">activated</span><span class="s1">, </span><span class="s2">deactivated</span><span class="s1">, </span><span class="s2">beforeDestroy</span><span class="s1">, </span><span class="s2">beforeUnmount</span><span class="s1">, </span><span class="s2">destroyed</span><span class="s1">, </span><span class="s2">unmounted</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">renderTracked</span><span class="s1">, </span><span class="s2">renderTriggered</span><span class="s1">, </span><span class="s2">errorCaptured</span><span class="s1">, </span><span class="s2">serverPrefetch</span><span class="s1">, </span>
    <span class="s3">// public API</span>
    <span class="s2">expose</span><span class="s1">, </span><span class="s2">inheritAttrs</span><span class="s1">, </span>
    <span class="s3">// assets</span>
    <span class="s2">components</span><span class="s1">, </span><span class="s2">directives</span><span class="s1">, </span><span class="s2">filters } = options</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">checkDuplicateProperties = createDuplicateChecker() </span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">[propsOptions] = instance.propsOptions</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(propsOptions) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">propsOptions) {</span>
                <span class="s2">checkDuplicateProperties(</span><span class="s0">&quot;Props&quot; </span><span class="s3">/* OptionTypes.PROPS */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// options initialization order (to be consistent with Vue 2):</span>
    <span class="s3">// - props (already done outside of this function)</span>
    <span class="s3">// - inject</span>
    <span class="s3">// - methods</span>
    <span class="s3">// - data (deferred since it relies on `this` access)</span>
    <span class="s3">// - computed</span>
    <span class="s3">// - watch (deferred since it relies on `this` access)</span>
    <span class="s1">if </span><span class="s2">(injectOptions) {</span>
        <span class="s2">resolveInjections(injectOptions</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">checkDuplicateProperties</span><span class="s1">, </span><span class="s2">instance.appContext.config.unwrapInjectedRef)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(methods) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">methods) {</span>
            <span class="s1">const </span><span class="s2">methodHandler = methods[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(methodHandler)) {</span>
                <span class="s3">// In dev mode, we use the `createRenderContext` function to define</span>
                <span class="s3">// methods to the proxy target, and those are read-only but</span>
                <span class="s3">// reconfigurable, so it needs to be redefined here</span>
                <span class="s2">{</span>
                    <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                        <span class="s2">value: methodHandler.bind(publicThis)</span><span class="s1">,</span>
                        <span class="s2">configurable: </span><span class="s1">true,</span>
                        <span class="s2">enumerable: </span><span class="s1">true,</span>
                        <span class="s2">writable: </span><span class="s1">true</span>
                    <span class="s2">})</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">{</span>
                    <span class="s2">checkDuplicateProperties(</span><span class="s0">&quot;Methods&quot; </span><span class="s3">/* OptionTypes.METHODS */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">warn(</span><span class="s0">`Method &quot;</span><span class="s2">${key}</span><span class="s0">&quot; has type &quot;</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">methodHandler}</span><span class="s0">&quot; in the component definition. ` </span><span class="s2">+</span>
                    <span class="s0">`Did you reference the function correctly?`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(dataOptions) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isFunction(dataOptions)) {</span>
            <span class="s2">warn(</span><span class="s0">`The data option must be a function. ` </span><span class="s2">+</span>
                <span class="s0">`Plain object usage is no longer supported.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">data = dataOptions.call(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isPromise(data)) {</span>
            <span class="s2">warn(</span><span class="s0">`data() returned a Promise - note data() cannot be async; If you ` </span><span class="s2">+</span>
                <span class="s0">`intend to perform data fetching before component renders, use ` </span><span class="s2">+</span>
                <span class="s0">`async setup() + &lt;Suspense&gt;.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!shared.isObject(data)) {</span>
            <span class="s2">warn(</span><span class="s0">`data() should return an object.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">instance.data = reactivity.reactive(data)</span><span class="s1">;</span>
            <span class="s2">{</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">data) {</span>
                    <span class="s2">checkDuplicateProperties(</span><span class="s0">&quot;Data&quot; </span><span class="s3">/* OptionTypes.DATA */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
                    <span class="s3">// expose data on ctx during dev</span>
                    <span class="s1">if </span><span class="s2">(!isReservedPrefix(key[</span><span class="s4">0</span><span class="s2">])) {</span>
                        <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                            <span class="s2">configurable: </span><span class="s1">true,</span>
                            <span class="s2">enumerable: </span><span class="s1">true,</span>
                            <span class="s2">get: () =&gt; data[key]</span><span class="s1">,</span>
                            <span class="s2">set: shared.NOOP</span>
                        <span class="s2">})</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// state initialization complete at this point - start caching access</span>
    <span class="s2">shouldCacheAccess = </span><span class="s1">true;</span>
    <span class="s1">if </span><span class="s2">(computedOptions) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">computedOptions) {</span>
            <span class="s1">const </span><span class="s2">opt = computedOptions[key]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">get = shared.isFunction(opt)</span>
                <span class="s2">? opt.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span>
                <span class="s2">: shared.isFunction(opt.get)</span>
                    <span class="s2">? opt.get.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span>
                    <span class="s2">: shared.NOOP</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(get === shared.NOOP) {</span>
                <span class="s2">warn(</span><span class="s0">`Computed property &quot;</span><span class="s2">${key}</span><span class="s0">&quot; has no getter.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">set = !shared.isFunction(opt) &amp;&amp; shared.isFunction(opt.set)</span>
                <span class="s2">? opt.set.bind(publicThis)</span>
                <span class="s2">: () =&gt; {</span>
                        <span class="s2">warn(</span><span class="s0">`Write operation failed: computed property &quot;</span><span class="s2">${key}</span><span class="s0">&quot; is readonly.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">;</span>
            <span class="s1">const </span><span class="s2">c = computed({</span>
                <span class="s2">get</span><span class="s1">,</span>
                <span class="s2">set</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">configurable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; c.value</span><span class="s1">,</span>
                <span class="s2">set: v =&gt; (c.value = v)</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">{</span>
                <span class="s2">checkDuplicateProperties(</span><span class="s0">&quot;Computed&quot; </span><span class="s3">/* OptionTypes.COMPUTED */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(watchOptions) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">watchOptions) {</span>
            <span class="s2">createWatcher(watchOptions[key]</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(provideOptions) {</span>
        <span class="s1">const </span><span class="s2">provides = shared.isFunction(provideOptions)</span>
            <span class="s2">? provideOptions.call(publicThis)</span>
            <span class="s2">: provideOptions</span><span class="s1">;</span>
        <span class="s2">Reflect.ownKeys(provides).forEach(key =&gt; {</span>
            <span class="s2">provide(key</span><span class="s1">, </span><span class="s2">provides[key])</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(created) {</span>
        <span class="s2">callHook(created</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s0">&quot;c&quot; </span><span class="s3">/* LifecycleHooks.CREATED */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">registerLifecycleHook(register</span><span class="s1">, </span><span class="s2">hook) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(hook)) {</span>
            <span class="s2">hook.forEach(_hook =&gt; register(_hook.bind(publicThis)))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(hook) {</span>
            <span class="s2">register(hook.bind(publicThis))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">registerLifecycleHook(onBeforeMount</span><span class="s1">, </span><span class="s2">beforeMount)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onMounted</span><span class="s1">, </span><span class="s2">mounted)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onBeforeUpdate</span><span class="s1">, </span><span class="s2">beforeUpdate)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onUpdated</span><span class="s1">, </span><span class="s2">updated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onActivated</span><span class="s1">, </span><span class="s2">activated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onDeactivated</span><span class="s1">, </span><span class="s2">deactivated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onErrorCaptured</span><span class="s1">, </span><span class="s2">errorCaptured)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onRenderTracked</span><span class="s1">, </span><span class="s2">renderTracked)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onRenderTriggered</span><span class="s1">, </span><span class="s2">renderTriggered)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onBeforeUnmount</span><span class="s1">, </span><span class="s2">beforeUnmount)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onUnmounted</span><span class="s1">, </span><span class="s2">unmounted)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onServerPrefetch</span><span class="s1">, </span><span class="s2">serverPrefetch)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(expose)) {</span>
        <span class="s1">if </span><span class="s2">(expose.length) {</span>
            <span class="s1">const </span><span class="s2">exposed = instance.exposed || (instance.exposed = {})</span><span class="s1">;</span>
            <span class="s2">expose.forEach(key =&gt; {</span>
                <span class="s2">Object.defineProperty(exposed</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                    <span class="s2">get: () =&gt; publicThis[key]</span><span class="s1">,</span>
                    <span class="s2">set: val =&gt; (publicThis[key] = val)</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!instance.exposed) {</span>
            <span class="s2">instance.exposed = {}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// options that are handled when creating the instance but also need to be</span>
    <span class="s3">// applied from mixins</span>
    <span class="s1">if </span><span class="s2">(render &amp;&amp; instance.render === shared.NOOP) {</span>
        <span class="s2">instance.render = render</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(inheritAttrs != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">instance.inheritAttrs = inheritAttrs</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// asset options.</span>
    <span class="s1">if </span><span class="s2">(components)</span>
        <span class="s2">instance.components = components</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(directives)</span>
        <span class="s2">instance.directives = directives</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveInjections(injectOptions</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">checkDuplicateProperties = shared.NOOP</span><span class="s1">, </span><span class="s2">unwrapRef = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(injectOptions)) {</span>
        <span class="s2">injectOptions = normalizeInject(injectOptions)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">injectOptions) {</span>
        <span class="s1">const </span><span class="s2">opt = injectOptions[key]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">injected</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(opt)) {</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'default' </span><span class="s1">in </span><span class="s2">opt) {</span>
                <span class="s2">injected = inject(opt.from || key</span><span class="s1">, </span><span class="s2">opt.default</span><span class="s1">, true </span><span class="s3">/* treat default function as factory */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">injected = inject(opt.from || key)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">injected = inject(opt)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(reactivity.isRef(injected)) {</span>
            <span class="s3">// TODO remove the check in 3.3</span>
            <span class="s1">if </span><span class="s2">(unwrapRef) {</span>
                <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                    <span class="s2">enumerable: </span><span class="s1">true,</span>
                    <span class="s2">configurable: </span><span class="s1">true,</span>
                    <span class="s2">get: () =&gt; injected.value</span><span class="s1">,</span>
                    <span class="s2">set: v =&gt; (injected.value = v)</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`injected property &quot;</span><span class="s2">${key}</span><span class="s0">&quot; is a ref and will be auto-unwrapped ` </span><span class="s2">+</span>
                        <span class="s0">`and no longer needs </span><span class="s1">\`</span><span class="s0">.value</span><span class="s1">\` </span><span class="s0">in the next minor release. ` </span><span class="s2">+</span>
                        <span class="s0">`To opt-in to the new behavior now, ` </span><span class="s2">+</span>
                        <span class="s0">`set </span><span class="s1">\`</span><span class="s0">app.config.unwrapInjectedRef = true</span><span class="s1">\` </span><span class="s0">(this config is ` </span><span class="s2">+</span>
                        <span class="s0">`temporary and will not be needed in the future.)`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">ctx[key] = injected</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">ctx[key] = injected</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">{</span>
            <span class="s2">checkDuplicateProperties(</span><span class="s0">&quot;Inject&quot; </span><span class="s3">/* OptionTypes.INJECT */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s2">callWithAsyncErrorHandling(shared.isArray(hook)</span>
        <span class="s2">? hook.map(h =&gt; h.bind(instance.proxy))</span>
        <span class="s2">: hook.bind(instance.proxy)</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createWatcher(raw</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key) {</span>
    <span class="s1">const </span><span class="s2">getter = key.includes(</span><span class="s0">'.'</span><span class="s2">)</span>
        <span class="s2">? createPathGetter(publicThis</span><span class="s1">, </span><span class="s2">key)</span>
        <span class="s2">: () =&gt; publicThis[key]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isString(raw)) {</span>
        <span class="s1">const </span><span class="s2">handler = ctx[raw]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isFunction(handler)) {</span>
            <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">handler)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">`Invalid watch handler specified by key &quot;</span><span class="s2">${raw}</span><span class="s0">&quot;`</span><span class="s1">, </span><span class="s2">handler)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(raw)) {</span>
        <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">raw.bind(publicThis))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(raw)) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
            <span class="s2">raw.forEach(r =&gt; createWatcher(r</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">handler = shared.isFunction(raw.handler)</span>
                <span class="s2">? raw.handler.bind(publicThis)</span>
                <span class="s2">: ctx[raw.handler]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(handler)) {</span>
                <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">handler</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">warn(</span><span class="s0">`Invalid watch handler specified by key &quot;</span><span class="s2">${raw.handler}</span><span class="s0">&quot;`</span><span class="s1">, </span><span class="s2">handler)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">warn(</span><span class="s0">`Invalid watch option: &quot;</span><span class="s2">${key}</span><span class="s0">&quot;`</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Resolve merged options and cache it on the component.</span>
 <span class="s5">* This is done only once per-component since the merging does not involve</span>
 <span class="s5">* instances.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">resolveMergedOptions(instance) {</span>
    <span class="s1">const </span><span class="s2">base = instance.type</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ mixins</span><span class="s1">, extends</span><span class="s2">: extendsOptions } = base</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ mixins: globalMixins</span><span class="s1">, </span><span class="s2">optionsCache: cache</span><span class="s1">, </span><span class="s2">config: { optionMergeStrategies } } = instance.appContext</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(base)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">resolved</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached) {</span>
        <span class="s2">resolved = cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(!globalMixins.length &amp;&amp; !mixins &amp;&amp; !extendsOptions) {</span>
        <span class="s2">{</span>
            <span class="s2">resolved = base</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">resolved = {}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(globalMixins.length) {</span>
            <span class="s2">globalMixins.forEach(m =&gt; mergeOptions(resolved</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">optionMergeStrategies</span><span class="s1">, true</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">mergeOptions(resolved</span><span class="s1">, </span><span class="s2">base</span><span class="s1">, </span><span class="s2">optionMergeStrategies)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(base)) {</span>
        <span class="s2">cache.set(base</span><span class="s1">, </span><span class="s2">resolved)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">resolved</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeOptions(to</span><span class="s1">, </span><span class="s2">from</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ mixins</span><span class="s1">, extends</span><span class="s2">: extendsOptions } = from</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(extendsOptions) {</span>
        <span class="s2">mergeOptions(to</span><span class="s1">, </span><span class="s2">extendsOptions</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(mixins) {</span>
        <span class="s2">mixins.forEach((m) =&gt; mergeOptions(to</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, true</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">from) {</span>
        <span class="s1">if </span><span class="s2">(asMixin &amp;&amp; key === </span><span class="s0">'expose'</span><span class="s2">) {</span>
            <span class="s2">warn(</span><span class="s0">`&quot;expose&quot; option is ignored when declared in mixins or extends. ` </span><span class="s2">+</span>
                    <span class="s0">`It should only be declared in the base component itself.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">strat = internalOptionMergeStrats[key] || (strats &amp;&amp; strats[key])</span><span class="s1">;</span>
            <span class="s2">to[key] = strat ? strat(to[key]</span><span class="s1">, </span><span class="s2">from[key]) : from[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">internalOptionMergeStrats = {</span>
    <span class="s2">data: mergeDataFn</span><span class="s1">,</span>
    <span class="s2">props: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">emits: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s3">// objects</span>
    <span class="s2">methods: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">computed: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s3">// lifecycle</span>
    <span class="s2">beforeCreate: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">created: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeMount: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">mounted: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeUpdate: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">updated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeDestroy: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeUnmount: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">destroyed: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">unmounted: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">activated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">deactivated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">errorCaptured: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">serverPrefetch: mergeAsArray</span><span class="s1">,</span>
    <span class="s3">// assets</span>
    <span class="s2">components: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">directives: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s3">// watch</span>
    <span class="s2">watch: mergeWatchOptions</span><span class="s1">,</span>
    <span class="s3">// provide / inject</span>
    <span class="s2">provide: mergeDataFn</span><span class="s1">,</span>
    <span class="s2">inject: mergeInject</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">mergeDataFn(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">if </span><span class="s2">(!from) {</span>
        <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!to) {</span>
        <span class="s1">return </span><span class="s2">from</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return function </span><span class="s2">mergedDataFn() {</span>
        <span class="s1">return </span><span class="s2">(shared.extend)(shared.isFunction(to) ? to.call(</span><span class="s1">this, this</span><span class="s2">) : to</span><span class="s1">, </span><span class="s2">shared.isFunction(from) ? from.call(</span><span class="s1">this, this</span><span class="s2">) : from)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeInject(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">mergeObjectOptions(normalizeInject(to)</span><span class="s1">, </span><span class="s2">normalizeInject(from))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeInject(raw) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s1">const </span><span class="s2">res = {}</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; raw.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">res[raw[i]] = raw[i]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">raw</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeAsArray(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">to ? [...</span><span class="s1">new </span><span class="s2">Set([].concat(to</span><span class="s1">, </span><span class="s2">from))] : from</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeObjectOptions(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">to ? shared.extend(shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">to)</span><span class="s1">, </span><span class="s2">from) : from</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeWatchOptions(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">if </span><span class="s2">(!to)</span>
        <span class="s1">return </span><span class="s2">from</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!from)</span>
        <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">merged = shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">to)</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">from) {</span>
        <span class="s2">merged[key] = mergeAsArray(to[key]</span><span class="s1">, </span><span class="s2">from[key])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">merged</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">initProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">isStateful</span><span class="s1">, </span><span class="s3">// result of bitwise flag comparison</span>
<span class="s2">isSSR = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">props = {}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">attrs = {}</span><span class="s1">;</span>
    <span class="s2">shared.def(attrs</span><span class="s1">, </span><span class="s2">InternalObjectKey</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">instance.propsDefaults = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs)</span><span class="s1">;</span>
    <span class="s3">// ensure all declared prop keys are present</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">instance.propsOptions[</span><span class="s4">0</span><span class="s2">]) {</span>
        <span class="s1">if </span><span class="s2">(!(key </span><span class="s1">in </span><span class="s2">props)) {</span>
            <span class="s2">props[key] = undefined</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// validation</span>
    <span class="s2">{</span>
        <span class="s2">validateProps(rawProps || {}</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isStateful) {</span>
        <span class="s3">// stateful</span>
        <span class="s2">instance.props = isSSR ? props : reactivity.shallowReactive(props)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(!instance.type.props) {</span>
            <span class="s3">// functional w/ optional props, props === attrs</span>
            <span class="s2">instance.props = attrs</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// functional w/ declared props</span>
            <span class="s2">instance.props = props</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">instance.attrs = attrs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isInHmrContext(instance) {</span>
    <span class="s1">while </span><span class="s2">(instance) {</span>
        <span class="s1">if </span><span class="s2">(instance.type.__hmrId)</span>
            <span class="s1">return true;</span>
        <span class="s2">instance = instance.parent</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">updateProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">rawPrevProps</span><span class="s1">, </span><span class="s2">optimized) {</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">attrs</span><span class="s1">, </span><span class="s2">vnode: { patchFlag } } = instance</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rawCurrentProps = reactivity.toRaw(props)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">[options] = instance.propsOptions</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hasAttrsChanged = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(</span>
    <span class="s3">// always force full diff in dev</span>
    <span class="s3">// - #1942 if hmr is enabled with sfc component</span>
    <span class="s3">// - vite#872 non-sfc component used by sfc component</span>
    <span class="s2">!(isInHmrContext(instance)) &amp;&amp;</span>
        <span class="s2">(optimized || patchFlag &gt; </span><span class="s4">0</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">!(patchFlag &amp; </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">8 </span><span class="s3">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
            <span class="s3">// Compiler-generated props &amp; no keys change, just set the updated</span>
            <span class="s3">// the props.</span>
            <span class="s1">const </span><span class="s2">propsToUpdate = instance.vnode.dynamicProps</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; propsToUpdate.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">let </span><span class="s2">key = propsToUpdate[i]</span><span class="s1">;</span>
                <span class="s3">// skip if the prop key is a declared emit event listener</span>
                <span class="s1">if </span><span class="s2">(isEmitListener(instance.emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s3">// PROPS flag guarantees rawProps to be non-null</span>
                <span class="s1">const </span><span class="s2">value = rawProps[key]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(options) {</span>
                    <span class="s3">// attr / props separation was done on init and will be consistent</span>
                    <span class="s3">// in this code path, so just check if attrs have it.</span>
                    <span class="s1">if </span><span class="s2">(shared.hasOwn(attrs</span><span class="s1">, </span><span class="s2">key)) {</span>
                        <span class="s1">if </span><span class="s2">(value !== attrs[key]) {</span>
                            <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                            <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">const </span><span class="s2">camelizedKey = shared.camelize(key)</span><span class="s1">;</span>
                        <span class="s2">props[camelizedKey] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">camelizedKey</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, false </span><span class="s3">/* isAbsent */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(value !== attrs[key]) {</span>
                        <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                        <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// full props update.</span>
        <span class="s1">if </span><span class="s2">(setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs)) {</span>
            <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
        <span class="s2">}</span>
        <span class="s3">// in case of dynamic props, check if we need to delete keys from</span>
        <span class="s3">// the props object</span>
        <span class="s1">let </span><span class="s2">kebabKey</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawCurrentProps) {</span>
            <span class="s1">if </span><span class="s2">(!rawProps ||</span>
                <span class="s3">// for camelCase</span>
                <span class="s2">(!shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">key) &amp;&amp;</span>
                    <span class="s3">// it's possible the original props was passed in as kebab-case</span>
                    <span class="s3">// and converted to camelCase (#955)</span>
                    <span class="s2">((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">kebabKey)))) {</span>
                <span class="s1">if </span><span class="s2">(options) {</span>
                    <span class="s1">if </span><span class="s2">(rawPrevProps &amp;&amp;</span>
                        <span class="s3">// for camelCase</span>
                        <span class="s2">(rawPrevProps[key] !== undefined ||</span>
                            <span class="s3">// for kebab-case</span>
                            <span class="s2">rawPrevProps[kebabKey] !== undefined)) {</span>
                        <span class="s2">props[key] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, true </span><span class="s3">/* isAbsent */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">delete </span><span class="s2">props[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// in the case of functional component w/o props declaration, props and</span>
        <span class="s3">// attrs point to the same object so it should already have been updated.</span>
        <span class="s1">if </span><span class="s2">(attrs !== rawCurrentProps) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
                <span class="s1">if </span><span class="s2">(!rawProps ||</span>
                    <span class="s2">(!shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">key) &amp;&amp;</span>
                        <span class="s2">(!</span><span class="s1">false </span><span class="s2">))) {</span>
                    <span class="s1">delete </span><span class="s2">attrs[key]</span><span class="s1">;</span>
                    <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// trigger updates for $attrs in case it's used in component slots</span>
    <span class="s1">if </span><span class="s2">(hasAttrsChanged) {</span>
        <span class="s2">reactivity.trigger(instance</span><span class="s1">, </span><span class="s0">&quot;set&quot; </span><span class="s3">/* TriggerOpTypes.SET */</span><span class="s1">, </span><span class="s0">'$attrs'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s2">validateProps(rawProps || {}</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs) {</span>
    <span class="s1">const </span><span class="s2">[options</span><span class="s1">, </span><span class="s2">needCastKeys] = instance.propsOptions</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hasAttrsChanged = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">rawCastValues</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(rawProps) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawProps) {</span>
            <span class="s3">// key, ref are reserved and never passed down</span>
            <span class="s1">if </span><span class="s2">(shared.isReservedProp(key)) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">value = rawProps[key]</span><span class="s1">;</span>
            <span class="s3">// prop option names are camelized during normalization, so to support</span>
            <span class="s3">// kebab -&gt; camel conversion here we need to camelize the key.</span>
            <span class="s1">let </span><span class="s2">camelKey</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(options &amp;&amp; shared.hasOwn(options</span><span class="s1">, </span><span class="s2">(camelKey = shared.camelize(key)))) {</span>
                <span class="s1">if </span><span class="s2">(!needCastKeys || !needCastKeys.includes(camelKey)) {</span>
                    <span class="s2">props[camelKey] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">(rawCastValues || (rawCastValues = {}))[camelKey] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!isEmitListener(instance.emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s1">if </span><span class="s2">(!(key </span><span class="s1">in </span><span class="s2">attrs) || value !== attrs[key]) {</span>
                    <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                    <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(needCastKeys) {</span>
        <span class="s1">const </span><span class="s2">rawCurrentProps = reactivity.toRaw(props)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">castValues = rawCastValues || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; needCastKeys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">key = needCastKeys[i]</span><span class="s1">;</span>
            <span class="s2">props[key] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">castValues[key]</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">!shared.hasOwn(castValues</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">hasAttrsChanged</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolvePropValue(options</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">isAbsent) {</span>
    <span class="s1">const </span><span class="s2">opt = options[key]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(opt != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">hasDefault = shared.hasOwn(opt</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s3">// default values</span>
        <span class="s1">if </span><span class="s2">(hasDefault &amp;&amp; value === undefined) {</span>
            <span class="s1">const </span><span class="s2">defaultValue = opt.default</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(opt.type !== Function &amp;&amp; shared.isFunction(defaultValue)) {</span>
                <span class="s1">const </span><span class="s2">{ propsDefaults } = instance</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">propsDefaults) {</span>
                    <span class="s2">value = propsDefaults[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
                    <span class="s2">value = propsDefaults[key] = defaultValue.call(</span><span class="s1">null, </span><span class="s2">props)</span><span class="s1">;</span>
                    <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">value = defaultValue</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// boolean casting</span>
        <span class="s1">if </span><span class="s2">(opt[</span><span class="s4">0 </span><span class="s3">/* BooleanFlags.shouldCast */</span><span class="s2">]) {</span>
            <span class="s1">if </span><span class="s2">(isAbsent &amp;&amp; !hasDefault) {</span>
                <span class="s2">value = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(opt[</span><span class="s4">1 </span><span class="s3">/* BooleanFlags.shouldCastTrue */</span><span class="s2">] &amp;&amp;</span>
                <span class="s2">(value === </span><span class="s0">'' </span><span class="s2">|| value === shared.hyphenate(key))) {</span>
                <span class="s2">value = </span><span class="s1">true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizePropsOptions(comp</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">cache = appContext.propsCache</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(comp)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">raw = comp.props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">normalized = {}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">needCastKeys = []</span><span class="s1">;</span>
    <span class="s3">// apply mixin/extends props</span>
    <span class="s1">let </span><span class="s2">hasExtends = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(!shared.isFunction(comp)) {</span>
        <span class="s1">const </span><span class="s2">extendProps = (raw) =&gt; {</span>
            <span class="s2">hasExtends = </span><span class="s1">true;</span>
            <span class="s1">const </span><span class="s2">[props</span><span class="s1">, </span><span class="s2">keys] = normalizePropsOptions(raw</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">props)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(keys)</span>
                <span class="s2">needCastKeys.push(...keys)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s2">appContext.mixins.forEach(extendProps)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.extends) {</span>
            <span class="s2">extendProps(comp.extends)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.mixins) {</span>
            <span class="s2">comp.mixins.forEach(extendProps)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
            <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">shared.EMPTY_ARR)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">shared.EMPTY_ARR</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; raw.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">if </span><span class="s2">(!shared.isString(raw[i])) {</span>
                <span class="s2">warn(</span><span class="s0">`props must be strings when using array syntax.`</span><span class="s1">, </span><span class="s2">raw[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">normalizedKey = shared.camelize(raw[i])</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(validatePropName(normalizedKey)) {</span>
                <span class="s2">normalized[normalizedKey] = shared.EMPTY_OBJ</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(raw) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isObject(raw)) {</span>
            <span class="s2">warn(</span><span class="s0">`invalid props options`</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">raw) {</span>
            <span class="s1">const </span><span class="s2">normalizedKey = shared.camelize(key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(validatePropName(normalizedKey)) {</span>
                <span class="s1">const </span><span class="s2">opt = raw[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">prop = (normalized[normalizedKey] =</span>
                    <span class="s2">shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : { ...opt })</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prop) {</span>
                    <span class="s1">const </span><span class="s2">booleanIndex = getTypeIndex(Boolean</span><span class="s1">, </span><span class="s2">prop.type)</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">stringIndex = getTypeIndex(String</span><span class="s1">, </span><span class="s2">prop.type)</span><span class="s1">;</span>
                    <span class="s2">prop[</span><span class="s4">0 </span><span class="s3">/* BooleanFlags.shouldCast */</span><span class="s2">] = booleanIndex &gt; -</span><span class="s4">1</span><span class="s1">;</span>
                    <span class="s2">prop[</span><span class="s4">1 </span><span class="s3">/* BooleanFlags.shouldCastTrue */</span><span class="s2">] =</span>
                        <span class="s2">stringIndex &lt; </span><span class="s4">0 </span><span class="s2">|| booleanIndex &lt; stringIndex</span><span class="s1">;</span>
                    <span class="s3">// if the prop needs boolean casting or default value</span>
                    <span class="s1">if </span><span class="s2">(booleanIndex &gt; -</span><span class="s4">1 </span><span class="s2">|| shared.hasOwn(prop</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">)) {</span>
                        <span class="s2">needCastKeys.push(normalizedKey)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">res = [normalized</span><span class="s1">, </span><span class="s2">needCastKeys]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
        <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">res)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">validatePropName(key) {</span>
    <span class="s1">if </span><span class="s2">(key[</span><span class="s4">0</span><span class="s2">] !== </span><span class="s0">'$'</span><span class="s2">) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">warn(</span><span class="s0">`Invalid prop name: &quot;</span><span class="s2">${key}</span><span class="s0">&quot; is a reserved property.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s3">// use function string name to check type constructors</span>
<span class="s3">// so that it works across vms / iframes.</span>
<span class="s1">function </span><span class="s2">getType(ctor) {</span>
    <span class="s1">const </span><span class="s2">match = ctor &amp;&amp; ctor.toString().match(</span><span class="s4">/^\s*(function|class) (\w+)/</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">match ? match[</span><span class="s4">2</span><span class="s2">] : ctor === </span><span class="s1">null </span><span class="s2">? </span><span class="s0">'null' </span><span class="s2">: </span><span class="s0">''</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSameType(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">return </span><span class="s2">getType(a) === getType(b)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getTypeIndex(type</span><span class="s1">, </span><span class="s2">expectedTypes) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(expectedTypes)) {</span>
        <span class="s1">return </span><span class="s2">expectedTypes.findIndex(t =&gt; isSameType(t</span><span class="s1">, </span><span class="s2">type))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(expectedTypes)) {</span>
        <span class="s1">return </span><span class="s2">isSameType(expectedTypes</span><span class="s1">, </span><span class="s2">type) ? </span><span class="s4">0 </span><span class="s2">: -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">-</span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">validateProps(rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">instance) {</span>
    <span class="s1">const </span><span class="s2">resolvedValues = reactivity.toRaw(props)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">options = instance.propsOptions[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">options) {</span>
        <span class="s1">let </span><span class="s2">opt = options[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(opt == </span><span class="s1">null</span><span class="s2">)</span>
            <span class="s1">continue;</span>
        <span class="s2">validateProp(key</span><span class="s1">, </span><span class="s2">resolvedValues[key]</span><span class="s1">, </span><span class="s2">opt</span><span class="s1">, </span><span class="s2">!shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">key) &amp;&amp; !shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">shared.hyphenate(key)))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">validateProp(name</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">prop</span><span class="s1">, </span><span class="s2">isAbsent) {</span>
    <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">required</span><span class="s1">, </span><span class="s2">validator } = prop</span><span class="s1">;</span>
    <span class="s3">// required!</span>
    <span class="s1">if </span><span class="s2">(required &amp;&amp; isAbsent) {</span>
        <span class="s2">warn(</span><span class="s0">'Missing required prop: &quot;' </span><span class="s2">+ name + </span><span class="s0">'&quot;'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s3">// missing but optional</span>
    <span class="s1">if </span><span class="s2">(value == </span><span class="s1">null </span><span class="s2">&amp;&amp; !prop.required) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s3">// type check</span>
    <span class="s1">if </span><span class="s2">(type != </span><span class="s1">null </span><span class="s2">&amp;&amp; type !== </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">let </span><span class="s2">isValid = </span><span class="s1">false;</span>
        <span class="s1">const </span><span class="s2">types = shared.isArray(type) ? type : [type]</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">expectedTypes = []</span><span class="s1">;</span>
        <span class="s3">// value is valid as long as one of the specified types match</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; types.length &amp;&amp; !isValid</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">{ valid</span><span class="s1">, </span><span class="s2">expectedType } = assertType(value</span><span class="s1">, </span><span class="s2">types[i])</span><span class="s1">;</span>
            <span class="s2">expectedTypes.push(expectedType || </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">isValid = valid</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!isValid) {</span>
            <span class="s2">warn(getInvalidTypeMessage(name</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">expectedTypes))</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// custom validator</span>
    <span class="s1">if </span><span class="s2">(validator &amp;&amp; !validator(value)) {</span>
        <span class="s2">warn(</span><span class="s0">'Invalid prop: custom validator check failed for prop &quot;' </span><span class="s2">+ name + </span><span class="s0">'&quot;.'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">isSimpleType = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">shared.makeMap(</span><span class="s0">'String,Number,Boolean,Function,Symbol,BigInt'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">assertType(value</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">let </span><span class="s2">valid</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">expectedType = getType(type)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isSimpleType(expectedType)) {</span>
        <span class="s1">const </span><span class="s2">t = </span><span class="s1">typeof </span><span class="s2">value</span><span class="s1">;</span>
        <span class="s2">valid = t === expectedType.toLowerCase()</span><span class="s1">;</span>
        <span class="s3">// for primitive wrapper objects</span>
        <span class="s1">if </span><span class="s2">(!valid &amp;&amp; t === </span><span class="s0">'object'</span><span class="s2">) {</span>
            <span class="s2">valid = value </span><span class="s1">instanceof </span><span class="s2">type</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(expectedType === </span><span class="s0">'Object'</span><span class="s2">) {</span>
        <span class="s2">valid = shared.isObject(value)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(expectedType === </span><span class="s0">'Array'</span><span class="s2">) {</span>
        <span class="s2">valid = shared.isArray(value)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(expectedType === </span><span class="s0">'null'</span><span class="s2">) {</span>
        <span class="s2">valid = value === </span><span class="s1">null;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">valid = value </span><span class="s1">instanceof </span><span class="s2">type</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">valid</span><span class="s1">,</span>
        <span class="s2">expectedType</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">getInvalidTypeMessage(name</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">expectedTypes) {</span>
    <span class="s1">let </span><span class="s2">message = </span><span class="s0">`Invalid prop: type check failed for prop &quot;</span><span class="s2">${name}</span><span class="s0">&quot;.` </span><span class="s2">+</span>
        <span class="s0">` Expected </span><span class="s2">${expectedTypes.map(shared.capitalize).join(</span><span class="s0">' | '</span><span class="s2">)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">expectedType = expectedTypes[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">receivedType = shared.toRawType(value)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">expectedValue = styleValue(value</span><span class="s1">, </span><span class="s2">expectedType)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">receivedValue = styleValue(value</span><span class="s1">, </span><span class="s2">receivedType)</span><span class="s1">;</span>
    <span class="s3">// check if we need to specify expected value</span>
    <span class="s1">if </span><span class="s2">(expectedTypes.length === </span><span class="s4">1 </span><span class="s2">&amp;&amp;</span>
        <span class="s2">isExplicable(expectedType) &amp;&amp;</span>
        <span class="s2">!isBoolean(expectedType</span><span class="s1">, </span><span class="s2">receivedType)) {</span>
        <span class="s2">message += </span><span class="s0">` with value </span><span class="s2">${expectedValue}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">message += </span><span class="s0">`, got </span><span class="s2">${receivedType} </span><span class="s0">`</span><span class="s1">;</span>
    <span class="s3">// check if we need to specify received value</span>
    <span class="s1">if </span><span class="s2">(isExplicable(receivedType)) {</span>
        <span class="s2">message += </span><span class="s0">`with value </span><span class="s2">${receivedValue}</span><span class="s0">.`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">message</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">styleValue(value</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">if </span><span class="s2">(type === </span><span class="s0">'String'</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s0">`&quot;</span><span class="s2">${value}</span><span class="s0">&quot;`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">'Number'</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${Number(value)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">isExplicable(type) {</span>
    <span class="s1">const </span><span class="s2">explicitTypes = [</span><span class="s0">'string'</span><span class="s1">, </span><span class="s0">'number'</span><span class="s1">, </span><span class="s0">'boolean'</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">explicitTypes.some(elem =&gt; type.toLowerCase() === elem)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* dev only</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">isBoolean(...args) {</span>
    <span class="s1">return </span><span class="s2">args.some(elem =&gt; elem.toLowerCase() === </span><span class="s0">'boolean'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isInternalKey = (key) =&gt; key[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'_' </span><span class="s2">|| key === </span><span class="s0">'$stable'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeSlotValue = (value) =&gt; shared.isArray(value)</span>
    <span class="s2">? value.map(normalizeVNode)</span>
    <span class="s2">: [normalizeVNode(value)]</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeSlot = (key</span><span class="s1">, </span><span class="s2">rawSlot</span><span class="s1">, </span><span class="s2">ctx) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(rawSlot._n) {</span>
        <span class="s3">// already normalized - #5353</span>
        <span class="s1">return </span><span class="s2">rawSlot</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">normalized = withCtx((...args) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s1">true </span><span class="s2">&amp;&amp; currentInstance) {</span>
            <span class="s2">warn(</span><span class="s0">`Slot &quot;</span><span class="s2">${key}</span><span class="s0">&quot; invoked outside of the render function: ` </span><span class="s2">+</span>
                <span class="s0">`this will not track dependencies used in the slot. ` </span><span class="s2">+</span>
                <span class="s0">`Invoke the slot function inside the render function instead.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">normalizeSlotValue(rawSlot(...args))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
    <span class="s2">normalized._c = </span><span class="s1">false;</span>
    <span class="s1">return </span><span class="s2">normalized</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeObjectSlots = (rawSlots</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">instance) =&gt; {</span>
    <span class="s1">const </span><span class="s2">ctx = rawSlots._ctx</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawSlots) {</span>
        <span class="s1">if </span><span class="s2">(isInternalKey(key))</span>
            <span class="s1">continue;</span>
        <span class="s1">const </span><span class="s2">value = rawSlots[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isFunction(value)) {</span>
            <span class="s2">slots[key] = normalizeSlot(key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(value != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">{</span>
                <span class="s2">warn(</span><span class="s0">`Non-function value encountered for slot &quot;</span><span class="s2">${key}</span><span class="s0">&quot;. ` </span><span class="s2">+</span>
                    <span class="s0">`Prefer function slots for better performance.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">normalized = normalizeSlotValue(value)</span><span class="s1">;</span>
            <span class="s2">slots[key] = () =&gt; normalized</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeVNodeSlots = (instance</span><span class="s1">, </span><span class="s2">children) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(!isKeepAlive(instance.vnode) &amp;&amp;</span>
        <span class="s2">!(</span><span class="s1">false </span><span class="s2">)) {</span>
        <span class="s2">warn(</span><span class="s0">`Non-function value encountered for default slot. ` </span><span class="s2">+</span>
            <span class="s0">`Prefer function slots for better performance.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">normalized = normalizeSlotValue(children)</span><span class="s1">;</span>
    <span class="s2">instance.slots.default = () =&gt; normalized</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">initSlots = (instance</span><span class="s1">, </span><span class="s2">children) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(instance.vnode.shapeFlag &amp; </span><span class="s4">32 </span><span class="s3">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">type = children._</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type) {</span>
            <span class="s3">// users can get the shallow readonly version of the slots object through `this.$slots`,</span>
            <span class="s3">// we should avoid the proxy object polluting the slots of the internal instance</span>
            <span class="s2">instance.slots = reactivity.toRaw(children)</span><span class="s1">;</span>
            <span class="s3">// make compiler marker non-enumerable</span>
            <span class="s2">shared.def(children</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">normalizeObjectSlots(children</span><span class="s1">, </span><span class="s2">(instance.slots = {}))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">instance.slots = {}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(children) {</span>
            <span class="s2">normalizeVNodeSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">shared.def(instance.slots</span><span class="s1">, </span><span class="s2">InternalObjectKey</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">updateSlots = (instance</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">slots } = instance</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">needDeletionCheck = </span><span class="s1">true;</span>
    <span class="s1">let </span><span class="s2">deletionComparisonTarget = shared.EMPTY_OBJ</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">32 </span><span class="s3">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">type = children._</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type) {</span>
            <span class="s3">// compiled slots.</span>
            <span class="s1">if </span><span class="s2">(isHmrUpdating) {</span>
                <span class="s3">// Parent was HMR updated so slot content may have changed.</span>
                <span class="s3">// force update slots and mark instance for hmr as well</span>
                <span class="s2">shared.extend(slots</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(optimized &amp;&amp; type === </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                <span class="s3">// compiled AND stable.</span>
                <span class="s3">// no need to update, and skip stale slots removal.</span>
                <span class="s2">needDeletionCheck = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// compiled but dynamic (v-if/v-for on slots) - update slots, but skip</span>
                <span class="s3">// normalization.</span>
                <span class="s2">shared.extend(slots</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
                <span class="s3">// #2893</span>
                <span class="s3">// when rendering the optimized slots by manually written render function,</span>
                <span class="s3">// we need to delete the `slots._` flag if necessary to make subsequent updates reliable,</span>
                <span class="s3">// i.e. let the `renderSlot` create the bailed Fragment</span>
                <span class="s1">if </span><span class="s2">(!optimized &amp;&amp; type === </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                    <span class="s1">delete </span><span class="s2">slots._</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">needDeletionCheck = !children.$stable</span><span class="s1">;</span>
            <span class="s2">normalizeObjectSlots(children</span><span class="s1">, </span><span class="s2">slots)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">deletionComparisonTarget = children</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(children) {</span>
        <span class="s3">// non slot object children (direct value) passed to a component</span>
        <span class="s2">normalizeVNodeSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">deletionComparisonTarget = { </span><span class="s1">default</span><span class="s2">: </span><span class="s4">1 </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// delete stale slots</span>
    <span class="s1">if </span><span class="s2">(needDeletionCheck) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">slots) {</span>
            <span class="s1">if </span><span class="s2">(!isInternalKey(key) &amp;&amp; !(key </span><span class="s1">in </span><span class="s2">deletionComparisonTarget)) {</span>
                <span class="s1">delete </span><span class="s2">slots[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">createAppContext() {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">app: </span><span class="s1">null,</span>
        <span class="s2">config: {</span>
            <span class="s2">isNativeTag: shared.NO</span><span class="s1">,</span>
            <span class="s2">performance: </span><span class="s1">false,</span>
            <span class="s2">globalProperties: {}</span><span class="s1">,</span>
            <span class="s2">optionMergeStrategies: {}</span><span class="s1">,</span>
            <span class="s2">errorHandler: undefined</span><span class="s1">,</span>
            <span class="s2">warnHandler: undefined</span><span class="s1">,</span>
            <span class="s2">compilerOptions: {}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">mixins: []</span><span class="s1">,</span>
        <span class="s2">components: {}</span><span class="s1">,</span>
        <span class="s2">directives: {}</span><span class="s1">,</span>
        <span class="s2">provides: Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">optionsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">,</span>
        <span class="s2">propsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">,</span>
        <span class="s2">emitsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">uid$1 = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createAppAPI(render</span><span class="s1">, </span><span class="s2">hydrate) {</span>
    <span class="s1">return function </span><span class="s2">createApp(rootComponent</span><span class="s1">, </span><span class="s2">rootProps = </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isFunction(rootComponent)) {</span>
            <span class="s2">rootComponent = { ...rootComponent }</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(rootProps != </span><span class="s1">null </span><span class="s2">&amp;&amp; !shared.isObject(rootProps)) {</span>
            <span class="s2">warn(</span><span class="s0">`root props passed to app.mount() must be an object.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">rootProps = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">context = createAppContext()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">installedPlugins = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">isMounted = </span><span class="s1">false;</span>
        <span class="s1">const </span><span class="s2">app = (context.app = {</span>
            <span class="s2">_uid: uid$1++</span><span class="s1">,</span>
            <span class="s2">_component: rootComponent</span><span class="s1">,</span>
            <span class="s2">_props: rootProps</span><span class="s1">,</span>
            <span class="s2">_container: </span><span class="s1">null,</span>
            <span class="s2">_context: context</span><span class="s1">,</span>
            <span class="s2">_instance: </span><span class="s1">null,</span>
            <span class="s2">version</span><span class="s1">,</span>
            <span class="s2">get config() {</span>
                <span class="s1">return </span><span class="s2">context.config</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">set config(v) {</span>
                <span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`app.config cannot be replaced. Modify individual options instead.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">use(plugin</span><span class="s1">, </span><span class="s2">...options) {</span>
                <span class="s1">if </span><span class="s2">(installedPlugins.has(plugin)) {</span>
                    <span class="s2">warn(</span><span class="s0">`Plugin has already been applied to target app.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(plugin &amp;&amp; shared.isFunction(plugin.install)) {</span>
                    <span class="s2">installedPlugins.add(plugin)</span><span class="s1">;</span>
                    <span class="s2">plugin.install(app</span><span class="s1">, </span><span class="s2">...options)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shared.isFunction(plugin)) {</span>
                    <span class="s2">installedPlugins.add(plugin)</span><span class="s1">;</span>
                    <span class="s2">plugin(app</span><span class="s1">, </span><span class="s2">...options)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`A plugin must either be a function or an object with an &quot;install&quot; ` </span><span class="s2">+</span>
                        <span class="s0">`function.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">mixin(mixin) {</span>
                <span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(!context.mixins.includes(mixin)) {</span>
                        <span class="s2">context.mixins.push(mixin)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">warn(</span><span class="s0">'Mixin has already been applied to target app' </span><span class="s2">+</span>
                            <span class="s2">(mixin.name ? </span><span class="s0">`: </span><span class="s2">${mixin.name}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">component(name</span><span class="s1">, </span><span class="s2">component) {</span>
                <span class="s2">{</span>
                    <span class="s2">validateComponentName(name</span><span class="s1">, </span><span class="s2">context.config)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!component) {</span>
                    <span class="s1">return </span><span class="s2">context.components[name]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(context.components[name]) {</span>
                    <span class="s2">warn(</span><span class="s0">`Component &quot;</span><span class="s2">${name}</span><span class="s0">&quot; has already been registered in target app.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.components[name] = component</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">directive(name</span><span class="s1">, </span><span class="s2">directive) {</span>
                <span class="s2">{</span>
                    <span class="s2">validateDirectiveName(name)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!directive) {</span>
                    <span class="s1">return </span><span class="s2">context.directives[name]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(context.directives[name]) {</span>
                    <span class="s2">warn(</span><span class="s0">`Directive &quot;</span><span class="s2">${name}</span><span class="s0">&quot; has already been registered in target app.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.directives[name] = directive</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">mount(rootContainer</span><span class="s1">, </span><span class="s2">isHydrate</span><span class="s1">, </span><span class="s2">isSVG) {</span>
                <span class="s1">if </span><span class="s2">(!isMounted) {</span>
                    <span class="s3">// #5571</span>
                    <span class="s1">if </span><span class="s2">(rootContainer.__vue_app__) {</span>
                        <span class="s2">warn(</span><span class="s0">`There is already an app instance mounted on the host container.</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">+</span>
                            <span class="s0">` If you want to mount another app on the same host container,` </span><span class="s2">+</span>
                            <span class="s0">` you need to unmount the previous app by calling </span><span class="s1">\`</span><span class="s0">app.unmount()</span><span class="s1">\` </span><span class="s0">first.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">const </span><span class="s2">vnode = createVNode(rootComponent</span><span class="s1">, </span><span class="s2">rootProps)</span><span class="s1">;</span>
                    <span class="s3">// store app context on the root VNode.</span>
                    <span class="s3">// this will be set on the root instance on initial mount.</span>
                    <span class="s2">vnode.appContext = context</span><span class="s1">;</span>
                    <span class="s3">// HMR root reload</span>
                    <span class="s2">{</span>
                        <span class="s2">context.reload = () =&gt; {</span>
                            <span class="s2">render(cloneVNode(vnode)</span><span class="s1">, </span><span class="s2">rootContainer</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                        <span class="s2">}</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">if </span><span class="s2">(isHydrate &amp;&amp; hydrate) {</span>
                        <span class="s2">hydrate(vnode</span><span class="s1">, </span><span class="s2">rootContainer)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">render(vnode</span><span class="s1">, </span><span class="s2">rootContainer</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">isMounted = </span><span class="s1">true;</span>
                    <span class="s2">app._container = rootContainer</span><span class="s1">;</span>
                    <span class="s2">rootContainer.__vue_app__ = app</span><span class="s1">;</span>
                    <span class="s2">{</span>
                        <span class="s2">app._instance = vnode.component</span><span class="s1">;</span>
                        <span class="s2">devtoolsInitApp(app</span><span class="s1">, </span><span class="s2">version)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">return </span><span class="s2">getExposeProxy(vnode.component) || vnode.component.proxy</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`App has already been mounted.</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">+</span>
                        <span class="s0">`If you want to remount the same app, move your app creation logic ` </span><span class="s2">+</span>
                        <span class="s0">`into a factory function and create fresh app instances for each ` </span><span class="s2">+</span>
                        <span class="s0">`mount - e.g. </span><span class="s1">\`</span><span class="s0">const createMyApp = () =&gt; createApp(App)</span><span class="s1">\`</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">unmount() {</span>
                <span class="s1">if </span><span class="s2">(isMounted) {</span>
                    <span class="s2">render(</span><span class="s1">null, </span><span class="s2">app._container)</span><span class="s1">;</span>
                    <span class="s2">{</span>
                        <span class="s2">app._instance = </span><span class="s1">null;</span>
                        <span class="s2">devtoolsUnmountApp(app)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">delete </span><span class="s2">app._container.__vue_app__</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">`Cannot unmount an app that is not mounted.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">provide(key</span><span class="s1">, </span><span class="s2">value) {</span>
                <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">context.provides) {</span>
                    <span class="s2">warn(</span><span class="s0">`App already provides property with key &quot;</span><span class="s2">${String(key)}</span><span class="s0">&quot;. ` </span><span class="s2">+</span>
                        <span class="s0">`It will be overwritten with the new value.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.provides[key] = value</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Function for handling a template ref</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">setRef(rawRef</span><span class="s1">, </span><span class="s2">oldRawRef</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">isUnmount = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(rawRef)) {</span>
        <span class="s2">rawRef.forEach((r</span><span class="s1">, </span><span class="s2">i) =&gt; setRef(r</span><span class="s1">, </span><span class="s2">oldRawRef &amp;&amp; (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef)</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">isUnmount))</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isAsyncWrapper(vnode) &amp;&amp; !isUnmount) {</span>
        <span class="s3">// when mounting async components, nothing needs to be done,</span>
        <span class="s3">// because the template ref is forwarded to inner component</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">refValue = vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */</span>
        <span class="s2">? getExposeProxy(vnode.component) || vnode.component.proxy</span>
        <span class="s2">: vnode.el</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">value = isUnmount ? </span><span class="s1">null </span><span class="s2">: refValue</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ i: owner</span><span class="s1">, </span><span class="s2">r: ref } = rawRef</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!owner) {</span>
        <span class="s2">warn(</span><span class="s0">`Missing ref owner context. ref cannot be used on hoisted vnodes. ` </span><span class="s2">+</span>
            <span class="s0">`A vnode with ref must be created inside the render function.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">oldRef = oldRawRef &amp;&amp; oldRawRef.r</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">refs = owner.refs === shared.EMPTY_OBJ ? (owner.refs = {}) : owner.refs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupState = owner.setupState</span><span class="s1">;</span>
    <span class="s3">// dynamic ref changed. unset old ref</span>
    <span class="s1">if </span><span class="s2">(oldRef != </span><span class="s1">null </span><span class="s2">&amp;&amp; oldRef !== ref) {</span>
        <span class="s1">if </span><span class="s2">(shared.isString(oldRef)) {</span>
            <span class="s2">refs[oldRef] = </span><span class="s1">null;</span>
            <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">oldRef)) {</span>
                <span class="s2">setupState[oldRef] = </span><span class="s1">null;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(reactivity.isRef(oldRef)) {</span>
            <span class="s2">oldRef.value = </span><span class="s1">null;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(ref)) {</span>
        <span class="s2">callWithErrorHandling(ref</span><span class="s1">, </span><span class="s2">owner</span><span class="s1">, </span><span class="s4">12 </span><span class="s3">/* ErrorCodes.FUNCTION_REF */</span><span class="s1">, </span><span class="s2">[value</span><span class="s1">, </span><span class="s2">refs])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">_isString = shared.isString(ref)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">_isRef = reactivity.isRef(ref)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(_isString || _isRef) {</span>
            <span class="s1">const </span><span class="s2">doSet = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(rawRef.f) {</span>
                    <span class="s1">const </span><span class="s2">existing = _isString</span>
                        <span class="s2">? shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)</span>
                            <span class="s2">? setupState[ref]</span>
                            <span class="s2">: refs[ref]</span>
                        <span class="s2">: ref.value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isUnmount) {</span>
                        <span class="s2">shared.isArray(existing) &amp;&amp; shared.remove(existing</span><span class="s1">, </span><span class="s2">refValue)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">if </span><span class="s2">(!shared.isArray(existing)) {</span>
                            <span class="s1">if </span><span class="s2">(_isString) {</span>
                                <span class="s2">refs[ref] = [refValue]</span><span class="s1">;</span>
                                <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)) {</span>
                                    <span class="s2">setupState[ref] = refs[ref]</span><span class="s1">;</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s1">else </span><span class="s2">{</span>
                                <span class="s2">ref.value = [refValue]</span><span class="s1">;</span>
                                <span class="s1">if </span><span class="s2">(rawRef.k)</span>
                                    <span class="s2">refs[rawRef.k] = ref.value</span><span class="s1">;</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s1">else if </span><span class="s2">(!existing.includes(refValue)) {</span>
                            <span class="s2">existing.push(refValue)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(_isString) {</span>
                    <span class="s2">refs[ref] = value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)) {</span>
                        <span class="s2">setupState[ref] = value</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(_isRef) {</span>
                    <span class="s2">ref.value = value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(rawRef.k)</span>
                        <span class="s2">refs[rawRef.k] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">'Invalid template ref type:'</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">ref}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(value) {</span>
                <span class="s2">doSet.id = -</span><span class="s4">1</span><span class="s1">;</span>
                <span class="s2">queuePostRenderEffect(doSet</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">doSet()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">'Invalid template ref type:'</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">ref}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">let </span><span class="s2">hasMismatch = </span><span class="s1">false;</span>
<span class="s1">const </span><span class="s2">isSVGContainer = (container) =&gt; </span><span class="s4">/svg/</span><span class="s2">.test(container.namespaceURI) &amp;&amp; container.tagName !== </span><span class="s0">'foreignObject'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isComment = (node) =&gt; node.nodeType === </span><span class="s4">8 </span><span class="s3">/* DOMNodeTypes.COMMENT */</span><span class="s1">;</span>
<span class="s3">// Note: hydration is DOM-specific</span>
<span class="s3">// But we have to place it in core due to tight coupling with core - splitting</span>
<span class="s3">// it out creates a ton of unnecessary complexity.</span>
<span class="s3">// Hydration also depends on some renderer internal logic which needs to be</span>
<span class="s3">// passed in via arguments.</span>
<span class="s1">function </span><span class="s2">createHydrationFunctions(rendererInternals) {</span>
    <span class="s1">const </span><span class="s2">{ mt: mountComponent</span><span class="s1">, </span><span class="s2">p: patch</span><span class="s1">, </span><span class="s2">o: { patchProp</span><span class="s1">, </span><span class="s2">createText</span><span class="s1">, </span><span class="s2">nextSibling</span><span class="s1">, </span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">remove</span><span class="s1">, </span><span class="s2">insert</span><span class="s1">, </span><span class="s2">createComment } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrate = (vnode</span><span class="s1">, </span><span class="s2">container) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!container.hasChildNodes()) {</span>
            <span class="s2">warn(</span><span class="s0">`Attempting to hydrate existing markup but container is empty. ` </span><span class="s2">+</span>
                    <span class="s0">`Performing full mount instead.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container)</span><span class="s1">;</span>
            <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
            <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">hasMismatch = </span><span class="s1">false;</span>
        <span class="s2">hydrateNode(container.firstChild</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, null, null, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
        <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hasMismatch &amp;&amp; !</span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s3">// this error should show up in production</span>
            <span class="s2">console.error(</span><span class="s0">`Hydration completed but contains mismatches.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateNode = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">isFragmentStart = isComment(node) &amp;&amp; node.data === </span><span class="s0">'['</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">onMismatch = () =&gt; handleMismatch(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">isFragmentStart)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">patchFlag } = vnode</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">domType = node.nodeType</span><span class="s1">;</span>
        <span class="s2">vnode.el = node</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(patchFlag === -</span><span class="s4">2 </span><span class="s3">/* PatchFlags.BAIL */</span><span class="s2">) {</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">vnode.dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">let </span><span class="s2">nextNode = </span><span class="s1">null;</span>
        <span class="s1">switch </span><span class="s2">(type) {</span>
            <span class="s1">case </span><span class="s2">Text:</span>
                <span class="s1">if </span><span class="s2">(domType !== </span><span class="s4">3 </span><span class="s3">/* DOMNodeTypes.TEXT */</span><span class="s2">) {</span>
                    <span class="s3">// #5728 empty text node inside a slot can cause hydration failure</span>
                    <span class="s3">// because the server rendered HTML won't contain a text node</span>
                    <span class="s1">if </span><span class="s2">(vnode.children === </span><span class="s0">''</span><span class="s2">) {</span>
                        <span class="s2">insert((vnode.el = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">, </span><span class="s2">parentNode(node)</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
                        <span class="s2">nextNode = node</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(node.data !== vnode.children) {</span>
                        <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                        <span class="s2">warn(</span><span class="s0">`Hydration text mismatch:` </span><span class="s2">+</span>
                                <span class="s0">`</span><span class="s1">\n</span><span class="s0">- Client: </span><span class="s2">${JSON.stringify(node.data)}</span><span class="s0">` </span><span class="s2">+</span>
                                <span class="s0">`</span><span class="s1">\n</span><span class="s0">- Server: </span><span class="s2">${JSON.stringify(vnode.children)}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">node.data = vnode.children</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">nextNode = nextSibling(node)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Comment:</span>
                <span class="s1">if </span><span class="s2">(domType !== </span><span class="s4">8 </span><span class="s3">/* DOMNodeTypes.COMMENT */ </span><span class="s2">|| isFragmentStart) {</span>
                    <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">nextNode = nextSibling(node)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Static:</span>
                <span class="s1">if </span><span class="s2">(isFragmentStart) {</span>
                    <span class="s3">// entire template is static but SSRed as a fragment</span>
                    <span class="s2">node = nextSibling(node)</span><span class="s1">;</span>
                    <span class="s2">domType = node.nodeType</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(domType === </span><span class="s4">1 </span><span class="s3">/* DOMNodeTypes.ELEMENT */ </span><span class="s2">|| domType === </span><span class="s4">3 </span><span class="s3">/* DOMNodeTypes.TEXT */</span><span class="s2">) {</span>
                    <span class="s3">// determine anchor, adopt content</span>
                    <span class="s2">nextNode = node</span><span class="s1">;</span>
                    <span class="s3">// if the static vnode has its content stripped during build,</span>
                    <span class="s3">// adopt it from the server-rendered HTML.</span>
                    <span class="s1">const </span><span class="s2">needToAdoptContent = !vnode.children.length</span><span class="s1">;</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; vnode.staticCount</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">if </span><span class="s2">(needToAdoptContent)</span>
                            <span class="s2">vnode.children +=</span>
                                <span class="s2">nextNode.nodeType === </span><span class="s4">1 </span><span class="s3">/* DOMNodeTypes.ELEMENT */</span>
                                    <span class="s2">? nextNode.outerHTML</span>
                                    <span class="s2">: nextNode.data</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(i === vnode.staticCount - </span><span class="s4">1</span><span class="s2">) {</span>
                            <span class="s2">vnode.anchor = nextNode</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">nextNode = nextSibling(nextNode)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">return </span><span class="s2">isFragmentStart ? nextSibling(nextNode) : nextNode</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Fragment:</span>
                <span class="s1">if </span><span class="s2">(!isFragmentStart) {</span>
                    <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">nextNode = hydrateFragment(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">default</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(domType !== </span><span class="s4">1 </span><span class="s3">/* DOMNodeTypes.ELEMENT */ </span><span class="s2">||</span>
                        <span class="s2">vnode.type.toLowerCase() !==</span>
                            <span class="s2">node.tagName.toLowerCase()) {</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = hydrateElement(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                    <span class="s3">// when setting up the render effect, if the initial vnode already</span>
                    <span class="s3">// has .el set, the component will perform hydration instead of mount</span>
                    <span class="s3">// on its sub-tree.</span>
                    <span class="s2">vnode.slotScopeIds = slotScopeIds</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
                    <span class="s2">mountComponent(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s3">// component may be async, so in the case of fragments we cannot rely</span>
                    <span class="s3">// on component's rendered output to determine the end of the fragment</span>
                    <span class="s3">// instead, we do a lookahead to find the end anchor node.</span>
                    <span class="s2">nextNode = isFragmentStart</span>
                        <span class="s2">? locateClosingAsyncAnchor(node)</span>
                        <span class="s2">: nextSibling(node)</span><span class="s1">;</span>
                    <span class="s3">// #4293 teleport as component root</span>
                    <span class="s1">if </span><span class="s2">(nextNode &amp;&amp;</span>
                        <span class="s2">isComment(nextNode) &amp;&amp;</span>
                        <span class="s2">nextNode.data === </span><span class="s0">'teleport end'</span><span class="s2">) {</span>
                        <span class="s2">nextNode = nextSibling(nextNode)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s3">// #3787</span>
                    <span class="s3">// if component is async, it may get moved / unmounted before its</span>
                    <span class="s3">// inner component is loaded, so we need to give it a placeholder</span>
                    <span class="s3">// vnode that matches its adopted DOM.</span>
                    <span class="s1">if </span><span class="s2">(isAsyncWrapper(vnode)) {</span>
                        <span class="s1">let </span><span class="s2">subTree</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(isFragmentStart) {</span>
                            <span class="s2">subTree = createVNode(Fragment)</span><span class="s1">;</span>
                            <span class="s2">subTree.anchor = nextNode</span>
                                <span class="s2">? nextNode.previousSibling</span>
                                <span class="s2">: container.lastChild</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s2">subTree =</span>
                                <span class="s2">node.nodeType === </span><span class="s4">3 </span><span class="s2">? createTextVNode(</span><span class="s0">''</span><span class="s2">) : createVNode(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">subTree.el = node</span><span class="s1">;</span>
                        <span class="s2">vnode.component.subTree = subTree</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(domType !== </span><span class="s4">8 </span><span class="s3">/* DOMNodeTypes.COMMENT */</span><span class="s2">) {</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = vnode.type.hydrate(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateChildren)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">nextNode = vnode.type.hydrate(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(parentNode(node))</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateNode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">'Invalid HostVNode type:'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">type}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, null, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">nextNode</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateElement = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">optimized = optimized || !!vnode.dynamicChildren</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s3">// #4006 for form elements with non-string v-model value bindings</span>
        <span class="s3">// e.g. &lt;option :value=&quot;obj&quot;&gt;, &lt;input type=&quot;checkbox&quot; :true-value=&quot;1&quot;&gt;</span>
        <span class="s1">const </span><span class="s2">forcePatchValue = (type === </span><span class="s0">'input' </span><span class="s2">&amp;&amp; dirs) || type === </span><span class="s0">'option'</span><span class="s1">;</span>
        <span class="s3">// skip props &amp; children if this is hoisted static nodes</span>
        <span class="s3">// #5405 in dev, always hydrate children for HMR</span>
        <span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(dirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'created'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// props</span>
            <span class="s1">if </span><span class="s2">(props) {</span>
                <span class="s1">if </span><span class="s2">(forcePatchValue ||</span>
                    <span class="s2">!optimized ||</span>
                    <span class="s2">patchFlag &amp; (</span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */ </span><span class="s2">| </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">)) {</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
                        <span class="s1">if </span><span class="s2">((forcePatchValue &amp;&amp; key.endsWith(</span><span class="s0">'value'</span><span class="s2">)) ||</span>
                            <span class="s2">(shared.isOn(key) &amp;&amp; !shared.isReservedProp(key))) {</span>
                            <span class="s2">patchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, null, </span><span class="s2">props[key]</span><span class="s1">, false, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(props.onClick) {</span>
                    <span class="s3">// Fast path for click listeners (which is most often) to avoid</span>
                    <span class="s3">// iterating through props.</span>
                    <span class="s2">patchProp(el</span><span class="s1">, </span><span class="s0">'onClick'</span><span class="s1">, null, </span><span class="s2">props.onClick</span><span class="s1">, false, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// vnode / directive hooks</span>
            <span class="s1">let </span><span class="s2">vnodeHooks</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">((vnodeHooks = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                <span class="s2">invokeVNodeHook(vnodeHooks</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(dirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeMount'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">((vnodeHooks = props &amp;&amp; props.onVnodeMounted) || dirs) {</span>
                <span class="s2">queueEffectWithSuspense(() =&gt; {</span>
                    <span class="s2">vnodeHooks &amp;&amp; invokeVNodeHook(vnodeHooks</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                    <span class="s2">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'mounted'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// children</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */ </span><span class="s2">&amp;&amp;</span>
                <span class="s3">// skip if element has innerHTML / textContent</span>
                <span class="s2">!(props &amp;&amp; (props.innerHTML || props.textContent))) {</span>
                <span class="s1">let </span><span class="s2">next = hydrateChildren(el.firstChild</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">hasWarned = </span><span class="s1">false;</span>
                <span class="s1">while </span><span class="s2">(next) {</span>
                    <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                    <span class="s1">if </span><span class="s2">(!hasWarned) {</span>
                        <span class="s2">warn(</span><span class="s0">`Hydration children mismatch in &lt;</span><span class="s2">${vnode.type}</span><span class="s0">&gt;: ` </span><span class="s2">+</span>
                            <span class="s0">`server rendered element contains more child nodes than client vdom.`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">hasWarned = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                    <span class="s3">// The SSRed DOM contains more nodes than it should. Remove them.</span>
                    <span class="s1">const </span><span class="s2">cur = next</span><span class="s1">;</span>
                    <span class="s2">next = next.nextSibling</span><span class="s1">;</span>
                    <span class="s2">remove(cur)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(el.textContent !== vnode.children) {</span>
                    <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                    <span class="s2">warn(</span><span class="s0">`Hydration text content mismatch in &lt;</span><span class="s2">${vnode.type}</span><span class="s0">&gt;:</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">+</span>
                            <span class="s0">`- Client: </span><span class="s2">${el.textContent}</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">+</span>
                            <span class="s0">`- Server: </span><span class="s2">${vnode.children}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">el.textContent = vnode.children</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">el.nextSibling</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateChildren = (node</span><span class="s1">, </span><span class="s2">parentVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">optimized = optimized || !!parentVNode.dynamicChildren</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">children = parentVNode.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">l = children.length</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">hasWarned = </span><span class="s1">false;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">vnode = optimized</span>
                <span class="s2">? children[i]</span>
                <span class="s2">: (children[i] = normalizeVNode(children[i]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node) {</span>
                <span class="s2">node = hydrateNode(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(vnode.type === Text &amp;&amp; !vnode.children) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(!hasWarned) {</span>
                    <span class="s2">warn(</span><span class="s0">`Hydration children mismatch in &lt;</span><span class="s2">${container.tagName.toLowerCase()}</span><span class="s0">&gt;: ` </span><span class="s2">+</span>
                        <span class="s0">`server rendered element contains fewer child nodes than client vdom.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">hasWarned = </span><span class="s1">true;</span>
                <span class="s2">}</span>
                <span class="s3">// the SSRed DOM didn't contain enough nodes. Mount the missing ones.</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateFragment = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ slotScopeIds: fragmentSlotScopeIds } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(fragmentSlotScopeIds) {</span>
            <span class="s2">slotScopeIds = slotScopeIds</span>
                <span class="s2">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s2">: fragmentSlotScopeIds</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">next = hydrateChildren(nextSibling(node)</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(next &amp;&amp; isComment(next) &amp;&amp; next.data === </span><span class="s0">']'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">nextSibling((vnode.anchor = next))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// fragment didn't hydrate successfully, since we didn't get a end anchor</span>
            <span class="s3">// back. This should have led to node/children mismatch warnings.</span>
            <span class="s2">hasMismatch = </span><span class="s1">true;</span>
            <span class="s3">// since the anchor is missing, we need to create one and insert it</span>
            <span class="s2">insert((vnode.anchor = createComment(</span><span class="s0">`]`</span><span class="s2">))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">next)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">handleMismatch = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">isFragment) =&gt; {</span>
        <span class="s2">hasMismatch = </span><span class="s1">true;</span>
        <span class="s2">warn(</span><span class="s0">`Hydration node mismatch:</span><span class="s1">\n</span><span class="s0">- Client vnode:`</span><span class="s1">, </span><span class="s2">vnode.type</span><span class="s1">, </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">- Server rendered DOM:`</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">node.nodeType === </span><span class="s4">3 </span><span class="s3">/* DOMNodeTypes.TEXT */</span>
                <span class="s2">? </span><span class="s0">`(text)`</span>
                <span class="s2">: isComment(node) &amp;&amp; node.data === </span><span class="s0">'['</span>
                    <span class="s2">? </span><span class="s0">`(start of fragment)`</span>
                    <span class="s2">: </span><span class="s0">``</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">vnode.el = </span><span class="s1">null;</span>
        <span class="s1">if </span><span class="s2">(isFragment) {</span>
            <span class="s3">// remove excessive fragment nodes</span>
            <span class="s1">const </span><span class="s2">end = locateClosingAsyncAnchor(node)</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(</span><span class="s1">true</span><span class="s2">) {</span>
                <span class="s1">const </span><span class="s2">next = nextSibling(node)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(next &amp;&amp; next !== end) {</span>
                    <span class="s2">remove(next)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">break;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">next = nextSibling(node)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
        <span class="s2">remove(node)</span><span class="s1">;</span>
        <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">next</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">locateClosingAsyncAnchor = (node) =&gt; {</span>
        <span class="s1">let </span><span class="s2">match = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(node) {</span>
            <span class="s2">node = nextSibling(node)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node &amp;&amp; isComment(node)) {</span>
                <span class="s1">if </span><span class="s2">(node.data === </span><span class="s0">'['</span><span class="s2">)</span>
                    <span class="s2">match++</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(node.data === </span><span class="s0">']'</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(match === </span><span class="s4">0</span><span class="s2">) {</span>
                        <span class="s1">return </span><span class="s2">nextSibling(node)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">match--</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">[hydrate</span><span class="s1">, </span><span class="s2">hydrateNode]</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/* eslint-disable no-restricted-globals */</span>
<span class="s1">let </span><span class="s2">supported</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">perf</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">if </span><span class="s2">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
        <span class="s2">perf.mark(</span><span class="s0">`vue-</span><span class="s2">${type}</span><span class="s0">-</span><span class="s2">${instance.uid}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s2">devtoolsPerfStart(instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">isSupported() ? perf.now() : Date.now())</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">if </span><span class="s2">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
        <span class="s1">const </span><span class="s2">startTag = </span><span class="s0">`vue-</span><span class="s2">${type}</span><span class="s0">-</span><span class="s2">${instance.uid}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">endTag = startTag + </span><span class="s0">`:end`</span><span class="s1">;</span>
        <span class="s2">perf.mark(endTag)</span><span class="s1">;</span>
        <span class="s2">perf.measure(</span><span class="s0">`&lt;</span><span class="s2">${formatComponentName(instance</span><span class="s1">, </span><span class="s2">instance.type)}</span><span class="s0">&gt; </span><span class="s2">${type}</span><span class="s0">`</span><span class="s1">, </span><span class="s2">startTag</span><span class="s1">, </span><span class="s2">endTag)</span><span class="s1">;</span>
        <span class="s2">perf.clearMarks(startTag)</span><span class="s1">;</span>
        <span class="s2">perf.clearMarks(endTag)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s2">devtoolsPerfEnd(instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">isSupported() ? perf.now() : Date.now())</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSupported() {</span>
    <span class="s1">if </span><span class="s2">(supported !== undefined) {</span>
        <span class="s1">return </span><span class="s2">supported</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; window.performance) {</span>
        <span class="s2">supported = </span><span class="s1">true;</span>
        <span class="s2">perf = window.performance</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">supported = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">supported</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">queuePostRenderEffect = queueEffectWithSuspense</span>
    <span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* The createRenderer function accepts two generic arguments:</span>
 <span class="s5">* HostNode and HostElement, corresponding to Node and Element types in the</span>
 <span class="s5">* host environment. For example, for runtime-dom, HostNode would be the DOM</span>
 <span class="s5">* `Node` interface and HostElement would be the DOM `Element` interface.</span>
 <span class="s5">*</span>
 <span class="s5">* Custom renderers can pass in the platform specific types like this:</span>
 <span class="s5">*</span>
 <span class="s5">* ``` js</span>
 <span class="s5">* const { render, createApp } = createRenderer&lt;Node, Element&gt;({</span>
 <span class="s5">*   patchProp,</span>
 <span class="s5">*   ...nodeOps</span>
 <span class="s5">* })</span>
 <span class="s5">* ```</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createRenderer(options) {</span>
    <span class="s1">return </span><span class="s2">baseCreateRenderer(options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// Separate API for creating hydration-enabled renderer.</span>
<span class="s3">// Hydration logic is only used when calling this function, making it</span>
<span class="s3">// tree-shakable.</span>
<span class="s1">function </span><span class="s2">createHydrationRenderer(options) {</span>
    <span class="s1">return </span><span class="s2">baseCreateRenderer(options</span><span class="s1">, </span><span class="s2">createHydrationFunctions)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// implementation</span>
<span class="s1">function </span><span class="s2">baseCreateRenderer(options</span><span class="s1">, </span><span class="s2">createHydrationFns) {</span>
    <span class="s1">const </span><span class="s2">target = shared.getGlobalThis()</span><span class="s1">;</span>
    <span class="s2">target.__VUE__ = </span><span class="s1">true;</span>
    <span class="s2">{</span>
        <span class="s2">setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ insert: hostInsert</span><span class="s1">, </span><span class="s2">remove: hostRemove</span><span class="s1">, </span><span class="s2">patchProp: hostPatchProp</span><span class="s1">, </span><span class="s2">createElement: hostCreateElement</span><span class="s1">, </span><span class="s2">createText: hostCreateText</span><span class="s1">, </span><span class="s2">createComment: hostCreateComment</span><span class="s1">, </span><span class="s2">setText: hostSetText</span><span class="s1">, </span><span class="s2">setElementText: hostSetElementText</span><span class="s1">, </span><span class="s2">parentNode: hostParentNode</span><span class="s1">, </span><span class="s2">nextSibling: hostNextSibling</span><span class="s1">, </span><span class="s2">setScopeId: hostSetScopeId = shared.NOOP</span><span class="s1">, </span><span class="s2">insertStaticContent: hostInsertStaticContent } = options</span><span class="s1">;</span>
    <span class="s3">// Note: functions inside this closure should use `const xxx = () =&gt; {}`</span>
    <span class="s3">// style in order to prevent being inlined by minifiers.</span>
    <span class="s1">const </span><span class="s2">patch = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor = </span><span class="s1">null, </span><span class="s2">parentComponent = </span><span class="s1">null, </span><span class="s2">parentSuspense = </span><span class="s1">null, </span><span class="s2">isSVG = </span><span class="s1">false, </span><span class="s2">slotScopeIds = </span><span class="s1">null, </span><span class="s2">optimized = isHmrUpdating ? </span><span class="s1">false </span><span class="s2">: !!n2.dynamicChildren) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 === n2) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s3">// patching &amp; not same type, unmount old tree</span>
        <span class="s1">if </span><span class="s2">(n1 &amp;&amp; !isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
            <span class="s2">anchor = getNextHostNode(n1)</span><span class="s1">;</span>
            <span class="s2">unmount(n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">n1 = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(n2.patchFlag === -</span><span class="s4">2 </span><span class="s3">/* PatchFlags.BAIL */</span><span class="s2">) {</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">n2.dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">shapeFlag } = n2</span><span class="s1">;</span>
        <span class="s1">switch </span><span class="s2">(type) {</span>
            <span class="s1">case </span><span class="s2">Text:</span>
                <span class="s2">processText(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Comment:</span>
                <span class="s2">processCommentNode(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Static:</span>
                <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s2">mountStaticNode(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">patchStaticNode(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Fragment:</span>
                <span class="s2">processFragment(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">default</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */</span><span class="s2">) {</span>
                    <span class="s2">processElement(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                    <span class="s2">processComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                    <span class="s2">type.process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">type.process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">warn(</span><span class="s0">'Invalid VNode type:'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">type}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// set ref</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null </span><span class="s2">&amp;&amp; parentComponent) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, </span><span class="s2">n1 &amp;&amp; n1.ref</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">n2 || n1</span><span class="s1">, </span><span class="s2">!n2)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processText = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert((n2.el = hostCreateText(n2.children))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">el = (n2.el = n1.el)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(n2.children !== n1.children) {</span>
                <span class="s2">hostSetText(el</span><span class="s1">, </span><span class="s2">n2.children)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processCommentNode = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert((n2.el = hostCreateComment(n2.children || </span><span class="s0">''</span><span class="s2">))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// there's no support for dynamic comments</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountStaticNode = (n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s2">[n2.el</span><span class="s1">, </span><span class="s2">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">n2.el</span><span class="s1">, </span><span class="s2">n2.anchor)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Dev / HMR only</span>
     <span class="s5">*/</span>
    <span class="s1">const </span><span class="s2">patchStaticNode = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s3">// static nodes are only patched during dev for HMR</span>
        <span class="s1">if </span><span class="s2">(n2.children !== n1.children) {</span>
            <span class="s1">const </span><span class="s2">anchor = hostNextSibling(n1.anchor)</span><span class="s1">;</span>
            <span class="s3">// remove existing</span>
            <span class="s2">removeStaticNode(n1)</span><span class="s1">;</span>
            <span class="s2">[n2.el</span><span class="s1">, </span><span class="s2">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
            <span class="s2">n2.anchor = n1.anchor</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">moveStaticNode = ({ el</span><span class="s1">, </span><span class="s2">anchor }</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling) =&gt; {</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(el &amp;&amp; el !== anchor) {</span>
            <span class="s2">next = hostNextSibling(el)</span><span class="s1">;</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling)</span><span class="s1">;</span>
            <span class="s2">el = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostInsert(anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">removeStaticNode = ({ el</span><span class="s1">, </span><span class="s2">anchor }) =&gt; {</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(el &amp;&amp; el !== anchor) {</span>
            <span class="s2">next = hostNextSibling(el)</span><span class="s1">;</span>
            <span class="s2">hostRemove(el)</span><span class="s1">;</span>
            <span class="s2">el = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostRemove(anchor)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processElement = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">isSVG = isSVG || n2.type === </span><span class="s0">'svg'</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">mountElement(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patchElement(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountElement = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">let </span><span class="s2">el</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">transition</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s2">el = vnode.el = hostCreateElement(vnode.type</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">props &amp;&amp; props.is</span><span class="s1">, </span><span class="s2">props)</span><span class="s1">;</span>
        <span class="s3">// mount children first, since some props may rely on child content</span>
        <span class="s3">// being already rendered, e.g. `&lt;select value&gt;`</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
            <span class="s2">hostSetElementText(el</span><span class="s1">, </span><span class="s2">vnode.children)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s2">mountChildren(vnode.children</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG &amp;&amp; type !== </span><span class="s0">'foreignObject'</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'created'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// scopeId</span>
        <span class="s2">setScopeId(el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">vnode.scopeId</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
        <span class="s3">// props</span>
        <span class="s1">if </span><span class="s2">(props) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
                <span class="s1">if </span><span class="s2">(key !== </span><span class="s0">'value' </span><span class="s2">&amp;&amp; !shared.isReservedProp(key)) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, null, </span><span class="s2">props[key]</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s5">/**</span>
             <span class="s5">* Special case for setting value on DOM elements:</span>
             <span class="s5">* - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)</span>
             <span class="s5">* - it needs to be forced (#1471)</span>
             <span class="s5">* #2353 proposes adding another renderer option to configure this, but</span>
             <span class="s5">* the properties affects are so finite it is worth special casing it</span>
             <span class="s5">* here to reduce the complexity. (Special casing it also should not</span>
             <span class="s5">* affect non-DOM renderers)</span>
             <span class="s5">*/</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'value' </span><span class="s1">in </span><span class="s2">props) {</span>
                <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'value'</span><span class="s1">, null, </span><span class="s2">props.value)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">((vnodeHook = props.onVnodeBeforeMount)) {</span>
                <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">{</span>
            <span class="s2">Object.defineProperty(el</span><span class="s1">, </span><span class="s0">'__vnode'</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">value: vnode</span><span class="s1">,</span>
                <span class="s2">enumerable: </span><span class="s1">false</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">Object.defineProperty(el</span><span class="s1">, </span><span class="s0">'__vueParentComponent'</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">value: parentComponent</span><span class="s1">,</span>
                <span class="s2">enumerable: </span><span class="s1">false</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeMount'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved</span>
        <span class="s3">// #1689 For inside suspense + suspense resolved case, just call it</span>
        <span class="s1">const </span><span class="s2">needCallTransitionHooks = (!parentSuspense || (parentSuspense &amp;&amp; !parentSuspense.pendingBranch)) &amp;&amp;</span>
            <span class="s2">transition &amp;&amp;</span>
            <span class="s2">!transition.persisted</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(needCallTransitionHooks) {</span>
            <span class="s2">transition.beforeEnter(el)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = props &amp;&amp; props.onVnodeMounted) ||</span>
            <span class="s2">needCallTransitionHooks ||</span>
            <span class="s2">dirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">needCallTransitionHooks &amp;&amp; transition.enter(el)</span><span class="s1">;</span>
                <span class="s2">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'mounted'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setScopeId = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">scopeId</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(scopeId) {</span>
            <span class="s2">hostSetScopeId(el</span><span class="s1">, </span><span class="s2">scopeId)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(slotScopeIds) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; slotScopeIds.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">hostSetScopeId(el</span><span class="s1">, </span><span class="s2">slotScopeIds[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(parentComponent) {</span>
            <span class="s1">let </span><span class="s2">subTree = parentComponent.subTree</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(subTree.patchFlag &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
                <span class="s2">subTree.patchFlag &amp; </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">) {</span>
                <span class="s2">subTree =</span>
                    <span class="s2">filterSingleRoot(subTree.children) || subTree</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(vnode === subTree) {</span>
                <span class="s1">const </span><span class="s2">parentVNode = parentComponent.vnode</span><span class="s1">;</span>
                <span class="s2">setScopeId(el</span><span class="s1">, </span><span class="s2">parentVNode</span><span class="s1">, </span><span class="s2">parentVNode.scopeId</span><span class="s1">, </span><span class="s2">parentVNode.slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent.parent)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountChildren = (children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">start = </span><span class="s4">0</span><span class="s2">) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">child = (children[i] = optimized</span>
                <span class="s2">? cloneIfMounted(children[i])</span>
                <span class="s2">: normalizeVNode(children[i]))</span><span class="s1">;</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">child</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchElement = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">el = (n2.el = n1.el)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">dirs } = n2</span><span class="s1">;</span>
        <span class="s3">// #1426 take the old vnode's patch flag into account since user may clone a</span>
        <span class="s3">// compiler-generated vnode, which de-opts to FULL_PROPS</span>
        <span class="s2">patchFlag |= n1.patchFlag &amp; </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">oldProps = n1.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">newProps = n2.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s3">// disable recurse in beforeUpdate hooks</span>
        <span class="s2">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = newProps.onVnodeBeforeUpdate)) {</span>
            <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">n1)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(n2</span><span class="s1">, </span><span class="s2">n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeUpdate'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isHmrUpdating) {</span>
            <span class="s3">// HMR updated, force full diff</span>
            <span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">areChildrenSVG = isSVG &amp;&amp; n2.type !== </span><span class="s0">'foreignObject'</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dynamicChildren) {</span>
            <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">areChildrenSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
                <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!optimized) {</span>
            <span class="s3">// full diff</span>
            <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">areChildrenSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s3">// the presence of a patchFlag means this element's render code was</span>
            <span class="s3">// generated by the compiler and can take the fast path.</span>
            <span class="s3">// in this path old node and new node are guaranteed to have the same shape</span>
            <span class="s3">// (i.e. at the exact same position in the source template)</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s2">) {</span>
                <span class="s3">// element props contain dynamic keys, full diff needed</span>
                <span class="s2">patchProps(el</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// class</span>
                <span class="s3">// this flag is matched when the element has dynamic class bindings.</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">2 </span><span class="s3">/* PatchFlags.CLASS */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(oldProps.class !== newProps.class) {</span>
                        <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'class'</span><span class="s1">, null, </span><span class="s2">newProps.class</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s3">// style</span>
                <span class="s3">// this flag is matched when the element has dynamic style bindings</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">4 </span><span class="s3">/* PatchFlags.STYLE */</span><span class="s2">) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'style'</span><span class="s1">, </span><span class="s2">oldProps.style</span><span class="s1">, </span><span class="s2">newProps.style</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// props</span>
                <span class="s3">// This flag is matched when the element has dynamic prop/attr bindings</span>
                <span class="s3">// other than class and style. The keys of dynamic prop/attrs are saved for</span>
                <span class="s3">// faster iteration.</span>
                <span class="s3">// Note dynamic keys like :[foo]=&quot;bar&quot; will cause this optimization to</span>
                <span class="s3">// bail out and go through a full diff because we need to unset the old key</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">8 </span><span class="s3">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
                    <span class="s3">// if the flag is present then dynamicProps must be non-null</span>
                    <span class="s1">const </span><span class="s2">propsToUpdate = n2.dynamicProps</span><span class="s1">;</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; propsToUpdate.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">const </span><span class="s2">key = propsToUpdate[i]</span><span class="s1">;</span>
                        <span class="s1">const </span><span class="s2">prev = oldProps[key]</span><span class="s1">;</span>
                        <span class="s1">const </span><span class="s2">next = newProps[key]</span><span class="s1">;</span>
                        <span class="s3">// #1471 force patch value</span>
                        <span class="s1">if </span><span class="s2">(next !== prev || key === </span><span class="s0">'value'</span><span class="s2">) {</span>
                            <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">n1.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// text</span>
            <span class="s3">// This flag is matched when the element has only dynamic text children.</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(n1.children !== n2.children) {</span>
                    <span class="s2">hostSetElementText(el</span><span class="s1">, </span><span class="s2">n2.children)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!optimized &amp;&amp; dynamicChildren == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s3">// unoptimized, full diff</span>
            <span class="s2">patchProps(el</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = newProps.onVnodeUpdated) || dirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">n1)</span><span class="s1">;</span>
                <span class="s2">dirs &amp;&amp; invokeDirectiveHook(n2</span><span class="s1">, </span><span class="s2">n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'updated'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// The fast path for blocks.</span>
    <span class="s1">const </span><span class="s2">patchBlockChildren = (oldChildren</span><span class="s1">, </span><span class="s2">newChildren</span><span class="s1">, </span><span class="s2">fallbackContainer</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; newChildren.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">oldVNode = oldChildren[i]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">newVNode = newChildren[i]</span><span class="s1">;</span>
            <span class="s3">// Determine the container (parent element) for the patch.</span>
            <span class="s1">const </span><span class="s2">container = </span>
            <span class="s3">// oldVNode may be an errored async setup() component inside Suspense</span>
            <span class="s3">// which will not have a mounted element</span>
            <span class="s2">oldVNode.el &amp;&amp;</span>
                <span class="s3">// - In the case of a Fragment, we need to provide the actual parent</span>
                <span class="s3">// of the Fragment itself so it can move its children.</span>
                <span class="s2">(oldVNode.type === Fragment ||</span>
                    <span class="s3">// - In the case of different nodes, there is going to be a replacement</span>
                    <span class="s3">// which also requires the correct parent container</span>
                    <span class="s2">!isSameVNodeType(oldVNode</span><span class="s1">, </span><span class="s2">newVNode) ||</span>
                    <span class="s3">// - In the case of a component, it could contain anything.</span>
                    <span class="s2">oldVNode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */ </span><span class="s2">| </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">))</span>
                <span class="s2">? hostParentNode(oldVNode.el)</span>
                <span class="s2">: </span><span class="s3">// In other cases, the parent container is not actually used so we</span>
                    <span class="s3">// just pass the block element here to avoid a DOM parentNode call.</span>
                    <span class="s2">fallbackContainer</span><span class="s1">;</span>
            <span class="s2">patch(oldVNode</span><span class="s1">, </span><span class="s2">newVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchProps = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(oldProps !== newProps) {</span>
            <span class="s1">if </span><span class="s2">(oldProps !== shared.EMPTY_OBJ) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">oldProps) {</span>
                    <span class="s1">if </span><span class="s2">(!shared.isReservedProp(key) &amp;&amp; !(key </span><span class="s1">in </span><span class="s2">newProps)) {</span>
                        <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">oldProps[key]</span><span class="s1">, null, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">newProps) {</span>
                <span class="s3">// empty string is not valid prop</span>
                <span class="s1">if </span><span class="s2">(shared.isReservedProp(key))</span>
                    <span class="s1">continue;</span>
                <span class="s1">const </span><span class="s2">next = newProps[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">prev = oldProps[key]</span><span class="s1">;</span>
                <span class="s3">// defer patching value</span>
                <span class="s1">if </span><span class="s2">(next !== prev &amp;&amp; key !== </span><span class="s0">'value'</span><span class="s2">) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'value' </span><span class="s1">in </span><span class="s2">newProps) {</span>
                <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'value'</span><span class="s1">, </span><span class="s2">oldProps.value</span><span class="s1">, </span><span class="s2">newProps.value)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processFragment = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">slotScopeIds: fragmentSlotScopeIds } = n2</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s3">// #5523 dev root fragment may inherit directives</span>
            <span class="s2">(isHmrUpdating || patchFlag &amp; </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">)) {</span>
            <span class="s3">// HMR updated / Dev root fragment (w/ comments), force full diff</span>
            <span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s3">// check if this is a slot fragment with :slotted scope ids</span>
        <span class="s1">if </span><span class="s2">(fragmentSlotScopeIds) {</span>
            <span class="s2">slotScopeIds = slotScopeIds</span>
                <span class="s2">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s2">: fragmentSlotScopeIds</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert(fragmentStartAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">hostInsert(fragmentEndAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s3">// a fragment can only have array children</span>
            <span class="s3">// since they are either generated by the compiler, or implicitly created</span>
            <span class="s3">// from arrays.</span>
            <span class="s2">mountChildren(n2.children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">fragmentEndAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
                <span class="s2">patchFlag &amp; </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s2">&amp;&amp;</span>
                <span class="s2">dynamicChildren &amp;&amp;</span>
                <span class="s3">// #2715 the previous fragment could've been a BAILed one as a result</span>
                <span class="s3">// of renderSlot() with no valid children</span>
                <span class="s2">n1.dynamicChildren) {</span>
                <span class="s3">// a stable fragment (template root or &lt;template v-for&gt;) doesn't need to</span>
                <span class="s3">// patch children order, but it may contain dynamicChildren.</span>
                <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
                    <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(</span>
                <span class="s3">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span>
                <span class="s3">//  get moved around. Make sure all root level vnodes inherit el.</span>
                <span class="s3">// #2134 or if it's a component root, it may also get moved around</span>
                <span class="s3">// as the component is being moved.</span>
                <span class="s2">n2.key != </span><span class="s1">null </span><span class="s2">||</span>
                    <span class="s2">(parentComponent &amp;&amp; n2 === parentComponent.subTree)) {</span>
                    <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, true </span><span class="s3">/* shallow */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// keyed / unkeyed, or manual fragments.</span>
                <span class="s3">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span>
                <span class="s3">// each child is guaranteed to be a block so the fragment will never</span>
                <span class="s3">// have dynamicChildren.</span>
                <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">fragmentEndAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processComponent = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">n2.slotScopeIds = slotScopeIds</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(n2.shapeFlag &amp; </span><span class="s4">512 </span><span class="s3">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s2">) {</span>
                <span class="s2">parentComponent.ctx.activate(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">mountComponent(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">updateComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountComponent = (initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">instance = (initialVNode.component = createComponentInstance(initialVNode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense))</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(instance.type.__hmrId) {</span>
            <span class="s2">registerHMR(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">{</span>
            <span class="s2">pushWarningContext(initialVNode)</span><span class="s1">;</span>
            <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`mount`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// inject renderer internals for keepAlive</span>
        <span class="s1">if </span><span class="s2">(isKeepAlive(initialVNode)) {</span>
            <span class="s2">instance.ctx.renderer = internals</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// resolve props and slots for setup context</span>
        <span class="s2">{</span>
            <span class="s2">{</span>
                <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`init`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">setupComponent(instance)</span><span class="s1">;</span>
            <span class="s2">{</span>
                <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`init`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// setup() is async. This component relies on async logic to be resolved</span>
        <span class="s3">// before proceeding</span>
        <span class="s1">if </span><span class="s2">(instance.asyncDep) {</span>
            <span class="s2">parentSuspense &amp;&amp; parentSuspense.registerDep(instance</span><span class="s1">, </span><span class="s2">setupRenderEffect)</span><span class="s1">;</span>
            <span class="s3">// Give it a placeholder if this is not hydration</span>
            <span class="s3">// TODO handle self-defined fallback</span>
            <span class="s1">if </span><span class="s2">(!initialVNode.el) {</span>
                <span class="s1">const </span><span class="s2">placeholder = (instance.subTree = createVNode(Comment))</span><span class="s1">;</span>
                <span class="s2">processCommentNode(</span><span class="s1">null, </span><span class="s2">placeholder</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">setupRenderEffect(instance</span><span class="s1">, </span><span class="s2">initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">{</span>
            <span class="s2">popWarningContext()</span><span class="s1">;</span>
            <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`mount`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">updateComponent = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">instance = (n2.component = n1.component)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shouldUpdateComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)) {</span>
            <span class="s1">if </span><span class="s2">(instance.asyncDep &amp;&amp;</span>
                <span class="s2">!instance.asyncResolved) {</span>
                <span class="s3">// async &amp; still pending - just update props and slots</span>
                <span class="s3">// since the component's reactive effect for render isn't set-up yet</span>
                <span class="s2">{</span>
                    <span class="s2">pushWarningContext(n2)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">updateComponentPreRender(instance</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">popWarningContext()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// normal update</span>
                <span class="s2">instance.next = n2</span><span class="s1">;</span>
                <span class="s3">// in case the child component is also queued, remove it to avoid</span>
                <span class="s3">// double updating the same child component in the same flush.</span>
                <span class="s2">invalidateJob(instance.update)</span><span class="s1">;</span>
                <span class="s3">// instance.update is the reactive effect.</span>
                <span class="s2">instance.update()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// no update needed. just copy over properties</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
            <span class="s2">instance.vnode = n2</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupRenderEffect = (instance</span><span class="s1">, </span><span class="s2">initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">componentUpdateFn = () =&gt; {</span>
            <span class="s1">if </span><span class="s2">(!instance.isMounted) {</span>
                <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">props } = initialVNode</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ bm</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">parent } = instance</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><span class="s1">;</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s3">// beforeMount hook</span>
                <span class="s1">if </span><span class="s2">(bm) {</span>
                    <span class="s2">shared.invokeArrayFns(bm)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// onVnodeBeforeMount</span>
                <span class="s1">if </span><span class="s2">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">initialVNode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(el &amp;&amp; hydrateNode) {</span>
                    <span class="s3">// vnode has adopted host node - perform hydration instead of mount.</span>
                    <span class="s1">const </span><span class="s2">hydrateSubTree = () =&gt; {</span>
                        <span class="s2">{</span>
                            <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">instance.subTree = renderComponentRoot(instance)</span><span class="s1">;</span>
                        <span class="s2">{</span>
                            <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">{</span>
                            <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`hydrate`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">hydrateNode(el</span><span class="s1">, </span><span class="s2">instance.subTree</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">{</span>
                            <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`hydrate`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isAsyncWrapperVNode) {</span>
                        <span class="s2">initialVNode.type.__asyncLoader().then(</span>
                        <span class="s3">// note: we are moving the render call into an async callback,</span>
                        <span class="s3">// which means it won't track dependencies - but it's ok because</span>
                        <span class="s3">// a server-rendered async wrapper is already in resolved state</span>
                        <span class="s3">// and it will never need to change.</span>
                        <span class="s2">() =&gt; !instance.isUnmounted &amp;&amp; hydrateSubTree())</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">hydrateSubTree()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">{</span>
                        <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">const </span><span class="s2">subTree = (instance.subTree = renderComponentRoot(instance))</span><span class="s1">;</span>
                    <span class="s2">{</span>
                        <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">{</span>
                        <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`patch`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">subTree</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">{</span>
                        <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`patch`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">initialVNode.el = subTree.el</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// mounted hook</span>
                <span class="s1">if </span><span class="s2">(m) {</span>
                    <span class="s2">queuePostRenderEffect(m</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// onVnodeMounted</span>
                <span class="s1">if </span><span class="s2">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeMounted)) {</span>
                    <span class="s1">const </span><span class="s2">scopedInitialVNode = initialVNode</span><span class="s1">;</span>
                    <span class="s2">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">scopedInitialVNode)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// activated hook for keep-alive roots.</span>
                <span class="s3">// #1742 activated hook must be accessed after first render</span>
                <span class="s3">// since the hook may be injected by a child keep-alive</span>
                <span class="s1">if </span><span class="s2">(initialVNode.shapeFlag &amp; </span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ </span><span class="s2">||</span>
                    <span class="s2">(parent &amp;&amp;</span>
                        <span class="s2">isAsyncWrapper(parent.vnode) &amp;&amp;</span>
                        <span class="s2">parent.vnode.shapeFlag &amp; </span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">)) {</span>
                    <span class="s2">instance.a &amp;&amp; queuePostRenderEffect(instance.a</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">instance.isMounted = </span><span class="s1">true;</span>
                <span class="s2">{</span>
                    <span class="s2">devtoolsComponentAdded(instance)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// #2458: deference mount-only object parameters to prevent memleaks</span>
                <span class="s2">initialVNode = container = anchor = </span><span class="s1">null;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// updateComponent</span>
                <span class="s3">// This is triggered by mutation of component's own state (next: null)</span>
                <span class="s3">// OR parent calling processComponent (next: VNode)</span>
                <span class="s1">let </span><span class="s2">{ next</span><span class="s1">, </span><span class="s2">bu</span><span class="s1">, </span><span class="s2">u</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">vnode } = instance</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">originNext = next</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">pushWarningContext(next || instance.vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// Disallow component effect recursion during pre-lifecycle hooks.</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(next) {</span>
                    <span class="s2">next.el = vnode.el</span><span class="s1">;</span>
                    <span class="s2">updateComponentPreRender(instance</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">next = vnode</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// beforeUpdate hook</span>
                <span class="s1">if </span><span class="s2">(bu) {</span>
                    <span class="s2">shared.invokeArrayFns(bu)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// onVnodeBeforeUpdate</span>
                <span class="s1">if </span><span class="s2">((vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s3">// render</span>
                <span class="s2">{</span>
                    <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">nextTree = renderComponentRoot(instance)</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`render`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">prevTree = instance.subTree</span><span class="s1">;</span>
                <span class="s2">instance.subTree = nextTree</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`patch`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">patch(prevTree</span><span class="s1">, </span><span class="s2">nextTree</span><span class="s1">, </span>
                <span class="s3">// parent may have changed if it's in a teleport</span>
                <span class="s2">hostParentNode(prevTree.el)</span><span class="s1">, </span>
                <span class="s3">// anchor may have changed if it's in a fragment</span>
                <span class="s2">getNextHostNode(prevTree)</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`patch`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">next.el = nextTree.el</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(originNext === </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s3">// self-triggered update. In case of HOC, update parent component</span>
                    <span class="s3">// vnode el. HOC is indicated by parent instance's subTree pointing</span>
                    <span class="s3">// to child component's vnode</span>
                    <span class="s2">updateHOCHostEl(instance</span><span class="s1">, </span><span class="s2">nextTree.el)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// updated hook</span>
                <span class="s1">if </span><span class="s2">(u) {</span>
                    <span class="s2">queuePostRenderEffect(u</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// onVnodeUpdated</span>
                <span class="s1">if </span><span class="s2">((vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated)) {</span>
                    <span class="s2">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">{</span>
                    <span class="s2">devtoolsComponentUpdated(instance)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">{</span>
                    <span class="s2">popWarningContext()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s3">// create reactive effect for rendering</span>
        <span class="s1">const </span><span class="s2">effect = (instance.effect = </span><span class="s1">new </span><span class="s2">reactivity.ReactiveEffect(componentUpdateFn</span><span class="s1">, </span><span class="s2">() =&gt; queueJob(update)</span><span class="s1">, </span><span class="s2">instance.scope </span><span class="s3">// track it in component's effect scope</span>
        <span class="s2">))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">update = (instance.update = () =&gt; effect.run())</span><span class="s1">;</span>
        <span class="s2">update.id = instance.uid</span><span class="s1">;</span>
        <span class="s3">// allowRecurse</span>
        <span class="s3">// #1801, #2043 component render effects should allow recursive updates</span>
        <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">{</span>
            <span class="s2">effect.onTrack = instance.rtc</span>
                <span class="s2">? e =&gt; shared.invokeArrayFns(instance.rtc</span><span class="s1">, </span><span class="s2">e)</span>
                <span class="s2">: </span><span class="s1">void </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">effect.onTrigger = instance.rtg</span>
                <span class="s2">? e =&gt; shared.invokeArrayFns(instance.rtg</span><span class="s1">, </span><span class="s2">e)</span>
                <span class="s2">: </span><span class="s1">void </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">update.ownerInstance = instance</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">update()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">updateComponentPreRender = (instance</span><span class="s1">, </span><span class="s2">nextVNode</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">nextVNode.component = instance</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">prevProps = instance.vnode.props</span><span class="s1">;</span>
        <span class="s2">instance.vnode = nextVNode</span><span class="s1">;</span>
        <span class="s2">instance.next = </span><span class="s1">null;</span>
        <span class="s2">updateProps(instance</span><span class="s1">, </span><span class="s2">nextVNode.props</span><span class="s1">, </span><span class="s2">prevProps</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">updateSlots(instance</span><span class="s1">, </span><span class="s2">nextVNode.children</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s3">// props update may have triggered pre-flush watchers.</span>
        <span class="s3">// flush them before the render update.</span>
        <span class="s2">flushPreFlushCbs()</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchChildren = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">c1 = n1 &amp;&amp; n1.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">prevShapeFlag = n1 ? n1.shapeFlag : </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">c2 = n2.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">shapeFlag } = n2</span><span class="s1">;</span>
        <span class="s3">// fast path</span>
        <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s4">128 </span><span class="s3">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s2">) {</span>
                <span class="s3">// this could be either fully-keyed or mixed (some keyed some not)</span>
                <span class="s3">// presence of patchFlag means children are guaranteed to be arrays</span>
                <span class="s2">patchKeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(patchFlag &amp; </span><span class="s4">256 </span><span class="s3">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s2">) {</span>
                <span class="s3">// unkeyed</span>
                <span class="s2">patchUnkeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// children has 3 possibilities: text, array or no children.</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
            <span class="s3">// text children fast path</span>
            <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(c2 !== c1) {</span>
                <span class="s2">hostSetElementText(container</span><span class="s1">, </span><span class="s2">c2)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s3">// prev children was array</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s3">// two arrays, cannot assume anything, do full diff</span>
                    <span class="s2">patchKeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s3">// no new children, just unmount old</span>
                    <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// prev children was text OR null</span>
                <span class="s3">// new children is array OR null</span>
                <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">hostSetElementText(container</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s3">// mount new if array</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">mountChildren(c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchUnkeyedChildren = (c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">c1 = c1 || shared.EMPTY_ARR</span><span class="s1">;</span>
        <span class="s2">c2 = c2 || shared.EMPTY_ARR</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">oldLength = c1.length</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">newLength = c2.length</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">commonLength = Math.min(oldLength</span><span class="s1">, </span><span class="s2">newLength)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; commonLength</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">nextChild = (c2[i] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[i])</span>
                <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
            <span class="s2">patch(c1[i]</span><span class="s1">, </span><span class="s2">nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(oldLength &gt; newLength) {</span>
            <span class="s3">// remove old</span>
            <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true, false, </span><span class="s2">commonLength)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// mount new</span>
            <span class="s2">mountChildren(c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">commonLength)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// can be all-keyed or mixed</span>
    <span class="s1">const </span><span class="s2">patchKeyedChildren = (c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">l2 = c2.length</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">e1 = c1.length - </span><span class="s4">1</span><span class="s1">; </span><span class="s3">// prev ending index</span>
        <span class="s1">let </span><span class="s2">e2 = l2 - </span><span class="s4">1</span><span class="s1">; </span><span class="s3">// next ending index</span>
        <span class="s3">// 1. sync from start</span>
        <span class="s3">// (a b) c</span>
        <span class="s3">// (a b) d e</span>
        <span class="s1">while </span><span class="s2">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s1">const </span><span class="s2">n1 = c1[i]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">n2 = (c2[i] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[i])</span>
                <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
                <span class="s2">patch(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
            <span class="s2">i++</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// 2. sync from end</span>
        <span class="s3">// a (b c)</span>
        <span class="s3">// d e (b c)</span>
        <span class="s1">while </span><span class="s2">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s1">const </span><span class="s2">n1 = c1[e1]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">n2 = (c2[e2] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[e2])</span>
                <span class="s2">: normalizeVNode(c2[e2]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
                <span class="s2">patch(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
            <span class="s2">e1--</span><span class="s1">;</span>
            <span class="s2">e2--</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// 3. common sequence + mount</span>
        <span class="s3">// (a b)</span>
        <span class="s3">// (a b) c</span>
        <span class="s3">// i = 2, e1 = 1, e2 = 2</span>
        <span class="s3">// (a b)</span>
        <span class="s3">// c (a b)</span>
        <span class="s3">// i = 0, e1 = -1, e2 = 0</span>
        <span class="s1">if </span><span class="s2">(i &gt; e1) {</span>
            <span class="s1">if </span><span class="s2">(i &lt;= e2) {</span>
                <span class="s1">const </span><span class="s2">nextPos = e2 + </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(i &lt;= e2) {</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">(c2[i] = optimized</span>
                        <span class="s2">? cloneIfMounted(c2[i])</span>
                        <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">i++</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// 4. common sequence + unmount</span>
        <span class="s3">// (a b) c</span>
        <span class="s3">// (a b)</span>
        <span class="s3">// i = 2, e1 = 2, e2 = 1</span>
        <span class="s3">// a (b c)</span>
        <span class="s3">// (b c)</span>
        <span class="s3">// i = 0, e1 = 0, e2 = -1</span>
        <span class="s1">else if </span><span class="s2">(i &gt; e2) {</span>
            <span class="s1">while </span><span class="s2">(i &lt;= e1) {</span>
                <span class="s2">unmount(c1[i]</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">i++</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">// 5. unknown sequence</span>
        <span class="s3">// [i ... e1 + 1]: a b [c d e] f g</span>
        <span class="s3">// [i ... e2 + 1]: a b [e d c h] f g</span>
        <span class="s3">// i = 2, e1 = 4, e2 = 5</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">s1 = i</span><span class="s1">; </span><span class="s3">// prev starting index</span>
            <span class="s1">const </span><span class="s2">s2 = i</span><span class="s1">; </span><span class="s3">// next starting index</span>
            <span class="s3">// 5.1 build key:index map for newChildren</span>
            <span class="s1">const </span><span class="s2">keyToNewIndexMap = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = s2</span><span class="s1">; </span><span class="s2">i &lt;= e2</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">nextChild = (c2[i] = optimized</span>
                    <span class="s2">? cloneIfMounted(c2[i])</span>
                    <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(nextChild.key != </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(keyToNewIndexMap.has(nextChild.key)) {</span>
                        <span class="s2">warn(</span><span class="s0">`Duplicate keys found during update:`</span><span class="s1">, </span><span class="s2">JSON.stringify(nextChild.key)</span><span class="s1">, </span><span class="s0">`Make sure keys are unique.`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">keyToNewIndexMap.set(nextChild.key</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// 5.2 loop through old children left to be patched and try to patch</span>
            <span class="s3">// matching nodes &amp; remove nodes that are no longer present</span>
            <span class="s1">let </span><span class="s2">j</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">patched = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">toBePatched = e2 - s2 + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">moved = </span><span class="s1">false;</span>
            <span class="s3">// used to track whether any node has moved</span>
            <span class="s1">let </span><span class="s2">maxNewIndexSoFar = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">// works as Map&lt;newIndex, oldIndex&gt;</span>
            <span class="s3">// Note that oldIndex is offset by +1</span>
            <span class="s3">// and oldIndex = 0 is a special value indicating the new node has</span>
            <span class="s3">// no corresponding old node.</span>
            <span class="s3">// used for determining longest stable subsequence</span>
            <span class="s1">const </span><span class="s2">newIndexToOldIndexMap = </span><span class="s1">new </span><span class="s2">Array(toBePatched)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; toBePatched</span><span class="s1">; </span><span class="s2">i++)</span>
                <span class="s2">newIndexToOldIndexMap[i] = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = s1</span><span class="s1">; </span><span class="s2">i &lt;= e1</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">prevChild = c1[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(patched &gt;= toBePatched) {</span>
                    <span class="s3">// all new children have been patched so this can only be a removal</span>
                    <span class="s2">unmount(prevChild</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s1">let </span><span class="s2">newIndex</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prevChild.key != </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s2">newIndex = keyToNewIndexMap.get(prevChild.key)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s3">// key-less node, try to locate a key-less node of the same type</span>
                    <span class="s1">for </span><span class="s2">(j = s2</span><span class="s1">; </span><span class="s2">j &lt;= e2</span><span class="s1">; </span><span class="s2">j++) {</span>
                        <span class="s1">if </span><span class="s2">(newIndexToOldIndexMap[j - s2] === </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">isSameVNodeType(prevChild</span><span class="s1">, </span><span class="s2">c2[j])) {</span>
                            <span class="s2">newIndex = j</span><span class="s1">;</span>
                            <span class="s1">break;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(newIndex === undefined) {</span>
                    <span class="s2">unmount(prevChild</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">newIndexToOldIndexMap[newIndex - s2] = i + </span><span class="s4">1</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(newIndex &gt;= maxNewIndexSoFar) {</span>
                        <span class="s2">maxNewIndexSoFar = newIndex</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">moved = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                    <span class="s2">patch(prevChild</span><span class="s1">, </span><span class="s2">c2[newIndex]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">patched++</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">// 5.3 move and mount</span>
            <span class="s3">// generate longest stable subsequence only when nodes have moved</span>
            <span class="s1">const </span><span class="s2">increasingNewIndexSequence = moved</span>
                <span class="s2">? getSequence(newIndexToOldIndexMap)</span>
                <span class="s2">: shared.EMPTY_ARR</span><span class="s1">;</span>
            <span class="s2">j = increasingNewIndexSequence.length - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">// looping backwards so that we can use last patched node as anchor</span>
            <span class="s1">for </span><span class="s2">(i = toBePatched - </span><span class="s4">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i--) {</span>
                <span class="s1">const </span><span class="s2">nextIndex = s2 + i</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">nextChild = c2[nextIndex]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">anchor = nextIndex + </span><span class="s4">1 </span><span class="s2">&lt; l2 ? c2[nextIndex + </span><span class="s4">1</span><span class="s2">].el : parentAnchor</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(newIndexToOldIndexMap[i] === </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s3">// mount new</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(moved) {</span>
                    <span class="s3">// move if:</span>
                    <span class="s3">// There is no stable subsequence (e.g. a reverse)</span>
                    <span class="s3">// OR current node is not among the stable sequence</span>
                    <span class="s1">if </span><span class="s2">(j &lt; </span><span class="s4">0 </span><span class="s2">|| i !== increasingNewIndexSequence[j]) {</span>
                        <span class="s2">move(nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* MoveType.REORDER */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">j--</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">move = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType</span><span class="s1">, </span><span class="s2">parentSuspense = </span><span class="s1">null</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">transition</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">shapeFlag } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s2">move(vnode.component.subTree</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s2">vnode.suspense.move(container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
            <span class="s2">type.move(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Fragment) {</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">move(children[i]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">hostInsert(vnode.anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Static) {</span>
            <span class="s2">moveStaticNode(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s3">// single nodes</span>
        <span class="s1">const </span><span class="s2">needTransition = moveType !== </span><span class="s4">2 </span><span class="s3">/* MoveType.REORDER */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">transition</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(needTransition) {</span>
            <span class="s1">if </span><span class="s2">(moveType === </span><span class="s4">0 </span><span class="s3">/* MoveType.ENTER */</span><span class="s2">) {</span>
                <span class="s2">transition.beforeEnter(el)</span><span class="s1">;</span>
                <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s2">queuePostRenderEffect(() =&gt; transition.enter(el)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">const </span><span class="s2">{ leave</span><span class="s1">, </span><span class="s2">delayLeave</span><span class="s1">, </span><span class="s2">afterLeave } = transition</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">remove = () =&gt; hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">performLeave = () =&gt; {</span>
                    <span class="s2">leave(el</span><span class="s1">, </span><span class="s2">() =&gt; {</span>
                        <span class="s2">remove()</span><span class="s1">;</span>
                        <span class="s2">afterLeave &amp;&amp; afterLeave()</span><span class="s1">;</span>
                    <span class="s2">})</span><span class="s1">;</span>
                <span class="s2">}</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(delayLeave) {</span>
                    <span class="s2">delayLeave(el</span><span class="s1">, </span><span class="s2">remove</span><span class="s1">, </span><span class="s2">performLeave)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">performLeave()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmount = (vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove = </span><span class="s1">false, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s3">// unset ref</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, null, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">) {</span>
            <span class="s2">parentComponent.ctx.deactivate(vnode)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">shouldInvokeDirs = shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp; dirs</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">shouldInvokeVnodeHook = !isAsyncWrapper(vnode)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {</span>
            <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s2">unmountComponent(vnode.component</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                <span class="s2">vnode.suspense.unmount(parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(shouldInvokeDirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeUnmount'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                <span class="s2">vnode.type.remove(vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(dynamicChildren &amp;&amp;</span>
                <span class="s3">// #1153: fast path should not be taken for non-stable (v-for) fragments</span>
                <span class="s2">(type !== Fragment ||</span>
                    <span class="s2">(patchFlag &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp; patchFlag &amp; </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">))) {</span>
                <span class="s3">// fast path for block nodes: only need to unmount dynamic children.</span>
                <span class="s2">unmountChildren(dynamicChildren</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, false, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">((type === Fragment &amp;&amp;</span>
                <span class="s2">patchFlag &amp;</span>
                    <span class="s2">(</span><span class="s4">128 </span><span class="s3">/* PatchFlags.KEYED_FRAGMENT */ </span><span class="s2">| </span><span class="s4">256 </span><span class="s3">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s2">)) ||</span>
                <span class="s2">(!optimized &amp;&amp; shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">)) {</span>
                <span class="s2">unmountChildren(children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(doRemove) {</span>
                <span class="s2">remove(vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">((shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeUnmounted)) ||</span>
            <span class="s2">shouldInvokeDirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">shouldInvokeDirs &amp;&amp;</span>
                    <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'unmounted'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">remove = vnode =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">transition } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type === Fragment) {</span>
            <span class="s1">if </span><span class="s2">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
                <span class="s2">vnode.patchFlag &amp; </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */ </span><span class="s2">&amp;&amp;</span>
                <span class="s2">transition &amp;&amp;</span>
                <span class="s2">!transition.persisted) {</span>
                <span class="s2">vnode.children.forEach(child =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(child.type === Comment) {</span>
                        <span class="s2">hostRemove(child.el)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">remove(child)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">removeFragment(el</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Static) {</span>
            <span class="s2">removeStaticNode(vnode)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">performRemove = () =&gt; {</span>
            <span class="s2">hostRemove(el)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) {</span>
                <span class="s2">transition.afterLeave()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">transition &amp;&amp;</span>
            <span class="s2">!transition.persisted) {</span>
            <span class="s1">const </span><span class="s2">{ leave</span><span class="s1">, </span><span class="s2">delayLeave } = transition</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">performLeave = () =&gt; leave(el</span><span class="s1">, </span><span class="s2">performRemove)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delayLeave) {</span>
                <span class="s2">delayLeave(vnode.el</span><span class="s1">, </span><span class="s2">performRemove</span><span class="s1">, </span><span class="s2">performLeave)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">performLeave()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">performRemove()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">removeFragment = (cur</span><span class="s1">, </span><span class="s2">end) =&gt; {</span>
        <span class="s3">// For fragments, directly remove all contained DOM nodes.</span>
        <span class="s3">// (fragment child nodes cannot have transition)</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(cur !== end) {</span>
            <span class="s2">next = hostNextSibling(cur)</span><span class="s1">;</span>
            <span class="s2">hostRemove(cur)</span><span class="s1">;</span>
            <span class="s2">cur = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostRemove(end)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmountComponent = (instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(instance.type.__hmrId) {</span>
            <span class="s2">unregisterHMR(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">{ bum</span><span class="s1">, </span><span class="s2">scope</span><span class="s1">, </span><span class="s2">update</span><span class="s1">, </span><span class="s2">subTree</span><span class="s1">, </span><span class="s2">um } = instance</span><span class="s1">;</span>
        <span class="s3">// beforeUnmount hook</span>
        <span class="s1">if </span><span class="s2">(bum) {</span>
            <span class="s2">shared.invokeArrayFns(bum)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// stop effects in component scope</span>
        <span class="s2">scope.stop()</span><span class="s1">;</span>
        <span class="s3">// update may be null if a component is unmounted before its async</span>
        <span class="s3">// setup has resolved.</span>
        <span class="s1">if </span><span class="s2">(update) {</span>
            <span class="s3">// so that scheduler will no longer invoke it</span>
            <span class="s2">update.active = </span><span class="s1">false;</span>
            <span class="s2">unmount(subTree</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// unmounted hook</span>
        <span class="s1">if </span><span class="s2">(um) {</span>
            <span class="s2">queuePostRenderEffect(um</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">queuePostRenderEffect(() =&gt; {</span>
            <span class="s2">instance.isUnmounted = </span><span class="s1">true;</span>
        <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s3">// A component with async dep inside a pending suspense is unmounted before</span>
        <span class="s3">// its async dep resolves. This should remove the dep from the suspense, and</span>
        <span class="s3">// cause the suspense to resolve immediately if that was the last dep.</span>
        <span class="s1">if </span><span class="s2">(parentSuspense &amp;&amp;</span>
            <span class="s2">parentSuspense.pendingBranch &amp;&amp;</span>
            <span class="s2">!parentSuspense.isUnmounted &amp;&amp;</span>
            <span class="s2">instance.asyncDep &amp;&amp;</span>
            <span class="s2">!instance.asyncResolved &amp;&amp;</span>
            <span class="s2">instance.suspenseId === parentSuspense.pendingId) {</span>
            <span class="s2">parentSuspense.deps--</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parentSuspense.deps === </span><span class="s4">0</span><span class="s2">) {</span>
                <span class="s2">parentSuspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">{</span>
            <span class="s2">devtoolsComponentRemoved(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmountChildren = (children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove = </span><span class="s1">false, </span><span class="s2">optimized = </span><span class="s1">false, </span><span class="s2">start = </span><span class="s4">0</span><span class="s2">) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">unmount(children[i]</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">getNextHostNode = vnode =&gt; {</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">getNextHostNode(vnode.component.subTree)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">vnode.suspense.next()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">hostNextSibling((vnode.anchor || vnode.el))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">render = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(vnode == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(container._vnode) {</span>
                <span class="s2">unmount(container._vnode</span><span class="s1">, null, null, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patch(container._vnode || </span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, null, null, </span><span class="s2">isSVG)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">flushPreFlushCbs()</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
        <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">internals = {</span>
        <span class="s2">p: patch</span><span class="s1">,</span>
        <span class="s2">um: unmount</span><span class="s1">,</span>
        <span class="s2">m: move</span><span class="s1">,</span>
        <span class="s2">r: remove</span><span class="s1">,</span>
        <span class="s2">mt: mountComponent</span><span class="s1">,</span>
        <span class="s2">mc: mountChildren</span><span class="s1">,</span>
        <span class="s2">pc: patchChildren</span><span class="s1">,</span>
        <span class="s2">pbc: patchBlockChildren</span><span class="s1">,</span>
        <span class="s2">n: getNextHostNode</span><span class="s1">,</span>
        <span class="s2">o: options</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hydrate</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hydrateNode</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(createHydrationFns) {</span>
        <span class="s2">[hydrate</span><span class="s1">, </span><span class="s2">hydrateNode] = createHydrationFns(internals)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">render</span><span class="s1">,</span>
        <span class="s2">hydrate</span><span class="s1">,</span>
        <span class="s2">createApp: createAppAPI(render</span><span class="s1">, </span><span class="s2">hydrate)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">toggleRecurse({ effect</span><span class="s1">, </span><span class="s2">update }</span><span class="s1">, </span><span class="s2">allowed) {</span>
    <span class="s2">effect.allowRecurse = update.allowRecurse = allowed</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* #1156</span>
 <span class="s5">* When a component is HMR-enabled, we need to make sure that all static nodes</span>
 <span class="s5">* inside a block also inherit the DOM element from the previous tree so that</span>
 <span class="s5">* HMR updates (which are full updates) can retrieve the element for patching.</span>
 <span class="s5">*</span>
 <span class="s5">* #2080</span>
 <span class="s5">* Inside keyed `template` fragment static children, if a fragment is moved,</span>
 <span class="s5">* the children will always be moved. Therefore, in order to ensure correct move</span>
 <span class="s5">* position, el should be inherited from previous nodes.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">shallow = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">ch1 = n1.children</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ch2 = n2.children</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(ch1) &amp;&amp; shared.isArray(ch2)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; ch1.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s3">// this is only called in the optimized path so array children are</span>
            <span class="s3">// guaranteed to be vnodes</span>
            <span class="s1">const </span><span class="s2">c1 = ch1[i]</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">c2 = ch2[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(c2.shapeFlag &amp; </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp; !c2.dynamicChildren) {</span>
                <span class="s1">if </span><span class="s2">(c2.patchFlag &lt;= </span><span class="s4">0 </span><span class="s2">|| c2.patchFlag === </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">) {</span>
                    <span class="s2">c2 = ch2[i] = cloneIfMounted(ch2[i])</span><span class="s1">;</span>
                    <span class="s2">c2.el = c1.el</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!shallow)</span>
                    <span class="s2">traverseStaticChildren(c1</span><span class="s1">, </span><span class="s2">c2)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// #6852 also inherit for text nodes</span>
            <span class="s1">if </span><span class="s2">(c2.type === Text) {</span>
                <span class="s2">c2.el = c1.el</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// also inherit for comment nodes, but not placeholders (e.g. v-if which</span>
            <span class="s3">// would have received .el during block patch)</span>
            <span class="s1">if </span><span class="s2">(c2.type === Comment &amp;&amp; !c2.el) {</span>
                <span class="s2">c2.el = c1.el</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
<span class="s1">function </span><span class="s2">getSequence(arr) {</span>
    <span class="s1">const </span><span class="s2">p = arr.slice()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">result = [</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">i</span><span class="s1">, </span><span class="s2">j</span><span class="s1">, </span><span class="s2">u</span><span class="s1">, </span><span class="s2">v</span><span class="s1">, </span><span class="s2">c</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">len = arr.length</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">arrI = arr[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(arrI !== </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s2">j = result[result.length - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(arr[j] &lt; arrI) {</span>
                <span class="s2">p[i] = j</span><span class="s1">;</span>
                <span class="s2">result.push(i)</span><span class="s1">;</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s2">u = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s2">v = result.length - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(u &lt; v) {</span>
                <span class="s2">c = (u + v) &gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(arr[result[c]] &lt; arrI) {</span>
                    <span class="s2">u = c + </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">v = c</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(arrI &lt; arr[result[u]]) {</span>
                <span class="s1">if </span><span class="s2">(u &gt; </span><span class="s4">0</span><span class="s2">) {</span>
                    <span class="s2">p[i] = result[u - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">result[u] = i</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">u = result.length</span><span class="s1">;</span>
    <span class="s2">v = result[u - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(u-- &gt; </span><span class="s4">0</span><span class="s2">) {</span>
        <span class="s2">result[u] = v</span><span class="s1">;</span>
        <span class="s2">v = p[v]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isTeleport = (type) =&gt; type.__isTeleport</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isTeleportDisabled = (props) =&gt; props &amp;&amp; (props.disabled || props.disabled === </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isTargetSVG = (target) =&gt; </span><span class="s1">typeof </span><span class="s2">SVGElement !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; target </span><span class="s1">instanceof </span><span class="s2">SVGElement</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">resolveTarget = (props</span><span class="s1">, </span><span class="s2">select) =&gt; {</span>
    <span class="s1">const </span><span class="s2">targetSelector = props &amp;&amp; props.to</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isString(targetSelector)) {</span>
        <span class="s1">if </span><span class="s2">(!select) {</span>
            <span class="s2">warn(</span><span class="s0">`Current renderer does not support string target for Teleports. ` </span><span class="s2">+</span>
                    <span class="s0">`(missing querySelector renderer option)`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">return null;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">target = select(targetSelector)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!target) {</span>
                <span class="s2">warn(</span><span class="s0">`Failed to locate Teleport target with selector &quot;</span><span class="s2">${targetSelector}</span><span class="s0">&quot;. ` </span><span class="s2">+</span>
                        <span class="s0">`Note the target element must exist before the component is mounted - ` </span><span class="s2">+</span>
                        <span class="s0">`i.e. the target cannot be rendered by the component itself, and ` </span><span class="s2">+</span>
                        <span class="s0">`ideally should be outside of the entire Vue component tree.`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">target</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(!targetSelector &amp;&amp; !isTeleportDisabled(props)) {</span>
            <span class="s2">warn(</span><span class="s0">`Invalid Teleport target: </span><span class="s2">${targetSelector}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">targetSelector</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TeleportImpl = {</span>
    <span class="s2">__isTeleport: </span><span class="s1">true,</span>
    <span class="s2">process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals) {</span>
        <span class="s1">const </span><span class="s2">{ mc: mountChildren</span><span class="s1">, </span><span class="s2">pc: patchChildren</span><span class="s1">, </span><span class="s2">pbc: patchBlockChildren</span><span class="s1">, </span><span class="s2">o: { insert</span><span class="s1">, </span><span class="s2">querySelector</span><span class="s1">, </span><span class="s2">createText</span><span class="s1">, </span><span class="s2">createComment } } = internals</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">disabled = isTeleportDisabled(n2.props)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">dynamicChildren } = n2</span><span class="s1">;</span>
        <span class="s3">// #3302</span>
        <span class="s3">// HMR updated, force full diff</span>
        <span class="s1">if </span><span class="s2">(isHmrUpdating) {</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s3">// insert anchors in the main view</span>
            <span class="s1">const </span><span class="s2">placeholder = (n2.el = createComment(</span><span class="s0">'teleport start'</span><span class="s2">)</span>
                <span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mainAnchor = (n2.anchor = createComment(</span><span class="s0">'teleport end'</span><span class="s2">)</span>
                <span class="s2">)</span><span class="s1">;</span>
            <span class="s2">insert(placeholder</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">insert(mainAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">target = (n2.target = resolveTarget(n2.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">targetAnchor = (n2.targetAnchor = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(target) {</span>
                <span class="s2">insert(targetAnchor</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
                <span class="s3">// #2652 we could be teleporting from a non-SVG tree into an SVG tree</span>
                <span class="s2">isSVG = isSVG || isTargetSVG(target)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!disabled) {</span>
                <span class="s2">warn(</span><span class="s0">'Invalid Teleport target on mount:'</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">target}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">mount = (container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
                <span class="s3">// Teleport *always* has Array children. This is enforced in both the</span>
                <span class="s3">// compiler and vnode children normalization.</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">mountChildren(children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(disabled) {</span>
                <span class="s2">mount(container</span><span class="s1">, </span><span class="s2">mainAnchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(target) {</span>
                <span class="s2">mount(target</span><span class="s1">, </span><span class="s2">targetAnchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// update content</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mainAnchor = (n2.anchor = n1.anchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">target = (n2.target = n1.target)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">targetAnchor = (n2.targetAnchor = n1.targetAnchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">wasDisabled = isTeleportDisabled(n1.props)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">currentContainer = wasDisabled ? container : target</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">currentAnchor = wasDisabled ? mainAnchor : targetAnchor</span><span class="s1">;</span>
            <span class="s2">isSVG = isSVG || isTargetSVG(target)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(dynamicChildren) {</span>
                <span class="s3">// fast path when the teleport happens to be a block root</span>
                <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">currentContainer</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
                <span class="s3">// even in block tree mode we need to make sure all root-level nodes</span>
                <span class="s3">// in the teleport inherit previous DOM references so that they can</span>
                <span class="s3">// be moved in future patches.</span>
                <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!optimized) {</span>
                <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">currentContainer</span><span class="s1">, </span><span class="s2">currentAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(disabled) {</span>
                <span class="s1">if </span><span class="s2">(!wasDisabled) {</span>
                    <span class="s3">// enabled -&gt; disabled</span>
                    <span class="s3">// move into main container</span>
                    <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">mainAnchor</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* TeleportMoveTypes.TOGGLE */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// target changed</span>
                <span class="s1">if </span><span class="s2">((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) {</span>
                    <span class="s1">const </span><span class="s2">nextTarget = (n2.target = resolveTarget(n2.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(nextTarget) {</span>
                        <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">nextTarget</span><span class="s1">, null, </span><span class="s2">internals</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">warn(</span><span class="s0">'Invalid Teleport target on update:'</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s0">`(</span><span class="s2">${</span><span class="s1">typeof </span><span class="s2">target}</span><span class="s0">)`</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(wasDisabled) {</span>
                    <span class="s3">// disabled -&gt; enabled</span>
                    <span class="s3">// move into teleport target</span>
                    <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">targetAnchor</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s4">1 </span><span class="s3">/* TeleportMoveTypes.TOGGLE */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateCssVars(n2)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">remove(vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ um: unmount</span><span class="s1">, </span><span class="s2">o: { remove: hostRemove } }</span><span class="s1">, </span><span class="s2">doRemove) {</span>
        <span class="s1">const </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">targetAnchor</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">props } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(target) {</span>
            <span class="s2">hostRemove(targetAnchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// an unmounted teleport should always remove its children if not disabled</span>
        <span class="s1">if </span><span class="s2">(doRemove || !isTeleportDisabled(props)) {</span>
            <span class="s2">hostRemove(anchor)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
                    <span class="s2">unmount(child</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true, </span><span class="s2">!!child.dynamicChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">move: moveTeleport</span><span class="s1">,</span>
    <span class="s2">hydrate: hydrateTeleport</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">moveTeleport(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s2">{ o: { insert }</span><span class="s1">, </span><span class="s2">m: move }</span><span class="s1">, </span><span class="s2">moveType = </span><span class="s4">2 </span><span class="s3">/* TeleportMoveTypes.REORDER */</span><span class="s2">) {</span>
    <span class="s3">// move target anchor if this is a target change.</span>
    <span class="s1">if </span><span class="s2">(moveType === </span><span class="s4">0 </span><span class="s3">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s2">) {</span>
        <span class="s2">insert(vnode.targetAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">props } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isReorder = moveType === </span><span class="s4">2 </span><span class="s3">/* TeleportMoveTypes.REORDER */</span><span class="s1">;</span>
    <span class="s3">// move main view anchor if this is a re-order.</span>
    <span class="s1">if </span><span class="s2">(isReorder) {</span>
        <span class="s2">insert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// if this is a re-order and teleport is enabled (content is in target)</span>
    <span class="s3">// do not move children. So the opposite is: only move children if this</span>
    <span class="s3">// is not a reorder, or the teleport is disabled</span>
    <span class="s1">if </span><span class="s2">(!isReorder || isTeleportDisabled(props)) {</span>
        <span class="s3">// Teleport has either Array children or no children.</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">move(children[i]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s4">2 </span><span class="s3">/* MoveType.REORDER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// move main view anchor if this is a re-order.</span>
    <span class="s1">if </span><span class="s2">(isReorder) {</span>
        <span class="s2">insert(anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hydrateTeleport(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ o: { nextSibling</span><span class="s1">, </span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">querySelector } }</span><span class="s1">, </span><span class="s2">hydrateChildren) {</span>
    <span class="s1">const </span><span class="s2">target = (vnode.target = resolveTarget(vnode.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s3">// if multiple teleports rendered to the same target element, we need to</span>
        <span class="s3">// pick up from where the last teleport finished instead of the first node</span>
        <span class="s1">const </span><span class="s2">targetNode = target._lpa || target.firstChild</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(isTeleportDisabled(vnode.props)) {</span>
                <span class="s2">vnode.anchor = hydrateChildren(nextSibling(node)</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentNode(node)</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">vnode.targetAnchor = targetNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">vnode.anchor = nextSibling(node)</span><span class="s1">;</span>
                <span class="s3">// lookahead until we find the target anchor</span>
                <span class="s3">// we cannot rely on return value of hydrateChildren() because there</span>
                <span class="s3">// could be nested teleports</span>
                <span class="s1">let </span><span class="s2">targetAnchor = targetNode</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(targetAnchor) {</span>
                    <span class="s2">targetAnchor = nextSibling(targetAnchor)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(targetAnchor &amp;&amp;</span>
                        <span class="s2">targetAnchor.nodeType === </span><span class="s4">8 </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">targetAnchor.data === </span><span class="s0">'teleport anchor'</span><span class="s2">) {</span>
                        <span class="s2">vnode.targetAnchor = targetAnchor</span><span class="s1">;</span>
                        <span class="s2">target._lpa =</span>
                            <span class="s2">vnode.targetAnchor &amp;&amp; nextSibling(vnode.targetAnchor)</span><span class="s1">;</span>
                        <span class="s1">break;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s2">hydrateChildren(targetNode</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateCssVars(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode.anchor &amp;&amp; nextSibling(vnode.anchor)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// Force-casted public typing for h and TSX props inference</span>
<span class="s1">const </span><span class="s2">Teleport = TeleportImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">updateCssVars(vnode) {</span>
    <span class="s3">// presence of .ut method indicates owner component uses css vars.</span>
    <span class="s3">// code path here can assume browser environment.</span>
    <span class="s1">const </span><span class="s2">ctx = vnode.ctx</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(ctx &amp;&amp; ctx.ut) {</span>
        <span class="s1">let </span><span class="s2">node = vnode.children[</span><span class="s4">0</span><span class="s2">].el</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(node !== vnode.targetAnchor) {</span>
            <span class="s1">if </span><span class="s2">(node.nodeType === </span><span class="s4">1</span><span class="s2">)</span>
                <span class="s2">node.setAttribute(</span><span class="s0">'data-v-owner'</span><span class="s1">, </span><span class="s2">ctx.uid)</span><span class="s1">;</span>
            <span class="s2">node = node.nextSibling</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">ctx.ut()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">Fragment = Symbol(</span><span class="s0">'Fragment' </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Text = Symbol(</span><span class="s0">'Text' </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Comment = Symbol(</span><span class="s0">'Comment' </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Static = Symbol(</span><span class="s0">'Static' </span><span class="s2">)</span><span class="s1">;</span>
<span class="s3">// Since v-if and v-for are the two possible ways node structure can dynamically</span>
<span class="s3">// change, once we consider v-if branches and each v-for fragment a block, we</span>
<span class="s3">// can divide a template into nested blocks, and within each block the node</span>
<span class="s3">// structure would be stable. This allows us to skip most children diffing</span>
<span class="s3">// and only worry about the dynamic nodes (indicated by patch flags).</span>
<span class="s1">const </span><span class="s2">blockStack = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">currentBlock = </span><span class="s1">null;</span>
<span class="s5">/**</span>
 <span class="s5">* Open a block.</span>
 <span class="s5">* This must be called before `createBlock`. It cannot be part of `createBlock`</span>
 <span class="s5">* because the children of the block are evaluated before `createBlock` itself</span>
 <span class="s5">* is called. The generated code typically looks like this:</span>
 <span class="s5">*</span>
 <span class="s5">* ```js</span>
 <span class="s5">* function render() {</span>
 <span class="s5">*   return (openBlock(),createBlock('div', null, [...]))</span>
 <span class="s5">* }</span>
 <span class="s5">* ```</span>
 <span class="s5">* disableTracking is true when creating a v-for fragment block, since a v-for</span>
 <span class="s5">* fragment always diffs its children.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">openBlock(disableTracking = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">blockStack.push((currentBlock = disableTracking ? </span><span class="s1">null </span><span class="s2">: []))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">closeBlock() {</span>
    <span class="s2">blockStack.pop()</span><span class="s1">;</span>
    <span class="s2">currentBlock = blockStack[blockStack.length - </span><span class="s4">1</span><span class="s2">] || </span><span class="s1">null;</span>
<span class="s2">}</span>
<span class="s3">// Whether we should be tracking dynamic child nodes inside a block.</span>
<span class="s3">// Only tracks when this value is &gt; 0</span>
<span class="s3">// We are not using a simple boolean because this value may need to be</span>
<span class="s3">// incremented/decremented by nested usage of v-once (see below)</span>
<span class="s1">let </span><span class="s2">isBlockTreeEnabled = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Block tracking sometimes needs to be disabled, for example during the</span>
 <span class="s5">* creation of a tree that needs to be cached by v-once. The compiler generates</span>
 <span class="s5">* code like this:</span>
 <span class="s5">*</span>
 <span class="s5">* ``` js</span>
 <span class="s5">* _cache[1] || (</span>
 <span class="s5">*   setBlockTracking(-1),</span>
 <span class="s5">*   _cache[1] = createVNode(...),</span>
 <span class="s5">*   setBlockTracking(1),</span>
 <span class="s5">*   _cache[1]</span>
 <span class="s5">* )</span>
 <span class="s5">* ```</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">setBlockTracking(value) {</span>
    <span class="s2">isBlockTreeEnabled += value</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setupBlock(vnode) {</span>
    <span class="s3">// save current block children on the block vnode</span>
    <span class="s2">vnode.dynamicChildren =</span>
        <span class="s2">isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s2">? currentBlock || shared.EMPTY_ARR : </span><span class="s1">null;</span>
    <span class="s3">// close block</span>
    <span class="s2">closeBlock()</span><span class="s1">;</span>
    <span class="s3">// a block is always going to be patched, so track it as a child of its</span>
    <span class="s3">// parent block</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp; currentBlock) {</span>
        <span class="s2">currentBlock.push(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createElementBlock(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag) {</span>
    <span class="s1">return </span><span class="s2">setupBlock(createBaseVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, true </span><span class="s3">/* isBlock */</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Create a block root vnode. Takes the same exact arguments as `createVNode`.</span>
 <span class="s5">* A block root keeps track of dynamic nodes within the block in the</span>
 <span class="s5">* `dynamicChildren` array.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createBlock(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps) {</span>
    <span class="s1">return </span><span class="s2">setupBlock(createVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, true </span><span class="s3">/* isBlock: prevent a block from tracking itself */</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isVNode(value) {</span>
    <span class="s1">return </span><span class="s2">value ? value.__v_isVNode === </span><span class="s1">true </span><span class="s2">: </span><span class="s1">false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2) {</span>
    <span class="s1">if </span><span class="s2">(n2.shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */ </span><span class="s2">&amp;&amp;</span>
        <span class="s2">hmrDirtyComponents.has(n2.type)) {</span>
        <span class="s3">// #7042, ensure the vnode being unmounted during HMR</span>
        <span class="s3">// bitwise operations to remove keep alive flags</span>
        <span class="s2">n1.shapeFlag &amp;= ~</span><span class="s4">256 </span><span class="s3">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">;</span>
        <span class="s2">n2.shapeFlag &amp;= ~</span><span class="s4">512 </span><span class="s3">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">;</span>
        <span class="s3">// HMR only: if the component has been hot-updated, force a reload.</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">n1.type === n2.type &amp;&amp; n1.key === n2.key</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">vnodeArgsTransformer</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Internal API for registering an arguments transform for createVNode</span>
 <span class="s5">* used for creating stubs in the test-utils</span>
 <span class="s5">* It is *internal* but needs to be exposed for test-utils to pick up proper</span>
 <span class="s5">* typings</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">transformVNodeArgs(transformer) {</span>
    <span class="s2">vnodeArgsTransformer = transformer</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createVNodeWithArgsTransform = (...args) =&gt; {</span>
    <span class="s1">return </span><span class="s2">_createVNode(...(vnodeArgsTransformer</span>
        <span class="s2">? vnodeArgsTransformer(args</span><span class="s1">, </span><span class="s2">currentRenderingInstance)</span>
        <span class="s2">: args))</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">InternalObjectKey = </span><span class="s0">`__vInternal`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeKey = ({ key }) =&gt; key != </span><span class="s1">null </span><span class="s2">? key : </span><span class="s1">null;</span>
<span class="s1">const </span><span class="s2">normalizeRef = ({ ref</span><span class="s1">, </span><span class="s2">ref_key</span><span class="s1">, </span><span class="s2">ref_for }) =&gt; {</span>
    <span class="s1">return </span><span class="s2">(ref != </span><span class="s1">null</span>
        <span class="s2">? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref)</span>
            <span class="s2">? { i: currentRenderingInstance</span><span class="s1">, </span><span class="s2">r: ref</span><span class="s1">, </span><span class="s2">k: ref_key</span><span class="s1">, </span><span class="s2">f: !!ref_for }</span>
            <span class="s2">: ref</span>
        <span class="s2">: </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createBaseVNode(type</span><span class="s1">, </span><span class="s2">props = </span><span class="s1">null, </span><span class="s2">children = </span><span class="s1">null, </span><span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">dynamicProps = </span><span class="s1">null, </span><span class="s2">shapeFlag = type === Fragment ? </span><span class="s4">0 </span><span class="s2">: </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */</span><span class="s1">, </span><span class="s2">isBlockNode = </span><span class="s1">false, </span><span class="s2">needFullChildrenNormalization = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">vnode = {</span>
        <span class="s2">__v_isVNode: </span><span class="s1">true,</span>
        <span class="s2">__v_skip: </span><span class="s1">true,</span>
        <span class="s2">type</span><span class="s1">,</span>
        <span class="s2">props</span><span class="s1">,</span>
        <span class="s2">key: props &amp;&amp; normalizeKey(props)</span><span class="s1">,</span>
        <span class="s2">ref: props &amp;&amp; normalizeRef(props)</span><span class="s1">,</span>
        <span class="s2">scopeId: currentScopeId</span><span class="s1">,</span>
        <span class="s2">slotScopeIds: </span><span class="s1">null,</span>
        <span class="s2">children</span><span class="s1">,</span>
        <span class="s2">component: </span><span class="s1">null,</span>
        <span class="s2">suspense: </span><span class="s1">null,</span>
        <span class="s2">ssContent: </span><span class="s1">null,</span>
        <span class="s2">ssFallback: </span><span class="s1">null,</span>
        <span class="s2">dirs: </span><span class="s1">null,</span>
        <span class="s2">transition: </span><span class="s1">null,</span>
        <span class="s2">el: </span><span class="s1">null,</span>
        <span class="s2">anchor: </span><span class="s1">null,</span>
        <span class="s2">target: </span><span class="s1">null,</span>
        <span class="s2">targetAnchor: </span><span class="s1">null,</span>
        <span class="s2">staticCount: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">shapeFlag</span><span class="s1">,</span>
        <span class="s2">patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicProps</span><span class="s1">,</span>
        <span class="s2">dynamicChildren: </span><span class="s1">null,</span>
        <span class="s2">appContext: </span><span class="s1">null,</span>
        <span class="s2">ctx: currentRenderingInstance</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(needFullChildrenNormalization) {</span>
        <span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s3">// normalize suspense children</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s2">type.normalize(vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(children) {</span>
        <span class="s3">// compiled element vnode - if children is passed, only possible types are</span>
        <span class="s3">// string or Array.</span>
        <span class="s2">vnode.shapeFlag |= shared.isString(children)</span>
            <span class="s2">? </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span>
            <span class="s2">: </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// validate key</span>
    <span class="s1">if </span><span class="s2">(vnode.key !== vnode.key) {</span>
        <span class="s2">warn(</span><span class="s0">`VNode created with invalid key (NaN). VNode type:`</span><span class="s1">, </span><span class="s2">vnode.type)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// track vnode for block tree</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp;</span>
        <span class="s3">// avoid a block node from tracking itself</span>
        <span class="s2">!isBlockNode &amp;&amp;</span>
        <span class="s3">// has current parent block</span>
        <span class="s2">currentBlock &amp;&amp;</span>
        <span class="s3">// presence of a patch flag indicates this node needs patching on updates.</span>
        <span class="s3">// component nodes also should always be patched, because even if the</span>
        <span class="s3">// component doesn't need to update, it needs to persist the instance on to</span>
        <span class="s3">// the next vnode so that it can be properly unmounted later.</span>
        <span class="s2">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s2">|| shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) &amp;&amp;</span>
        <span class="s3">// the EVENTS flag is only for hydration and if it is the only flag, the</span>
        <span class="s3">// vnode should not be considered dynamic due to handler caching.</span>
        <span class="s2">vnode.patchFlag !== </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">) {</span>
        <span class="s2">currentBlock.push(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createVNode = (createVNodeWithArgsTransform )</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">_createVNode(type</span><span class="s1">, </span><span class="s2">props = </span><span class="s1">null, </span><span class="s2">children = </span><span class="s1">null, </span><span class="s2">patchFlag = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">dynamicProps = </span><span class="s1">null, </span><span class="s2">isBlockNode = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(!type || type === NULL_DYNAMIC_COMPONENT) {</span>
        <span class="s1">if </span><span class="s2">(!type) {</span>
            <span class="s2">warn(</span><span class="s0">`Invalid vnode type when creating vnode: </span><span class="s2">${type}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">type = Comment</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isVNode(type)) {</span>
        <span class="s3">// createVNode receiving an existing vnode. This happens in cases like</span>
        <span class="s3">// &lt;component :is=&quot;vnode&quot;/&gt;</span>
        <span class="s3">// #2078 make sure to merge refs during the clone instead of overwriting it</span>
        <span class="s1">const </span><span class="s2">cloned = cloneVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, true </span><span class="s3">/* mergeRef: true */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(children) {</span>
            <span class="s2">normalizeChildren(cloned</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp; !isBlockNode &amp;&amp; currentBlock) {</span>
            <span class="s1">if </span><span class="s2">(cloned.shapeFlag &amp; </span><span class="s4">6 </span><span class="s3">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                <span class="s2">currentBlock[currentBlock.indexOf(type)] = cloned</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">currentBlock.push(cloned)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">cloned.patchFlag |= -</span><span class="s4">2 </span><span class="s3">/* PatchFlags.BAIL */</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">cloned</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// class component normalization.</span>
    <span class="s1">if </span><span class="s2">(isClassComponent(type)) {</span>
        <span class="s2">type = type.__vccOpts</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// class &amp; style normalization.</span>
    <span class="s1">if </span><span class="s2">(props) {</span>
        <span class="s3">// for reactive or proxy objects, we need to clone it to enable mutation.</span>
        <span class="s2">props = guardReactiveProps(props)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ </span><span class="s1">class</span><span class="s2">: klass</span><span class="s1">, </span><span class="s2">style } = props</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(klass &amp;&amp; !shared.isString(klass)) {</span>
            <span class="s2">props.class = shared.normalizeClass(klass)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(style)) {</span>
            <span class="s3">// reactive state objects need to be cloned since they are likely to be</span>
            <span class="s3">// mutated</span>
            <span class="s1">if </span><span class="s2">(reactivity.isProxy(style) &amp;&amp; !shared.isArray(style)) {</span>
                <span class="s2">style = shared.extend({}</span><span class="s1">, </span><span class="s2">style)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">props.style = shared.normalizeStyle(style)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// encode the vnode type information into a bitmap</span>
    <span class="s1">const </span><span class="s2">shapeFlag = shared.isString(type)</span>
        <span class="s2">? </span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */</span>
        <span class="s2">: isSuspense(type)</span>
            <span class="s2">? </span><span class="s4">128 </span><span class="s3">/* ShapeFlags.SUSPENSE */</span>
            <span class="s2">: isTeleport(type)</span>
                <span class="s2">? </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span>
                <span class="s2">: shared.isObject(type)</span>
                    <span class="s2">? </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */</span>
                    <span class="s2">: shared.isFunction(type)</span>
                        <span class="s2">? </span><span class="s4">2 </span><span class="s3">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span>
                        <span class="s2">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */ </span><span class="s2">&amp;&amp; reactivity.isProxy(type)) {</span>
        <span class="s2">type = reactivity.toRaw(type)</span><span class="s1">;</span>
        <span class="s2">warn(</span><span class="s0">`Vue received a Component which was made a reactive object. This can ` </span><span class="s2">+</span>
            <span class="s0">`lead to unnecessary performance overhead, and should be avoided by ` </span><span class="s2">+</span>
            <span class="s0">`marking the component with </span><span class="s1">\`</span><span class="s0">markRaw</span><span class="s1">\` </span><span class="s0">or using </span><span class="s1">\`</span><span class="s0">shallowRef</span><span class="s1">\` </span><span class="s0">` </span><span class="s2">+</span>
            <span class="s0">`instead of </span><span class="s1">\`</span><span class="s0">ref</span><span class="s1">\`</span><span class="s0">.`</span><span class="s1">, </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">Component that was made reactive: `</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">createBaseVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">isBlockNode</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">guardReactiveProps(props) {</span>
    <span class="s1">if </span><span class="s2">(!props)</span>
        <span class="s1">return null;</span>
    <span class="s1">return </span><span class="s2">reactivity.isProxy(props) || InternalObjectKey </span><span class="s1">in </span><span class="s2">props</span>
        <span class="s2">? shared.extend({}</span><span class="s1">, </span><span class="s2">props)</span>
        <span class="s2">: props</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">cloneVNode(vnode</span><span class="s1">, </span><span class="s2">extraProps</span><span class="s1">, </span><span class="s2">mergeRef = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s3">// This is intentionally NOT using spread or extend to avoid the runtime</span>
    <span class="s3">// key enumeration cost.</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">children } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mergedProps = extraProps ? mergeProps(props || {}</span><span class="s1">, </span><span class="s2">extraProps) : props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cloned = {</span>
        <span class="s2">__v_isVNode: </span><span class="s1">true,</span>
        <span class="s2">__v_skip: </span><span class="s1">true,</span>
        <span class="s2">type: vnode.type</span><span class="s1">,</span>
        <span class="s2">props: mergedProps</span><span class="s1">,</span>
        <span class="s2">key: mergedProps &amp;&amp; normalizeKey(mergedProps)</span><span class="s1">,</span>
        <span class="s2">ref: extraProps &amp;&amp; extraProps.ref</span>
            <span class="s2">? </span><span class="s3">// #2078 in the case of &lt;component :is=&quot;vnode&quot; ref=&quot;extra&quot;/&gt;</span>
                <span class="s3">// if the vnode itself already has a ref, cloneVNode will need to merge</span>
                <span class="s3">// the refs so the single vnode can be set on multiple refs</span>
                <span class="s2">mergeRef &amp;&amp; ref</span>
                    <span class="s2">? shared.isArray(ref)</span>
                        <span class="s2">? ref.concat(normalizeRef(extraProps))</span>
                        <span class="s2">: [ref</span><span class="s1">, </span><span class="s2">normalizeRef(extraProps)]</span>
                    <span class="s2">: normalizeRef(extraProps)</span>
            <span class="s2">: ref</span><span class="s1">,</span>
        <span class="s2">scopeId: vnode.scopeId</span><span class="s1">,</span>
        <span class="s2">slotScopeIds: vnode.slotScopeIds</span><span class="s1">,</span>
        <span class="s2">children: patchFlag === -</span><span class="s4">1 </span><span class="s3">/* PatchFlags.HOISTED */ </span><span class="s2">&amp;&amp; shared.isArray(children)</span>
            <span class="s2">? children.map(deepCloneVNode)</span>
            <span class="s2">: children</span><span class="s1">,</span>
        <span class="s2">target: vnode.target</span><span class="s1">,</span>
        <span class="s2">targetAnchor: vnode.targetAnchor</span><span class="s1">,</span>
        <span class="s2">staticCount: vnode.staticCount</span><span class="s1">,</span>
        <span class="s2">shapeFlag: vnode.shapeFlag</span><span class="s1">,</span>
        <span class="s3">// if the vnode is cloned with extra props, we can no longer assume its</span>
        <span class="s3">// existing patch flag to be reliable and need to add the FULL_PROPS flag.</span>
        <span class="s3">// note: preserve flag for fragments since they use the flag for children</span>
        <span class="s3">// fast paths only.</span>
        <span class="s2">patchFlag: extraProps &amp;&amp; vnode.type !== Fragment</span>
            <span class="s2">? patchFlag === -</span><span class="s4">1 </span><span class="s3">// hoisted node</span>
                <span class="s2">? </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span>
                <span class="s2">: patchFlag | </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span>
            <span class="s2">: patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicProps: vnode.dynamicProps</span><span class="s1">,</span>
        <span class="s2">dynamicChildren: vnode.dynamicChildren</span><span class="s1">,</span>
        <span class="s2">appContext: vnode.appContext</span><span class="s1">,</span>
        <span class="s2">dirs: vnode.dirs</span><span class="s1">,</span>
        <span class="s2">transition: vnode.transition</span><span class="s1">,</span>
        <span class="s3">// These should technically only be non-null on mounted VNodes. However,</span>
        <span class="s3">// they *should* be copied for kept-alive vnodes. So we just always copy</span>
        <span class="s3">// them since them being non-null during a mount doesn't affect the logic as</span>
        <span class="s3">// they will simply be overwritten.</span>
        <span class="s2">component: vnode.component</span><span class="s1">,</span>
        <span class="s2">suspense: vnode.suspense</span><span class="s1">,</span>
        <span class="s2">ssContent: vnode.ssContent &amp;&amp; cloneVNode(vnode.ssContent)</span><span class="s1">,</span>
        <span class="s2">ssFallback: vnode.ssFallback &amp;&amp; cloneVNode(vnode.ssFallback)</span><span class="s1">,</span>
        <span class="s2">el: vnode.el</span><span class="s1">,</span>
        <span class="s2">anchor: vnode.anchor</span><span class="s1">,</span>
        <span class="s2">ctx: vnode.ctx</span><span class="s1">,</span>
        <span class="s2">ce: vnode.ce</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">cloned</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Dev only, for HMR of hoisted vnodes reused in v-for</span>
 <span class="s5">* https://github.com/vitejs/vite/issues/2022</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">deepCloneVNode(vnode) {</span>
    <span class="s1">const </span><span class="s2">cloned = cloneVNode(vnode)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(vnode.children)) {</span>
        <span class="s2">cloned.children = vnode.children.map(deepCloneVNode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">cloned</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createTextVNode(text = </span><span class="s0">' '</span><span class="s1">, </span><span class="s2">flag = </span><span class="s4">0</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">createVNode(Text</span><span class="s1">, null, </span><span class="s2">text</span><span class="s1">, </span><span class="s2">flag)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createStaticVNode(content</span><span class="s1">, </span><span class="s2">numberOfNodes) {</span>
    <span class="s3">// A static vnode can contain multiple stringified elements, and the number</span>
    <span class="s3">// of elements is necessary for hydration.</span>
    <span class="s1">const </span><span class="s2">vnode = createVNode(Static</span><span class="s1">, null, </span><span class="s2">content)</span><span class="s1">;</span>
    <span class="s2">vnode.staticCount = numberOfNodes</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createCommentVNode(text = </span><span class="s0">''</span><span class="s1">, </span>
<span class="s3">// when used as the v-else branch, the comment node must be created as a</span>
<span class="s3">// block to ensure correct updates.</span>
<span class="s2">asBlock = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">asBlock</span>
        <span class="s2">? (openBlock()</span><span class="s1">, </span><span class="s2">createBlock(Comment</span><span class="s1">, null, </span><span class="s2">text))</span>
        <span class="s2">: createVNode(Comment</span><span class="s1">, null, </span><span class="s2">text)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeVNode(child) {</span>
    <span class="s1">if </span><span class="s2">(child == </span><span class="s1">null </span><span class="s2">|| </span><span class="s1">typeof </span><span class="s2">child === </span><span class="s0">'boolean'</span><span class="s2">) {</span>
        <span class="s3">// empty placeholder</span>
        <span class="s1">return </span><span class="s2">createVNode(Comment)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(child)) {</span>
        <span class="s3">// fragment</span>
        <span class="s1">return </span><span class="s2">createVNode(Fragment</span><span class="s1">, null, </span>
        <span class="s3">// #3666, avoid reference pollution when reusing vnode</span>
        <span class="s2">child.slice())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">child === </span><span class="s0">'object'</span><span class="s2">) {</span>
        <span class="s3">// already vnode, this should be the most common since compiled templates</span>
        <span class="s3">// always produce all-vnode children arrays</span>
        <span class="s1">return </span><span class="s2">cloneIfMounted(child)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s3">// strings and numbers</span>
        <span class="s1">return </span><span class="s2">createVNode(Text</span><span class="s1">, null, </span><span class="s2">String(child))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">// optimized normalization for template-compiled render fns</span>
<span class="s1">function </span><span class="s2">cloneIfMounted(child) {</span>
    <span class="s1">return </span><span class="s2">(child.el === </span><span class="s1">null </span><span class="s2">&amp;&amp; child.patchFlag !== -</span><span class="s4">1 </span><span class="s3">/* PatchFlags.HOISTED */</span><span class="s2">) ||</span>
        <span class="s2">child.memo</span>
        <span class="s2">? child</span>
        <span class="s2">: cloneVNode(child)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">children) {</span>
    <span class="s1">let </span><span class="s2">type = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ shapeFlag } = vnode</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(children == </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">children = </span><span class="s1">null;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(children)) {</span>
        <span class="s2">type = </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">children === </span><span class="s0">'object'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s3">/* ShapeFlags.ELEMENT */ </span><span class="s2">| </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">)) {</span>
            <span class="s3">// Normalize slot to plain children for plain element and Teleport</span>
            <span class="s1">const </span><span class="s2">slot = children.default</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(slot) {</span>
                <span class="s3">// _c marker is added by withCtx() indicating this is a compiled slot</span>
                <span class="s2">slot._c &amp;&amp; (slot._d = </span><span class="s1">false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">slot())</span><span class="s1">;</span>
                <span class="s2">slot._c &amp;&amp; (slot._d = </span><span class="s1">true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">type = </span><span class="s4">32 </span><span class="s3">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">slotFlag = children._</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!slotFlag &amp;&amp; !(InternalObjectKey </span><span class="s1">in </span><span class="s2">children)) {</span>
                <span class="s2">children._ctx = currentRenderingInstance</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(slotFlag === </span><span class="s4">3 </span><span class="s3">/* SlotFlags.FORWARDED */ </span><span class="s2">&amp;&amp; currentRenderingInstance) {</span>
                <span class="s3">// a child component receives forwarded slots from the parent.</span>
                <span class="s3">// its slot type is determined by its parent's slot type.</span>
                <span class="s1">if </span><span class="s2">(currentRenderingInstance.slots._ === </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                    <span class="s2">children._ = </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">children._ = </span><span class="s4">2 </span><span class="s3">/* SlotFlags.DYNAMIC */</span><span class="s1">;</span>
                    <span class="s2">vnode.patchFlag |= </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(children)) {</span>
        <span class="s2">children = { </span><span class="s1">default</span><span class="s2">: children</span><span class="s1">, </span><span class="s2">_ctx: currentRenderingInstance }</span><span class="s1">;</span>
        <span class="s2">type = </span><span class="s4">32 </span><span class="s3">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">children = String(children)</span><span class="s1">;</span>
        <span class="s3">// force teleport children to array so it can be moved around</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s3">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
            <span class="s2">type = </span><span class="s4">16 </span><span class="s3">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
            <span class="s2">children = [createTextVNode(children)]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">type = </span><span class="s4">8 </span><span class="s3">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">vnode.children = children</span><span class="s1">;</span>
    <span class="s2">vnode.shapeFlag |= type</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeProps(...args) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; args.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">toMerge = args[i]</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">toMerge) {</span>
            <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'class'</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(ret.class !== toMerge.class) {</span>
                    <span class="s2">ret.class = shared.normalizeClass([ret.class</span><span class="s1">, </span><span class="s2">toMerge.class])</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(key === </span><span class="s0">'style'</span><span class="s2">) {</span>
                <span class="s2">ret.style = shared.normalizeStyle([ret.style</span><span class="s1">, </span><span class="s2">toMerge.style])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shared.isOn(key)) {</span>
                <span class="s1">const </span><span class="s2">existing = ret[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">incoming = toMerge[key]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(incoming &amp;&amp;</span>
                    <span class="s2">existing !== incoming &amp;&amp;</span>
                    <span class="s2">!(shared.isArray(existing) &amp;&amp; existing.includes(incoming))) {</span>
                    <span class="s2">ret[key] = existing</span>
                        <span class="s2">? [].concat(existing</span><span class="s1">, </span><span class="s2">incoming)</span>
                        <span class="s2">: incoming</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(key !== </span><span class="s0">''</span><span class="s2">) {</span>
                <span class="s2">ret[key] = toMerge[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invokeVNodeHook(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">prevVNode = </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">7 </span><span class="s3">/* ErrorCodes.VNODE_HOOK */</span><span class="s1">, </span><span class="s2">[</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">prevVNode</span>
    <span class="s2">])</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">emptyAppContext = createAppContext()</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">uid = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createComponentInstance(vnode</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">suspense) {</span>
    <span class="s1">const </span><span class="s2">type = vnode.type</span><span class="s1">;</span>
    <span class="s3">// inherit parent app context - or - if root, adopt from root vnode</span>
    <span class="s1">const </span><span class="s2">appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">instance = {</span>
        <span class="s2">uid: uid++</span><span class="s1">,</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">type</span><span class="s1">,</span>
        <span class="s2">parent</span><span class="s1">,</span>
        <span class="s2">appContext</span><span class="s1">,</span>
        <span class="s2">root: </span><span class="s1">null,</span>
        <span class="s2">next: </span><span class="s1">null,</span>
        <span class="s2">subTree: </span><span class="s1">null,</span>
        <span class="s2">effect: </span><span class="s1">null,</span>
        <span class="s2">update: </span><span class="s1">null,</span>
        <span class="s2">scope: </span><span class="s1">new </span><span class="s2">reactivity.EffectScope(</span><span class="s1">true </span><span class="s3">/* detached */</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">render: </span><span class="s1">null,</span>
        <span class="s2">proxy: </span><span class="s1">null,</span>
        <span class="s2">exposed: </span><span class="s1">null,</span>
        <span class="s2">exposeProxy: </span><span class="s1">null,</span>
        <span class="s2">withProxy: </span><span class="s1">null,</span>
        <span class="s2">provides: parent ? parent.provides : Object.create(appContext.provides)</span><span class="s1">,</span>
        <span class="s2">accessCache: </span><span class="s1">null,</span>
        <span class="s2">renderCache: []</span><span class="s1">,</span>
        <span class="s3">// local resolved assets</span>
        <span class="s2">components: </span><span class="s1">null,</span>
        <span class="s2">directives: </span><span class="s1">null,</span>
        <span class="s3">// resolved props and emits options</span>
        <span class="s2">propsOptions: normalizePropsOptions(type</span><span class="s1">, </span><span class="s2">appContext)</span><span class="s1">,</span>
        <span class="s2">emitsOptions: normalizeEmitsOptions(type</span><span class="s1">, </span><span class="s2">appContext)</span><span class="s1">,</span>
        <span class="s3">// emit</span>
        <span class="s2">emit: </span><span class="s1">null,</span>
        <span class="s2">emitted: </span><span class="s1">null,</span>
        <span class="s3">// props default value</span>
        <span class="s2">propsDefaults: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s3">// inheritAttrs</span>
        <span class="s2">inheritAttrs: type.inheritAttrs</span><span class="s1">,</span>
        <span class="s3">// state</span>
        <span class="s2">ctx: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">data: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">props: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">attrs: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">slots: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">refs: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">setupState: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">setupContext: </span><span class="s1">null,</span>
        <span class="s3">// suspense related</span>
        <span class="s2">suspense</span><span class="s1">,</span>
        <span class="s2">suspenseId: suspense ? suspense.pendingId : </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">asyncDep: </span><span class="s1">null,</span>
        <span class="s2">asyncResolved: </span><span class="s1">false,</span>
        <span class="s3">// lifecycle hooks</span>
        <span class="s3">// not using enums here because it results in computed properties</span>
        <span class="s2">isMounted: </span><span class="s1">false,</span>
        <span class="s2">isUnmounted: </span><span class="s1">false,</span>
        <span class="s2">isDeactivated: </span><span class="s1">false,</span>
        <span class="s2">bc: </span><span class="s1">null,</span>
        <span class="s2">c: </span><span class="s1">null,</span>
        <span class="s2">bm: </span><span class="s1">null,</span>
        <span class="s2">m: </span><span class="s1">null,</span>
        <span class="s2">bu: </span><span class="s1">null,</span>
        <span class="s2">u: </span><span class="s1">null,</span>
        <span class="s2">um: </span><span class="s1">null,</span>
        <span class="s2">bum: </span><span class="s1">null,</span>
        <span class="s2">da: </span><span class="s1">null,</span>
        <span class="s2">a: </span><span class="s1">null,</span>
        <span class="s2">rtg: </span><span class="s1">null,</span>
        <span class="s2">rtc: </span><span class="s1">null,</span>
        <span class="s2">ec: </span><span class="s1">null,</span>
        <span class="s2">sp: </span><span class="s1">null</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">instance.ctx = createDevRenderContext(instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">instance.root = parent ? parent.root : instance</span><span class="s1">;</span>
    <span class="s2">instance.emit = emit.bind(</span><span class="s1">null, </span><span class="s2">instance)</span><span class="s1">;</span>
    <span class="s3">// apply custom element special handling</span>
    <span class="s1">if </span><span class="s2">(vnode.ce) {</span>
        <span class="s2">vnode.ce(instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">instance</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">currentInstance = </span><span class="s1">null;</span>
<span class="s1">const </span><span class="s2">getCurrentInstance = () =&gt; currentInstance || currentRenderingInstance</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">setCurrentInstance = (instance) =&gt; {</span>
    <span class="s2">currentInstance = instance</span><span class="s1">;</span>
    <span class="s2">instance.scope.on()</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">unsetCurrentInstance = () =&gt; {</span>
    <span class="s2">currentInstance &amp;&amp; currentInstance.scope.off()</span><span class="s1">;</span>
    <span class="s2">currentInstance = </span><span class="s1">null;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isBuiltInTag = </span><span class="s3">/*#__PURE__*/ </span><span class="s2">shared.makeMap(</span><span class="s0">'slot,component'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">validateComponentName(name</span><span class="s1">, </span><span class="s2">config) {</span>
    <span class="s1">const </span><span class="s2">appIsNativeTag = config.isNativeTag || shared.NO</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isBuiltInTag(name) || appIsNativeTag(name)) {</span>
        <span class="s2">warn(</span><span class="s0">'Do not use built-in or reserved HTML elements as component id: ' </span><span class="s2">+ name)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isStatefulComponent(instance) {</span>
    <span class="s1">return </span><span class="s2">instance.vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s3">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">isInSSRComponentSetup = </span><span class="s1">false;</span>
<span class="s1">function </span><span class="s2">setupComponent(instance</span><span class="s1">, </span><span class="s2">isSSR = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">isInSSRComponentSetup = isSSR</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">children } = instance.vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isStateful = isStatefulComponent(instance)</span><span class="s1">;</span>
    <span class="s2">initProps(instance</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">isStateful</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
    <span class="s2">initSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupResult = isStateful</span>
        <span class="s2">? setupStatefulComponent(instance</span><span class="s1">, </span><span class="s2">isSSR)</span>
        <span class="s2">: undefined</span><span class="s1">;</span>
    <span class="s2">isInSSRComponentSetup = </span><span class="s1">false;</span>
    <span class="s1">return </span><span class="s2">setupResult</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setupStatefulComponent(instance</span><span class="s1">, </span><span class="s2">isSSR) {</span>
    <span class="s1">var </span><span class="s2">_a</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(Component.name) {</span>
            <span class="s2">validateComponentName(Component.name</span><span class="s1">, </span><span class="s2">instance.appContext.config)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Component.components) {</span>
            <span class="s1">const </span><span class="s2">names = Object.keys(Component.components)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; names.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">validateComponentName(names[i]</span><span class="s1">, </span><span class="s2">instance.appContext.config)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Component.directives) {</span>
            <span class="s1">const </span><span class="s2">names = Object.keys(Component.directives)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; names.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">validateDirectiveName(names[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Component.compilerOptions &amp;&amp; isRuntimeOnly()) {</span>
            <span class="s2">warn(</span><span class="s0">`&quot;compilerOptions&quot; is only supported when using a build of Vue that ` </span><span class="s2">+</span>
                <span class="s0">`includes the runtime compiler. Since you are using a runtime-only ` </span><span class="s2">+</span>
                <span class="s0">`build, the options should be passed via your build tool config instead.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// 0. create render proxy property access cache</span>
    <span class="s2">instance.accessCache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">// 1. create public instance / render proxy</span>
    <span class="s3">// also mark it raw so it's never observed</span>
    <span class="s2">instance.proxy = reactivity.markRaw(</span><span class="s1">new </span><span class="s2">Proxy(instance.ctx</span><span class="s1">, </span><span class="s2">PublicInstanceProxyHandlers))</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">exposePropsOnRenderContext(instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// 2. call setup()</span>
    <span class="s1">const </span><span class="s2">{ setup } = Component</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(setup) {</span>
        <span class="s1">const </span><span class="s2">setupContext = (instance.setupContext =</span>
            <span class="s2">setup.length &gt; </span><span class="s4">1 </span><span class="s2">? createSetupContext(instance) : </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">setupResult = callWithErrorHandling(setup</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s1">, </span><span class="s2">[reactivity.shallowReadonly(instance.props) </span><span class="s1">, </span><span class="s2">setupContext])</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isPromise(setupResult)) {</span>
            <span class="s2">setupResult.then(unsetCurrentInstance</span><span class="s1">, </span><span class="s2">unsetCurrentInstance)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSSR) {</span>
                <span class="s3">// return the promise so server-renderer can wait on it</span>
                <span class="s1">return </span><span class="s2">setupResult</span>
                    <span class="s2">.then((resolvedResult) =&gt; {</span>
                    <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">resolvedResult</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
                <span class="s2">})</span>
                    <span class="s2">.catch(e =&gt; {</span>
                    <span class="s2">handleError(e</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s3">// async setup returned Promise.</span>
                <span class="s3">// bail here and wait for re-entry.</span>
                <span class="s2">instance.asyncDep = setupResult</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(!instance.suspense) {</span>
                    <span class="s1">const </span><span class="s2">name = (_a = Component.name) !== </span><span class="s1">null </span><span class="s2">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s2">? _a : </span><span class="s0">'Anonymous'</span><span class="s1">;</span>
                    <span class="s2">warn(</span><span class="s0">`Component &lt;</span><span class="s2">${name}</span><span class="s0">&gt;: setup function returned a promise, but no ` </span><span class="s2">+</span>
                        <span class="s0">`&lt;Suspense&gt; boundary was found in the parent component tree. ` </span><span class="s2">+</span>
                        <span class="s0">`A component with async setup() must be nested in a &lt;Suspense&gt; ` </span><span class="s2">+</span>
                        <span class="s0">`in order to be rendered.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">setupResult</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">setupResult</span><span class="s1">, </span><span class="s2">isSSR) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(setupResult)) {</span>
        <span class="s3">// setup returned an inline render function</span>
        <span class="s1">if </span><span class="s2">(instance.type.__ssrInlineRender) {</span>
            <span class="s3">// when the function's name is `ssrRender` (compiled by SFC inline mode),</span>
            <span class="s3">// set it as ssrRender instead.</span>
            <span class="s2">instance.ssrRender = setupResult</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">instance.render = setupResult</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(setupResult)) {</span>
        <span class="s1">if </span><span class="s2">(isVNode(setupResult)) {</span>
            <span class="s2">warn(</span><span class="s0">`setup() should not return VNodes directly - ` </span><span class="s2">+</span>
                <span class="s0">`return a render function instead.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">// setup returned bindings.</span>
        <span class="s3">// assuming a render function compiled from template is present.</span>
        <span class="s2">{</span>
            <span class="s2">instance.devtoolsRawSetupState = setupResult</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">instance.setupState = reactivity.proxyRefs(setupResult)</span><span class="s1">;</span>
        <span class="s2">{</span>
            <span class="s2">exposeSetupStateOnRenderContext(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(setupResult !== undefined) {</span>
        <span class="s2">warn(</span><span class="s0">`setup() should return an object. Received: </span><span class="s2">${setupResult === </span><span class="s1">null </span><span class="s2">? </span><span class="s0">'null' </span><span class="s2">: </span><span class="s1">typeof </span><span class="s2">setupResult}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">compile</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">installWithProxy</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* For runtime-dom to register the compiler.</span>
 <span class="s5">* Note the exported method uses any to avoid d.ts relying on the compiler types.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">registerRuntimeCompiler(_compile) {</span>
    <span class="s2">compile = _compile</span><span class="s1">;</span>
    <span class="s2">installWithProxy = i =&gt; {</span>
        <span class="s1">if </span><span class="s2">(i.render._rc) {</span>
            <span class="s2">i.withProxy = </span><span class="s1">new </span><span class="s2">Proxy(i.ctx</span><span class="s1">, </span><span class="s2">RuntimeCompiledPublicInstanceProxyHandlers)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">// dev only</span>
<span class="s1">const </span><span class="s2">isRuntimeOnly = () =&gt; !compile</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR</span><span class="s1">, </span><span class="s2">skipOptions) {</span>
    <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
    <span class="s3">// template / render function normalization</span>
    <span class="s3">// could be already set when returned from setup()</span>
    <span class="s1">if </span><span class="s2">(!instance.render) {</span>
        <span class="s3">// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation</span>
        <span class="s3">// is done by server-renderer</span>
        <span class="s1">if </span><span class="s2">(!isSSR &amp;&amp; compile &amp;&amp; !Component.render) {</span>
            <span class="s1">const </span><span class="s2">template = Component.template ||</span>
                <span class="s2">resolveMergedOptions(instance).template</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(template) {</span>
                <span class="s2">{</span>
                    <span class="s2">startMeasure(instance</span><span class="s1">, </span><span class="s0">`compile`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">{ isCustomElement</span><span class="s1">, </span><span class="s2">compilerOptions } = instance.appContext.config</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ delimiters</span><span class="s1">, </span><span class="s2">compilerOptions: componentCompilerOptions } = Component</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">finalCompilerOptions = shared.extend(shared.extend({</span>
                    <span class="s2">isCustomElement</span><span class="s1">,</span>
                    <span class="s2">delimiters</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">compilerOptions)</span><span class="s1">, </span><span class="s2">componentCompilerOptions)</span><span class="s1">;</span>
                <span class="s2">Component.render = compile(template</span><span class="s1">, </span><span class="s2">finalCompilerOptions)</span><span class="s1">;</span>
                <span class="s2">{</span>
                    <span class="s2">endMeasure(instance</span><span class="s1">, </span><span class="s0">`compile`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">instance.render = (Component.render || shared.NOOP)</span><span class="s1">;</span>
        <span class="s3">// for runtime-compiled render functions using `with` blocks, the render</span>
        <span class="s3">// proxy used needs a different `has` handler which is more performant and</span>
        <span class="s3">// also only allows a whitelist of globals to fallthrough.</span>
        <span class="s1">if </span><span class="s2">(installWithProxy) {</span>
            <span class="s2">installWithProxy(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// support for 2.x options</span>
    <span class="s2">{</span>
        <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s2">applyOptions(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s3">// warn missing template/render</span>
    <span class="s3">// the runtime compilation of template in SSR is done by server-render</span>
    <span class="s1">if </span><span class="s2">(!Component.render &amp;&amp; instance.render === shared.NOOP &amp;&amp; !isSSR) {</span>
        <span class="s3">/* istanbul ignore if */</span>
        <span class="s1">if </span><span class="s2">(!compile &amp;&amp; Component.template) {</span>
            <span class="s2">warn(</span><span class="s0">`Component provided template option but ` </span><span class="s2">+</span>
                <span class="s0">`runtime compilation is not supported in this build of Vue.` </span><span class="s2">+</span>
                <span class="s2">(</span><span class="s0">``</span><span class="s2">) </span><span class="s3">/* should not happen */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">`Component is missing template or render function.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createAttrsProxy(instance) {</span>
    <span class="s1">return new </span><span class="s2">Proxy(instance.attrs</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
                <span class="s2">markAttrsAccessed()</span><span class="s1">;</span>
                <span class="s2">reactivity.track(instance</span><span class="s1">, </span><span class="s0">&quot;get&quot; </span><span class="s3">/* TrackOpTypes.GET */</span><span class="s1">, </span><span class="s0">'$attrs'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">target[key]</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">set() {</span>
                <span class="s2">warn(</span><span class="s0">`setupContext.attrs is readonly.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return false;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">deleteProperty() {</span>
                <span class="s2">warn(</span><span class="s0">`setupContext.attrs is readonly.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return false;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createSetupContext(instance) {</span>
    <span class="s1">const </span><span class="s2">expose = exposed =&gt; {</span>
        <span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(instance.exposed) {</span>
                <span class="s2">warn(</span><span class="s0">`expose() should be called only once per setup().`</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(exposed != </span><span class="s1">null</span><span class="s2">) {</span>
                <span class="s1">let </span><span class="s2">exposedType = </span><span class="s1">typeof </span><span class="s2">exposed</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(exposedType === </span><span class="s0">'object'</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(shared.isArray(exposed)) {</span>
                        <span class="s2">exposedType = </span><span class="s0">'array'</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(reactivity.isRef(exposed)) {</span>
                        <span class="s2">exposedType = </span><span class="s0">'ref'</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(exposedType !== </span><span class="s0">'object'</span><span class="s2">) {</span>
                    <span class="s2">warn(</span><span class="s0">`expose() should be passed a plain object, received </span><span class="s2">${exposedType}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">instance.exposed = exposed || {}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">attrs</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s3">// We use getters in dev in case libs like test-utils overwrite instance</span>
        <span class="s3">// properties (overwrites should not be done in prod)</span>
        <span class="s1">return </span><span class="s2">Object.freeze({</span>
            <span class="s2">get attrs() {</span>
                <span class="s1">return </span><span class="s2">attrs || (attrs = createAttrsProxy(instance))</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">get slots() {</span>
                <span class="s1">return </span><span class="s2">reactivity.shallowReadonly(instance.slots)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">get emit() {</span>
                <span class="s1">return </span><span class="s2">(event</span><span class="s1">, </span><span class="s2">...args) =&gt; instance.emit(event</span><span class="s1">, </span><span class="s2">...args)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">expose</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getExposeProxy(instance) {</span>
    <span class="s1">if </span><span class="s2">(instance.exposed) {</span>
        <span class="s1">return </span><span class="s2">(instance.exposeProxy ||</span>
            <span class="s2">(instance.exposeProxy = </span><span class="s1">new </span><span class="s2">Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed))</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
                    <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">target) {</span>
                        <span class="s1">return </span><span class="s2">target[key]</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">publicPropertiesMap) {</span>
                        <span class="s1">return </span><span class="s2">publicPropertiesMap[key](instance)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span><span class="s1">,</span>
                <span class="s2">has(target</span><span class="s1">, </span><span class="s2">key) {</span>
                    <span class="s1">return </span><span class="s2">key </span><span class="s1">in </span><span class="s2">target || key </span><span class="s1">in </span><span class="s2">publicPropertiesMap</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">classifyRE = </span><span class="s4">/(?:^|[-_])(\w)/g</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">classify = (str) =&gt; str.replace(classifyRE</span><span class="s1">, </span><span class="s2">c =&gt; c.toUpperCase()).replace(</span><span class="s4">/[-_]/g</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getComponentName(Component</span><span class="s1">, </span><span class="s2">includeInferred = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(Component)</span>
        <span class="s2">? Component.displayName || Component.name</span>
        <span class="s2">: Component.name || (includeInferred &amp;&amp; Component.__name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/* istanbul ignore next */</span>
<span class="s1">function </span><span class="s2">formatComponentName(instance</span><span class="s1">, </span><span class="s2">Component</span><span class="s1">, </span><span class="s2">isRoot = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">let </span><span class="s2">name = getComponentName(Component)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!name &amp;&amp; Component.__file) {</span>
        <span class="s1">const </span><span class="s2">match = Component.__file.match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(match) {</span>
            <span class="s2">name = match[</span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!name &amp;&amp; instance &amp;&amp; instance.parent) {</span>
        <span class="s3">// try to infer the name based on reverse resolution</span>
        <span class="s1">const </span><span class="s2">inferFromRegistry = (registry) =&gt; {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">registry) {</span>
                <span class="s1">if </span><span class="s2">(registry[key] === Component) {</span>
                    <span class="s1">return </span><span class="s2">key</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">name =</span>
            <span class="s2">inferFromRegistry(instance.components ||</span>
                <span class="s2">instance.parent.type.components) || inferFromRegistry(instance.appContext.components)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">name ? classify(name) : isRoot ? </span><span class="s0">`App` </span><span class="s2">: </span><span class="s0">`Anonymous`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isClassComponent(value) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(value) &amp;&amp; </span><span class="s0">'__vccOpts' </span><span class="s1">in </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">computed = ((getterOrOptions</span><span class="s1">, </span><span class="s2">debugOptions) =&gt; {</span>
    <span class="s3">// @ts-ignore</span>
    <span class="s1">return </span><span class="s2">reactivity.computed(getterOrOptions</span><span class="s1">, </span><span class="s2">debugOptions</span><span class="s1">, </span><span class="s2">isInSSRComponentSetup)</span><span class="s1">;</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s3">// dev only</span>
<span class="s1">const </span><span class="s2">warnRuntimeUsage = (method) =&gt; warn(</span><span class="s0">`</span><span class="s2">${method}</span><span class="s0">() is a compiler-hint helper that is only usable inside ` </span><span class="s2">+</span>
    <span class="s0">`&lt;script setup&gt; of a single file component. Its arguments should be ` </span><span class="s2">+</span>
    <span class="s0">`compiled away and passing it at runtime has no effect.`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s3">// implementation</span>
<span class="s1">function </span><span class="s2">defineProps() {</span>
    <span class="s2">{</span>
        <span class="s2">warnRuntimeUsage(</span><span class="s0">`defineProps`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s3">// implementation</span>
<span class="s1">function </span><span class="s2">defineEmits() {</span>
    <span class="s2">{</span>
        <span class="s2">warnRuntimeUsage(</span><span class="s0">`defineEmits`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's exposed</span>
 <span class="s5">* instance properties when it is accessed by a parent component via template</span>
 <span class="s5">* refs.</span>
 <span class="s5">*</span>
 <span class="s5">* `&lt;script setup&gt;` components are closed by default - i.e. variables inside</span>
 <span class="s5">* the `&lt;script setup&gt;` scope is not exposed to parent unless explicitly exposed</span>
 <span class="s5">* via `defineExpose`.</span>
 <span class="s5">*</span>
 <span class="s5">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s5">* output and should **not** be actually called at runtime.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">defineExpose(exposed) {</span>
    <span class="s2">{</span>
        <span class="s2">warnRuntimeUsage(</span><span class="s0">`defineExpose`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Vue `&lt;script setup&gt;` compiler macro for providing props default values when</span>
 <span class="s5">* using type-based `defineProps` declaration.</span>
 <span class="s5">*</span>
 <span class="s5">* Example usage:</span>
 <span class="s5">* ```ts</span>
 <span class="s5">* withDefaults(defineProps&lt;{</span>
 <span class="s5">*   size?: number</span>
 <span class="s5">*   labels?: string[]</span>
 <span class="s5">* }&gt;(), {</span>
 <span class="s5">*   size: 3,</span>
 <span class="s5">*   labels: () =&gt; ['default label']</span>
 <span class="s5">* })</span>
 <span class="s5">* ```</span>
 <span class="s5">*</span>
 <span class="s5">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the output</span>
 <span class="s5">* and should **not** be actually called at runtime.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">withDefaults(props</span><span class="s1">, </span><span class="s2">defaults) {</span>
    <span class="s2">{</span>
        <span class="s2">warnRuntimeUsage(</span><span class="s0">`withDefaults`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">useSlots() {</span>
    <span class="s1">return </span><span class="s2">getContext().slots</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">useAttrs() {</span>
    <span class="s1">return </span><span class="s2">getContext().attrs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getContext() {</span>
    <span class="s1">const </span><span class="s2">i = getCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!i) {</span>
        <span class="s2">warn(</span><span class="s0">`useContext() called without active instance.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">i.setupContext || (i.setupContext = createSetupContext(i))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Runtime helper for merging default declarations. Imported by compiled code</span>
 <span class="s5">* only.</span>
 <span class="s5">* </span><span class="s6">@internal</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">mergeDefaults(raw</span><span class="s1">, </span><span class="s2">defaults) {</span>
    <span class="s1">const </span><span class="s2">props = shared.isArray(raw)</span>
        <span class="s2">? raw.reduce((normalized</span><span class="s1">, </span><span class="s2">p) =&gt; ((normalized[p] = {})</span><span class="s1">, </span><span class="s2">normalized)</span><span class="s1">, </span><span class="s2">{})</span>
        <span class="s2">: raw</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">defaults) {</span>
        <span class="s1">const </span><span class="s2">opt = props[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(opt) {</span>
            <span class="s1">if </span><span class="s2">(shared.isArray(opt) || shared.isFunction(opt)) {</span>
                <span class="s2">props[key] = { type: opt</span><span class="s1">, default</span><span class="s2">: defaults[key] }</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">opt.default = defaults[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(opt === </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">props[key] = { </span><span class="s1">default</span><span class="s2">: defaults[key] }</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">warn(</span><span class="s0">`props default key &quot;</span><span class="s2">${key}</span><span class="s0">&quot; has no corresponding declaration.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">props</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Used to create a proxy for the rest element when destructuring props with</span>
 <span class="s5">* defineProps().</span>
 <span class="s5">* </span><span class="s6">@internal</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">createPropsRestProxy(props</span><span class="s1">, </span><span class="s2">excludedKeys) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
        <span class="s1">if </span><span class="s2">(!excludedKeys.includes(key)) {</span>
            <span class="s2">Object.defineProperty(ret</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; props[key]</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* `&lt;script setup&gt;` helper for persisting the current instance context over</span>
 <span class="s5">* async/await flows.</span>
 <span class="s5">*</span>
 <span class="s5">* `@vue/compiler-sfc` converts the following:</span>
 <span class="s5">*</span>
 <span class="s5">* ```ts</span>
 <span class="s5">* const x = await foo()</span>
 <span class="s5">* ```</span>
 <span class="s5">*</span>
 <span class="s5">* into:</span>
 <span class="s5">*</span>
 <span class="s5">* ```ts</span>
 <span class="s5">* let __temp, __restore</span>
 <span class="s5">* const x = (([__temp, __restore] = withAsyncContext(() =&gt; foo())),__temp=await __temp,__restore(),__temp)</span>
 <span class="s5">* ```</span>
 <span class="s5">* </span><span class="s6">@internal</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">withAsyncContext(getAwaitable) {</span>
    <span class="s1">const </span><span class="s2">ctx = getCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!ctx) {</span>
        <span class="s2">warn(</span><span class="s0">`withAsyncContext called without active current instance. ` </span><span class="s2">+</span>
            <span class="s0">`This is likely a bug.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">awaitable = getAwaitable()</span><span class="s1">;</span>
    <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isPromise(awaitable)) {</span>
        <span class="s2">awaitable = awaitable.catch(e =&gt; {</span>
            <span class="s2">setCurrentInstance(ctx)</span><span class="s1">;</span>
            <span class="s1">throw </span><span class="s2">e</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">[awaitable</span><span class="s1">, </span><span class="s2">() =&gt; setCurrentInstance(ctx)]</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">// Actual implementation</span>
<span class="s1">function </span><span class="s2">h(type</span><span class="s1">, </span><span class="s2">propsOrChildren</span><span class="s1">, </span><span class="s2">children) {</span>
    <span class="s1">const </span><span class="s2">l = arguments.length</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(l === </span><span class="s4">2</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(propsOrChildren) &amp;&amp; !shared.isArray(propsOrChildren)) {</span>
            <span class="s3">// single vnode without props</span>
            <span class="s1">if </span><span class="s2">(isVNode(propsOrChildren)) {</span>
                <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, null, </span><span class="s2">[propsOrChildren])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s3">// props without children</span>
            <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, </span><span class="s2">propsOrChildren)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s3">// omit props</span>
            <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, null, </span><span class="s2">propsOrChildren)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(l &gt; </span><span class="s4">3</span><span class="s2">) {</span>
            <span class="s2">children = Array.prototype.slice.call(arguments</span><span class="s1">, </span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(l === </span><span class="s4">3 </span><span class="s2">&amp;&amp; isVNode(children)) {</span>
            <span class="s2">children = [children]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, </span><span class="s2">propsOrChildren</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">ssrContextKey = Symbol(</span><span class="s0">`ssrContext` </span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">useSSRContext = () =&gt; {</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">ctx = inject(ssrContextKey)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!ctx) {</span>
            <span class="s2">warn(</span><span class="s0">`Server rendering context not provided. Make sure to only call ` </span><span class="s2">+</span>
                    <span class="s0">`useSSRContext() conditionally in the server build.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">ctx</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">isShallow(value) {</span>
    <span class="s1">return </span><span class="s2">!!(value &amp;&amp; value[</span><span class="s0">&quot;__v_isShallow&quot; </span><span class="s3">/* ReactiveFlags.IS_SHALLOW */</span><span class="s2">])</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">initCustomFormatter() {</span>
    <span class="s3">/* eslint-disable no-restricted-globals */</span>
    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">window === </span><span class="s0">'undefined'</span><span class="s2">) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">vueStyle = { style: </span><span class="s0">'color:#3ba776' </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">numberStyle = { style: </span><span class="s0">'color:#0b1bc9' </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">stringStyle = { style: </span><span class="s0">'color:#b62e24' </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">keywordStyle = { style: </span><span class="s0">'color:#9d288c' </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s3">// custom formatter for Chrome</span>
    <span class="s3">// https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html</span>
    <span class="s1">const </span><span class="s2">formatter = {</span>
        <span class="s2">header(obj) {</span>
            <span class="s3">// TODO also format ComponentPublicInstance &amp; ctx.slots/attrs in setup</span>
            <span class="s1">if </span><span class="s2">(!shared.isObject(obj)) {</span>
                <span class="s1">return null;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(obj.__isVue) {</span>
                <span class="s1">return </span><span class="s2">[</span><span class="s0">'div'</span><span class="s1">, </span><span class="s2">vueStyle</span><span class="s1">, </span><span class="s0">`VueInstance`</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(reactivity.isRef(obj)) {</span>
                <span class="s1">return </span><span class="s2">[</span>
                    <span class="s0">'div'</span><span class="s1">,</span>
                    <span class="s2">{}</span><span class="s1">,</span>
                    <span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">vueStyle</span><span class="s1">, </span><span class="s2">genRefFlag(obj)]</span><span class="s1">,</span>
                    <span class="s0">'&lt;'</span><span class="s1">,</span>
                    <span class="s2">formatValue(obj.value)</span><span class="s1">,</span>
                    <span class="s0">`&gt;`</span>
                <span class="s2">]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(reactivity.isReactive(obj)) {</span>
                <span class="s1">return </span><span class="s2">[</span>
                    <span class="s0">'div'</span><span class="s1">,</span>
                    <span class="s2">{}</span><span class="s1">,</span>
                    <span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">vueStyle</span><span class="s1">, </span><span class="s2">isShallow(obj) ? </span><span class="s0">'ShallowReactive' </span><span class="s2">: </span><span class="s0">'Reactive'</span><span class="s2">]</span><span class="s1">,</span>
                    <span class="s0">'&lt;'</span><span class="s1">,</span>
                    <span class="s2">formatValue(obj)</span><span class="s1">,</span>
                    <span class="s0">`&gt;</span><span class="s2">${reactivity.isReadonly(obj) ? </span><span class="s0">` (readonly)` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span>
                <span class="s2">]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(reactivity.isReadonly(obj)) {</span>
                <span class="s1">return </span><span class="s2">[</span>
                    <span class="s0">'div'</span><span class="s1">,</span>
                    <span class="s2">{}</span><span class="s1">,</span>
                    <span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">vueStyle</span><span class="s1">, </span><span class="s2">isShallow(obj) ? </span><span class="s0">'ShallowReadonly' </span><span class="s2">: </span><span class="s0">'Readonly'</span><span class="s2">]</span><span class="s1">,</span>
                    <span class="s0">'&lt;'</span><span class="s1">,</span>
                    <span class="s2">formatValue(obj)</span><span class="s1">,</span>
                    <span class="s0">'&gt;'</span>
                <span class="s2">]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return null;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">hasBody(obj) {</span>
            <span class="s1">return </span><span class="s2">obj &amp;&amp; obj.__isVue</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">body(obj) {</span>
            <span class="s1">if </span><span class="s2">(obj &amp;&amp; obj.__isVue) {</span>
                <span class="s1">return </span><span class="s2">[</span>
                    <span class="s0">'div'</span><span class="s1">,</span>
                    <span class="s2">{}</span><span class="s1">,</span>
                    <span class="s2">...formatInstance(obj.$)</span>
                <span class="s2">]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">function </span><span class="s2">formatInstance(instance) {</span>
        <span class="s1">const </span><span class="s2">blocks = []</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(instance.type.props &amp;&amp; instance.props) {</span>
            <span class="s2">blocks.push(createInstanceBlock(</span><span class="s0">'props'</span><span class="s1">, </span><span class="s2">reactivity.toRaw(instance.props)))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(instance.setupState !== shared.EMPTY_OBJ) {</span>
            <span class="s2">blocks.push(createInstanceBlock(</span><span class="s0">'setup'</span><span class="s1">, </span><span class="s2">instance.setupState))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(instance.data !== shared.EMPTY_OBJ) {</span>
            <span class="s2">blocks.push(createInstanceBlock(</span><span class="s0">'data'</span><span class="s1">, </span><span class="s2">reactivity.toRaw(instance.data)))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">computed = extractKeys(instance</span><span class="s1">, </span><span class="s0">'computed'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(computed) {</span>
            <span class="s2">blocks.push(createInstanceBlock(</span><span class="s0">'computed'</span><span class="s1">, </span><span class="s2">computed))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">injected = extractKeys(instance</span><span class="s1">, </span><span class="s0">'inject'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(injected) {</span>
            <span class="s2">blocks.push(createInstanceBlock(</span><span class="s0">'injected'</span><span class="s1">, </span><span class="s2">injected))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">blocks.push([</span>
            <span class="s0">'div'</span><span class="s1">,</span>
            <span class="s2">{}</span><span class="s1">,</span>
            <span class="s2">[</span>
                <span class="s0">'span'</span><span class="s1">,</span>
                <span class="s2">{</span>
                    <span class="s2">style: keywordStyle.style + </span><span class="s0">';opacity:0.66'</span>
                <span class="s2">}</span><span class="s1">,</span>
                <span class="s0">'$ (internal): '</span>
            <span class="s2">]</span><span class="s1">,</span>
            <span class="s2">[</span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">{ object: instance }]</span>
        <span class="s2">])</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">blocks</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">createInstanceBlock(type</span><span class="s1">, </span><span class="s2">target) {</span>
        <span class="s2">target = shared.extend({}</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!Object.keys(target).length) {</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">{}]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">[</span>
            <span class="s0">'div'</span><span class="s1">,</span>
            <span class="s2">{ style: </span><span class="s0">'line-height:1.25em;margin-bottom:0.6em' </span><span class="s2">}</span><span class="s1">,</span>
            <span class="s2">[</span>
                <span class="s0">'div'</span><span class="s1">,</span>
                <span class="s2">{</span>
                    <span class="s2">style: </span><span class="s0">'color:#476582'</span>
                <span class="s2">}</span><span class="s1">,</span>
                <span class="s2">type</span>
            <span class="s2">]</span><span class="s1">,</span>
            <span class="s2">[</span>
                <span class="s0">'div'</span><span class="s1">,</span>
                <span class="s2">{</span>
                    <span class="s2">style: </span><span class="s0">'padding-left:1.25em'</span>
                <span class="s2">}</span><span class="s1">,</span>
                <span class="s2">...Object.keys(target).map(key =&gt; {</span>
                    <span class="s1">return </span><span class="s2">[</span>
                        <span class="s0">'div'</span><span class="s1">,</span>
                        <span class="s2">{}</span><span class="s1">,</span>
                        <span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">keywordStyle</span><span class="s1">, </span><span class="s2">key + </span><span class="s0">': '</span><span class="s2">]</span><span class="s1">,</span>
                        <span class="s2">formatValue(target[key]</span><span class="s1">, false</span><span class="s2">)</span>
                    <span class="s2">]</span><span class="s1">;</span>
                <span class="s2">})</span>
            <span class="s2">]</span>
        <span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">formatValue(v</span><span class="s1">, </span><span class="s2">asRaw = </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">v === </span><span class="s0">'number'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">numberStyle</span><span class="s1">, </span><span class="s2">v]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">v === </span><span class="s0">'string'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">stringStyle</span><span class="s1">, </span><span class="s2">JSON.stringify(v)]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">v === </span><span class="s0">'boolean'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">keywordStyle</span><span class="s1">, </span><span class="s2">v]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.isObject(v)) {</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">{ object: asRaw ? reactivity.toRaw(v) : v }]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">return </span><span class="s2">[</span><span class="s0">'span'</span><span class="s1">, </span><span class="s2">stringStyle</span><span class="s1">, </span><span class="s2">String(v)]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">extractKeys(instance</span><span class="s1">, </span><span class="s2">type) {</span>
        <span class="s1">const </span><span class="s2">Comp = instance.type</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isFunction(Comp)) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">extracted = {}</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">instance.ctx) {</span>
            <span class="s1">if </span><span class="s2">(isKeyOfType(Comp</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">type)) {</span>
                <span class="s2">extracted[key] = instance.ctx[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">extracted</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">isKeyOfType(Comp</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">type) {</span>
        <span class="s1">const </span><span class="s2">opts = Comp[type]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((shared.isArray(opts) &amp;&amp; opts.includes(key)) ||</span>
            <span class="s2">(shared.isObject(opts) &amp;&amp; key </span><span class="s1">in </span><span class="s2">opts)) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Comp.extends &amp;&amp; isKeyOfType(Comp.extends</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">type)) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Comp.mixins &amp;&amp; Comp.mixins.some(m =&gt; isKeyOfType(m</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">type))) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">genRefFlag(v) {</span>
        <span class="s1">if </span><span class="s2">(isShallow(v)) {</span>
            <span class="s1">return </span><span class="s0">`ShallowRef`</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(v.effect) {</span>
            <span class="s1">return </span><span class="s0">`ComputedRef`</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s0">`Ref`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(window.devtoolsFormatters) {</span>
        <span class="s2">window.devtoolsFormatters.push(formatter)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">window.devtoolsFormatters = [formatter]</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">withMemo(memo</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">const </span><span class="s2">cached = cache[index]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached &amp;&amp; isMemoSame(cached</span><span class="s1">, </span><span class="s2">memo)) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">ret = render()</span><span class="s1">;</span>
    <span class="s3">// shallow clone</span>
    <span class="s2">ret.memo = memo.slice()</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(cache[index] = ret)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isMemoSame(cached</span><span class="s1">, </span><span class="s2">memo) {</span>
    <span class="s1">const </span><span class="s2">prev = cached.memo</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(prev.length != memo.length) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; prev.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">if </span><span class="s2">(shared.hasChanged(prev[i]</span><span class="s1">, </span><span class="s2">memo[i])) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">// make sure to let parent block track it when returning cached</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s2">&amp;&amp; currentBlock) {</span>
        <span class="s2">currentBlock.push(cached)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>

<span class="s3">// Core API ------------------------------------------------------------------</span>
<span class="s1">const </span><span class="s2">version = </span><span class="s0">&quot;3.2.47&quot;</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">_ssrUtils = {</span>
    <span class="s2">createComponentInstance</span><span class="s1">,</span>
    <span class="s2">setupComponent</span><span class="s1">,</span>
    <span class="s2">renderComponentRoot</span><span class="s1">,</span>
    <span class="s2">setCurrentRenderingInstance</span><span class="s1">,</span>
    <span class="s2">isVNode</span><span class="s1">,</span>
    <span class="s2">normalizeVNode</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.</span>
 <span class="s5">* </span><span class="s6">@internal</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">ssrUtils = (_ssrUtils )</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@internal </span><span class="s5">only exposed in compat builds</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">resolveFilter = </span><span class="s1">null;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@internal </span><span class="s5">only exposed in compat builds.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">compatUtils = (</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>

<span class="s2">exports.EffectScope = reactivity.EffectScope</span><span class="s1">;</span>
<span class="s2">exports.ReactiveEffect = reactivity.ReactiveEffect</span><span class="s1">;</span>
<span class="s2">exports.customRef = reactivity.customRef</span><span class="s1">;</span>
<span class="s2">exports.effect = reactivity.effect</span><span class="s1">;</span>
<span class="s2">exports.effectScope = reactivity.effectScope</span><span class="s1">;</span>
<span class="s2">exports.getCurrentScope = reactivity.getCurrentScope</span><span class="s1">;</span>
<span class="s2">exports.isProxy = reactivity.isProxy</span><span class="s1">;</span>
<span class="s2">exports.isReactive = reactivity.isReactive</span><span class="s1">;</span>
<span class="s2">exports.isReadonly = reactivity.isReadonly</span><span class="s1">;</span>
<span class="s2">exports.isRef = reactivity.isRef</span><span class="s1">;</span>
<span class="s2">exports.isShallow = reactivity.isShallow</span><span class="s1">;</span>
<span class="s2">exports.markRaw = reactivity.markRaw</span><span class="s1">;</span>
<span class="s2">exports.onScopeDispose = reactivity.onScopeDispose</span><span class="s1">;</span>
<span class="s2">exports.proxyRefs = reactivity.proxyRefs</span><span class="s1">;</span>
<span class="s2">exports.reactive = reactivity.reactive</span><span class="s1">;</span>
<span class="s2">exports.readonly = reactivity.readonly</span><span class="s1">;</span>
<span class="s2">exports.ref = reactivity.ref</span><span class="s1">;</span>
<span class="s2">exports.shallowReactive = reactivity.shallowReactive</span><span class="s1">;</span>
<span class="s2">exports.shallowReadonly = reactivity.shallowReadonly</span><span class="s1">;</span>
<span class="s2">exports.shallowRef = reactivity.shallowRef</span><span class="s1">;</span>
<span class="s2">exports.stop = reactivity.stop</span><span class="s1">;</span>
<span class="s2">exports.toRaw = reactivity.toRaw</span><span class="s1">;</span>
<span class="s2">exports.toRef = reactivity.toRef</span><span class="s1">;</span>
<span class="s2">exports.toRefs = reactivity.toRefs</span><span class="s1">;</span>
<span class="s2">exports.triggerRef = reactivity.triggerRef</span><span class="s1">;</span>
<span class="s2">exports.unref = reactivity.unref</span><span class="s1">;</span>
<span class="s2">exports.camelize = shared.camelize</span><span class="s1">;</span>
<span class="s2">exports.capitalize = shared.capitalize</span><span class="s1">;</span>
<span class="s2">exports.normalizeClass = shared.normalizeClass</span><span class="s1">;</span>
<span class="s2">exports.normalizeProps = shared.normalizeProps</span><span class="s1">;</span>
<span class="s2">exports.normalizeStyle = shared.normalizeStyle</span><span class="s1">;</span>
<span class="s2">exports.toDisplayString = shared.toDisplayString</span><span class="s1">;</span>
<span class="s2">exports.toHandlerKey = shared.toHandlerKey</span><span class="s1">;</span>
<span class="s2">exports.BaseTransition = BaseTransition</span><span class="s1">;</span>
<span class="s2">exports.Comment = Comment</span><span class="s1">;</span>
<span class="s2">exports.Fragment = Fragment</span><span class="s1">;</span>
<span class="s2">exports.KeepAlive = KeepAlive</span><span class="s1">;</span>
<span class="s2">exports.Static = Static</span><span class="s1">;</span>
<span class="s2">exports.Suspense = Suspense</span><span class="s1">;</span>
<span class="s2">exports.Teleport = Teleport</span><span class="s1">;</span>
<span class="s2">exports.Text = Text</span><span class="s1">;</span>
<span class="s2">exports.assertNumber = assertNumber</span><span class="s1">;</span>
<span class="s2">exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling</span><span class="s1">;</span>
<span class="s2">exports.callWithErrorHandling = callWithErrorHandling</span><span class="s1">;</span>
<span class="s2">exports.cloneVNode = cloneVNode</span><span class="s1">;</span>
<span class="s2">exports.compatUtils = compatUtils</span><span class="s1">;</span>
<span class="s2">exports.computed = computed</span><span class="s1">;</span>
<span class="s2">exports.createBlock = createBlock</span><span class="s1">;</span>
<span class="s2">exports.createCommentVNode = createCommentVNode</span><span class="s1">;</span>
<span class="s2">exports.createElementBlock = createElementBlock</span><span class="s1">;</span>
<span class="s2">exports.createElementVNode = createBaseVNode</span><span class="s1">;</span>
<span class="s2">exports.createHydrationRenderer = createHydrationRenderer</span><span class="s1">;</span>
<span class="s2">exports.createPropsRestProxy = createPropsRestProxy</span><span class="s1">;</span>
<span class="s2">exports.createRenderer = createRenderer</span><span class="s1">;</span>
<span class="s2">exports.createSlots = createSlots</span><span class="s1">;</span>
<span class="s2">exports.createStaticVNode = createStaticVNode</span><span class="s1">;</span>
<span class="s2">exports.createTextVNode = createTextVNode</span><span class="s1">;</span>
<span class="s2">exports.createVNode = createVNode</span><span class="s1">;</span>
<span class="s2">exports.defineAsyncComponent = defineAsyncComponent</span><span class="s1">;</span>
<span class="s2">exports.defineComponent = defineComponent</span><span class="s1">;</span>
<span class="s2">exports.defineEmits = defineEmits</span><span class="s1">;</span>
<span class="s2">exports.defineExpose = defineExpose</span><span class="s1">;</span>
<span class="s2">exports.defineProps = defineProps</span><span class="s1">;</span>
<span class="s2">exports.getCurrentInstance = getCurrentInstance</span><span class="s1">;</span>
<span class="s2">exports.getTransitionRawChildren = getTransitionRawChildren</span><span class="s1">;</span>
<span class="s2">exports.guardReactiveProps = guardReactiveProps</span><span class="s1">;</span>
<span class="s2">exports.h = h</span><span class="s1">;</span>
<span class="s2">exports.handleError = handleError</span><span class="s1">;</span>
<span class="s2">exports.initCustomFormatter = initCustomFormatter</span><span class="s1">;</span>
<span class="s2">exports.inject = inject</span><span class="s1">;</span>
<span class="s2">exports.isMemoSame = isMemoSame</span><span class="s1">;</span>
<span class="s2">exports.isRuntimeOnly = isRuntimeOnly</span><span class="s1">;</span>
<span class="s2">exports.isVNode = isVNode</span><span class="s1">;</span>
<span class="s2">exports.mergeDefaults = mergeDefaults</span><span class="s1">;</span>
<span class="s2">exports.mergeProps = mergeProps</span><span class="s1">;</span>
<span class="s2">exports.nextTick = nextTick</span><span class="s1">;</span>
<span class="s2">exports.onActivated = onActivated</span><span class="s1">;</span>
<span class="s2">exports.onBeforeMount = onBeforeMount</span><span class="s1">;</span>
<span class="s2">exports.onBeforeUnmount = onBeforeUnmount</span><span class="s1">;</span>
<span class="s2">exports.onBeforeUpdate = onBeforeUpdate</span><span class="s1">;</span>
<span class="s2">exports.onDeactivated = onDeactivated</span><span class="s1">;</span>
<span class="s2">exports.onErrorCaptured = onErrorCaptured</span><span class="s1">;</span>
<span class="s2">exports.onMounted = onMounted</span><span class="s1">;</span>
<span class="s2">exports.onRenderTracked = onRenderTracked</span><span class="s1">;</span>
<span class="s2">exports.onRenderTriggered = onRenderTriggered</span><span class="s1">;</span>
<span class="s2">exports.onServerPrefetch = onServerPrefetch</span><span class="s1">;</span>
<span class="s2">exports.onUnmounted = onUnmounted</span><span class="s1">;</span>
<span class="s2">exports.onUpdated = onUpdated</span><span class="s1">;</span>
<span class="s2">exports.openBlock = openBlock</span><span class="s1">;</span>
<span class="s2">exports.popScopeId = popScopeId</span><span class="s1">;</span>
<span class="s2">exports.provide = provide</span><span class="s1">;</span>
<span class="s2">exports.pushScopeId = pushScopeId</span><span class="s1">;</span>
<span class="s2">exports.queuePostFlushCb = queuePostFlushCb</span><span class="s1">;</span>
<span class="s2">exports.registerRuntimeCompiler = registerRuntimeCompiler</span><span class="s1">;</span>
<span class="s2">exports.renderList = renderList</span><span class="s1">;</span>
<span class="s2">exports.renderSlot = renderSlot</span><span class="s1">;</span>
<span class="s2">exports.resolveComponent = resolveComponent</span><span class="s1">;</span>
<span class="s2">exports.resolveDirective = resolveDirective</span><span class="s1">;</span>
<span class="s2">exports.resolveDynamicComponent = resolveDynamicComponent</span><span class="s1">;</span>
<span class="s2">exports.resolveFilter = resolveFilter</span><span class="s1">;</span>
<span class="s2">exports.resolveTransitionHooks = resolveTransitionHooks</span><span class="s1">;</span>
<span class="s2">exports.setBlockTracking = setBlockTracking</span><span class="s1">;</span>
<span class="s2">exports.setDevtoolsHook = setDevtoolsHook</span><span class="s1">;</span>
<span class="s2">exports.setTransitionHooks = setTransitionHooks</span><span class="s1">;</span>
<span class="s2">exports.ssrContextKey = ssrContextKey</span><span class="s1">;</span>
<span class="s2">exports.ssrUtils = ssrUtils</span><span class="s1">;</span>
<span class="s2">exports.toHandlers = toHandlers</span><span class="s1">;</span>
<span class="s2">exports.transformVNodeArgs = transformVNodeArgs</span><span class="s1">;</span>
<span class="s2">exports.useAttrs = useAttrs</span><span class="s1">;</span>
<span class="s2">exports.useSSRContext = useSSRContext</span><span class="s1">;</span>
<span class="s2">exports.useSlots = useSlots</span><span class="s1">;</span>
<span class="s2">exports.useTransitionState = useTransitionState</span><span class="s1">;</span>
<span class="s2">exports.version = version</span><span class="s1">;</span>
<span class="s2">exports.warn = warn</span><span class="s1">;</span>
<span class="s2">exports.watch = watch</span><span class="s1">;</span>
<span class="s2">exports.watchEffect = watchEffect</span><span class="s1">;</span>
<span class="s2">exports.watchPostEffect = watchPostEffect</span><span class="s1">;</span>
<span class="s2">exports.watchSyncEffect = watchSyncEffect</span><span class="s1">;</span>
<span class="s2">exports.withAsyncContext = withAsyncContext</span><span class="s1">;</span>
<span class="s2">exports.withCtx = withCtx</span><span class="s1">;</span>
<span class="s2">exports.withDefaults = withDefaults</span><span class="s1">;</span>
<span class="s2">exports.withDirectives = withDirectives</span><span class="s1">;</span>
<span class="s2">exports.withMemo = withMemo</span><span class="s1">;</span>
<span class="s2">exports.withScopeId = withScopeId</span><span class="s1">;</span>
</pre>
</body>
</html>