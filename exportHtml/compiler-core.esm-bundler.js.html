<html>
<head>
<title>compiler-core.esm-bundler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compiler-core.esm-bundler.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ isString</span><span class="s0">, </span><span class="s1">hyphenate</span><span class="s0">, </span><span class="s1">NOOP</span><span class="s0">, </span><span class="s1">extend</span><span class="s0">, </span><span class="s1">isObject</span><span class="s0">, </span><span class="s1">NO</span><span class="s0">, </span><span class="s1">isArray</span><span class="s0">, </span><span class="s1">makeMap</span><span class="s0">, </span><span class="s1">isSymbol</span><span class="s0">, </span><span class="s1">capitalize</span><span class="s0">, </span><span class="s1">camelize as camelize$1</span><span class="s0">, </span><span class="s1">EMPTY_OBJ</span><span class="s0">, </span><span class="s1">PatchFlagNames</span><span class="s0">, </span><span class="s1">slotFlagsText</span><span class="s0">, </span><span class="s1">isOn</span><span class="s0">, </span><span class="s1">isBuiltInDirective</span><span class="s0">, </span><span class="s1">isReservedProp</span><span class="s0">, </span><span class="s1">toHandlerKey } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">export </span><span class="s1">{ generateCodeFrame } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">defaultOnError(error) {</span>
    <span class="s0">throw </span><span class="s1">error</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">defaultOnWarn(msg) {</span>
    <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; console.warn(</span><span class="s2">`[Vue warn] </span><span class="s1">${msg.message}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createCompilerError(code</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">messages</span><span class="s0">, </span><span class="s1">additionalMessage) {</span>
    <span class="s0">const </span><span class="s1">msg = (process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) || !</span><span class="s0">true</span>
        <span class="s1">? (messages || errorMessages)[code] + (additionalMessage || </span><span class="s2">``</span><span class="s1">)</span>
        <span class="s1">: code</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">error = </span><span class="s0">new </span><span class="s1">SyntaxError(String(msg))</span><span class="s0">;</span>
    <span class="s1">error.code = code</span><span class="s0">;</span>
    <span class="s1">error.loc = loc</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">error</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">errorMessages = {</span>
    <span class="s3">// parse errors</span>
    <span class="s1">[</span><span class="s4">0 </span><span class="s3">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">]: </span><span class="s2">'Illegal comment.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">1 </span><span class="s3">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">]: </span><span class="s2">'CDATA section is allowed only in XML context.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">2 </span><span class="s3">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">]: </span><span class="s2">'Duplicate attribute.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">3 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">]: </span><span class="s2">'End tag cannot have attributes.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">4 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">]: </span><span class="s2">&quot;Illegal '/' in tags.&quot;</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in tag.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">6 </span><span class="s3">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in CDATA section.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">7 </span><span class="s3">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in comment.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">8 </span><span class="s3">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in script.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">9 </span><span class="s3">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">]: </span><span class="s2">'Unexpected EOF in tag.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">10 </span><span class="s3">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">]: </span><span class="s2">'Incorrectly closed comment.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">11 </span><span class="s3">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">]: </span><span class="s2">'Incorrectly opened comment.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s2">&quot;Illegal tag name. Use '&amp;lt;' to print '&lt;'.&quot;</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">13 </span><span class="s3">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s2">'Attribute value was expected.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">14 </span><span class="s3">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s1">]: </span><span class="s2">'End tag name was expected.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">15 </span><span class="s3">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">]: </span><span class="s2">'Whitespace was expected.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">16 </span><span class="s3">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">]: </span><span class="s2">&quot;Unexpected '&lt;!--' in comment.&quot;</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">17 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s2">'Attribute name cannot contain U+0022 (&quot;), U+0027 (</span><span class="s0">\'</span><span class="s2">), and U+003C (&lt;).'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">18 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s2">'Unquoted attribute value cannot contain U+0022 (&quot;), U+0027 (</span><span class="s0">\'</span><span class="s2">), U+003C (&lt;), U+003D (=), and U+0060 (`).'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">19 </span><span class="s3">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s2">&quot;Attribute name cannot start with '='.&quot;</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">21 </span><span class="s3">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s2">&quot;'&lt;?' is allowed only in XML context.&quot;</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">20 </span><span class="s3">/* ErrorCodes.UNEXPECTED_NULL_CHARACTER */</span><span class="s1">]: </span><span class="s2">`Unexpected null character.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">22 </span><span class="s3">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">]: </span><span class="s2">&quot;Illegal '/' in tags.&quot;</span><span class="s0">,</span>
    <span class="s3">// Vue-specific parse errors</span>
    <span class="s1">[</span><span class="s4">23 </span><span class="s3">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">]: </span><span class="s2">'Invalid end tag.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">24 </span><span class="s3">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s1">]: </span><span class="s2">'Element is missing end tag.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">25 </span><span class="s3">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">]: </span><span class="s2">'Interpolation end sign was not found.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">27 </span><span class="s3">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">]: </span><span class="s2">'End bracket for dynamic directive argument was not found. ' </span><span class="s1">+</span>
        <span class="s2">'Note that dynamic directive argument cannot contain spaces.'</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">26 </span><span class="s3">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">]: </span><span class="s2">'Legal directive name was expected.'</span><span class="s0">,</span>
    <span class="s3">// transform errors</span>
    <span class="s1">[</span><span class="s4">28 </span><span class="s3">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-if/v-else-if is missing expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">29 </span><span class="s3">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s1">]: </span><span class="s2">`v-if/else branches must use unique keys.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">]: </span><span class="s2">`v-else/v-else-if has no adjacent v-if or v-else-if.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">31 </span><span class="s3">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-for is missing expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-for has invalid expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">33 </span><span class="s3">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s1">]: </span><span class="s2">`&lt;template v-for&gt; key should be placed on the &lt;template&gt; tag.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-bind is missing expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-on is missing expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">36 </span><span class="s3">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s1">]: </span><span class="s2">`Unexpected custom directive on &lt;slot&gt; outlet.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">37 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s1">]: </span><span class="s2">`Mixed v-slot usage on both the component and nested &lt;template&gt;. ` </span><span class="s1">+</span>
        <span class="s2">`When there are multiple named slots, all slots should use &lt;template&gt; ` </span><span class="s1">+</span>
        <span class="s2">`syntax to avoid scope ambiguity.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">38 </span><span class="s3">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s1">]: </span><span class="s2">`Duplicate slot names found. `</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">39 </span><span class="s3">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s1">]: </span><span class="s2">`Extraneous children found when component already has explicitly named ` </span><span class="s1">+</span>
        <span class="s2">`default slot. These children will be ignored.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">40 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s1">]: </span><span class="s2">`v-slot can only be used on components or &lt;template&gt; tags.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">41 </span><span class="s3">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-model is missing expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">42 </span><span class="s3">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`v-model value must be a valid JavaScript member expression.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">43 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */</span><span class="s1">]: </span><span class="s2">`v-model cannot be used on v-for or v-slot scope variables because they are not writable.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">44 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s1">]: </span><span class="s2">`v-model cannot be used on a prop, because local prop bindings are not writable.</span><span class="s0">\n</span><span class="s2">Use a v-bind binding combined with a v-on listener that emits update:x event instead.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">45 </span><span class="s3">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s1">]: </span><span class="s2">`Error parsing JavaScript expression: `</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">46 </span><span class="s3">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s1">]: </span><span class="s2">`&lt;KeepAlive&gt; expects exactly one child component.`</span><span class="s0">,</span>
    <span class="s3">// generic errors</span>
    <span class="s1">[</span><span class="s4">47 </span><span class="s3">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;prefixIdentifiers&quot; option is not supported in this build of compiler.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">48 </span><span class="s3">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`ES module mode is not supported in this build of compiler.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">49 </span><span class="s3">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;cacheHandlers&quot; option is only supported when the &quot;prefixIdentifiers&quot; option is enabled.`</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s4">50 </span><span class="s3">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s2">`&quot;scopeId&quot; option is only supported in module mode.`</span><span class="s0">,</span>
    <span class="s3">// just to fulfill types</span>
    <span class="s1">[</span><span class="s4">51 </span><span class="s3">/* ErrorCodes.__EXTEND_POINT__ */</span><span class="s1">]: </span><span class="s2">``</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">FRAGMENT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`Fragment` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">TELEPORT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`Teleport` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">SUSPENSE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`Suspense` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">KEEP_ALIVE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`KeepAlive` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">BASE_TRANSITION = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`BaseTransition` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">OPEN_BLOCK = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`openBlock` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_BLOCK = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createBlock` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_ELEMENT_BLOCK = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createElementBlock` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_VNODE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createVNode` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_ELEMENT_VNODE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createElementVNode` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_COMMENT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createCommentVNode` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_TEXT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createTextVNode` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_STATIC = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createStaticVNode` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RESOLVE_COMPONENT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`resolveComponent` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RESOLVE_DYNAMIC_COMPONENT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`resolveDynamicComponent` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RESOLVE_DIRECTIVE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`resolveDirective` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RESOLVE_FILTER = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`resolveFilter` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">WITH_DIRECTIVES = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`withDirectives` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RENDER_LIST = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`renderList` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">RENDER_SLOT = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`renderSlot` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CREATE_SLOTS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`createSlots` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">TO_DISPLAY_STRING = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`toDisplayString` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">MERGE_PROPS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`mergeProps` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">NORMALIZE_CLASS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`normalizeClass` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">NORMALIZE_STYLE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`normalizeStyle` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">NORMALIZE_PROPS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`normalizeProps` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">GUARD_REACTIVE_PROPS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`guardReactiveProps` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">TO_HANDLERS = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`toHandlers` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CAMELIZE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`camelize` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">CAPITALIZE = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`capitalize` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">TO_HANDLER_KEY = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`toHandlerKey` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">SET_BLOCK_TRACKING = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`setBlockTracking` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">PUSH_SCOPE_ID = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`pushScopeId` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">POP_SCOPE_ID = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`popScopeId` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">WITH_CTX = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`withCtx` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">UNREF = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`unref` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">IS_REF = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`isRef` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">WITH_MEMO = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`withMemo` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">IS_MEMO_SAME = Symbol((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">`isMemoSame` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
<span class="s3">// Name mapping for runtime helpers that need to be imported from 'vue' in</span>
<span class="s3">// generated code. Make sure these are correctly exported in the runtime!</span>
<span class="s0">const </span><span class="s1">helperNameMap = {</span>
    <span class="s1">[FRAGMENT]: </span><span class="s2">`Fragment`</span><span class="s0">,</span>
    <span class="s1">[TELEPORT]: </span><span class="s2">`Teleport`</span><span class="s0">,</span>
    <span class="s1">[SUSPENSE]: </span><span class="s2">`Suspense`</span><span class="s0">,</span>
    <span class="s1">[KEEP_ALIVE]: </span><span class="s2">`KeepAlive`</span><span class="s0">,</span>
    <span class="s1">[BASE_TRANSITION]: </span><span class="s2">`BaseTransition`</span><span class="s0">,</span>
    <span class="s1">[OPEN_BLOCK]: </span><span class="s2">`openBlock`</span><span class="s0">,</span>
    <span class="s1">[CREATE_BLOCK]: </span><span class="s2">`createBlock`</span><span class="s0">,</span>
    <span class="s1">[CREATE_ELEMENT_BLOCK]: </span><span class="s2">`createElementBlock`</span><span class="s0">,</span>
    <span class="s1">[CREATE_VNODE]: </span><span class="s2">`createVNode`</span><span class="s0">,</span>
    <span class="s1">[CREATE_ELEMENT_VNODE]: </span><span class="s2">`createElementVNode`</span><span class="s0">,</span>
    <span class="s1">[CREATE_COMMENT]: </span><span class="s2">`createCommentVNode`</span><span class="s0">,</span>
    <span class="s1">[CREATE_TEXT]: </span><span class="s2">`createTextVNode`</span><span class="s0">,</span>
    <span class="s1">[CREATE_STATIC]: </span><span class="s2">`createStaticVNode`</span><span class="s0">,</span>
    <span class="s1">[RESOLVE_COMPONENT]: </span><span class="s2">`resolveComponent`</span><span class="s0">,</span>
    <span class="s1">[RESOLVE_DYNAMIC_COMPONENT]: </span><span class="s2">`resolveDynamicComponent`</span><span class="s0">,</span>
    <span class="s1">[RESOLVE_DIRECTIVE]: </span><span class="s2">`resolveDirective`</span><span class="s0">,</span>
    <span class="s1">[RESOLVE_FILTER]: </span><span class="s2">`resolveFilter`</span><span class="s0">,</span>
    <span class="s1">[WITH_DIRECTIVES]: </span><span class="s2">`withDirectives`</span><span class="s0">,</span>
    <span class="s1">[RENDER_LIST]: </span><span class="s2">`renderList`</span><span class="s0">,</span>
    <span class="s1">[RENDER_SLOT]: </span><span class="s2">`renderSlot`</span><span class="s0">,</span>
    <span class="s1">[CREATE_SLOTS]: </span><span class="s2">`createSlots`</span><span class="s0">,</span>
    <span class="s1">[TO_DISPLAY_STRING]: </span><span class="s2">`toDisplayString`</span><span class="s0">,</span>
    <span class="s1">[MERGE_PROPS]: </span><span class="s2">`mergeProps`</span><span class="s0">,</span>
    <span class="s1">[NORMALIZE_CLASS]: </span><span class="s2">`normalizeClass`</span><span class="s0">,</span>
    <span class="s1">[NORMALIZE_STYLE]: </span><span class="s2">`normalizeStyle`</span><span class="s0">,</span>
    <span class="s1">[NORMALIZE_PROPS]: </span><span class="s2">`normalizeProps`</span><span class="s0">,</span>
    <span class="s1">[GUARD_REACTIVE_PROPS]: </span><span class="s2">`guardReactiveProps`</span><span class="s0">,</span>
    <span class="s1">[TO_HANDLERS]: </span><span class="s2">`toHandlers`</span><span class="s0">,</span>
    <span class="s1">[CAMELIZE]: </span><span class="s2">`camelize`</span><span class="s0">,</span>
    <span class="s1">[CAPITALIZE]: </span><span class="s2">`capitalize`</span><span class="s0">,</span>
    <span class="s1">[TO_HANDLER_KEY]: </span><span class="s2">`toHandlerKey`</span><span class="s0">,</span>
    <span class="s1">[SET_BLOCK_TRACKING]: </span><span class="s2">`setBlockTracking`</span><span class="s0">,</span>
    <span class="s1">[PUSH_SCOPE_ID]: </span><span class="s2">`pushScopeId`</span><span class="s0">,</span>
    <span class="s1">[POP_SCOPE_ID]: </span><span class="s2">`popScopeId`</span><span class="s0">,</span>
    <span class="s1">[WITH_CTX]: </span><span class="s2">`withCtx`</span><span class="s0">,</span>
    <span class="s1">[UNREF]: </span><span class="s2">`unref`</span><span class="s0">,</span>
    <span class="s1">[IS_REF]: </span><span class="s2">`isRef`</span><span class="s0">,</span>
    <span class="s1">[WITH_MEMO]: </span><span class="s2">`withMemo`</span><span class="s0">,</span>
    <span class="s1">[IS_MEMO_SAME]: </span><span class="s2">`isMemoSame`</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">registerRuntimeHelpers(helpers) {</span>
    <span class="s1">Object.getOwnPropertySymbols(helpers).forEach(s =&gt; {</span>
        <span class="s1">helperNameMap[s] = helpers[s]</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s3">// AST Utilities ---------------------------------------------------------------</span>
<span class="s3">// Some expressions, e.g. sequence and conditional expressions, are never</span>
<span class="s3">// associated with template nodes, so their source locations are just a stub.</span>
<span class="s3">// Container types like CompoundExpression also don't need a real location.</span>
<span class="s0">const </span><span class="s1">locStub = {</span>
    <span class="s1">source: </span><span class="s2">''</span><span class="s0">,</span>
    <span class="s1">start: { line: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">end: { line: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createRoot(children</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */</span><span class="s0">,</span>
        <span class="s1">children</span><span class="s0">,</span>
        <span class="s1">helpers: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
        <span class="s1">components: []</span><span class="s0">,</span>
        <span class="s1">directives: []</span><span class="s0">,</span>
        <span class="s1">hoists: []</span><span class="s0">,</span>
        <span class="s1">imports: []</span><span class="s0">,</span>
        <span class="s1">cached: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">temps: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">codegenNode: undefined</span><span class="s0">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createVNodeCall(context</span><span class="s0">, </span><span class="s1">tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps</span><span class="s0">, </span><span class="s1">directives</span><span class="s0">, </span><span class="s1">isBlock = </span><span class="s0">false, </span><span class="s1">disableTracking = </span><span class="s0">false, </span><span class="s1">isComponent = </span><span class="s0">false, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">if </span><span class="s1">(context) {</span>
        <span class="s0">if </span><span class="s1">(isBlock) {</span>
            <span class="s1">context.helper(OPEN_BLOCK)</span><span class="s0">;</span>
            <span class="s1">context.helper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(directives) {</span>
            <span class="s1">context.helper(WITH_DIRECTIVES)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s0">,</span>
        <span class="s1">tag</span><span class="s0">,</span>
        <span class="s1">props</span><span class="s0">,</span>
        <span class="s1">children</span><span class="s0">,</span>
        <span class="s1">patchFlag</span><span class="s0">,</span>
        <span class="s1">dynamicProps</span><span class="s0">,</span>
        <span class="s1">directives</span><span class="s0">,</span>
        <span class="s1">isBlock</span><span class="s0">,</span>
        <span class="s1">disableTracking</span><span class="s0">,</span>
        <span class="s1">isComponent</span><span class="s0">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createArrayExpression(elements</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">elements</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createObjectExpression(properties</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">properties</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createObjectProperty(key</span><span class="s0">, </span><span class="s1">value) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">16 </span><span class="s3">/* NodeTypes.JS_PROPERTY */</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span><span class="s0">,</span>
        <span class="s1">key: isString(key) ? createSimpleExpression(key</span><span class="s0">, true</span><span class="s1">) : key</span><span class="s0">,</span>
        <span class="s1">value</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createSimpleExpression(content</span><span class="s0">, </span><span class="s1">isStatic = </span><span class="s0">false, </span><span class="s1">loc = locStub</span><span class="s0">, </span><span class="s1">constType = </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">content</span><span class="s0">,</span>
        <span class="s1">isStatic</span><span class="s0">,</span>
        <span class="s1">constType: isStatic ? </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */ </span><span class="s1">: constType</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createInterpolation(content</span><span class="s0">, </span><span class="s1">loc) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">content: isString(content)</span>
            <span class="s1">? createSimpleExpression(content</span><span class="s0">, false, </span><span class="s1">loc)</span>
            <span class="s1">: content</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createCompoundExpression(children</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">children</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createCallExpression(callee</span><span class="s0">, </span><span class="s1">args = []</span><span class="s0">, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">loc</span><span class="s0">,</span>
        <span class="s1">callee</span><span class="s0">,</span>
        <span class="s1">arguments: args</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createFunctionExpression(params</span><span class="s0">, </span><span class="s1">returns = undefined</span><span class="s0">, </span><span class="s1">newline = </span><span class="s0">false, </span><span class="s1">isSlot = </span><span class="s0">false, </span><span class="s1">loc = locStub) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">18 </span><span class="s3">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">params</span><span class="s0">,</span>
        <span class="s1">returns</span><span class="s0">,</span>
        <span class="s1">newline</span><span class="s0">,</span>
        <span class="s1">isSlot</span><span class="s0">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createConditionalExpression(test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate</span><span class="s0">, </span><span class="s1">newline = </span><span class="s0">true</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">test</span><span class="s0">,</span>
        <span class="s1">consequent</span><span class="s0">,</span>
        <span class="s1">alternate</span><span class="s0">,</span>
        <span class="s1">newline</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createCacheExpression(index</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">isVNode = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">index</span><span class="s0">,</span>
        <span class="s1">value</span><span class="s0">,</span>
        <span class="s1">isVNode</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createBlockStatement(body) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">21 </span><span class="s3">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s0">,</span>
        <span class="s1">body</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createTemplateLiteral(elements) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">22 </span><span class="s3">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s0">,</span>
        <span class="s1">elements</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createIfStatement(test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">23 </span><span class="s3">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s0">,</span>
        <span class="s1">test</span><span class="s0">,</span>
        <span class="s1">consequent</span><span class="s0">,</span>
        <span class="s1">alternate</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createAssignmentExpression(left</span><span class="s0">, </span><span class="s1">right) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">24 </span><span class="s3">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">left</span><span class="s0">,</span>
        <span class="s1">right</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createSequenceExpression(expressions) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">25 </span><span class="s3">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s0">,</span>
        <span class="s1">expressions</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createReturnStatement(returns) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">26 </span><span class="s3">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s0">,</span>
        <span class="s1">returns</span><span class="s0">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">isStaticExp = (p) =&gt; p.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; p.isStatic</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">isBuiltInType = (tag</span><span class="s0">, </span><span class="s1">expected) =&gt; tag === expected || tag === hyphenate(expected)</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">isCoreComponent(tag) {</span>
    <span class="s0">if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'Teleport'</span><span class="s1">)) {</span>
        <span class="s0">return </span><span class="s1">TELEPORT</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'Suspense'</span><span class="s1">)) {</span>
        <span class="s0">return </span><span class="s1">SUSPENSE</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'KeepAlive'</span><span class="s1">)) {</span>
        <span class="s0">return </span><span class="s1">KEEP_ALIVE</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s0">, </span><span class="s2">'BaseTransition'</span><span class="s1">)) {</span>
        <span class="s0">return </span><span class="s1">BASE_TRANSITION</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">nonIdentifierRE = </span><span class="s4">/^\d|[^\$\w]/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">isSimpleIdentifier = (name) =&gt; !nonIdentifierRE.test(name)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">validFirstIdentCharRE = </span><span class="s4">/[A-Za-z_$\xA0-\uFFFF]/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">validIdentCharRE = </span><span class="s4">/[\.\?\w$\xA0-\uFFFF]/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">whitespaceRE = </span><span class="s4">/\s+[.[]\s*|\s*[.[]\s+/g</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Simple lexer to check if an expression is a member expression. This is</span>
 <span class="s5">* lax and only checks validity at the root level (i.e. does not validate exps</span>
 <span class="s5">* inside square brackets), but it's ok since these are only used on template</span>
 <span class="s5">* expressions and false positives are invalid expressions in the first place.</span>
 <span class="s5">*/</span>
<span class="s0">const </span><span class="s1">isMemberExpressionBrowser = (path) =&gt; {</span>
    <span class="s3">// remove whitespaces around . or [ first</span>
    <span class="s1">path = path.trim().replace(whitespaceRE</span><span class="s0">, </span><span class="s1">s =&gt; s.trim())</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">state = </span><span class="s4">0 </span><span class="s3">/* MemberExpLexState.inMemberExp */</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">stateStack = []</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">currentOpenBracketCount = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">currentOpenParensCount = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">currentStringType = </span><span class="s0">null;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; path.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">char = path.charAt(i)</span><span class="s0">;</span>
        <span class="s0">switch </span><span class="s1">(state) {</span>
            <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* MemberExpLexState.inMemberExp */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(char === </span><span class="s2">'['</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                    <span class="s1">state = </span><span class="s4">1 </span><span class="s3">/* MemberExpLexState.inBrackets */</span><span class="s0">;</span>
                    <span class="s1">currentOpenBracketCount++</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">'('</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                    <span class="s1">state = </span><span class="s4">2 </span><span class="s3">/* MemberExpLexState.inParens */</span><span class="s0">;</span>
                    <span class="s1">currentOpenParensCount++</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(!(i === </span><span class="s4">0 </span><span class="s1">? validFirstIdentCharRE : validIdentCharRE).test(char)) {</span>
                    <span class="s0">return false;</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* MemberExpLexState.inBrackets */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(char === </span><span class="s2">`'` </span><span class="s1">|| char === </span><span class="s2">`&quot;` </span><span class="s1">|| char === </span><span class="s2">'`'</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                    <span class="s1">state = </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s0">;</span>
                    <span class="s1">currentStringType = char</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`[`</span><span class="s1">) {</span>
                    <span class="s1">currentOpenBracketCount++</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`]`</span><span class="s1">) {</span>
                    <span class="s0">if </span><span class="s1">(!--currentOpenBracketCount) {</span>
                        <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* MemberExpLexState.inParens */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(char === </span><span class="s2">`'` </span><span class="s1">|| char === </span><span class="s2">`&quot;` </span><span class="s1">|| char === </span><span class="s2">'`'</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s0">;</span>
                    <span class="s1">state = </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s0">;</span>
                    <span class="s1">currentStringType = char</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`(`</span><span class="s1">) {</span>
                    <span class="s1">currentOpenParensCount++</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(char === </span><span class="s2">`)`</span><span class="s1">) {</span>
                    <span class="s3">// if the exp ends as a call then it should not be considered valid</span>
                    <span class="s0">if </span><span class="s1">(i === path.length - </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s0">return false;</span>
                    <span class="s1">}</span>
                    <span class="s0">if </span><span class="s1">(!--currentOpenParensCount) {</span>
                        <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* MemberExpLexState.inString */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(char === currentStringType) {</span>
                    <span class="s1">state = stateStack.pop()</span><span class="s0">;</span>
                    <span class="s1">currentStringType = </span><span class="s0">null;</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">!currentOpenBracketCount &amp;&amp; !currentOpenParensCount</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">isMemberExpressionNode = NOOP</span>
    <span class="s0">;</span>
<span class="s0">const </span><span class="s1">isMemberExpression = isMemberExpressionBrowser</span>
    <span class="s0">;</span>
<span class="s0">function </span><span class="s1">getInnerRange(loc</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">length) {</span>
    <span class="s0">const </span><span class="s1">source = loc.source.slice(offset</span><span class="s0">, </span><span class="s1">offset + length)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">newLoc = {</span>
        <span class="s1">source</span><span class="s0">,</span>
        <span class="s1">start: advancePositionWithClone(loc.start</span><span class="s0">, </span><span class="s1">loc.source</span><span class="s0">, </span><span class="s1">offset)</span><span class="s0">,</span>
        <span class="s1">end: loc.end</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(length != </span><span class="s0">null</span><span class="s1">) {</span>
        <span class="s1">newLoc.end = advancePositionWithClone(loc.start</span><span class="s0">, </span><span class="s1">loc.source</span><span class="s0">, </span><span class="s1">offset + length)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">newLoc</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">advancePositionWithClone(pos</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters = source.length) {</span>
    <span class="s0">return </span><span class="s1">advancePositionWithMutation(extend({}</span><span class="s0">, </span><span class="s1">pos)</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s3">// advance by mutation without cloning (for performance reasons), since this</span>
<span class="s3">// gets called a lot in the parser</span>
<span class="s0">function </span><span class="s1">advancePositionWithMutation(pos</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters = source.length) {</span>
    <span class="s0">let </span><span class="s1">linesCount = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">lastNewLinePos = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; numberOfCharacters</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">if </span><span class="s1">(source.charCodeAt(i) === </span><span class="s4">10 </span><span class="s3">/* newline char code */</span><span class="s1">) {</span>
            <span class="s1">linesCount++</span><span class="s0">;</span>
            <span class="s1">lastNewLinePos = i</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pos.offset += numberOfCharacters</span><span class="s0">;</span>
    <span class="s1">pos.line += linesCount</span><span class="s0">;</span>
    <span class="s1">pos.column =</span>
        <span class="s1">lastNewLinePos === -</span><span class="s4">1</span>
            <span class="s1">? pos.column + numberOfCharacters</span>
            <span class="s1">: numberOfCharacters - lastNewLinePos</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">assert(condition</span><span class="s0">, </span><span class="s1">msg) {</span>
    <span class="s3">/* istanbul ignore if */</span>
    <span class="s0">if </span><span class="s1">(!condition) {</span>
        <span class="s0">throw new </span><span class="s1">Error(msg || </span><span class="s2">`unexpected compiler condition`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">findDir(node</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">allowEmpty = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(allowEmpty || p.exp) &amp;&amp;</span>
            <span class="s1">(isString(name) ? p.name === name : name.test(p.name))) {</span>
            <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">findProp(node</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">dynamicOnly = </span><span class="s0">false, </span><span class="s1">allowEmpty = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(dynamicOnly)</span>
                <span class="s0">continue;</span>
            <span class="s0">if </span><span class="s1">(p.name === name &amp;&amp; (p.value || allowEmpty)) {</span>
                <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(p.exp || allowEmpty) &amp;&amp;</span>
            <span class="s1">isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s1">name)) {</span>
            <span class="s0">return </span><span class="s1">p</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isStaticArgOf(arg</span><span class="s0">, </span><span class="s1">name) {</span>
    <span class="s0">return </span><span class="s1">!!(arg &amp;&amp; isStaticExp(arg) &amp;&amp; arg.content === name)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">hasDynamicKeyVBind(node) {</span>
    <span class="s0">return </span><span class="s1">node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(!p.arg || </span><span class="s3">// v-bind=&quot;obj&quot;</span>
            <span class="s1">p.arg.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">|| </span><span class="s3">// v-bind:[_ctx.foo]</span>
            <span class="s1">!p.arg.isStatic) </span><span class="s3">// v-bind:[foo]</span>
    <span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isText$1(node) {</span>
    <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s1">|| node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isVSlot(p) {</span>
    <span class="s0">return </span><span class="s1">p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'slot'</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isTemplateNode(node) {</span>
    <span class="s0">return </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSlotOutlet(node) {</span>
    <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getVNodeHelper(ssr</span><span class="s0">, </span><span class="s1">isComponent) {</span>
    <span class="s0">return </span><span class="s1">ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getVNodeBlockHelper(ssr</span><span class="s0">, </span><span class="s1">isComponent) {</span>
    <span class="s0">return </span><span class="s1">ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">propsHelperSet = </span><span class="s0">new </span><span class="s1">Set([NORMALIZE_PROPS</span><span class="s0">, </span><span class="s1">GUARD_REACTIVE_PROPS])</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">getUnnormalizedProps(props</span><span class="s0">, </span><span class="s1">callPath = []) {</span>
    <span class="s0">if </span><span class="s1">(props &amp;&amp;</span>
        <span class="s1">!isString(props) &amp;&amp;</span>
        <span class="s1">props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">callee = props.callee</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!isString(callee) &amp;&amp; propsHelperSet.has(callee)) {</span>
            <span class="s0">return </span><span class="s1">getUnnormalizedProps(props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">callPath.concat(props))</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">[props</span><span class="s0">, </span><span class="s1">callPath]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">injectProp(node</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">let </span><span class="s1">propsWithInjection</span><span class="s0">;</span>
    <span class="s5">/**</span>
     <span class="s5">* 1. mergeProps(...)</span>
     <span class="s5">* 2. toHandlers(...)</span>
     <span class="s5">* 3. normalizeProps(...)</span>
     <span class="s5">* 4. normalizeProps(guardReactiveProps(...))</span>
     <span class="s5">*</span>
     <span class="s5">* we need to get the real props before normalization</span>
     <span class="s5">*/</span>
    <span class="s0">let </span><span class="s1">props = node.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */ </span><span class="s1">? node.props : node.arguments[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">callPath = []</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">parentCall</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(props &amp;&amp;</span>
        <span class="s1">!isString(props) &amp;&amp;</span>
        <span class="s1">props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">ret = getUnnormalizedProps(props)</span><span class="s0">;</span>
        <span class="s1">props = ret[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s1">callPath = ret[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(props == </span><span class="s0">null </span><span class="s1">|| isString(props)) {</span>
        <span class="s1">propsWithInjection = createObjectExpression([prop])</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(props.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s3">// merged props... add ours</span>
        <span class="s3">// only inject key to object literal if it's the first argument so that</span>
        <span class="s3">// if doesn't override user provided keys</span>
        <span class="s0">const </span><span class="s1">first = props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!isString(first) &amp;&amp; first.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s3">// #6631</span>
            <span class="s0">if </span><span class="s1">(!hasProp(prop</span><span class="s0">, </span><span class="s1">first)) {</span>
                <span class="s1">first.properties.unshift(prop)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(props.callee === TO_HANDLERS) {</span>
                <span class="s3">// #2366</span>
                <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">createObjectExpression([prop])</span><span class="s0">,</span>
                    <span class="s1">props</span>
                <span class="s1">])</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">props.arguments.unshift(createObjectExpression([prop]))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">!propsWithInjection &amp;&amp; (propsWithInjection = props)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(props.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(!hasProp(prop</span><span class="s0">, </span><span class="s1">props)) {</span>
            <span class="s1">props.properties.unshift(prop)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">propsWithInjection = props</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// single v-bind with expression, return a merged replacement</span>
        <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">createObjectExpression([prop])</span><span class="s0">,</span>
            <span class="s1">props</span>
        <span class="s1">])</span><span class="s0">;</span>
        <span class="s3">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
        <span class="s3">// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
        <span class="s3">// the `guardReactiveProps` will no longer be needed</span>
        <span class="s0">if </span><span class="s1">(parentCall &amp;&amp; parentCall.callee === GUARD_REACTIVE_PROPS) {</span>
            <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(parentCall) {</span>
            <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">node.props = propsWithInjection</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(parentCall) {</span>
            <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">node.arguments[</span><span class="s4">2</span><span class="s1">] = propsWithInjection</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">// check existing key to avoid overriding user provided keys</span>
<span class="s0">function </span><span class="s1">hasProp(prop</span><span class="s0">, </span><span class="s1">props) {</span>
    <span class="s0">let </span><span class="s1">result = </span><span class="s0">false;</span>
    <span class="s0">if </span><span class="s1">(prop.key.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">propKeyName = prop.key.content</span><span class="s0">;</span>
        <span class="s1">result = props.properties.some(p =&gt; p.key.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">p.key.content === propKeyName)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">toValidAssetId(name</span><span class="s0">, </span><span class="s1">type) {</span>
    <span class="s3">// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
    <span class="s0">return </span><span class="s2">`_</span><span class="s1">${type}</span><span class="s2">_</span><span class="s1">${name.replace(</span><span class="s4">/[^\w]/g</span><span class="s0">, </span><span class="s1">(searchValue</span><span class="s0">, </span><span class="s1">replaceValue) =&gt; {</span>
        <span class="s0">return </span><span class="s1">searchValue === </span><span class="s2">'-' </span><span class="s1">? </span><span class="s2">'_' </span><span class="s1">: name.charCodeAt(replaceValue).toString()</span><span class="s0">;</span>
    <span class="s1">})}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s3">// Check if a node contains expressions that reference current context scope ids</span>
<span class="s0">function </span><span class="s1">hasScopeRef(node</span><span class="s0">, </span><span class="s1">ids) {</span>
    <span class="s0">if </span><span class="s1">(!node || Object.keys(ids).length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">return false;</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(node.type) {</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">(hasScopeRef(p.arg</span><span class="s0">, </span><span class="s1">ids) || hasScopeRef(p.exp</span><span class="s0">, </span><span class="s1">ids))) {</span>
                    <span class="s0">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(hasScopeRef(node.source</span><span class="s0">, </span><span class="s1">ids)) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">node.branches.some(b =&gt; hasScopeRef(b</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(hasScopeRef(node.condition</span><span class="s0">, </span><span class="s1">ids)) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">node.children.some(c =&gt; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(!node.isStatic &amp;&amp;</span>
                <span class="s1">isSimpleIdentifier(node.content) &amp;&amp;</span>
                <span class="s1">!!ids[node.content])</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">node.children.some(c =&gt; isObject(c) &amp;&amp; hasScopeRef(c</span><span class="s0">, </span><span class="s1">ids))</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">hasScopeRef(node.content</span><span class="s0">, </span><span class="s1">ids)</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s0">return false;</span>
        <span class="s0">default</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) </span><span class="s0">;</span>
            <span class="s0">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getMemoedVNodeCall(node) {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp; node.callee === WITH_MEMO) {</span>
        <span class="s0">return </span><span class="s1">node.arguments[</span><span class="s4">1</span><span class="s1">].returns</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">makeBlock(node</span><span class="s0">, </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">removeHelper</span><span class="s0">, </span><span class="s1">inSSR }) {</span>
    <span class="s0">if </span><span class="s1">(!node.isBlock) {</span>
        <span class="s1">node.isBlock = </span><span class="s0">true;</span>
        <span class="s1">removeHelper(getVNodeHelper(inSSR</span><span class="s0">, </span><span class="s1">node.isComponent))</span><span class="s0">;</span>
        <span class="s1">helper(OPEN_BLOCK)</span><span class="s0">;</span>
        <span class="s1">helper(getVNodeBlockHelper(inSSR</span><span class="s0">, </span><span class="s1">node.isComponent))</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">deprecationData = {</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`Platform-native elements with &quot;is&quot; prop will no longer be ` </span><span class="s1">+</span>
            <span class="s2">`treated as components in Vue 3 unless the &quot;is&quot; value is explicitly ` </span><span class="s1">+</span>
            <span class="s2">`prefixed with &quot;vue:&quot;.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s1">]: {</span>
        <span class="s1">message: key =&gt; </span><span class="s2">`.sync modifier for v-bind has been removed. Use v-model with ` </span><span class="s1">+</span>
            <span class="s2">`argument instead. </span><span class="s0">\`</span><span class="s2">v-bind:</span><span class="s1">${key}</span><span class="s2">.sync</span><span class="s0">\` </span><span class="s2">should be changed to ` </span><span class="s1">+</span>
            <span class="s2">`</span><span class="s0">\`</span><span class="s2">v-model:</span><span class="s1">${key}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-model.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`.prop modifier for v-bind has been removed and no longer necessary. ` </span><span class="s1">+</span>
            <span class="s2">`Vue 3 will automatically set a binding as DOM property when appropriate.`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`v-bind=&quot;obj&quot; usage is now order sensitive and behaves like JavaScript ` </span><span class="s1">+</span>
            <span class="s2">`object spread: it will now overwrite an existing non-mergeable attribute ` </span><span class="s1">+</span>
            <span class="s2">`that appears before v-bind in the case of conflict. ` </span><span class="s1">+</span>
            <span class="s2">`To retain 2.x behavior, move v-bind to make it the first attribute. ` </span><span class="s1">+</span>
            <span class="s2">`You can also suppress this warning if the usage is intended.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-bind.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_V_ON_NATIVE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`.native modifier for v-on has been removed as is no longer necessary.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`v-if / v-for precedence when used on the same element has changed ` </span><span class="s1">+</span>
            <span class="s2">`in Vue 3: v-if now takes higher precedence and will no longer have ` </span><span class="s1">+</span>
            <span class="s2">`access to v-for scope variables. It is best to avoid the ambiguity ` </span><span class="s1">+</span>
            <span class="s2">`with &lt;template&gt; tags or use a computed property that filters v-for ` </span><span class="s1">+</span>
            <span class="s2">`data source.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`&lt;template&gt; with no special directives will render as a native template ` </span><span class="s1">+</span>
            <span class="s2">`element instead of its inner content in Vue 3.`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`&quot;inline-template&quot; has been removed in Vue 3.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">[</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s2">`filters have been removed in Vue 3. ` </span><span class="s1">+</span>
            <span class="s2">`The &quot;|&quot; symbol will be treated as native JavaScript bitwise OR operator. ` </span><span class="s1">+</span>
            <span class="s2">`Use method calls or computed properties instead.`</span><span class="s0">,</span>
        <span class="s1">link: </span><span class="s2">`https://v3-migration.vuejs.org/breaking-changes/filters.html`</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">getCompatValue(key</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">config = context.options</span>
        <span class="s1">? context.options.compatConfig</span>
        <span class="s1">: context.compatConfig</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">value = config &amp;&amp; config[key]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(key === </span><span class="s2">'MODE'</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">value || </span><span class="s4">3</span><span class="s0">; </span><span class="s3">// compiler defaults to v3 behavior</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">value</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isCompatEnabled(key</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">mode = getCompatValue(</span><span class="s2">'MODE'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">value = getCompatValue(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s3">// in v3 mode, only enable if explicitly set to true</span>
    <span class="s3">// otherwise enable for any non-false value</span>
    <span class="s0">return </span><span class="s1">mode === </span><span class="s4">3 </span><span class="s1">? value === </span><span class="s0">true </span><span class="s1">: value !== </span><span class="s0">false;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">checkCompatEnabled(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args) {</span>
    <span class="s0">const </span><span class="s1">enabled = isCompatEnabled(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; enabled) {</span>
        <span class="s1">warnDeprecation(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">enabled</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">warnDeprecation(key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">...args) {</span>
    <span class="s0">const </span><span class="s1">val = getCompatValue(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(val === </span><span class="s2">'suppress-warning'</span><span class="s1">) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">{ message</span><span class="s0">, </span><span class="s1">link } = deprecationData[key]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">msg = </span><span class="s2">`(deprecation </span><span class="s1">${key}</span><span class="s2">) </span><span class="s1">${</span><span class="s0">typeof </span><span class="s1">message === </span><span class="s2">'function' </span><span class="s1">? message(...args) : message}${link ? </span><span class="s2">`</span><span class="s0">\n  </span><span class="s2">Details: </span><span class="s1">${link}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">SyntaxError(msg)</span><span class="s0">;</span>
    <span class="s1">err.code = key</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(loc)</span>
        <span class="s1">err.loc = loc</span><span class="s0">;</span>
    <span class="s1">context.onWarn(err)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s3">// The default decoder only provides escapes for characters reserved as part of</span>
<span class="s3">// the template syntax, and is only used if the custom renderer did not provide</span>
<span class="s3">// a platform-specific decoder.</span>
<span class="s0">const </span><span class="s1">decodeRE = </span><span class="s4">/&amp;(gt|lt|amp|apos|quot);/g</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">decodeMap = {</span>
    <span class="s1">gt: </span><span class="s2">'&gt;'</span><span class="s0">,</span>
    <span class="s1">lt: </span><span class="s2">'&lt;'</span><span class="s0">,</span>
    <span class="s1">amp: </span><span class="s2">'&amp;'</span><span class="s0">,</span>
    <span class="s1">apos: </span><span class="s2">&quot;'&quot;</span><span class="s0">,</span>
    <span class="s1">quot: </span><span class="s2">'&quot;'</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">defaultParserOptions = {</span>
    <span class="s1">delimiters: [</span><span class="s2">`{{`</span><span class="s0">, </span><span class="s2">`}}`</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">getNamespace: () =&gt; </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s0">,</span>
    <span class="s1">getTextMode: () =&gt; </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s0">,</span>
    <span class="s1">isVoidTag: NO</span><span class="s0">,</span>
    <span class="s1">isPreTag: NO</span><span class="s0">,</span>
    <span class="s1">isCustomElement: NO</span><span class="s0">,</span>
    <span class="s1">decodeEntities: (rawText) =&gt; rawText.replace(decodeRE</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">p1) =&gt; decodeMap[p1])</span><span class="s0">,</span>
    <span class="s1">onError: defaultOnError</span><span class="s0">,</span>
    <span class="s1">onWarn: defaultOnWarn</span><span class="s0">,</span>
    <span class="s1">comments: (process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">baseParse(content</span><span class="s0">, </span><span class="s1">options = {}) {</span>
    <span class="s0">const </span><span class="s1">context = createParserContext(content</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">createRoot(parseChildren(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">, </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createParserContext(content</span><span class="s0">, </span><span class="s1">rawOptions) {</span>
    <span class="s0">const </span><span class="s1">options = extend({}</span><span class="s0">, </span><span class="s1">defaultParserOptions)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">key</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(key </span><span class="s0">in </span><span class="s1">rawOptions) {</span>
        <span class="s3">// @ts-ignore</span>
        <span class="s1">options[key] =</span>
            <span class="s1">rawOptions[key] === undefined</span>
                <span class="s1">? defaultParserOptions[key]</span>
                <span class="s1">: rawOptions[key]</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">options</span><span class="s0">,</span>
        <span class="s1">column: </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">line: </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">offset: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">originalSource: content</span><span class="s0">,</span>
        <span class="s1">source: content</span><span class="s0">,</span>
        <span class="s1">inPre: </span><span class="s0">false,</span>
        <span class="s1">inVPre: </span><span class="s0">false,</span>
        <span class="s1">onWarn: options.onWarn</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseChildren(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors) {</span>
    <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">nodes = []</span><span class="s0">;</span>
    <span class="s0">while </span><span class="s1">(!isEnd(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors)) {</span>
        <span class="s0">const </span><span class="s1">s = context.source</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">node = undefined</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */ </span><span class="s1">|| mode === </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(s</span><span class="s0">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s3">// '{{'</span>
                <span class="s1">node = parseInterpolation(context</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */ </span><span class="s1">&amp;&amp; s[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'&lt;'</span><span class="s1">) {</span>
                <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state</span>
                <span class="s0">if </span><span class="s1">(s.length === </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'!'</span><span class="s1">) {</span>
                    <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state</span>
                    <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;!--'</span><span class="s1">)) {</span>
                        <span class="s1">node = parseComment(context)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;!DOCTYPE'</span><span class="s1">)) {</span>
                        <span class="s3">// Ignore DOCTYPE by a limitation.</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;![CDATA['</span><span class="s1">)) {</span>
                        <span class="s0">if </span><span class="s1">(ns !== </span><span class="s4">0 </span><span class="s3">/* Namespaces.HTML */</span><span class="s1">) {</span>
                            <span class="s1">node = parseCDATA(context</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s3">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">)</span><span class="s0">;</span>
                            <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">11 </span><span class="s3">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'/'</span><span class="s1">) {</span>
                    <span class="s3">// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state</span>
                    <span class="s0">if </span><span class="s1">(s.length === </span><span class="s4">2</span><span class="s1">) {</span>
                        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">5 </span><span class="s3">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">2</span><span class="s1">] === </span><span class="s2">'&gt;'</span><span class="s1">) {</span>
                        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">14 </span><span class="s3">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s0">continue;</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">2</span><span class="s1">])) {</span>
                        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">23 </span><span class="s3">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s1">parseTag(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
                        <span class="s0">continue;</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">1</span><span class="s1">])) {</span>
                    <span class="s1">node = parseElement(context</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
                    <span class="s3">// 2.x &lt;template&gt; with no directive compat</span>
                    <span class="s0">if </span><span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context) &amp;&amp;</span>
                        <span class="s1">node &amp;&amp;</span>
                        <span class="s1">node.tag === </span><span class="s2">'template' </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">!node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">isSpecialTemplateDirective(p.name))) {</span>
                        <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
                            <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
                        <span class="s1">node = node.children</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'?'</span><span class="s1">) {</span>
                    <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">21 </span><span class="s3">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">node = parseBogusComment(context)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">12 </span><span class="s3">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!node) {</span>
            <span class="s1">node = parseText(context</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isArray(node)) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node[i])</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// Whitespace handling strategy like v2</span>
    <span class="s0">let </span><span class="s1">removedWhitespace = </span><span class="s0">false;</span>
    <span class="s0">if </span><span class="s1">(mode !== </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */ </span><span class="s1">&amp;&amp; mode !== </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">shouldCondense = context.options.whitespace !== </span><span class="s2">'preserve'</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodes.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">node = nodes[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(!context.inPre) {</span>
                    <span class="s0">if </span><span class="s1">(!</span><span class="s4">/[^\t\r\n\f ]/</span><span class="s1">.test(node.content)) {</span>
                        <span class="s0">const </span><span class="s1">prev = nodes[i - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                        <span class="s0">const </span><span class="s1">next = nodes[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                        <span class="s3">// Remove if:</span>
                        <span class="s3">// - the whitespace is the first or last node, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between twos comments, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between comment and element, or:</span>
                        <span class="s3">// - (condense mode) the whitespace is between two elements AND contains newline</span>
                        <span class="s0">if </span><span class="s1">(!prev ||</span>
                            <span class="s1">!next ||</span>
                            <span class="s1">(shouldCondense &amp;&amp;</span>
                                <span class="s1">((prev.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                    <span class="s1">next.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s4">/[\r\n]/</span><span class="s1">.test(node.content))))) {</span>
                            <span class="s1">removedWhitespace = </span><span class="s0">true;</span>
                            <span class="s1">nodes[i] = </span><span class="s0">null;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s3">// Otherwise, the whitespace is condensed into a single space</span>
                            <span class="s1">node.content = </span><span class="s2">' '</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(shouldCondense) {</span>
                        <span class="s3">// in condense mode, consecutive whitespaces in text are condensed</span>
                        <span class="s3">// down to a single space.</span>
                        <span class="s1">node.content = node.content.replace(</span><span class="s4">/[\t\r\n\f ]+/g</span><span class="s0">, </span><span class="s2">' '</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s3">// #6410 normalize windows newlines in &lt;pre&gt;:</span>
                    <span class="s3">// in SSR, browsers normalize server-rendered \r\n into a single \n</span>
                    <span class="s3">// in the DOM</span>
                    <span class="s1">node.content = node.content.replace(</span><span class="s4">/\r\n/g</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Remove comment nodes if desired by configuration.</span>
            <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp; !context.options.comments) {</span>
                <span class="s1">removedWhitespace = </span><span class="s0">true;</span>
                <span class="s1">nodes[i] = </span><span class="s0">null;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(context.inPre &amp;&amp; parent &amp;&amp; context.options.isPreTag(parent.tag)) {</span>
            <span class="s3">// remove leading newline per html spec</span>
            <span class="s3">// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element</span>
            <span class="s0">const </span><span class="s1">first = nodes[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(first &amp;&amp; first.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                <span class="s1">first.content = first.content.replace(</span><span class="s4">/^\r?\n/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">removedWhitespace ? nodes.filter(Boolean) : nodes</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">pushNode(nodes</span><span class="s0">, </span><span class="s1">node) {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">prev = last(nodes)</span><span class="s0">;</span>
        <span class="s3">// Merge if both this and the previous node are text and those are</span>
        <span class="s3">// consecutive. This happens for cases like &quot;a &lt; b&quot;.</span>
        <span class="s0">if </span><span class="s1">(prev &amp;&amp;</span>
            <span class="s1">prev.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">prev.loc.end.offset === node.loc.start.offset) {</span>
            <span class="s1">prev.content += node.content</span><span class="s0">;</span>
            <span class="s1">prev.loc.end = node.loc.end</span><span class="s0">;</span>
            <span class="s1">prev.loc.source += node.loc.source</span><span class="s0">;</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">nodes.push(node)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseCDATA(context</span><span class="s0">, </span><span class="s1">ancestors) {</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">9</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">nodes = parseChildren(context</span><span class="s0">, </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">6 </span><span class="s3">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">nodes</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseComment(context) {</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
    <span class="s3">// Regular comment.</span>
    <span class="s0">const </span><span class="s1">match = </span><span class="s4">/--(\!)?&gt;/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!match) {</span>
        <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">context.source.length)</span><span class="s0">;</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">7 </span><span class="s3">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(match.index &lt;= </span><span class="s4">3</span><span class="s1">) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(match[</span><span class="s4">1</span><span class="s1">]) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">10 </span><span class="s3">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s0">, </span><span class="s1">match.index)</span><span class="s0">;</span>
        <span class="s3">// Advancing with reporting nested comments.</span>
        <span class="s0">const </span><span class="s1">s = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">match.index)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">prevIndex = </span><span class="s4">1</span><span class="s0">, </span><span class="s1">nestedIndex = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">((nestedIndex = s.indexOf(</span><span class="s2">'&lt;!--'</span><span class="s0">, </span><span class="s1">prevIndex)) !== -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">nestedIndex - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(nestedIndex + </span><span class="s4">4 </span><span class="s1">&lt; s.length) {</span>
                <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">16 </span><span class="s3">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">prevIndex = nestedIndex + </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match.index + match[</span><span class="s4">0</span><span class="s1">].length - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s0">,</span>
        <span class="s1">content</span><span class="s0">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseBogusComment(context) {</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">contentStart = context.source[</span><span class="s4">1</span><span class="s1">] === </span><span class="s2">'?' </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">closeIndex = context.source.indexOf(</span><span class="s2">'&gt;'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">content = context.source.slice(contentStart)</span><span class="s0">;</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">context.source.length)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">content = context.source.slice(contentStart</span><span class="s0">, </span><span class="s1">closeIndex)</span><span class="s0">;</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">closeIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s0">,</span>
        <span class="s1">content</span><span class="s0">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseElement(context</span><span class="s0">, </span><span class="s1">ancestors) {</span>
    <span class="s3">// Start tag.</span>
    <span class="s0">const </span><span class="s1">wasInPre = context.inPre</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">wasInVPre = context.inVPre</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">element = parseTag(context</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* TagType.Start */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isPreBoundary = context.inPre &amp;&amp; !wasInPre</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(element.isSelfClosing || context.options.isVoidTag(element.tag)) {</span>
        <span class="s3">// #4030 self-closing &lt;pre&gt; tag</span>
        <span class="s0">if </span><span class="s1">(isPreBoundary) {</span>
            <span class="s1">context.inPre = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isVPreBoundary) {</span>
            <span class="s1">context.inVPre = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">element</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// Children.</span>
    <span class="s1">ancestors.push(element)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">mode = context.options.getTextMode(element</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">children = parseChildren(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors)</span><span class="s0">;</span>
    <span class="s1">ancestors.pop()</span><span class="s0">;</span>
    <span class="s3">// 2.x inline-template compat</span>
    <span class="s1">{</span>
        <span class="s0">const </span><span class="s1">inlineTemplateProp = element.props.find(p =&gt; p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'inline-template'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(inlineTemplateProp &amp;&amp;</span>
            <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">inlineTemplateProp.loc)) {</span>
            <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">element.loc.end)</span><span class="s0">;</span>
            <span class="s1">inlineTemplateProp.value = {</span>
                <span class="s1">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s0">,</span>
                <span class="s1">content: loc.source</span><span class="s0">,</span>
                <span class="s1">loc</span>
            <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">element.children = children</span><span class="s0">;</span>
    <span class="s3">// End tag.</span>
    <span class="s0">if </span><span class="s1">(startsWithEndTagOpen(context.source</span><span class="s0">, </span><span class="s1">element.tag)) {</span>
        <span class="s1">parseTag(context</span><span class="s0">, </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">24 </span><span class="s3">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">element.loc.start)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; element.tag.toLowerCase() === </span><span class="s2">'script'</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">first = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(first &amp;&amp; startsWith(first.loc.source</span><span class="s0">, </span><span class="s2">'&lt;!--'</span><span class="s1">)) {</span>
                <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">8 </span><span class="s3">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">element.loc = getSelection(context</span><span class="s0">, </span><span class="s1">element.loc.start)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isPreBoundary) {</span>
        <span class="s1">context.inPre = </span><span class="s0">false;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isVPreBoundary) {</span>
        <span class="s1">context.inVPre = </span><span class="s0">false;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">element</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">isSpecialTemplateDirective = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s2">`if,else,else-if,for,slot`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">parseTag(context</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">parent) {</span>
    <span class="s3">// Tag open.</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">tag = match[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">ns = context.options.getNamespace(tag</span><span class="s0">, </span><span class="s1">parent)</span><span class="s0">;</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s0">;</span>
    <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
    <span class="s3">// save current state in case we need to re-parse attributes with v-pre</span>
    <span class="s0">const </span><span class="s1">cursor = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">currentSource = context.source</span><span class="s0">;</span>
    <span class="s3">// check &lt;pre&gt; tag</span>
    <span class="s0">if </span><span class="s1">(context.options.isPreTag(tag)) {</span>
        <span class="s1">context.inPre = </span><span class="s0">true;</span>
    <span class="s1">}</span>
    <span class="s3">// Attributes.</span>
    <span class="s0">let </span><span class="s1">props = parseAttributes(context</span><span class="s0">, </span><span class="s1">type)</span><span class="s0">;</span>
    <span class="s3">// check v-pre</span>
    <span class="s0">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s3">/* TagType.Start */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!context.inVPre &amp;&amp;</span>
        <span class="s1">props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'pre'</span><span class="s1">)) {</span>
        <span class="s1">context.inVPre = </span><span class="s0">true;</span>
        <span class="s3">// reset context</span>
        <span class="s1">extend(context</span><span class="s0">, </span><span class="s1">cursor)</span><span class="s0">;</span>
        <span class="s1">context.source = currentSource</span><span class="s0">;</span>
        <span class="s3">// re-parse attrs and filter out v-pre itself</span>
        <span class="s1">props = parseAttributes(context</span><span class="s0">, </span><span class="s1">type).filter(p =&gt; p.name !== </span><span class="s2">'v-pre'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// Tag close.</span>
    <span class="s0">let </span><span class="s1">isSelfClosing = </span><span class="s0">false;</span>
    <span class="s0">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">9 </span><span class="s3">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">isSelfClosing = startsWith(context.source</span><span class="s0">, </span><span class="s2">'/&gt;'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */ </span><span class="s1">&amp;&amp; isSelfClosing) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">4 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">isSelfClosing ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s1">) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s3">// 2.x deprecation checks</span>
    <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">isCompatEnabled(</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s0">, </span><span class="s1">context)) {</span>
        <span class="s0">let </span><span class="s1">hasIf = </span><span class="s0">false;</span>
        <span class="s0">let </span><span class="s1">hasFor = </span><span class="s0">false;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">p = props[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'if'</span><span class="s1">) {</span>
                    <span class="s1">hasIf = </span><span class="s0">true;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(p.name === </span><span class="s2">'for'</span><span class="s1">) {</span>
                    <span class="s1">hasFor = </span><span class="s0">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(hasIf &amp;&amp; hasFor) {</span>
                <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start))</span><span class="s0">;</span>
                <span class="s0">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">tagType = </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!context.inVPre) {</span>
        <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'slot'</span><span class="s1">) {</span>
            <span class="s1">tagType = </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(tag === </span><span class="s2">'template'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; isSpecialTemplateDirective(p.name))) {</span>
                <span class="s1">tagType = </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(isComponent(tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">context)) {</span>
            <span class="s1">tagType = </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s0">,</span>
        <span class="s1">ns</span><span class="s0">,</span>
        <span class="s1">tag</span><span class="s0">,</span>
        <span class="s1">tagType</span><span class="s0">,</span>
        <span class="s1">props</span><span class="s0">,</span>
        <span class="s1">isSelfClosing</span><span class="s0">,</span>
        <span class="s1">children: []</span><span class="s0">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">,</span>
        <span class="s1">codegenNode: undefined </span><span class="s3">// to be created during transform phase</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isComponent(tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">options = context.options</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(options.isCustomElement(tag)) {</span>
        <span class="s0">return false;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(tag === </span><span class="s2">'component' </span><span class="s1">||</span>
        <span class="s4">/^[A-Z]/</span><span class="s1">.test(tag) ||</span>
        <span class="s1">isCoreComponent(tag) ||</span>
        <span class="s1">(options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) ||</span>
        <span class="s1">(options.isNativeTag &amp;&amp; !options.isNativeTag(tag))) {</span>
        <span class="s0">return true;</span>
    <span class="s1">}</span>
    <span class="s3">// at this point the tag should be a native tag, but check for potential &quot;is&quot;</span>
    <span class="s3">// casting</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">p = props[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'is' </span><span class="s1">&amp;&amp; p.value) {</span>
                <span class="s0">if </span><span class="s1">(p.value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
                    <span class="s0">return true;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(checkCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">p.loc)) {</span>
                    <span class="s0">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// directive</span>
            <span class="s3">// v-is (TODO Deprecate)</span>
            <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'is'</span><span class="s1">) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(</span>
            <span class="s3">// :is on plain element - only treat as component in compat mode</span>
            <span class="s1">p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">) &amp;&amp;</span>
                <span class="s0">true </span><span class="s1">&amp;&amp;</span>
                <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">p.loc)) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseAttributes(context</span><span class="s0">, </span><span class="s1">type) {</span>
    <span class="s0">const </span><span class="s1">props = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">attributeNames = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
    <span class="s0">while </span><span class="s1">(context.source.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!startsWith(context.source</span><span class="s0">, </span><span class="s2">'&gt;'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">!startsWith(context.source</span><span class="s0">, </span><span class="s2">'/&gt;'</span><span class="s1">)) {</span>
        <span class="s0">if </span><span class="s1">(startsWith(context.source</span><span class="s0">, </span><span class="s2">'/'</span><span class="s1">)) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">22 </span><span class="s3">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
            <span class="s0">continue;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s3">/* TagType.End */</span><span class="s1">) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">3 </span><span class="s3">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">attr = parseAttribute(context</span><span class="s0">, </span><span class="s1">attributeNames)</span><span class="s0">;</span>
        <span class="s3">// Trim whitespace between class</span>
        <span class="s3">// https://github.com/vuejs/core/issues/4251</span>
        <span class="s0">if </span><span class="s1">(attr.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">attr.value &amp;&amp;</span>
            <span class="s1">attr.name === </span><span class="s2">'class'</span><span class="s1">) {</span>
            <span class="s1">attr.value.content = attr.value.content.replace(</span><span class="s4">/\s+/g</span><span class="s0">, </span><span class="s2">' '</span><span class="s1">).trim()</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s3">/* TagType.Start */</span><span class="s1">) {</span>
            <span class="s1">props.push(attr)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s4">/^[^\t\r\n\f /&gt;]/</span><span class="s1">.test(context.source)) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">15 </span><span class="s3">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">props</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseAttribute(context</span><span class="s0">, </span><span class="s1">nameSet) {</span>
    <span class="s3">// Name.</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">name = match[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(nameSet.has(name)) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">2 </span><span class="s3">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">nameSet.add(name)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'='</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">19 </span><span class="s3">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s0">const </span><span class="s1">pattern = </span><span class="s4">/[&quot;'&lt;]/g</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">m</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">((m = pattern.exec(name))) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">17 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s0">, </span><span class="s1">m.index)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">name.length)</span><span class="s0">;</span>
    <span class="s3">// Value</span>
    <span class="s0">let </span><span class="s1">value = undefined</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s4">/^[\t\r\n\f ]*=/</span><span class="s1">.test(context.source)) {</span>
        <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">advanceSpaces(context)</span><span class="s0">;</span>
        <span class="s1">value = parseAttributeValue(context)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!value) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">13 </span><span class="s3">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; </span><span class="s4">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span><span class="s1">.test(name)) {</span>
        <span class="s0">const </span><span class="s1">match = </span><span class="s4">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i</span><span class="s1">.exec(name)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">isPropShorthand = startsWith(name</span><span class="s0">, </span><span class="s2">'.'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">dirName = match[</span><span class="s4">1</span><span class="s1">] ||</span>
            <span class="s1">(isPropShorthand || startsWith(name</span><span class="s0">, </span><span class="s2">':'</span><span class="s1">)</span>
                <span class="s1">? </span><span class="s2">'bind'</span>
                <span class="s1">: startsWith(name</span><span class="s0">, </span><span class="s2">'@'</span><span class="s1">)</span>
                    <span class="s1">? </span><span class="s2">'on'</span>
                    <span class="s1">: </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">arg</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(match[</span><span class="s4">2</span><span class="s1">]) {</span>
            <span class="s0">const </span><span class="s1">isSlot = dirName === </span><span class="s2">'slot'</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">startOffset = name.lastIndexOf(match[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">loc = getSelection(context</span><span class="s0">, </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">startOffset)</span><span class="s0">, </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">startOffset + match[</span><span class="s4">2</span><span class="s1">].length + ((isSlot &amp;&amp; match[</span><span class="s4">3</span><span class="s1">]) || </span><span class="s2">''</span><span class="s1">).length))</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">content = match[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">isStatic = </span><span class="s0">true;</span>
            <span class="s0">if </span><span class="s1">(content.startsWith(</span><span class="s2">'['</span><span class="s1">)) {</span>
                <span class="s1">isStatic = </span><span class="s0">false;</span>
                <span class="s0">if </span><span class="s1">(!content.endsWith(</span><span class="s2">']'</span><span class="s1">)) {</span>
                    <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">27 </span><span class="s3">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">content.length - </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(isSlot) {</span>
                <span class="s3">// #1241 special case for v-slot: vuetify relies extensively on slot</span>
                <span class="s3">// names containing dots. v-slot doesn't have any modifiers and Vue 2.x</span>
                <span class="s3">// supports such usage so we are keeping it consistent with 2.x.</span>
                <span class="s1">content += match[</span><span class="s4">3</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">arg = {</span>
                <span class="s1">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
                <span class="s1">content</span><span class="s0">,</span>
                <span class="s1">isStatic</span><span class="s0">,</span>
                <span class="s1">constType: isStatic</span>
                    <span class="s1">? </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span>
                    <span class="s1">: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
                <span class="s1">loc</span>
            <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(value &amp;&amp; value.isQuoted) {</span>
            <span class="s0">const </span><span class="s1">valueLoc = value.loc</span><span class="s0">;</span>
            <span class="s1">valueLoc.start.offset++</span><span class="s0">;</span>
            <span class="s1">valueLoc.start.column++</span><span class="s0">;</span>
            <span class="s1">valueLoc.end = advancePositionWithClone(valueLoc.start</span><span class="s0">, </span><span class="s1">value.content)</span><span class="s0">;</span>
            <span class="s1">valueLoc.source = valueLoc.source.slice(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">modifiers = match[</span><span class="s4">3</span><span class="s1">] ? match[</span><span class="s4">3</span><span class="s1">].slice(</span><span class="s4">1</span><span class="s1">).split(</span><span class="s2">'.'</span><span class="s1">) : []</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(isPropShorthand)</span>
            <span class="s1">modifiers.push(</span><span class="s2">'prop'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s3">// 2.x compat v-bind:foo.sync -&gt; v-model:foo</span>
        <span class="s0">if </span><span class="s1">(dirName === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; arg) {</span>
            <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'sync'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">arg.loc.source)) {</span>
                <span class="s1">dirName = </span><span class="s2">'model'</span><span class="s0">;</span>
                <span class="s1">modifiers.splice(modifiers.indexOf(</span><span class="s2">'sync'</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; modifiers.includes(</span><span class="s2">'prop'</span><span class="s1">)) {</span>
                <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">type: </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s0">,</span>
            <span class="s1">name: dirName</span><span class="s0">,</span>
            <span class="s1">exp: value &amp;&amp; {</span>
                <span class="s1">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
                <span class="s1">content: value.content</span><span class="s0">,</span>
                <span class="s1">isStatic: </span><span class="s0">false,</span>
                <span class="s3">// Treat as non-constant by default. This can be potentially set to</span>
                <span class="s3">// other values by `transformExpression` to make it eligible for hoisting.</span>
                <span class="s1">constType: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
                <span class="s1">loc: value.loc</span>
            <span class="s1">}</span><span class="s0">,</span>
            <span class="s1">arg</span><span class="s0">,</span>
            <span class="s1">modifiers</span><span class="s0">,</span>
            <span class="s1">loc</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// missing directive name or illegal directive name</span>
    <span class="s0">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(name</span><span class="s0">, </span><span class="s2">'v-'</span><span class="s1">)) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">26 </span><span class="s3">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s0">,</span>
        <span class="s1">name</span><span class="s0">,</span>
        <span class="s1">value: value &amp;&amp; {</span>
            <span class="s1">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s0">,</span>
            <span class="s1">content: value.content</span><span class="s0">,</span>
            <span class="s1">loc: value.loc</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseAttributeValue(context) {</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">content</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">quote = context.source[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isQuoted = quote === </span><span class="s2">`&quot;` </span><span class="s1">|| quote === </span><span class="s2">`'`</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isQuoted) {</span>
        <span class="s3">// Quoted value.</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">endIndex = context.source.indexOf(quote)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(endIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">context.source.length</span><span class="s0">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">endIndex</span><span class="s0">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// Unquoted</span>
        <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f &gt;]+/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!match) {</span>
            <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">unexpectedChars = </span><span class="s4">/[&quot;'&lt;=`]/g</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">m</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">((m = unexpectedChars.exec(match[</span><span class="s4">0</span><span class="s1">]))) {</span>
            <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">18 </span><span class="s3">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s0">, </span><span class="s1">m.index)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s0">, </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{ content</span><span class="s0">, </span><span class="s1">isQuoted</span><span class="s0">, </span><span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start) }</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseInterpolation(context</span><span class="s0">, </span><span class="s1">mode) {</span>
    <span class="s0">const </span><span class="s1">[open</span><span class="s0">, </span><span class="s1">close] = context.options.delimiters</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">closeIndex = context.source.indexOf(close</span><span class="s0">, </span><span class="s1">open.length)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s0">, </span><span class="s4">25 </span><span class="s3">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">open.length)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">innerStart = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">innerEnd = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">rawContentLength = closeIndex - open.length</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">rawContent = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">rawContentLength)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">preTrimContent = parseTextData(context</span><span class="s0">, </span><span class="s1">rawContentLength</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">content = preTrimContent.trim()</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">startOffset = preTrimContent.indexOf(content)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(startOffset &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">advancePositionWithMutation(innerStart</span><span class="s0">, </span><span class="s1">rawContent</span><span class="s0">, </span><span class="s1">startOffset)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</span><span class="s0">;</span>
    <span class="s1">advancePositionWithMutation(innerEnd</span><span class="s0">, </span><span class="s1">rawContent</span><span class="s0">, </span><span class="s1">endOffset)</span><span class="s0">;</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">close.length)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s0">,</span>
        <span class="s1">content: {</span>
            <span class="s1">type: </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s0">,</span>
            <span class="s1">isStatic: </span><span class="s0">false,</span>
            <span class="s3">// Set `isConstant` to false by default and will decide in transformExpression</span>
            <span class="s1">constType: </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">,</span>
            <span class="s1">content</span><span class="s0">,</span>
            <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">innerStart</span><span class="s0">, </span><span class="s1">innerEnd)</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseText(context</span><span class="s0">, </span><span class="s1">mode) {</span>
    <span class="s0">const </span><span class="s1">endTokens = mode === </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */ </span><span class="s1">? [</span><span class="s2">']]&gt;'</span><span class="s1">] : [</span><span class="s2">'&lt;'</span><span class="s0">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">endIndex = context.source.length</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; endTokens.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">index = context.source.indexOf(endTokens[i]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(index !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; endIndex &gt; index) {</span>
            <span class="s1">endIndex = index</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">start = getCursor(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">content = parseTextData(context</span><span class="s0">, </span><span class="s1">endIndex</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s0">,</span>
        <span class="s1">content</span><span class="s0">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s0">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* Get text data with a given length from the current location.</span>
 <span class="s5">* This translates HTML entities in the text data.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">parseTextData(context</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">mode) {</span>
    <span class="s0">const </span><span class="s1">rawText = context.source.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>
    <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(mode === </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */ </span><span class="s1">||</span>
        <span class="s1">mode === </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */ </span><span class="s1">||</span>
        <span class="s1">!rawText.includes(</span><span class="s2">'&amp;'</span><span class="s1">)) {</span>
        <span class="s0">return </span><span class="s1">rawText</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.</span>
        <span class="s0">return </span><span class="s1">context.options.decodeEntities(rawText</span><span class="s0">, </span><span class="s1">mode === </span><span class="s4">4 </span><span class="s3">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getCursor(context) {</span>
    <span class="s0">const </span><span class="s1">{ column</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">offset } = context</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{ column</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">offset }</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getSelection(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end) {</span>
    <span class="s1">end = end || getCursor(context)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">start</span><span class="s0">,</span>
        <span class="s1">end</span><span class="s0">,</span>
        <span class="s1">source: context.originalSource.slice(start.offset</span><span class="s0">, </span><span class="s1">end.offset)</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">last(xs) {</span>
    <span class="s0">return </span><span class="s1">xs[xs.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">startsWith(source</span><span class="s0">, </span><span class="s1">searchString) {</span>
    <span class="s0">return </span><span class="s1">source.startsWith(searchString)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">numberOfCharacters) {</span>
    <span class="s0">const </span><span class="s1">{ source } = context</span><span class="s0">;</span>
    <span class="s1">advancePositionWithMutation(context</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
    <span class="s1">context.source = source.slice(numberOfCharacters)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">advanceSpaces(context) {</span>
    <span class="s0">const </span><span class="s1">match = </span><span class="s4">/^[\t\r\n\f ]+/</span><span class="s1">.exec(context.source)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(match) {</span>
        <span class="s1">advanceBy(context</span><span class="s0">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getNewPosition(context</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">numberOfCharacters) {</span>
    <span class="s0">return </span><span class="s1">advancePositionWithClone(start</span><span class="s0">, </span><span class="s1">context.originalSource.slice(start.offset</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">, </span><span class="s1">numberOfCharacters)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">emitError(context</span><span class="s0">, </span><span class="s1">code</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">loc = getCursor(context)) {</span>
    <span class="s0">if </span><span class="s1">(offset) {</span>
        <span class="s1">loc.offset += offset</span><span class="s0">;</span>
        <span class="s1">loc.column += offset</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">context.options.onError(createCompilerError(code</span><span class="s0">, </span><span class="s1">{</span>
        <span class="s1">start: loc</span><span class="s0">,</span>
        <span class="s1">end: loc</span><span class="s0">,</span>
        <span class="s1">source: </span><span class="s2">''</span>
    <span class="s1">}))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isEnd(context</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">ancestors) {</span>
    <span class="s0">const </span><span class="s1">s = context.source</span><span class="s0">;</span>
    <span class="s0">switch </span><span class="s1">(mode) {</span>
        <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* TextModes.DATA */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">'&lt;/'</span><span class="s1">)) {</span>
                <span class="s3">// TODO: probably bad performance</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = ancestors.length - </span><span class="s4">1</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s0">; </span><span class="s1">--i) {</span>
                    <span class="s0">if </span><span class="s1">(startsWithEndTagOpen(s</span><span class="s0">, </span><span class="s1">ancestors[i].tag)) {</span>
                        <span class="s0">return true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* TextModes.RCDATA */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* TextModes.RAWTEXT */</span><span class="s1">: {</span>
            <span class="s0">const </span><span class="s1">parent = last(ancestors)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(parent &amp;&amp; startsWithEndTagOpen(s</span><span class="s0">, </span><span class="s1">parent.tag)) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* TextModes.CDATA */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(startsWith(s</span><span class="s0">, </span><span class="s2">']]&gt;'</span><span class="s1">)) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">!s</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">startsWithEndTagOpen(source</span><span class="s0">, </span><span class="s1">tag) {</span>
    <span class="s0">return </span><span class="s1">(startsWith(source</span><span class="s0">, </span><span class="s2">'&lt;/'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">source.slice(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2 </span><span class="s1">+ tag.length).toLowerCase() === tag.toLowerCase() &amp;&amp;</span>
        <span class="s4">/[\t\r\n\f /&gt;]/</span><span class="s1">.test(source[</span><span class="s4">2 </span><span class="s1">+ tag.length] || </span><span class="s2">'&gt;'</span><span class="s1">))</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">hoistStatic(root</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s1">walk(root</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
    <span class="s3">// Root node is unfortunately non-hoistable due to potential parent</span>
    <span class="s3">// fallthrough attributes.</span>
    <span class="s1">isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">root.children[</span><span class="s4">0</span><span class="s1">]))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">child) {</span>
    <span class="s0">const </span><span class="s1">{ children } = root</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isSlotOutlet(child))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">walk(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">doNotHoistNode = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">{ children } = node</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">originalCount = children.length</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">hoistedCount = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
        <span class="s3">// only plain elements &amp; text calls are eligible for hoisting.</span>
        <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">child.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">constantType = doNotHoistNode</span>
                <span class="s1">? </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span>
                <span class="s1">: getConstantType(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(constantType &gt; </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(constantType &gt;= </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                    <span class="s1">child.codegenNode.patchFlag =</span>
                        <span class="s1">-</span><span class="s4">1 </span><span class="s3">/* PatchFlags.HOISTED */ </span><span class="s1">+ ((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* HOISTED */` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">child.codegenNode = context.hoist(child.codegenNode)</span><span class="s0">;</span>
                    <span class="s1">hoistedCount++</span><span class="s0">;</span>
                    <span class="s0">continue;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s3">// node may contain dynamic children, but its props may be eligible for</span>
                <span class="s3">// hoisting.</span>
                <span class="s0">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                    <span class="s0">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">((!flag ||</span>
                        <span class="s1">flag === </span><span class="s4">512 </span><span class="s3">/* PatchFlags.NEED_PATCH */ </span><span class="s1">||</span>
                        <span class="s1">flag === </span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s1">) &amp;&amp;</span>
                        <span class="s1">getGeneratedPropsConstantType(child</span><span class="s0">, </span><span class="s1">context) &gt;=</span>
                            <span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                        <span class="s0">const </span><span class="s1">props = getNodeProps(child)</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(props) {</span>
                            <span class="s1">codegenNode.props = context.hoist(props)</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">if </span><span class="s1">(codegenNode.dynamicProps) {</span>
                        <span class="s1">codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// walk further</span>
        <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">isComponent = child.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(isComponent) {</span>
                <span class="s1">context.scopes.vSlot++</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">walk(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(isComponent) {</span>
                <span class="s1">context.scopes.vSlot--</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">) {</span>
            <span class="s3">// Do not hoist v-for single child because it has to be a block</span>
            <span class="s1">walk(child</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">child.children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; child.branches.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s3">// Do not hoist v-if single child because it has to be a block</span>
                <span class="s1">walk(child.branches[i]</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">child.branches[i].children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(hoistedCount &amp;&amp; context.transformHoist) {</span>
        <span class="s1">context.transformHoist(children</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// all children were hoisted - the entire children array is hoistable.</span>
    <span class="s0">if </span><span class="s1">(hoistedCount &amp;&amp;</span>
        <span class="s1">hoistedCount === originalCount &amp;&amp;</span>
        <span class="s1">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.codegenNode &amp;&amp;</span>
        <span class="s1">node.codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">isArray(node.codegenNode.children)) {</span>
        <span class="s1">node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children))</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getConstantType(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ constantCache } = context</span><span class="s0">;</span>
    <span class="s0">switch </span><span class="s1">(node.type) {</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(node.tagType !== </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">cached = constantCache.get(node)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(cached !== undefined) {</span>
                <span class="s0">return </span><span class="s1">cached</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(codegenNode.type !== </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(codegenNode.isBlock &amp;&amp;</span>
                <span class="s1">node.tag !== </span><span class="s2">'svg' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">node.tag !== </span><span class="s2">'foreignObject'</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(!flag) {</span>
                <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
                <span class="s3">// Element itself has no patch flag. However we still need to check:</span>
                <span class="s3">// 1. Even for a node with no patch flag, it is possible for it to contain</span>
                <span class="s3">// non-hoistable expressions that refers to scope variables, e.g. compiler</span>
                <span class="s3">// injected keys or cached event handlers. Therefore we need to always</span>
                <span class="s3">// check the codegenNode's props to be sure.</span>
                <span class="s0">const </span><span class="s1">generatedPropsType = getGeneratedPropsConstantType(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(generatedPropsType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(generatedPropsType &lt; returnType) {</span>
                    <span class="s1">returnType = generatedPropsType</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s3">// 2. its children.</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                    <span class="s0">const </span><span class="s1">childType = getConstantType(node.children[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                        <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">if </span><span class="s1">(childType &lt; returnType) {</span>
                        <span class="s1">returnType = childType</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
                <span class="s3">// type, check if any of the props can cause the type to be lowered</span>
                <span class="s3">// we can skip can_patch because it's guaranteed by the absence of a</span>
                <span class="s3">// patchFlag.</span>
                <span class="s0">if </span><span class="s1">(returnType &gt; </span><span class="s4">1 </span><span class="s3">/* ConstantTypes.CAN_SKIP_PATCH */</span><span class="s1">) {</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                        <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; p.exp) {</span>
                            <span class="s0">const </span><span class="s1">expType = getConstantType(p.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                            <span class="s0">if </span><span class="s1">(expType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                                <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                            <span class="s1">}</span>
                            <span class="s0">if </span><span class="s1">(expType &lt; returnType) {</span>
                                <span class="s1">returnType = expType</span><span class="s0">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">// only svg/foreignObject could be block here, however if they are</span>
                <span class="s3">// static then they don't need to be blocks since there will be no</span>
                <span class="s3">// nested updates.</span>
                <span class="s0">if </span><span class="s1">(codegenNode.isBlock) {</span>
                    <span class="s3">// except set custom directives.</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                        <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                            <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">context.removeHelper(OPEN_BLOCK)</span><span class="s0">;</span>
                    <span class="s1">context.removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">codegenNode.isComponent))</span><span class="s0">;</span>
                    <span class="s1">codegenNode.isBlock = </span><span class="s0">false;</span>
                    <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">codegenNode.isComponent))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s1">returnType)</span><span class="s0">;</span>
                <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">constantCache.set(node</span><span class="s0">, </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">getConstantType(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">node.constType</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isString(child) || isSymbol(child)) {</span>
                    <span class="s0">continue;</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">childType = getConstantType(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(childType &lt; returnType) {</span>
                    <span class="s1">returnType = childType</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
        <span class="s0">default</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) </span><span class="s0">;</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">allowHoistedHelperSet = </span><span class="s0">new </span><span class="s1">Set([</span>
    <span class="s1">NORMALIZE_CLASS</span><span class="s0">,</span>
    <span class="s1">NORMALIZE_STYLE</span><span class="s0">,</span>
    <span class="s1">NORMALIZE_PROPS</span><span class="s0">,</span>
    <span class="s1">GUARD_REACTIVE_PROPS</span>
<span class="s1">])</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">getConstantTypeOfHelperCall(value</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isString(value.callee) &amp;&amp;</span>
        <span class="s1">allowHoistedHelperSet.has(value.callee)) {</span>
        <span class="s0">const </span><span class="s1">arg = value.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">getConstantType(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(arg.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s3">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
            <span class="s0">return </span><span class="s1">getConstantTypeOfHelperCall(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getGeneratedPropsConstantType(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s3">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">props = getNodeProps(node)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(props &amp;&amp; props.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">{ properties } = props</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value } = properties[i]</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">keyType = getConstantType(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(keyType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">keyType</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(keyType &lt; returnType) {</span>
                <span class="s1">returnType = keyType</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">valueType</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">valueType = getConstantType(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s3">// some helper calls can be hoisted,</span>
                <span class="s3">// such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
                <span class="s3">// in this case we need to respect the ConstantType of the helper's arguments</span>
                <span class="s1">valueType = getConstantTypeOfHelperCall(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">valueType = </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(valueType === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">valueType</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(valueType &lt; returnType) {</span>
                <span class="s1">returnType = valueType</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">returnType</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getNodeProps(node) {</span>
    <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">codegenNode.props</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getPatchFlag(node) {</span>
    <span class="s0">const </span><span class="s1">flag = node.patchFlag</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">flag ? parseInt(flag</span><span class="s0">, </span><span class="s4">10</span><span class="s1">) : undefined</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">createTransformContext(root</span><span class="s0">, </span><span class="s1">{ filename = </span><span class="s2">''</span><span class="s0">, </span><span class="s1">prefixIdentifiers = </span><span class="s0">false, </span><span class="s1">hoistStatic = </span><span class="s0">false, </span><span class="s1">cacheHandlers = </span><span class="s0">false, </span><span class="s1">nodeTransforms = []</span><span class="s0">, </span><span class="s1">directiveTransforms = {}</span><span class="s0">, </span><span class="s1">transformHoist = </span><span class="s0">null, </span><span class="s1">isBuiltInComponent = NOOP</span><span class="s0">, </span><span class="s1">isCustomElement = NOOP</span><span class="s0">, </span><span class="s1">expressionPlugins = []</span><span class="s0">, </span><span class="s1">scopeId = </span><span class="s0">null, </span><span class="s1">slotted = </span><span class="s0">true, </span><span class="s1">ssr = </span><span class="s0">false, </span><span class="s1">inSSR = </span><span class="s0">false, </span><span class="s1">ssrCssVars = </span><span class="s2">``</span><span class="s0">, </span><span class="s1">bindingMetadata = EMPTY_OBJ</span><span class="s0">, </span><span class="s1">inline = </span><span class="s0">false, </span><span class="s1">isTS = </span><span class="s0">false, </span><span class="s1">onError = defaultOnError</span><span class="s0">, </span><span class="s1">onWarn = defaultOnWarn</span><span class="s0">, </span><span class="s1">compatConfig }) {</span>
    <span class="s0">const </span><span class="s1">nameMatch = filename.replace(</span><span class="s4">/\?.*$/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">context = {</span>
        <span class="s3">// options</span>
        <span class="s1">selfName: nameMatch &amp;&amp; capitalize(camelize$1(nameMatch[</span><span class="s4">1</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
        <span class="s1">hoistStatic</span><span class="s0">,</span>
        <span class="s1">cacheHandlers</span><span class="s0">,</span>
        <span class="s1">nodeTransforms</span><span class="s0">,</span>
        <span class="s1">directiveTransforms</span><span class="s0">,</span>
        <span class="s1">transformHoist</span><span class="s0">,</span>
        <span class="s1">isBuiltInComponent</span><span class="s0">,</span>
        <span class="s1">isCustomElement</span><span class="s0">,</span>
        <span class="s1">expressionPlugins</span><span class="s0">,</span>
        <span class="s1">scopeId</span><span class="s0">,</span>
        <span class="s1">slotted</span><span class="s0">,</span>
        <span class="s1">ssr</span><span class="s0">,</span>
        <span class="s1">inSSR</span><span class="s0">,</span>
        <span class="s1">ssrCssVars</span><span class="s0">,</span>
        <span class="s1">bindingMetadata</span><span class="s0">,</span>
        <span class="s1">inline</span><span class="s0">,</span>
        <span class="s1">isTS</span><span class="s0">,</span>
        <span class="s1">onError</span><span class="s0">,</span>
        <span class="s1">onWarn</span><span class="s0">,</span>
        <span class="s1">compatConfig</span><span class="s0">,</span>
        <span class="s3">// state</span>
        <span class="s1">root</span><span class="s0">,</span>
        <span class="s1">helpers: </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">,</span>
        <span class="s1">components: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
        <span class="s1">directives: </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">,</span>
        <span class="s1">hoists: []</span><span class="s0">,</span>
        <span class="s1">imports: []</span><span class="s0">,</span>
        <span class="s1">constantCache: </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">,</span>
        <span class="s1">temps: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">cached: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">identifiers: Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">scopes: {</span>
            <span class="s1">vFor: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s1">vSlot: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s1">vPre: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s1">vOnce: </span><span class="s4">0</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">parent: </span><span class="s0">null,</span>
        <span class="s1">currentNode: root</span><span class="s0">,</span>
        <span class="s1">childIndex: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">inVOnce: </span><span class="s0">false,</span>
        <span class="s3">// methods</span>
        <span class="s1">helper(name) {</span>
            <span class="s0">const </span><span class="s1">count = context.helpers.get(name) || </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">context.helpers.set(name</span><span class="s0">, </span><span class="s1">count + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">name</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">removeHelper(name) {</span>
            <span class="s0">const </span><span class="s1">count = context.helpers.get(name)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(count) {</span>
                <span class="s0">const </span><span class="s1">currentCount = count - </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(!currentCount) {</span>
                    <span class="s1">context.helpers.delete(name)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">context.helpers.set(name</span><span class="s0">, </span><span class="s1">currentCount)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">helperString(name) {</span>
            <span class="s0">return </span><span class="s2">`_</span><span class="s1">${helperNameMap[context.helper(name)]}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">replaceNode(node) {</span>
            <span class="s3">/* istanbul ignore if */</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) {</span>
                <span class="s0">if </span><span class="s1">(!context.currentNode) {</span>
                    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Node being replaced is already removed.`</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(!context.parent) {</span>
                    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Cannot replace root node.`</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">context.parent.children[context.childIndex] = context.currentNode = node</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">removeNode(node) {</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; !context.parent) {</span>
                <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Cannot remove root node.`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">list = context.parent.children</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">removalIndex = node</span>
                <span class="s1">? list.indexOf(node)</span>
                <span class="s1">: context.currentNode</span>
                    <span class="s1">? context.childIndex</span>
                    <span class="s1">: -</span><span class="s4">1</span><span class="s0">;</span>
            <span class="s3">/* istanbul ignore if */</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; removalIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`node being removed is not a child of current parent`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(!node || node === context.currentNode) {</span>
                <span class="s3">// current node removed</span>
                <span class="s1">context.currentNode = </span><span class="s0">null;</span>
                <span class="s1">context.onNodeRemoved()</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s3">// sibling node removed</span>
                <span class="s0">if </span><span class="s1">(context.childIndex &gt; removalIndex) {</span>
                    <span class="s1">context.childIndex--</span><span class="s0">;</span>
                    <span class="s1">context.onNodeRemoved()</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">context.parent.children.splice(removalIndex</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">onNodeRemoved: () =&gt; { }</span><span class="s0">,</span>
        <span class="s1">addIdentifiers(exp) {</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">removeIdentifiers(exp) {</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">hoist(exp) {</span>
            <span class="s0">if </span><span class="s1">(isString(exp))</span>
                <span class="s1">exp = createSimpleExpression(exp)</span><span class="s0">;</span>
            <span class="s1">context.hoists.push(exp)</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">identifier = createSimpleExpression(</span><span class="s2">`_hoisted_</span><span class="s1">${context.hoists.length}</span><span class="s2">`</span><span class="s0">, false, </span><span class="s1">exp.loc</span><span class="s0">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">identifier.hoisted = exp</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">identifier</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">cache(exp</span><span class="s0">, </span><span class="s1">isVNode = </span><span class="s0">false</span><span class="s1">) {</span>
            <span class="s0">return </span><span class="s1">createCacheExpression(context.cached++</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">isVNode)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">{</span>
        <span class="s1">context.filters = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">transform(root</span><span class="s0">, </span><span class="s1">options) {</span>
    <span class="s0">const </span><span class="s1">context = createTransformContext(root</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
    <span class="s1">traverseNode(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(options.hoistStatic) {</span>
        <span class="s1">hoistStatic(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!options.ssr) {</span>
        <span class="s1">createRootCodegen(root</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// finalize meta information</span>
    <span class="s1">root.helpers = </span><span class="s0">new </span><span class="s1">Set([...context.helpers.keys()])</span><span class="s0">;</span>
    <span class="s1">root.components = [...context.components]</span><span class="s0">;</span>
    <span class="s1">root.directives = [...context.directives]</span><span class="s0">;</span>
    <span class="s1">root.imports = context.imports</span><span class="s0">;</span>
    <span class="s1">root.hoists = context.hoists</span><span class="s0">;</span>
    <span class="s1">root.temps = context.temps</span><span class="s0">;</span>
    <span class="s1">root.cached = context.cached</span><span class="s0">;</span>
    <span class="s1">{</span>
        <span class="s1">root.filters = [...context.filters]</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createRootCodegen(root</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ helper } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ children } = root</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(children.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s3">// if the single child is an element, turn it into a block.</span>
        <span class="s0">if </span><span class="s1">(isSingleElementRoot(root</span><span class="s0">, </span><span class="s1">child) &amp;&amp; child.codegenNode) {</span>
            <span class="s3">// single element root is never hoisted so codegenNode will never be</span>
            <span class="s3">// SimpleExpressionNode</span>
            <span class="s0">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s1">makeBlock(codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">root.codegenNode = codegenNode</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// - single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
            <span class="s3">// - single text node: always patched.</span>
            <span class="s3">// root codegen falls through via genNode()</span>
            <span class="s1">root.codegenNode = child</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s3">// root has multiple nodes - return a fragment block.</span>
        <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s3">// check if the fragment actually contains a single valid child with</span>
        <span class="s3">// the rest being comments</span>
        <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s0">;</span>
            <span class="s1">patchFlagText += </span><span class="s2">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">root.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">root.children</span><span class="s0">, </span><span class="s1">patchFlag + ((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* </span><span class="s1">${patchFlagText} </span><span class="s2">*/` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, </span><span class="s1">undefined</span><span class="s0">, false </span><span class="s3">/* isComponent */</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else ;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">traverseChildren(parent</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">nodeRemoved = () =&gt; {</span>
        <span class="s1">i--</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">; </span><span class="s1">i &lt; parent.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">child = parent.children[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(isString(child))</span>
            <span class="s0">continue;</span>
        <span class="s1">context.parent = parent</span><span class="s0">;</span>
        <span class="s1">context.childIndex = i</span><span class="s0">;</span>
        <span class="s1">context.onNodeRemoved = nodeRemoved</span><span class="s0">;</span>
        <span class="s1">traverseNode(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">traverseNode(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s1">context.currentNode = node</span><span class="s0">;</span>
    <span class="s3">// apply transform plugins</span>
    <span class="s0">const </span><span class="s1">{ nodeTransforms } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">exitFns = []</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodeTransforms.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">onExit = nodeTransforms[i](node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(onExit) {</span>
            <span class="s0">if </span><span class="s1">(isArray(onExit)) {</span>
                <span class="s1">exitFns.push(...onExit)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">exitFns.push(onExit)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!context.currentNode) {</span>
            <span class="s3">// node was removed</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// node may have been replaced</span>
            <span class="s1">node = context.currentNode</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(node.type) {</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(!context.ssr) {</span>
                <span class="s3">// inject import for the Comment symbol, which is needed for creating</span>
                <span class="s3">// comment nodes with `createVNode`</span>
                <span class="s1">context.helper(CREATE_COMMENT)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
            <span class="s3">// no need to traverse, but we need to inject toString helper</span>
            <span class="s0">if </span><span class="s1">(!context.ssr) {</span>
                <span class="s1">context.helper(TO_DISPLAY_STRING)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s3">// for container types, further traverse downwards</span>
        <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.branches.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s1">traverseNode(node.branches[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */</span><span class="s1">:</span>
            <span class="s1">traverseChildren(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s3">// exit transforms</span>
    <span class="s1">context.currentNode = node</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">i = exitFns.length</span><span class="s0">;</span>
    <span class="s0">while </span><span class="s1">(i--) {</span>
        <span class="s1">exitFns[i]()</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createStructuralDirectiveTransform(name</span><span class="s0">, </span><span class="s1">fn) {</span>
    <span class="s0">const </span><span class="s1">matches = isString(name)</span>
        <span class="s1">? (n) =&gt; n === name</span>
        <span class="s1">: (n) =&gt; name.test(n)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">{ props } = node</span><span class="s0">;</span>
            <span class="s3">// structural directive transforms are not concerned with slots</span>
            <span class="s3">// as they are handled separately in vSlot.ts</span>
            <span class="s0">if </span><span class="s1">(node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */ </span><span class="s1">&amp;&amp; props.some(isVSlot)) {</span>
                <span class="s0">return;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">exitFns = []</span><span class="s0">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s0">const </span><span class="s1">prop = props[i]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; matches(prop.name)) {</span>
                    <span class="s3">// structural directives are removed to avoid infinite recursion</span>
                    <span class="s3">// also we remove them *before* applying so that it can further</span>
                    <span class="s3">// traverse itself in case it moves the node around</span>
                    <span class="s1">props.splice(i</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">i--</span><span class="s0">;</span>
                    <span class="s0">const </span><span class="s1">onExit = fn(node</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(onExit)</span>
                        <span class="s1">exitFns.push(onExit)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">exitFns</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">PURE_ANNOTATION = </span><span class="s2">`/*#__PURE__*/`</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">aliasHelper = (s) =&gt; </span><span class="s2">`</span><span class="s1">${helperNameMap[s]}</span><span class="s2">: _</span><span class="s1">${helperNameMap[s]}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createCodegenContext(ast</span><span class="s0">, </span><span class="s1">{ mode = </span><span class="s2">'function'</span><span class="s0">, </span><span class="s1">prefixIdentifiers = mode === </span><span class="s2">'module'</span><span class="s0">, </span><span class="s1">sourceMap = </span><span class="s0">false, </span><span class="s1">filename = </span><span class="s2">`template.vue.html`</span><span class="s0">, </span><span class="s1">scopeId = </span><span class="s0">null, </span><span class="s1">optimizeImports = </span><span class="s0">false, </span><span class="s1">runtimeGlobalName = </span><span class="s2">`Vue`</span><span class="s0">, </span><span class="s1">runtimeModuleName = </span><span class="s2">`vue`</span><span class="s0">, </span><span class="s1">ssrRuntimeModuleName = </span><span class="s2">'vue/server-renderer'</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false, </span><span class="s1">isTS = </span><span class="s0">false, </span><span class="s1">inSSR = </span><span class="s0">false </span><span class="s1">}) {</span>
    <span class="s0">const </span><span class="s1">context = {</span>
        <span class="s1">mode</span><span class="s0">,</span>
        <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
        <span class="s1">sourceMap</span><span class="s0">,</span>
        <span class="s1">filename</span><span class="s0">,</span>
        <span class="s1">scopeId</span><span class="s0">,</span>
        <span class="s1">optimizeImports</span><span class="s0">,</span>
        <span class="s1">runtimeGlobalName</span><span class="s0">,</span>
        <span class="s1">runtimeModuleName</span><span class="s0">,</span>
        <span class="s1">ssrRuntimeModuleName</span><span class="s0">,</span>
        <span class="s1">ssr</span><span class="s0">,</span>
        <span class="s1">isTS</span><span class="s0">,</span>
        <span class="s1">inSSR</span><span class="s0">,</span>
        <span class="s1">source: ast.loc.source</span><span class="s0">,</span>
        <span class="s1">code: </span><span class="s2">``</span><span class="s0">,</span>
        <span class="s1">column: </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">line: </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s1">offset: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">indentLevel: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">pure: </span><span class="s0">false,</span>
        <span class="s1">map: undefined</span><span class="s0">,</span>
        <span class="s1">helper(key) {</span>
            <span class="s0">return </span><span class="s2">`_</span><span class="s1">${helperNameMap[key]}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">push(code</span><span class="s0">, </span><span class="s1">node) {</span>
            <span class="s1">context.code += code</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">indent() {</span>
            <span class="s1">newline(++context.indentLevel)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">deindent(withoutNewLine = </span><span class="s0">false</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(withoutNewLine) {</span>
                <span class="s1">--context.indentLevel</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">newline(--context.indentLevel)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">newline() {</span>
            <span class="s1">newline(context.indentLevel)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">function </span><span class="s1">newline(n) {</span>
        <span class="s1">context.push(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+ </span><span class="s2">`  `</span><span class="s1">.repeat(n))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">context</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">generate(ast</span><span class="s0">, </span><span class="s1">options = {}) {</span>
    <span class="s0">const </span><span class="s1">context = createCodegenContext(ast</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(options.onContextCreated)</span>
        <span class="s1">options.onContextCreated(context)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ mode</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">prefixIdentifiers</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">scopeId</span><span class="s0">, </span><span class="s1">ssr } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">hasHelpers = helpers.length &gt; </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">useWithBlock = !prefixIdentifiers &amp;&amp; mode !== </span><span class="s2">'module'</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isSetupInlined = !</span><span class="s0">true ;</span>
    <span class="s3">// preambles</span>
    <span class="s3">// in setup() inline mode, the preamble is generated in a sub context</span>
    <span class="s3">// and returned separately.</span>
    <span class="s0">const </span><span class="s1">preambleContext = isSetupInlined</span>
        <span class="s1">? createCodegenContext(ast</span><span class="s0">, </span><span class="s1">options)</span>
        <span class="s1">: context</span><span class="s0">;</span>
    <span class="s1">{</span>
        <span class="s1">genFunctionPreamble(ast</span><span class="s0">, </span><span class="s1">preambleContext)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// enter render function</span>
    <span class="s0">const </span><span class="s1">functionName = ssr ? </span><span class="s2">`ssrRender` </span><span class="s1">: </span><span class="s2">`render`</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">args = ssr ? [</span><span class="s2">'_ctx'</span><span class="s0">, </span><span class="s2">'_push'</span><span class="s0">, </span><span class="s2">'_parent'</span><span class="s0">, </span><span class="s2">'_attrs'</span><span class="s1">] : [</span><span class="s2">'_ctx'</span><span class="s0">, </span><span class="s2">'_cache'</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">signature = args.join(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">{</span>
        <span class="s1">push(</span><span class="s2">`function </span><span class="s1">${functionName}</span><span class="s2">(</span><span class="s1">${signature}</span><span class="s2">) {`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">indent()</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(useWithBlock) {</span>
        <span class="s1">push(</span><span class="s2">`with (_ctx) {`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">indent()</span><span class="s0">;</span>
        <span class="s3">// function mode const declarations should be inside with block</span>
        <span class="s3">// also they should be renamed to avoid collision with user properties</span>
        <span class="s0">if </span><span class="s1">(hasHelpers) {</span>
            <span class="s1">push(</span><span class="s2">`const { </span><span class="s1">${helpers.map(aliasHelper).join(</span><span class="s2">', '</span><span class="s1">)} </span><span class="s2">} = _Vue`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">push(</span><span class="s2">`</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// generate asset resolution statements</span>
    <span class="s0">if </span><span class="s1">(ast.components.length) {</span>
        <span class="s1">genAssets(ast.components</span><span class="s0">, </span><span class="s2">'component'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(ast.directives.length || ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(ast.directives.length) {</span>
        <span class="s1">genAssets(ast.directives</span><span class="s0">, </span><span class="s2">'directive'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(ast.filters &amp;&amp; ast.filters.length) {</span>
        <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">genAssets(ast.filters</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">newline()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">push(</span><span class="s2">`let `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; ast.temps</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s1">push(</span><span class="s2">`</span><span class="s1">${i &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">`, ` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">_temp</span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(ast.components.length || ast.directives.length || ast.temps) {</span>
        <span class="s1">push(</span><span class="s2">`</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">newline()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// generate the VNode tree expression</span>
    <span class="s0">if </span><span class="s1">(!ssr) {</span>
        <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(ast.codegenNode) {</span>
        <span class="s1">genNode(ast.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s2">`null`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(useWithBlock) {</span>
        <span class="s1">deindent()</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">deindent()</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">ast</span><span class="s0">,</span>
        <span class="s1">code: context.code</span><span class="s0">,</span>
        <span class="s1">preamble: isSetupInlined ? preambleContext.code : </span><span class="s2">``</span><span class="s0">,</span>
        <span class="s3">// SourceMapGenerator does have toJSON() method but it's not in the types</span>
        <span class="s1">map: context.map ? context.map.toJSON() : undefined</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genFunctionPreamble(ast</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ ssr</span><span class="s0">, </span><span class="s1">prefixIdentifiers</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">runtimeModuleName</span><span class="s0">, </span><span class="s1">runtimeGlobalName</span><span class="s0">, </span><span class="s1">ssrRuntimeModuleName } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">VueBinding = runtimeGlobalName</span><span class="s0">;</span>
    <span class="s3">// Generate const declaration for helpers</span>
    <span class="s3">// In prefix mode, we place the const declaration at top so it's done</span>
    <span class="s3">// only once; But if we not prefixing, we place the declaration inside the</span>
    <span class="s3">// with block so it doesn't incur the `in` check cost for every helper access.</span>
    <span class="s0">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(helpers.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">{</span>
            <span class="s3">// &quot;with&quot; mode.</span>
            <span class="s3">// save Vue in a separate variable to avoid collision</span>
            <span class="s1">push(</span><span class="s2">`const _Vue = </span><span class="s1">${VueBinding}</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s3">// in &quot;with&quot; mode, helpers are declared inside the with block to avoid</span>
            <span class="s3">// has check cost, but hoists are lifted out of the function - we need</span>
            <span class="s3">// to provide the helper here.</span>
            <span class="s0">if </span><span class="s1">(ast.hoists.length) {</span>
                <span class="s0">const </span><span class="s1">staticHelpers = [</span>
                    <span class="s1">CREATE_VNODE</span><span class="s0">,</span>
                    <span class="s1">CREATE_ELEMENT_VNODE</span><span class="s0">,</span>
                    <span class="s1">CREATE_COMMENT</span><span class="s0">,</span>
                    <span class="s1">CREATE_TEXT</span><span class="s0">,</span>
                    <span class="s1">CREATE_STATIC</span>
                <span class="s1">]</span>
                    <span class="s1">.filter(helper =&gt; helpers.includes(helper))</span>
                    <span class="s1">.map(aliasHelper)</span>
                    <span class="s1">.join(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">push(</span><span class="s2">`const { </span><span class="s1">${staticHelpers} </span><span class="s2">} = _Vue</span><span class="s0">\n</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">genHoists(ast.hoists</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">newline()</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genAssets(assets</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">isTS }) {</span>
    <span class="s0">const </span><span class="s1">resolver = helper(type === </span><span class="s2">'filter'</span>
        <span class="s1">? RESOLVE_FILTER</span>
        <span class="s1">: type === </span><span class="s2">'component'</span>
            <span class="s1">? RESOLVE_COMPONENT</span>
            <span class="s1">: RESOLVE_DIRECTIVE)</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; assets.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">let </span><span class="s1">id = assets[i]</span><span class="s0">;</span>
        <span class="s3">// potential component implicit self-reference inferred from SFC filename</span>
        <span class="s0">const </span><span class="s1">maybeSelfReference = id.endsWith(</span><span class="s2">'__self'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(maybeSelfReference) {</span>
            <span class="s1">id = id.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">6</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">push(</span><span class="s2">`const </span><span class="s1">${toValidAssetId(id</span><span class="s0">, </span><span class="s1">type)} </span><span class="s2">= </span><span class="s1">${resolver}</span><span class="s2">(</span><span class="s1">${JSON.stringify(id)}${maybeSelfReference ? </span><span class="s2">`, true` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">)</span><span class="s1">${isTS ? </span><span class="s2">`!` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(i &lt; assets.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genHoists(hoists</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">if </span><span class="s1">(!hoists.length) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s1">context.pure = </span><span class="s0">true;</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">scopeId</span><span class="s0">, </span><span class="s1">mode } = context</span><span class="s0">;</span>
    <span class="s1">newline()</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; hoists.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">exp = hoists[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(exp) {</span>
            <span class="s1">push(</span><span class="s2">`const _hoisted_</span><span class="s1">${i + </span><span class="s4">1</span><span class="s1">} </span><span class="s2">= </span><span class="s1">${</span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">genNode(exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">context.pure = </span><span class="s0">false;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isText(n) {</span>
    <span class="s0">return </span><span class="s1">(isString(n) ||</span>
        <span class="s1">n.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genNodeListAsArray(nodes</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">multilines = nodes.length &gt; </span><span class="s4">3 </span><span class="s1">||</span>
        <span class="s1">(((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) &amp;&amp; nodes.some(n =&gt; isArray(n) || !isText(n)))</span><span class="s0">;</span>
    <span class="s1">context.push(</span><span class="s2">`[`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">multilines &amp;&amp; context.indent()</span><span class="s0">;</span>
    <span class="s1">genNodeList(nodes</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">multilines)</span><span class="s0">;</span>
    <span class="s1">multilines &amp;&amp; context.deindent()</span><span class="s0">;</span>
    <span class="s1">context.push(</span><span class="s2">`]`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genNodeList(nodes</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">multilines = </span><span class="s0">false, </span><span class="s1">comma = </span><span class="s0">true</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; nodes.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">node = nodes[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(isString(node)) {</span>
            <span class="s1">push(node)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(isArray(node)) {</span>
            <span class="s1">genNodeListAsArray(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">genNode(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(i &lt; nodes.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(multilines) {</span>
                <span class="s1">comma &amp;&amp; push(</span><span class="s2">','</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">newline()</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">comma &amp;&amp; push(</span><span class="s2">', '</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genNode(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">if </span><span class="s1">(isString(node)) {</span>
        <span class="s1">context.push(node)</span><span class="s0">;</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isSymbol(node)) {</span>
        <span class="s1">context.push(context.helper(node))</span><span class="s0">;</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(node.type) {</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">:</span>
            <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">assert(node.codegenNode != </span><span class="s0">null, </span><span class="s2">`Codegen node is missing for element/if/for node. ` </span><span class="s1">+</span>
                    <span class="s2">`Apply appropriate transforms first.`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">genNode(node.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">:</span>
            <span class="s1">genText(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
            <span class="s1">genInterpolation(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
            <span class="s1">genNode(node.codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s1">genComment(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">:</span>
            <span class="s1">genVNodeCall(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCallExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genObjectExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genArrayExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">18 </span><span class="s3">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genFunctionExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genConditionalExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCacheExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">21 </span><span class="s3">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s1">:</span>
            <span class="s1">genNodeList(node.body</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true, false</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s3">// SSR only types</span>
        <span class="s0">case </span><span class="s4">22 </span><span class="s3">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s1">:</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">23 </span><span class="s3">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s1">:</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">24 </span><span class="s3">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">25 </span><span class="s3">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s4">26 </span><span class="s3">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s1">:</span>
            <span class="s0">break;</span>
        <span class="s3">/* istanbul ignore next */</span>
        <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s3">// noop</span>
            <span class="s0">break;</span>
        <span class="s0">default</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) {</span>
                <span class="s1">assert(</span><span class="s0">false, </span><span class="s2">`unhandled codegen node type: </span><span class="s1">${node.type}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s3">// make sure we exhaust all possible types</span>
                <span class="s0">const </span><span class="s1">exhaustiveCheck = node</span><span class="s0">;</span>
                <span class="s0">return </span><span class="s1">exhaustiveCheck</span><span class="s0">;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genText(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s1">context.push(JSON.stringify(node.content)</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ content</span><span class="s0">, </span><span class="s1">isStatic } = node</span><span class="s0">;</span>
    <span class="s1">context.push(isStatic ? JSON.stringify(content) : content</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genInterpolation(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(pure)</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(TO_DISPLAY_STRING)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">genNode(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(isString(child)) {</span>
            <span class="s1">context.push(child)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">genNode(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genExpressionAsPropertyKey(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push } = context</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">push(</span><span class="s2">`[`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">genCompoundExpression(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`]`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(node.isStatic) {</span>
        <span class="s3">// only quote keys if necessary</span>
        <span class="s0">const </span><span class="s1">text = isSimpleIdentifier(node.content)</span>
            <span class="s1">? node.content</span>
            <span class="s1">: JSON.stringify(node.content)</span><span class="s0">;</span>
        <span class="s1">push(text</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s2">`[</span><span class="s1">${node.content}</span><span class="s2">]`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genComment(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(CREATE_COMMENT)}</span><span class="s2">(</span><span class="s1">${JSON.stringify(node.content)}</span><span class="s2">)`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genVNodeCall(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps</span><span class="s0">, </span><span class="s1">directives</span><span class="s0">, </span><span class="s1">isBlock</span><span class="s0">, </span><span class="s1">disableTracking</span><span class="s0">, </span><span class="s1">isComponent } = node</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(directives) {</span>
        <span class="s1">push(helper(WITH_DIRECTIVES) + </span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isBlock) {</span>
        <span class="s1">push(</span><span class="s2">`(</span><span class="s1">${helper(OPEN_BLOCK)}</span><span class="s2">(</span><span class="s1">${disableTracking ? </span><span class="s2">`true` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">), `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">callHelper = isBlock</span>
        <span class="s1">? getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent)</span>
        <span class="s1">: getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">isComponent)</span><span class="s0">;</span>
    <span class="s1">push(helper(callHelper) + </span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s1">genNodeList(genNullableArgs([tag</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag</span><span class="s0">, </span><span class="s1">dynamicProps])</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isBlock) {</span>
        <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(directives) {</span>
        <span class="s1">push(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">genNode(directives</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genNullableArgs(args) {</span>
    <span class="s0">let </span><span class="s1">i = args.length</span><span class="s0">;</span>
    <span class="s0">while </span><span class="s1">(i--) {</span>
        <span class="s0">if </span><span class="s1">(args[i] != </span><span class="s0">null</span><span class="s1">)</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">args.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">).map(arg =&gt; arg || </span><span class="s2">`null`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s3">// JavaScript</span>
<span class="s0">function </span><span class="s1">genCallExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">pure } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">callee = isString(node.callee) ? node.callee : helper(node.callee)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(callee + </span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s1">genNodeList(node.arguments</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genObjectExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ properties } = node</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!properties.length) {</span>
        <span class="s1">push(</span><span class="s2">`{}`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">multilines = properties.length &gt; </span><span class="s4">1 </span><span class="s1">||</span>
        <span class="s1">(((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) &amp;&amp;</span>
            <span class="s1">properties.some(p =&gt; p.value.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s1">push(multilines ? </span><span class="s2">`{` </span><span class="s1">: </span><span class="s2">`{ `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">multilines &amp;&amp; indent()</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value } = properties[i]</span><span class="s0">;</span>
        <span class="s3">// key</span>
        <span class="s1">genExpressionAsPropertyKey(key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`: `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s3">// value</span>
        <span class="s1">genNode(value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(i &lt; properties.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s3">// will only reach this if it's multilines</span>
            <span class="s1">push(</span><span class="s2">`,`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">multilines &amp;&amp; deindent()</span><span class="s0">;</span>
    <span class="s1">push(multilines ? </span><span class="s2">`}` </span><span class="s1">: </span><span class="s2">` }`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genArrayExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s1">genNodeListAsArray(node.elements</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genFunctionExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ params</span><span class="s0">, </span><span class="s1">returns</span><span class="s0">, </span><span class="s1">body</span><span class="s0">, </span><span class="s1">newline</span><span class="s0">, </span><span class="s1">isSlot } = node</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isSlot) {</span>
        <span class="s3">// wrap slot functions with owner context</span>
        <span class="s1">push(</span><span class="s2">`_</span><span class="s1">${helperNameMap[WITH_CTX]}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s2">`(`</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isArray(params)) {</span>
        <span class="s1">genNodeList(params</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(params) {</span>
        <span class="s1">genNode(params</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s2">`) =&gt; `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(newline || body) {</span>
        <span class="s1">push(</span><span class="s2">`{`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">indent()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(returns) {</span>
        <span class="s0">if </span><span class="s1">(newline) {</span>
            <span class="s1">push(</span><span class="s2">`return `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isArray(returns)) {</span>
            <span class="s1">genNodeListAsArray(returns</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">genNode(returns</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(body) {</span>
        <span class="s1">genNode(body</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(newline || body) {</span>
        <span class="s1">deindent()</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`}`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isSlot) {</span>
        <span class="s0">if </span><span class="s1">(node.isNonScopedSlot) {</span>
            <span class="s1">push(</span><span class="s2">`, undefined, true`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genConditionalExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ test</span><span class="s0">, </span><span class="s1">consequent</span><span class="s0">, </span><span class="s1">alternate</span><span class="s0">, </span><span class="s1">newline: needNewline } = node</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(test.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">needsParens = !isSimpleIdentifier(test.content)</span><span class="s0">;</span>
        <span class="s1">needsParens &amp;&amp; push(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">genExpression(test</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">needsParens &amp;&amp; push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">genNode(test</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">needNewline &amp;&amp; indent()</span><span class="s0">;</span>
    <span class="s1">context.indentLevel++</span><span class="s0">;</span>
    <span class="s1">needNewline || push(</span><span class="s2">` `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`? `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">genNode(consequent</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">context.indentLevel--</span><span class="s0">;</span>
    <span class="s1">needNewline &amp;&amp; newline()</span><span class="s0">;</span>
    <span class="s1">needNewline || push(</span><span class="s2">` `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`: `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isNested = alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!isNested) {</span>
        <span class="s1">context.indentLevel++</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">genNode(alternate</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!isNested) {</span>
        <span class="s1">context.indentLevel--</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">needNewline &amp;&amp; deindent(</span><span class="s0">true </span><span class="s3">/* without newline */</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genCacheExpression(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ push</span><span class="s0">, </span><span class="s1">helper</span><span class="s0">, </span><span class="s1">indent</span><span class="s0">, </span><span class="s1">deindent</span><span class="s0">, </span><span class="s1">newline } = context</span><span class="s0">;</span>
    <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">] || (`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(node.isVNode) {</span>
        <span class="s1">indent()</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s2">(-1),`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">newline()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">] = `</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">genNode(node.value</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(node.isVNode) {</span>
        <span class="s1">push(</span><span class="s2">`,`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s2">(1),`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">newline()</span><span class="s0">;</span>
        <span class="s1">push(</span><span class="s2">`_cache[</span><span class="s1">${node.index}</span><span class="s2">]`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">deindent()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">walkIdentifiers(root</span><span class="s0">, </span><span class="s1">onIdentifier</span><span class="s0">, </span><span class="s1">includeAll = </span><span class="s0">false, </span><span class="s1">parentStack = []</span><span class="s0">, </span><span class="s1">knownIds = Object.create(</span><span class="s0">null</span><span class="s1">)) {</span>
    <span class="s1">{</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isReferencedIdentifier(id</span><span class="s0">, </span><span class="s1">parent</span><span class="s0">, </span><span class="s1">parentStack) {</span>
    <span class="s1">{</span>
        <span class="s0">return false;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isInDestructureAssignment(parent</span><span class="s0">, </span><span class="s1">parentStack) {</span>
    <span class="s0">if </span><span class="s1">(parent &amp;&amp;</span>
        <span class="s1">(parent.type === </span><span class="s2">'ObjectProperty' </span><span class="s1">|| parent.type === </span><span class="s2">'ArrayPattern'</span><span class="s1">)) {</span>
        <span class="s0">let </span><span class="s1">i = parentStack.length</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">(i--) {</span>
            <span class="s0">const </span><span class="s1">p = parentStack[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(p.type === </span><span class="s2">'AssignmentExpression'</span><span class="s1">) {</span>
                <span class="s0">return true;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(p.type !== </span><span class="s2">'ObjectProperty' </span><span class="s1">&amp;&amp; !p.type.endsWith(</span><span class="s2">'Pattern'</span><span class="s1">)) {</span>
                <span class="s0">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return false;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">walkFunctionParams(node</span><span class="s0">, </span><span class="s1">onIdent) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">p of node.params) {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">id of extractIdentifiers(p)) {</span>
            <span class="s1">onIdent(id)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">walkBlockDeclarations(block</span><span class="s0">, </span><span class="s1">onIdent) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">stmt of block.body) {</span>
        <span class="s0">if </span><span class="s1">(stmt.type === </span><span class="s2">'VariableDeclaration'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(stmt.declare)</span>
                <span class="s0">continue;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">decl of stmt.declarations) {</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">id of extractIdentifiers(decl.id)) {</span>
                    <span class="s1">onIdent(id)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(stmt.type === </span><span class="s2">'FunctionDeclaration' </span><span class="s1">||</span>
            <span class="s1">stmt.type === </span><span class="s2">'ClassDeclaration'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(stmt.declare || !stmt.id)</span>
                <span class="s0">continue;</span>
            <span class="s1">onIdent(stmt.id)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">extractIdentifiers(param</span><span class="s0">, </span><span class="s1">nodes = []) {</span>
    <span class="s0">switch </span><span class="s1">(param.type) {</span>
        <span class="s0">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
            <span class="s1">nodes.push(param)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
            <span class="s0">let </span><span class="s1">object = param</span><span class="s0">;</span>
            <span class="s0">while </span><span class="s1">(object.type === </span><span class="s2">'MemberExpression'</span><span class="s1">) {</span>
                <span class="s1">object = object.object</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">nodes.push(object)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'ObjectPattern'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">prop of param.properties) {</span>
                <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s2">'RestElement'</span><span class="s1">) {</span>
                    <span class="s1">extractIdentifiers(prop.argument</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">extractIdentifiers(prop.value</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'ArrayPattern'</span><span class="s1">:</span>
            <span class="s1">param.elements.forEach(element =&gt; {</span>
                <span class="s0">if </span><span class="s1">(element)</span>
                    <span class="s1">extractIdentifiers(element</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
            <span class="s1">})</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'RestElement'</span><span class="s1">:</span>
            <span class="s1">extractIdentifiers(param.argument</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'AssignmentPattern'</span><span class="s1">:</span>
            <span class="s1">extractIdentifiers(param.left</span><span class="s0">, </span><span class="s1">nodes)</span><span class="s0">;</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">nodes</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">isFunctionType = (node) =&gt; {</span>
    <span class="s0">return </span><span class="s4">/Function(?:Expression|Declaration)$|Method$/</span><span class="s1">.test(node.type)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">isStaticProperty = (node) =&gt; node &amp;&amp;</span>
    <span class="s1">(node.type === </span><span class="s2">'ObjectProperty' </span><span class="s1">|| node.type === </span><span class="s2">'ObjectMethod'</span><span class="s1">) &amp;&amp;</span>
    <span class="s1">!node.computed</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">isStaticPropertyKey = (node</span><span class="s0">, </span><span class="s1">parent) =&gt; isStaticProperty(parent) &amp;&amp; parent.key === node</span><span class="s0">;</span>

<span class="s3">// these keywords should not appear inside expressions, but operators like</span>
<span class="s3">// 'typeof', 'instanceof', and 'in' are allowed</span>
<span class="s0">const </span><span class="s1">prohibitedKeywordRE = </span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">b' </span><span class="s1">+</span>
    <span class="s1">(</span><span class="s2">'arguments,await,break,case,catch,class,const,continue,debugger,default,' </span><span class="s1">+</span>
        <span class="s2">'delete,do,else,export,extends,finally,for,function,if,import,let,new,' </span><span class="s1">+</span>
        <span class="s2">'return,super,switch,throw,try,var,void,while,with,yield'</span><span class="s1">)</span>
        <span class="s1">.split(</span><span class="s2">','</span><span class="s1">)</span>
        <span class="s1">.join(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">b|</span><span class="s0">\\</span><span class="s2">b'</span><span class="s1">) +</span>
    <span class="s2">'</span><span class="s0">\\</span><span class="s2">b'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s3">// strip strings in expressions</span>
<span class="s0">const </span><span class="s1">stripStringRE = </span><span class="s4">/'(?:[^'\\]|\\.)*'|&quot;(?:[^&quot;\\]|\\.)*&quot;|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Validate a non-prefixed expression.</span>
 <span class="s5">* This is only called when using the in-browser runtime compiler since it</span>
 <span class="s5">* doesn't prefix expressions.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">validateBrowserExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">asParams = </span><span class="s0">false, </span><span class="s1">asRawStatements = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">exp = node.content</span><span class="s0">;</span>
    <span class="s3">// empty expressions are validated per-directive since some directives</span>
    <span class="s3">// do allow empty expressions.</span>
    <span class="s0">if </span><span class="s1">(!exp.trim()) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">new </span><span class="s1">Function(asRawStatements</span>
            <span class="s1">? </span><span class="s2">` </span><span class="s1">${exp} </span><span class="s2">`</span>
            <span class="s1">: </span><span class="s2">`return </span><span class="s1">${asParams ? </span><span class="s2">`(</span><span class="s1">${exp}</span><span class="s2">) =&gt; {}` </span><span class="s1">: </span><span class="s2">`(</span><span class="s1">${exp}</span><span class="s2">)`</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">catch </span><span class="s1">(e) {</span>
        <span class="s0">let </span><span class="s1">message = e.message</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">keywordMatch = exp</span>
            <span class="s1">.replace(stripStringRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">.match(prohibitedKeywordRE)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(keywordMatch) {</span>
            <span class="s1">message = </span><span class="s2">`avoid using JavaScript keyword as property name: &quot;</span><span class="s1">${keywordMatch[</span><span class="s4">0</span><span class="s1">]}</span><span class="s2">&quot;`</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">45 </span><span class="s3">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s0">, </span><span class="s1">node.loc</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">message))</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">transformExpression = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
        <span class="s1">node.content = processExpression(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s3">// handle directives on element</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">dir = node.props[i]</span><span class="s0">;</span>
            <span class="s3">// do not process for v-on &amp; v-for since they are special handled</span>
            <span class="s0">if </span><span class="s1">(dir.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; dir.name !== </span><span class="s2">'for'</span><span class="s1">) {</span>
                <span class="s0">const </span><span class="s1">exp = dir.exp</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">arg = dir.arg</span><span class="s0">;</span>
                <span class="s3">// do not process exp if this is v-on:arg - we need special handling</span>
                <span class="s3">// for wrapping inline statements.</span>
                <span class="s0">if </span><span class="s1">(exp &amp;&amp;</span>
                    <span class="s1">exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!(dir.name === </span><span class="s2">'on' </span><span class="s1">&amp;&amp; arg)) {</span>
                    <span class="s1">dir.exp = processExpression(exp</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
                    <span class="s3">// slot args must be processed as function params</span>
                    <span class="s1">dir.name === </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(arg &amp;&amp; arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !arg.isStatic) {</span>
                    <span class="s1">dir.arg = processExpression(arg</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s3">// Important: since this function uses Node.js only dependencies, it should</span>
<span class="s3">// always be used with a leading !true check so that it can be</span>
<span class="s3">// tree-shaken from the browser build.</span>
<span class="s0">function </span><span class="s1">processExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span>
<span class="s3">// some expressions like v-slot props &amp; v-for aliases should be parsed as</span>
<span class="s3">// function params</span>
<span class="s1">asParams = </span><span class="s0">false, </span>
<span class="s3">// v-on handler values may contain multiple statements</span>
<span class="s1">asRawStatements = </span><span class="s0">false, </span><span class="s1">localVars = Object.create(context.identifiers)) {</span>
    <span class="s1">{</span>
        <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) {</span>
            <span class="s3">// simple in-browser validation (same logic in 2.x)</span>
            <span class="s1">validateBrowserExpression(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">asParams</span><span class="s0">, </span><span class="s1">asRawStatements)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">stringifyExpression(exp) {</span>
    <span class="s0">if </span><span class="s1">(isString(exp)) {</span>
        <span class="s0">return </span><span class="s1">exp</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">exp.content</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">exp.children</span>
            <span class="s1">.map(stringifyExpression)</span>
            <span class="s1">.join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">transformIf = createStructuralDirectiveTransform(</span><span class="s4">/^(if|else|else-if)$/</span><span class="s0">, </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">return </span><span class="s1">processIf(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">(ifNode</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, </span><span class="s1">isRoot) =&gt; {</span>
        <span class="s3">// #1587: We need to dynamically increment the key based on the current</span>
        <span class="s3">// node's sibling nodes, since chained v-if/else branches are</span>
        <span class="s3">// rendered at the same depth</span>
        <span class="s0">const </span><span class="s1">siblings = context.parent.children</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">i = siblings.indexOf(ifNode)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">key = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">(i-- &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">sibling = siblings[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">) {</span>
                <span class="s1">key += sibling.branches.length</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// Exit callback. Complete the codegenNode when all children have been</span>
        <span class="s3">// transformed.</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s0">if </span><span class="s1">(isRoot) {</span>
                <span class="s1">ifNode.codegenNode = createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s3">// attach this branch's codegen node to the v-if root.</span>
                <span class="s0">const </span><span class="s1">parentCondition = getParentCondition(ifNode.codegenNode)</span><span class="s0">;</span>
                <span class="s1">parentCondition.alternate = createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">key + ifNode.branches.length - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s3">// target-agnostic transform used for both Client and SSR</span>
<span class="s0">function </span><span class="s1">processIf(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">processCodegen) {</span>
    <span class="s0">if </span><span class="s1">(dir.name !== </span><span class="s2">'else' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(!dir.exp || !dir.exp.content.trim())) {</span>
        <span class="s0">const </span><span class="s1">loc = dir.exp ? dir.exp.loc : node.loc</span><span class="s0">;</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">28 </span><span class="s3">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
        <span class="s1">dir.exp = createSimpleExpression(</span><span class="s2">`true`</span><span class="s0">, false, </span><span class="s1">loc)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true </span><span class="s1">&amp;&amp; dir.exp) {</span>
        <span class="s1">validateBrowserExpression(dir.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(dir.name === </span><span class="s2">'if'</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">branch = createIfBranch(node</span><span class="s0">, </span><span class="s1">dir)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">ifNode = {</span>
            <span class="s1">type: </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s0">,</span>
            <span class="s1">loc: node.loc</span><span class="s0">,</span>
            <span class="s1">branches: [branch]</span>
        <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">context.replaceNode(ifNode)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(processCodegen) {</span>
            <span class="s0">return </span><span class="s1">processCodegen(ifNode</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// locate the adjacent v-if</span>
        <span class="s0">const </span><span class="s1">siblings = context.parent.children</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">comments = []</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">i = siblings.indexOf(node)</span><span class="s0">;</span>
        <span class="s0">while </span><span class="s1">(i-- &gt;= -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">sibling = siblings[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                <span class="s1">context.removeNode(sibling)</span><span class="s0">;</span>
                <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; comments.unshift(sibling)</span><span class="s0">;</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(sibling &amp;&amp;</span>
                <span class="s1">sibling.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!sibling.content.trim().length) {</span>
                <span class="s1">context.removeNode(sibling)</span><span class="s0">;</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">) {</span>
                <span class="s3">// Check if v-else was followed by v-else-if</span>
                <span class="s0">if </span><span class="s1">(dir.name === </span><span class="s2">'else-if' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">sibling.branches[sibling.branches.length - </span><span class="s4">1</span><span class="s1">].condition === undefined) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">node.loc))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s3">// move the node to the if node's branches</span>
                <span class="s1">context.removeNode()</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">branch = createIfBranch(node</span><span class="s0">, </span><span class="s1">dir)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">comments.length &amp;&amp;</span>
                    <span class="s3">// #3619 ignore comments if the v-if is direct child of &lt;transition&gt;</span>
                    <span class="s1">!(context.parent &amp;&amp;</span>
                        <span class="s1">context.parent.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">isBuiltInType(context.parent.tag</span><span class="s0">, </span><span class="s2">'transition'</span><span class="s1">))) {</span>
                    <span class="s1">branch.children = [...comments</span><span class="s0">, </span><span class="s1">...branch.children]</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s3">// check if user is forcing same key on different branches</span>
                <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) || !</span><span class="s0">true</span><span class="s1">) {</span>
                    <span class="s0">const </span><span class="s1">key = branch.userKey</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(key) {</span>
                        <span class="s1">sibling.branches.forEach(({ userKey }) =&gt; {</span>
                            <span class="s0">if </span><span class="s1">(isSameKey(userKey</span><span class="s0">, </span><span class="s1">key)) {</span>
                                <span class="s1">context.onError(createCompilerError(</span><span class="s4">29 </span><span class="s3">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s0">, </span><span class="s1">branch.userKey.loc))</span><span class="s0">;</span>
                            <span class="s1">}</span>
                        <span class="s1">})</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">sibling.branches.push(branch)</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(sibling</span><span class="s0">, </span><span class="s1">branch</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s3">// since the branch was removed, it will not be traversed.</span>
                <span class="s3">// make sure to traverse here.</span>
                <span class="s1">traverseNode(branch</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s3">// call on exit</span>
                <span class="s0">if </span><span class="s1">(onExit)</span>
                    <span class="s1">onExit()</span><span class="s0">;</span>
                <span class="s3">// make sure to reset currentNode after traversal to indicate this</span>
                <span class="s3">// node has been removed.</span>
                <span class="s1">context.currentNode = </span><span class="s0">null;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">node.loc))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createIfBranch(node</span><span class="s0">, </span><span class="s1">dir) {</span>
    <span class="s0">const </span><span class="s1">isTemplateIf = node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s0">,</span>
        <span class="s1">loc: node.loc</span><span class="s0">,</span>
        <span class="s1">condition: dir.name === </span><span class="s2">'else' </span><span class="s1">? undefined : dir.exp</span><span class="s0">,</span>
        <span class="s1">children: isTemplateIf &amp;&amp; !findDir(node</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">) ? node.children : [node]</span><span class="s0">,</span>
        <span class="s1">userKey: findProp(node</span><span class="s0">, </span><span class="s2">`key`</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">isTemplateIf</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createCodegenNodeForBranch(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">if </span><span class="s1">(branch.condition) {</span>
        <span class="s0">return </span><span class="s1">createConditionalExpression(branch.condition</span><span class="s0">, </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">, </span>
        <span class="s3">// make sure to pass in asBlock: true so that the comment node call</span>
        <span class="s3">// closes the current block.</span>
        <span class="s1">createCallExpression(context.helper(CREATE_COMMENT)</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">'&quot;v-if&quot;' </span><span class="s1">: </span><span class="s2">'&quot;&quot;'</span><span class="s0">,</span>
            <span class="s2">'true'</span>
        <span class="s1">]))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s0">, </span><span class="s1">keyIndex</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">{ helper } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">keyProperty = createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`</span><span class="s1">${keyIndex}</span><span class="s2">`</span><span class="s0">, false, </span><span class="s1">locStub</span><span class="s0">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ children } = branch</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">firstChild = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| firstChild.type !== </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(needFragmentWrapper) {</span>
        <span class="s0">if </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; firstChild.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">) {</span>
            <span class="s3">// optimize away nested fragments when child is a ForNode</span>
            <span class="s0">const </span><span class="s1">vnodeCall = firstChild.codegenNode</span><span class="s0">;</span>
            <span class="s1">injectProp(vnodeCall</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">vnodeCall</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s0">;</span>
            <span class="s3">// check if the fragment actually contains a single valid child with</span>
            <span class="s3">// the rest being comments</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">!branch.isTemplateIf &amp;&amp;</span>
                <span class="s1">children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s0">;</span>
                <span class="s1">patchFlagText += </span><span class="s2">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s3">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">createObjectExpression([keyProperty])</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">patchFlag + ((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* </span><span class="s1">${patchFlagText} </span><span class="s2">*/` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, false, false </span><span class="s3">/* isComponent */</span><span class="s0">, </span><span class="s1">branch.loc)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">ret = firstChild.codegenNode</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">vnodeCall = getMemoedVNodeCall(ret)</span><span class="s0">;</span>
        <span class="s3">// Change createVNode to createBlock.</span>
        <span class="s0">if </span><span class="s1">(vnodeCall.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
            <span class="s1">makeBlock(vnodeCall</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s3">// inject branch key</span>
        <span class="s1">injectProp(vnodeCall</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSameKey(a</span><span class="s0">, </span><span class="s1">b) {</span>
    <span class="s0">if </span><span class="s1">(!a || a.type !== b.type) {</span>
        <span class="s0">return false;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(a.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(a.value.content !== b.value.content) {</span>
            <span class="s0">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// directive</span>
        <span class="s0">const </span><span class="s1">exp = a.exp</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">branchExp = b.exp</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(exp.type !== branchExp.type) {</span>
            <span class="s0">return false;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(exp.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
            <span class="s1">exp.isStatic !== branchExp.isStatic ||</span>
            <span class="s1">exp.content !== branchExp.content) {</span>
            <span class="s0">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return true;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getParentCondition(node) {</span>
    <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(node.alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">node = node.alternate</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(node.type === </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s1">node = node.value</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">transformFor = createStructuralDirectiveTransform(</span><span class="s2">'for'</span><span class="s0">, </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">const </span><span class="s1">{ helper</span><span class="s0">, </span><span class="s1">removeHelper } = context</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">processFor(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">forNode =&gt; {</span>
        <span class="s3">// create the loop render function expression now, and add the</span>
        <span class="s3">// iterator on exit after all children have been traversed</span>
        <span class="s0">const </span><span class="s1">renderExp = createCallExpression(helper(RENDER_LIST)</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">forNode.source</span>
        <span class="s1">])</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isTemplate = isTemplateNode(node)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">memo = findDir(node</span><span class="s0">, </span><span class="s2">'memo'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">keyProp = findProp(node</span><span class="s0">, </span><span class="s2">`key`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">keyExp = keyProp &amp;&amp;</span>
            <span class="s1">(keyProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s1">? createSimpleExpression(keyProp.value.content</span><span class="s0">, true</span><span class="s1">)</span>
                <span class="s1">: keyProp.exp)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">keyProperty = keyProp ? createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">keyExp) : </span><span class="s0">null;</span>
        <span class="s0">const </span><span class="s1">isStableFragment = forNode.source.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">forNode.source.constType &gt; </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">fragmentFlag = isStableFragment</span>
            <span class="s1">? </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span>
            <span class="s1">: keyProp</span>
                <span class="s1">? </span><span class="s4">128 </span><span class="s3">/* PatchFlags.KEYED_FRAGMENT */</span>
                <span class="s1">: </span><span class="s4">256 </span><span class="s3">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s0">;</span>
        <span class="s1">forNode.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">renderExp</span><span class="s0">, </span><span class="s1">fragmentFlag +</span>
            <span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[fragmentFlag]} </span><span class="s2">*/` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true </span><span class="s3">/* isBlock */</span><span class="s0">, </span><span class="s1">!isStableFragment </span><span class="s3">/* disableTracking */</span><span class="s0">, false </span><span class="s3">/* isComponent */</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s3">// finish the codegen now that all children have been traversed</span>
            <span class="s0">let </span><span class="s1">childBlock</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">{ children } = forNode</span><span class="s0">;</span>
            <span class="s3">// check &lt;template v-for&gt; key placement</span>
            <span class="s0">if </span><span class="s1">(((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) || !</span><span class="s0">true</span><span class="s1">) &amp;&amp; isTemplate) {</span>
                <span class="s1">node.children.some(c =&gt; {</span>
                    <span class="s0">if </span><span class="s1">(c.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
                        <span class="s0">const </span><span class="s1">key = findProp(c</span><span class="s0">, </span><span class="s2">'key'</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(key) {</span>
                            <span class="s1">context.onError(createCompilerError(</span><span class="s4">33 </span><span class="s3">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s0">, </span><span class="s1">key.loc))</span><span class="s0">;</span>
                            <span class="s0">return true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| children[</span><span class="s4">0</span><span class="s1">].type !== </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">slotOutlet = isSlotOutlet(node)</span>
                <span class="s1">? node</span>
                <span class="s1">: isTemplate &amp;&amp;</span>
                    <span class="s1">node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isSlotOutlet(node.children[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">? node.children[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">// api-extractor somehow fails to infer this</span>
                    <span class="s1">: </span><span class="s0">null;</span>
            <span class="s0">if </span><span class="s1">(slotOutlet) {</span>
                <span class="s3">// &lt;slot v-for=&quot;...&quot;&gt; or &lt;template v-for=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                <span class="s1">childBlock = slotOutlet.codegenNode</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s3">// &lt;template v-for=&quot;...&quot; :key=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                    <span class="s3">// we need to inject the key to the renderSlot() call.</span>
                    <span class="s3">// the props for renderSlot is passed as the 3rd argument.</span>
                    <span class="s1">injectProp(childBlock</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(needFragmentWrapper) {</span>
                <span class="s3">// &lt;template v-for=&quot;...&quot;&gt; with text or multi-elements</span>
                <span class="s3">// should generate a fragment block for each loop</span>
                <span class="s1">childBlock = createVNodeCall(context</span><span class="s0">, </span><span class="s1">helper(FRAGMENT)</span><span class="s0">, </span><span class="s1">keyProperty ? createObjectExpression([keyProperty]) : undefined</span><span class="s0">, </span><span class="s1">node.children</span><span class="s0">, </span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s1">+</span>
                    <span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)</span>
                        <span class="s1">? </span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">64 </span><span class="s3">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]} </span><span class="s2">*/`</span>
                        <span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, true, </span><span class="s1">undefined</span><span class="s0">, false </span><span class="s3">/* isComponent */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s3">// Normal element v-for. Directly use the child's codegenNode</span>
                <span class="s3">// but mark it as a block.</span>
                <span class="s1">childBlock = children[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">.codegenNode</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s1">injectProp(childBlock</span><span class="s0">, </span><span class="s1">keyProperty</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(childBlock.isBlock !== !isStableFragment) {</span>
                    <span class="s0">if </span><span class="s1">(childBlock.isBlock) {</span>
                        <span class="s3">// switch from block to vnode</span>
                        <span class="s1">removeHelper(OPEN_BLOCK)</span><span class="s0">;</span>
                        <span class="s1">removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s3">// switch from vnode to block</span>
                        <span class="s1">removeHelper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">childBlock.isBlock = !isStableFragment</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(childBlock.isBlock) {</span>
                    <span class="s1">helper(OPEN_BLOCK)</span><span class="s0">;</span>
                    <span class="s1">helper(getVNodeBlockHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">helper(getVNodeHelper(context.inSSR</span><span class="s0">, </span><span class="s1">childBlock.isComponent))</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(memo) {</span>
                <span class="s0">const </span><span class="s1">loop = createFunctionExpression(createForLoopParams(forNode.parseResult</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">createSimpleExpression(</span><span class="s2">`_cached`</span><span class="s1">)</span>
                <span class="s1">]))</span><span class="s0">;</span>
                <span class="s1">loop.body = createBlockStatement([</span>
                    <span class="s1">createCompoundExpression([</span><span class="s2">`const _memo = (`</span><span class="s0">, </span><span class="s1">memo.exp</span><span class="s0">, </span><span class="s2">`)`</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s1">createCompoundExpression([</span>
                        <span class="s2">`if (_cached`</span><span class="s0">,</span>
                        <span class="s1">...(keyExp ? [</span><span class="s2">` &amp;&amp; _cached.key === `</span><span class="s0">, </span><span class="s1">keyExp] : [])</span><span class="s0">,</span>
                        <span class="s2">` &amp;&amp; </span><span class="s1">${context.helperString(IS_MEMO_SAME)}</span><span class="s2">(_cached, _memo)) return _cached`</span>
                    <span class="s1">])</span><span class="s0">,</span>
                    <span class="s1">createCompoundExpression([</span><span class="s2">`const _item = `</span><span class="s0">, </span><span class="s1">childBlock])</span><span class="s0">,</span>
                    <span class="s1">createSimpleExpression(</span><span class="s2">`_item.memo = _memo`</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">createSimpleExpression(</span><span class="s2">`return _item`</span><span class="s1">)</span>
                <span class="s1">])</span><span class="s0">;</span>
                <span class="s1">renderExp.arguments.push(loop</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`_cache`</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(String(context.cached++)))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult)</span><span class="s0">, </span><span class="s1">childBlock</span><span class="s0">, true </span><span class="s3">/* force newline */</span><span class="s1">))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s3">// target-agnostic transform used for both Client and SSR</span>
<span class="s0">function </span><span class="s1">processFor(node</span><span class="s0">, </span><span class="s1">dir</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">processCodegen) {</span>
    <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">31 </span><span class="s3">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">parseResult = parseForExpression(</span>
    <span class="s3">// can only be simple expression because vFor transform is applied</span>
    <span class="s3">// before expression transform.</span>
    <span class="s1">dir.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!parseResult) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">{ addIdentifiers</span><span class="s0">, </span><span class="s1">removeIdentifiers</span><span class="s0">, </span><span class="s1">scopes } = context</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ source</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index } = parseResult</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">forNode = {</span>
        <span class="s1">type: </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s0">,</span>
        <span class="s1">loc: dir.loc</span><span class="s0">,</span>
        <span class="s1">source</span><span class="s0">,</span>
        <span class="s1">valueAlias: value</span><span class="s0">,</span>
        <span class="s1">keyAlias: key</span><span class="s0">,</span>
        <span class="s1">objectIndexAlias: index</span><span class="s0">,</span>
        <span class="s1">parseResult</span><span class="s0">,</span>
        <span class="s1">children: isTemplateNode(node) ? node.children : [node]</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">context.replaceNode(forNode)</span><span class="s0">;</span>
    <span class="s3">// bookkeeping</span>
    <span class="s1">scopes.vFor++</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(forNode)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">() =&gt; {</span>
        <span class="s1">scopes.vFor--</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(onExit)</span>
            <span class="s1">onExit()</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">forAliasRE = </span><span class="s4">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span><span class="s0">;</span>
<span class="s3">// This regex doesn't cover the case if key or index aliases have destructuring,</span>
<span class="s3">// but those do not make sense in the first place, so this works in practice.</span>
<span class="s0">const </span><span class="s1">forIteratorRE = </span><span class="s4">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">stripParensRE = </span><span class="s4">/^\(|\)$/g</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">parseForExpression(input</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">loc = input.loc</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">exp = input.content</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">inMatch = exp.match(forAliasRE)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!inMatch)</span>
        <span class="s0">return;</span>
    <span class="s0">const </span><span class="s1">[</span><span class="s0">, </span><span class="s1">LHS</span><span class="s0">, </span><span class="s1">RHS] = inMatch</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">result = {</span>
        <span class="s1">source: createAliasExpression(loc</span><span class="s0">, </span><span class="s1">RHS.trim()</span><span class="s0">, </span><span class="s1">exp.indexOf(RHS</span><span class="s0">, </span><span class="s1">LHS.length))</span><span class="s0">,</span>
        <span class="s1">value: undefined</span><span class="s0">,</span>
        <span class="s1">key: undefined</span><span class="s0">,</span>
        <span class="s1">index: undefined</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s1">validateBrowserExpression(result.source</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">valueContent = LHS.trim().replace(stripParensRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).trim()</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">trimmedOffset = LHS.indexOf(valueContent)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">iteratorMatch = valueContent.match(forIteratorRE)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(iteratorMatch) {</span>
        <span class="s1">valueContent = valueContent.replace(forIteratorRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).trim()</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">keyContent = iteratorMatch[</span><span class="s4">1</span><span class="s1">].trim()</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">keyOffset</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(keyContent) {</span>
            <span class="s1">keyOffset = exp.indexOf(keyContent</span><span class="s0">, </span><span class="s1">trimmedOffset + valueContent.length)</span><span class="s0">;</span>
            <span class="s1">result.key = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">keyContent</span><span class="s0">, </span><span class="s1">keyOffset)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true</span><span class="s1">) {</span>
                <span class="s1">validateBrowserExpression(result.key</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(iteratorMatch[</span><span class="s4">2</span><span class="s1">]) {</span>
            <span class="s0">const </span><span class="s1">indexContent = iteratorMatch[</span><span class="s4">2</span><span class="s1">].trim()</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(indexContent) {</span>
                <span class="s1">result.index = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">indexContent</span><span class="s0">, </span><span class="s1">exp.indexOf(indexContent</span><span class="s0">, </span><span class="s1">result.key</span>
                    <span class="s1">? keyOffset + keyContent.length</span>
                    <span class="s1">: trimmedOffset + valueContent.length))</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true</span><span class="s1">) {</span>
                    <span class="s1">validateBrowserExpression(result.index</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(valueContent) {</span>
        <span class="s1">result.value = createAliasExpression(loc</span><span class="s0">, </span><span class="s1">valueContent</span><span class="s0">, </span><span class="s1">trimmedOffset)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true</span><span class="s1">) {</span>
            <span class="s1">validateBrowserExpression(result.value</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createAliasExpression(range</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">offset) {</span>
    <span class="s0">return </span><span class="s1">createSimpleExpression(content</span><span class="s0">, false, </span><span class="s1">getInnerRange(range</span><span class="s0">, </span><span class="s1">offset</span><span class="s0">, </span><span class="s1">content.length))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createForLoopParams({ value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index }</span><span class="s0">, </span><span class="s1">memoArgs = []) {</span>
    <span class="s0">return </span><span class="s1">createParamsList([value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">...memoArgs])</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">createParamsList(args) {</span>
    <span class="s0">let </span><span class="s1">i = args.length</span><span class="s0">;</span>
    <span class="s0">while </span><span class="s1">(i--) {</span>
        <span class="s0">if </span><span class="s1">(args[i])</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">args</span>
        <span class="s1">.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">.map((arg</span><span class="s0">, </span><span class="s1">i) =&gt; arg || createSimpleExpression(</span><span class="s2">`_`</span><span class="s1">.repeat(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, false</span><span class="s1">))</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">defaultFallback = createSimpleExpression(</span><span class="s2">`undefined`</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
<span class="s3">// A NodeTransform that:</span>
<span class="s3">// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
<span class="s3">//    by transformExpression. This is only applied in non-browser builds with</span>
<span class="s3">//    { prefixIdentifiers: true }.</span>
<span class="s3">// 2. Track v-slot depths so that we know a slot is inside another slot.</span>
<span class="s3">//    Note the exit callback is executed before buildSlots() on the same node,</span>
<span class="s3">//    so only nested slots see positive numbers.</span>
<span class="s0">const </span><span class="s1">trackSlotScopes = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */ </span><span class="s1">||</span>
            <span class="s1">node.tagType === </span><span class="s4">3 </span><span class="s3">/* ElementTypes.TEMPLATE */</span><span class="s1">)) {</span>
        <span class="s3">// We are only checking non-empty v-slot here</span>
        <span class="s3">// since we only care about slots that introduce scope variables.</span>
        <span class="s0">const </span><span class="s1">vSlot = findDir(node</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(vSlot) {</span>
            <span class="s1">vSlot.exp</span><span class="s0">;</span>
            <span class="s1">context.scopes.vSlot++</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">() =&gt; {</span>
                <span class="s1">context.scopes.vSlot--</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s3">// A NodeTransform that tracks scope identifiers for scoped slots with v-for.</span>
<span class="s3">// This transform is only applied in non-browser builds with { prefixIdentifiers: true }</span>
<span class="s0">const </span><span class="s1">trackVForSlotScopes = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">let </span><span class="s1">vFor</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isTemplateNode(node) &amp;&amp;</span>
        <span class="s1">node.props.some(isVSlot) &amp;&amp;</span>
        <span class="s1">(vFor = findDir(node</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">))) {</span>
        <span class="s0">const </span><span class="s1">result = (vFor.parseResult = parseForExpression(vFor.exp</span><span class="s0">, </span><span class="s1">context))</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(result) {</span>
            <span class="s0">const </span><span class="s1">{ value</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">index } = result</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">{ addIdentifiers</span><span class="s0">, </span><span class="s1">removeIdentifiers } = context</span><span class="s0">;</span>
            <span class="s1">value &amp;&amp; addIdentifiers(value)</span><span class="s0">;</span>
            <span class="s1">key &amp;&amp; addIdentifiers(key)</span><span class="s0">;</span>
            <span class="s1">index &amp;&amp; addIdentifiers(index)</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">() =&gt; {</span>
                <span class="s1">value &amp;&amp; removeIdentifiers(value)</span><span class="s0">;</span>
                <span class="s1">key &amp;&amp; removeIdentifiers(key)</span><span class="s0">;</span>
                <span class="s1">index &amp;&amp; removeIdentifiers(index)</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">buildClientSlotFn = (props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc) =&gt; createFunctionExpression(props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, false </span><span class="s3">/* newline */</span><span class="s0">, true </span><span class="s3">/* isSlot */</span><span class="s0">, </span><span class="s1">children.length ? children[</span><span class="s4">0</span><span class="s1">].loc : loc)</span><span class="s0">;</span>
<span class="s3">// Instead of being a DirectiveTransform, v-slot processing is called during</span>
<span class="s3">// transformElement to build the slots object for a component.</span>
<span class="s0">function </span><span class="s1">buildSlots(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">buildSlotFn = buildClientSlotFn) {</span>
    <span class="s1">context.helper(WITH_CTX)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ children</span><span class="s0">, </span><span class="s1">loc } = node</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">slotsProperties = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">dynamicSlots = []</span><span class="s0">;</span>
    <span class="s3">// If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
    <span class="s3">// since it likely uses a scope variable.</span>
    <span class="s0">let </span><span class="s1">hasDynamicSlots = context.scopes.vSlot &gt; </span><span class="s4">0 </span><span class="s1">|| context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">// 1. Check for slot with slotProps on component itself.</span>
    <span class="s3">//    &lt;Comp v-slot=&quot;{ prop }&quot;/&gt;</span>
    <span class="s0">const </span><span class="s1">onComponentSlot = findDir(node</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(onComponentSlot) {</span>
        <span class="s0">const </span><span class="s1">{ arg</span><span class="s0">, </span><span class="s1">exp } = onComponentSlot</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(arg &amp;&amp; !isStaticExp(arg)) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
        <span class="s1">}</span>
        <span class="s1">slotsProperties.push(createObjectProperty(arg || createSimpleExpression(</span><span class="s2">'default'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">buildSlotFn(exp</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc)))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// 2. Iterate through children and check for template slots</span>
    <span class="s3">//    &lt;template v-slot:foo=&quot;{ prop }&quot;&gt;</span>
    <span class="s0">let </span><span class="s1">hasTemplateSlots = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasNamedDefaultSlot = </span><span class="s0">false;</span>
    <span class="s0">const </span><span class="s1">implicitDefaultChildren = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">seenSlotNames = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">conditionalBranchIndex = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">slotElement = children[i]</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">slotDir</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!isTemplateNode(slotElement) ||</span>
            <span class="s1">!(slotDir = findDir(slotElement</span><span class="s0">, </span><span class="s2">'slot'</span><span class="s0">, true</span><span class="s1">))) {</span>
            <span class="s3">// not a &lt;template v-slot&gt;, skip.</span>
            <span class="s0">if </span><span class="s1">(slotElement.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                <span class="s1">implicitDefaultChildren.push(slotElement)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">continue;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(onComponentSlot) {</span>
            <span class="s3">// already has on-component slot - this is incorrect usage.</span>
            <span class="s1">context.onError(createCompilerError(</span><span class="s4">37 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s0">, </span><span class="s1">slotDir.loc))</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
        <span class="s1">hasTemplateSlots = </span><span class="s0">true;</span>
        <span class="s0">const </span><span class="s1">{ children: slotChildren</span><span class="s0">, </span><span class="s1">loc: slotLoc } = slotElement</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ arg: slotName = createSimpleExpression(</span><span class="s2">`default`</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exp: slotProps</span><span class="s0">, </span><span class="s1">loc: dirLoc } = slotDir</span><span class="s0">;</span>
        <span class="s3">// check if name is dynamic.</span>
        <span class="s0">let </span><span class="s1">staticSlotName</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(isStaticExp(slotName)) {</span>
            <span class="s1">staticSlotName = slotName ? slotName.content : </span><span class="s2">`default`</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">slotFunction = buildSlotFn(slotProps</span><span class="s0">, </span><span class="s1">slotChildren</span><span class="s0">, </span><span class="s1">slotLoc)</span><span class="s0">;</span>
        <span class="s3">// check if this slot is conditional (v-if/v-for)</span>
        <span class="s0">let </span><span class="s1">vIf</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vElse</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vFor</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">((vIf = findDir(slotElement</span><span class="s0">, </span><span class="s2">'if'</span><span class="s1">))) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
            <span class="s1">dynamicSlots.push(createConditionalExpression(vIf.exp</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">, </span><span class="s1">defaultFallback))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">((vElse = findDir(slotElement</span><span class="s0">, </span><span class="s4">/^else(-if)?$/</span><span class="s0">, true </span><span class="s3">/* allowEmpty */</span><span class="s1">))) {</span>
            <span class="s3">// find adjacent v-if</span>
            <span class="s0">let </span><span class="s1">j = i</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">prev</span><span class="s0">;</span>
            <span class="s0">while </span><span class="s1">(j--) {</span>
                <span class="s1">prev = children[j]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(prev.type !== </span><span class="s4">3 </span><span class="s3">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                    <span class="s0">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(prev &amp;&amp; isTemplateNode(prev) &amp;&amp; findDir(prev</span><span class="s0">, </span><span class="s2">'if'</span><span class="s1">)) {</span>
                <span class="s3">// remove node</span>
                <span class="s1">children.splice(i</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">i--</span><span class="s0">;</span>
                <span class="s3">// attach this slot to previous conditional</span>
                <span class="s0">let </span><span class="s1">conditional = dynamicSlots[dynamicSlots.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s0">while </span><span class="s1">(conditional.alternate.type === </span><span class="s4">19 </span><span class="s3">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                    <span class="s1">conditional = conditional.alternate</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s1">conditional.alternate = vElse.exp</span>
                    <span class="s1">? createConditionalExpression(vElse.exp</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">, </span><span class="s1">defaultFallback)</span>
                    <span class="s1">: buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction</span><span class="s0">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s3">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s0">, </span><span class="s1">vElse.loc))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">((vFor = findDir(slotElement</span><span class="s0">, </span><span class="s2">'for'</span><span class="s1">))) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s0">true;</span>
            <span class="s0">const </span><span class="s1">parseResult = vFor.parseResult ||</span>
                <span class="s1">parseForExpression(vFor.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(parseResult) {</span>
                <span class="s3">// Render the dynamic slots as an array and add it to the createSlot()</span>
                <span class="s3">// args. The runtime knows how to handle it appropriately.</span>
                <span class="s1">dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">parseResult.source</span><span class="s0">,</span>
                    <span class="s1">createFunctionExpression(createForLoopParams(parseResult)</span><span class="s0">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s0">, </span><span class="s1">slotFunction)</span><span class="s0">, true </span><span class="s3">/* force newline */</span><span class="s1">)</span>
                <span class="s1">]))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s3">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">vFor.loc))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// check duplicate static names</span>
            <span class="s0">if </span><span class="s1">(staticSlotName) {</span>
                <span class="s0">if </span><span class="s1">(seenSlotNames.has(staticSlotName)) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">38 </span><span class="s3">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s0">, </span><span class="s1">dirLoc))</span><span class="s0">;</span>
                    <span class="s0">continue;</span>
                <span class="s1">}</span>
                <span class="s1">seenSlotNames.add(staticSlotName)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(staticSlotName === </span><span class="s2">'default'</span><span class="s1">) {</span>
                    <span class="s1">hasNamedDefaultSlot = </span><span class="s0">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">slotsProperties.push(createObjectProperty(slotName</span><span class="s0">, </span><span class="s1">slotFunction))</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!onComponentSlot) {</span>
        <span class="s0">const </span><span class="s1">buildDefaultSlotProperty = (props</span><span class="s0">, </span><span class="s1">children) =&gt; {</span>
            <span class="s0">const </span><span class="s1">fn = buildSlotFn(props</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(context.compatConfig) {</span>
                <span class="s1">fn.isNonScopedSlot = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">createObjectProperty(</span><span class="s2">`default`</span><span class="s0">, </span><span class="s1">fn)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!hasTemplateSlots) {</span>
            <span class="s3">// implicit default slot (on component)</span>
            <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s0">, </span><span class="s1">children))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(implicitDefaultChildren.length &amp;&amp;</span>
            <span class="s3">// #3766</span>
            <span class="s3">// with whitespace: 'preserve', whitespaces between slots will end up in</span>
            <span class="s3">// implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
            <span class="s1">implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))) {</span>
            <span class="s3">// implicit default slot (mixed with named slots)</span>
            <span class="s0">if </span><span class="s1">(hasNamedDefaultSlot) {</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">39 </span><span class="s3">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s0">, </span><span class="s1">implicitDefaultChildren[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s0">, </span><span class="s1">implicitDefaultChildren))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">slotFlag = hasDynamicSlots</span>
        <span class="s1">? </span><span class="s4">2 </span><span class="s3">/* SlotFlags.DYNAMIC */</span>
        <span class="s1">: hasForwardedSlots(node.children)</span>
            <span class="s1">? </span><span class="s4">3 </span><span class="s3">/* SlotFlags.FORWARDED */</span>
            <span class="s1">: </span><span class="s4">1 </span><span class="s3">/* SlotFlags.STABLE */</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">slots = createObjectExpression(slotsProperties.concat(createObjectProperty(</span><span class="s2">`_`</span><span class="s0">, </span>
    <span class="s3">// 2 = compiled but dynamic = can skip normalization, but must run diff</span>
    <span class="s3">// 1 = compiled and static = can skip normalization AND diff as optimized</span>
    <span class="s1">createSimpleExpression(slotFlag + ((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* </span><span class="s1">${slotFlagsText[slotFlag]} </span><span class="s2">*/` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">)</span><span class="s0">, false</span><span class="s1">)))</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(dynamicSlots.length) {</span>
        <span class="s1">slots = createCallExpression(context.helper(CREATE_SLOTS)</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">slots</span><span class="s0">,</span>
            <span class="s1">createArrayExpression(dynamicSlots)</span>
        <span class="s1">])</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">slots</span><span class="s0">,</span>
        <span class="s1">hasDynamicSlots</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">buildDynamicSlot(name</span><span class="s0">, </span><span class="s1">fn</span><span class="s0">, </span><span class="s1">index) {</span>
    <span class="s0">const </span><span class="s1">props = [</span>
        <span class="s1">createObjectProperty(</span><span class="s2">`name`</span><span class="s0">, </span><span class="s1">name)</span><span class="s0">,</span>
        <span class="s1">createObjectProperty(</span><span class="s2">`fn`</span><span class="s0">, </span><span class="s1">fn)</span>
    <span class="s1">]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(index != </span><span class="s0">null</span><span class="s1">) {</span>
        <span class="s1">props.push(createObjectProperty(</span><span class="s2">`key`</span><span class="s0">, </span><span class="s1">createSimpleExpression(String(index)</span><span class="s0">, true</span><span class="s1">)))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">createObjectExpression(props)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">hasForwardedSlots(children) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
        <span class="s0">switch </span><span class="s1">(child.type) {</span>
            <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(child.tagType === </span><span class="s4">2 </span><span class="s3">/* ElementTypes.SLOT */ </span><span class="s1">||</span>
                    <span class="s1">hasForwardedSlots(child.children)) {</span>
                    <span class="s0">return true;</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* NodeTypes.IF */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(hasForwardedSlots(child.branches))</span>
                    <span class="s0">return true;</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(hasForwardedSlots(child.children))</span>
                    <span class="s0">return true;</span>
                <span class="s0">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return false;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isNonWhitespaceContent(node) {</span>
    <span class="s0">if </span><span class="s1">(node.type !== </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp; node.type !== </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s1">)</span>
        <span class="s0">return true;</span>
    <span class="s0">return </span><span class="s1">node.type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span>
        <span class="s1">? !!node.content.trim()</span>
        <span class="s1">: isNonWhitespaceContent(node.content)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s3">// some directive transforms (e.g. v-model) may return a symbol for runtime</span>
<span class="s3">// import, which should be used instead of a resolveDirective call.</span>
<span class="s0">const </span><span class="s1">directiveImportMap = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">;</span>
<span class="s3">// generate a JavaScript AST for this element's codegen</span>
<span class="s0">const </span><span class="s1">transformElement = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s3">// perform the work on exit, after all child expressions have been</span>
    <span class="s3">// processed and merged.</span>
    <span class="s0">return function </span><span class="s1">postTransformElement() {</span>
        <span class="s1">node = context.currentNode</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                <span class="s1">node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">))) {</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">props } = node</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isComponent = node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s0">;</span>
        <span class="s3">// The goal of the transform is to create a codegenNode implementing the</span>
        <span class="s3">// VNodeCall interface.</span>
        <span class="s0">let </span><span class="s1">vnodeTag = isComponent</span>
            <span class="s1">? resolveComponentType(node</span><span class="s0">, </span><span class="s1">context)</span>
            <span class="s1">: </span><span class="s2">`&quot;</span><span class="s1">${tag}</span><span class="s2">&quot;`</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isDynamicComponent = isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vnodeProps</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vnodeChildren</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vnodePatchFlag</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vnodeDynamicProps</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">dynamicPropNames</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">vnodeDirectives</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">shouldUseBlock = </span>
        <span class="s3">// dynamic component may resolve to plain elements</span>
        <span class="s1">isDynamicComponent ||</span>
            <span class="s1">vnodeTag === TELEPORT ||</span>
            <span class="s1">vnodeTag === SUSPENSE ||</span>
            <span class="s1">(!isComponent &amp;&amp;</span>
                <span class="s3">// &lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
                <span class="s3">// updates inside get proper isSVG flag at runtime. (#639, #643)</span>
                <span class="s3">// This is technically web-specific, but splitting the logic out of core</span>
                <span class="s3">// leads to too much unnecessary complexity.</span>
                <span class="s1">(tag === </span><span class="s2">'svg' </span><span class="s1">|| tag === </span><span class="s2">'foreignObject'</span><span class="s1">))</span><span class="s0">;</span>
        <span class="s3">// props</span>
        <span class="s0">if </span><span class="s1">(props.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">propsBuildResult = buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">undefined</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">isDynamicComponent)</span><span class="s0">;</span>
            <span class="s1">vnodeProps = propsBuildResult.props</span><span class="s0">;</span>
            <span class="s1">patchFlag = propsBuildResult.patchFlag</span><span class="s0">;</span>
            <span class="s1">dynamicPropNames = propsBuildResult.dynamicPropNames</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">directives = propsBuildResult.directives</span><span class="s0">;</span>
            <span class="s1">vnodeDirectives =</span>
                <span class="s1">directives &amp;&amp; directives.length</span>
                    <span class="s1">? createArrayExpression(directives.map(dir =&gt; buildDirectiveArgs(dir</span><span class="s0">, </span><span class="s1">context)))</span>
                    <span class="s1">: undefined</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(propsBuildResult.shouldUseBlock) {</span>
                <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// children</span>
        <span class="s0">if </span><span class="s1">(node.children.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(vnodeTag === KEEP_ALIVE) {</span>
                <span class="s3">// Although a built-in component, we compile KeepAlive with raw children</span>
                <span class="s3">// instead of slot functions so that it can be used inside Transition</span>
                <span class="s3">// or other Transition-wrapping HOCs.</span>
                <span class="s3">// To ensure correct updates with block optimizations, we need to:</span>
                <span class="s3">// 1. Force keep-alive into a block. This avoids its children being</span>
                <span class="s3">//    collected by a parent block.</span>
                <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
                <span class="s3">// 2. Force keep-alive to always be updated, since it uses raw children.</span>
                <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; node.children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">46 </span><span class="s3">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s0">, </span><span class="s1">{</span>
                        <span class="s1">start: node.children[</span><span class="s4">0</span><span class="s1">].loc.start</span><span class="s0">,</span>
                        <span class="s1">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s1">].loc.end</span><span class="s0">,</span>
                        <span class="s1">source: </span><span class="s2">''</span>
                    <span class="s1">}))</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">shouldBuildAsSlots = isComponent &amp;&amp;</span>
                <span class="s3">// Teleport is not a real component and has dedicated runtime handling</span>
                <span class="s1">vnodeTag !== TELEPORT &amp;&amp;</span>
                <span class="s3">// explained above.</span>
                <span class="s1">vnodeTag !== KEEP_ALIVE</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(shouldBuildAsSlots) {</span>
                <span class="s0">const </span><span class="s1">{ slots</span><span class="s0">, </span><span class="s1">hasDynamicSlots } = buildSlots(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">vnodeChildren = slots</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(hasDynamicSlots) {</span>
                    <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s3">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; vnodeTag !== TELEPORT) {</span>
                <span class="s0">const </span><span class="s1">child = node.children[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">type = child.type</span><span class="s0">;</span>
                <span class="s3">// check for dynamic text children</span>
                <span class="s0">const </span><span class="s1">hasDynamicTextChild = type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(hasDynamicTextChild &amp;&amp;</span>
                    <span class="s1">getConstantType(child</span><span class="s0">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s1">patchFlag |= </span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s3">// pass directly if the only child is a text node</span>
                <span class="s3">// (plain / interpolation / expression)</span>
                <span class="s0">if </span><span class="s1">(hasDynamicTextChild || type === </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                    <span class="s1">vnodeChildren = child</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">vnodeChildren = node.children</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">vnodeChildren = node.children</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// patchFlag &amp; dynamicPropNames</span>
        <span class="s0">if </span><span class="s1">(patchFlag !== </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) {</span>
                <span class="s0">if </span><span class="s1">(patchFlag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">// special flags (negative and mutually exclusive)</span>
                    <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[patchFlag]} </span><span class="s2">*/`</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s3">// bitwise flags</span>
                    <span class="s0">const </span><span class="s1">flagNames = Object.keys(PatchFlagNames)</span>
                        <span class="s1">.map(Number)</span>
                        <span class="s1">.filter(n =&gt; n &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; n)</span>
                        <span class="s1">.map(n =&gt; PatchFlagNames[n])</span>
                        <span class="s1">.join(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s2">` /* </span><span class="s1">${flagNames} </span><span class="s2">*/`</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">vnodePatchFlag = String(patchFlag)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(dynamicPropNames &amp;&amp; dynamicPropNames.length) {</span>
                <span class="s1">vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">node.codegenNode = createVNodeCall(context</span><span class="s0">, </span><span class="s1">vnodeTag</span><span class="s0">, </span><span class="s1">vnodeProps</span><span class="s0">, </span><span class="s1">vnodeChildren</span><span class="s0">, </span><span class="s1">vnodePatchFlag</span><span class="s0">, </span><span class="s1">vnodeDynamicProps</span><span class="s0">, </span><span class="s1">vnodeDirectives</span><span class="s0">, </span><span class="s1">!!shouldUseBlock</span><span class="s0">, false </span><span class="s3">/* disableTracking */</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">resolveComponentType(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">let </span><span class="s1">{ tag } = node</span><span class="s0">;</span>
    <span class="s3">// 1. dynamic component</span>
    <span class="s0">const </span><span class="s1">isExplicitDynamic = isComponentTag(tag)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isProp = findProp(node</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isProp) {</span>
        <span class="s0">if </span><span class="s1">(isExplicitDynamic ||</span>
            <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context))) {</span>
            <span class="s0">const </span><span class="s1">exp = isProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s1">? isProp.value &amp;&amp; createSimpleExpression(isProp.value.content</span><span class="s0">, true</span><span class="s1">)</span>
                <span class="s1">: isProp.exp</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(exp) {</span>
                <span class="s0">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">exp</span>
                <span class="s1">])</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(isProp.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">isProp.value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
            <span class="s3">// &lt;button is=&quot;vue:xxx&quot;&gt;</span>
            <span class="s3">// if not &lt;component&gt;, only is value that starts with &quot;vue:&quot; will be</span>
            <span class="s3">// treated as component by the parse phase and reach here, unless it's</span>
            <span class="s3">// compat mode where all is values are considered components</span>
            <span class="s1">tag = isProp.value.content.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// 1.5 v-is (TODO: Deprecate)</span>
    <span class="s0">const </span><span class="s1">isDir = !isExplicitDynamic &amp;&amp; findDir(node</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isDir &amp;&amp; isDir.exp) {</span>
        <span class="s0">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">isDir.exp</span>
        <span class="s1">])</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
    <span class="s0">const </span><span class="s1">builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(builtIn) {</span>
        <span class="s3">// built-ins are simply fallthroughs / have special handling during ssr</span>
        <span class="s3">// so we don't need to import their runtime equivalents</span>
        <span class="s0">if </span><span class="s1">(!ssr)</span>
            <span class="s1">context.helper(builtIn)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">builtIn</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// 5. user component (resolve)</span>
    <span class="s1">context.helper(RESOLVE_COMPONENT)</span><span class="s0">;</span>
    <span class="s1">context.components.add(tag)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">toValidAssetId(tag</span><span class="s0">, </span><span class="s2">`component`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">props = node.props</span><span class="s0">, </span><span class="s1">isComponent</span><span class="s0">, </span><span class="s1">isDynamicComponent</span><span class="s0">, </span><span class="s1">ssr = </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">{ tag</span><span class="s0">, </span><span class="s1">loc: elementLoc</span><span class="s0">, </span><span class="s1">children } = node</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">properties = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">mergeArgs = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">runtimeDirectives = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">hasChildren = children.length &gt; </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">shouldUseBlock = </span><span class="s0">false;</span>
    <span class="s3">// patchFlag analysis</span>
    <span class="s0">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">hasRef = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasClassBinding = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasStyleBinding = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasHydrationEventBinding = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasDynamicKeys = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">hasVnodeHook = </span><span class="s0">false;</span>
    <span class="s0">const </span><span class="s1">dynamicPropNames = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">pushMergeArg = (arg) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(properties.length) {</span>
            <span class="s1">mergeArgs.push(createObjectExpression(dedupeProperties(properties)</span><span class="s0">, </span><span class="s1">elementLoc))</span><span class="s0">;</span>
            <span class="s1">properties = []</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(arg)</span>
            <span class="s1">mergeArgs.push(arg)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">analyzePatchFlag = ({ key</span><span class="s0">, </span><span class="s1">value }) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(isStaticExp(key)) {</span>
            <span class="s0">const </span><span class="s1">name = key.content</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">isEventHandler = isOn(name)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(isEventHandler &amp;&amp;</span>
                <span class="s1">(!isComponent || isDynamicComponent) &amp;&amp;</span>
                <span class="s3">// omit the flag for click handlers because hydration gives click</span>
                <span class="s3">// dedicated fast path.</span>
                <span class="s1">name.toLowerCase() !== </span><span class="s2">'onclick' </span><span class="s1">&amp;&amp;</span>
                <span class="s3">// omit v-model handlers</span>
                <span class="s1">name !== </span><span class="s2">'onUpdate:modelValue' </span><span class="s1">&amp;&amp;</span>
                <span class="s3">// omit onVnodeXXX hooks</span>
                <span class="s1">!isReservedProp(name)) {</span>
                <span class="s1">hasHydrationEventBinding = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(isEventHandler &amp;&amp; isReservedProp(name)) {</span>
                <span class="s1">hasVnodeHook = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(value.type === </span><span class="s4">20 </span><span class="s3">/* NodeTypes.JS_CACHE_EXPRESSION */ </span><span class="s1">||</span>
                <span class="s1">((value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
                    <span class="s1">value.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">getConstantType(value</span><span class="s0">, </span><span class="s1">context) &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
                <span class="s3">// skip if the prop is a cached handler or has constant value</span>
                <span class="s0">return;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'ref'</span><span class="s1">) {</span>
                <span class="s1">hasRef = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(name === </span><span class="s2">'class'</span><span class="s1">) {</span>
                <span class="s1">hasClassBinding = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(name === </span><span class="s2">'style'</span><span class="s1">) {</span>
                <span class="s1">hasStyleBinding = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(name !== </span><span class="s2">'key' </span><span class="s1">&amp;&amp; !dynamicPropNames.includes(name)) {</span>
                <span class="s1">dynamicPropNames.push(name)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s3">// treat the dynamic class and style binding of the component as dynamic props</span>
            <span class="s0">if </span><span class="s1">(isComponent &amp;&amp;</span>
                <span class="s1">(name === </span><span class="s2">'class' </span><span class="s1">|| name === </span><span class="s2">'style'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">!dynamicPropNames.includes(name)) {</span>
                <span class="s1">dynamicPropNames.push(name)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">hasDynamicKeys = </span><span class="s0">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s3">// static attribute</span>
        <span class="s0">const </span><span class="s1">prop = props[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">{ loc</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value } = prop</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">isStatic = </span><span class="s0">true;</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'ref'</span><span class="s1">) {</span>
                <span class="s1">hasRef = </span><span class="s0">true;</span>
                <span class="s0">if </span><span class="s1">(context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s2">'ref_for'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">'true'</span><span class="s1">)))</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// skip is on &lt;component&gt;, or is=&quot;vue:xxx&quot;</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'is' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(isComponentTag(tag) ||</span>
                    <span class="s1">(value &amp;&amp; value.content.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) ||</span>
                    <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context)))) {</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s1">properties.push(createObjectProperty(createSimpleExpression(name</span><span class="s0">, true, </span><span class="s1">getInnerRange(loc</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">name.length))</span><span class="s0">, </span><span class="s1">createSimpleExpression(value ? value.content : </span><span class="s2">''</span><span class="s0">, </span><span class="s1">isStatic</span><span class="s0">, </span><span class="s1">value ? value.loc : loc)))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// directives</span>
            <span class="s0">const </span><span class="s1">{ name</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">loc } = prop</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">isVBind = name === </span><span class="s2">'bind'</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">isVOn = name === </span><span class="s2">'on'</span><span class="s0">;</span>
            <span class="s3">// skip v-slot - it is handled by its dedicated transform.</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'slot'</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(!isComponent) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">40 </span><span class="s3">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s3">// skip v-once/v-memo - they are handled by dedicated transforms.</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'once' </span><span class="s1">|| name === </span><span class="s2">'memo'</span><span class="s1">) {</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s3">// skip v-is and :is on &lt;component&gt;</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'is' </span><span class="s1">||</span>
                <span class="s1">(isVBind &amp;&amp;</span>
                    <span class="s1">isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'is'</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">(isComponentTag(tag) ||</span>
                        <span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s0">, </span><span class="s1">context))))) {</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s3">// skip v-on in SSR compilation</span>
            <span class="s0">if </span><span class="s1">(isVOn &amp;&amp; ssr) {</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(</span>
            <span class="s3">// #938: elements with dynamic keys should be forced into blocks</span>
            <span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'key'</span><span class="s1">)) ||</span>
                <span class="s3">// inline before-update hooks need to force block so that it is invoked</span>
                <span class="s3">// before children</span>
                <span class="s1">(isVOn &amp;&amp; hasChildren &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'vue:before-update'</span><span class="s1">))) {</span>
                <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s0">, </span><span class="s2">'ref'</span><span class="s1">) &amp;&amp; context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s2">'ref_for'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">'true'</span><span class="s1">)))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s3">// special case for v-bind and v-on with no argument</span>
            <span class="s0">if </span><span class="s1">(!arg &amp;&amp; (isVBind || isVOn)) {</span>
                <span class="s1">hasDynamicKeys = </span><span class="s0">true;</span>
                <span class="s0">if </span><span class="s1">(exp) {</span>
                    <span class="s0">if </span><span class="s1">(isVBind) {</span>
                        <span class="s3">// have to merge early for compat build check</span>
                        <span class="s1">pushMergeArg()</span><span class="s0">;</span>
                        <span class="s1">{</span>
                            <span class="s3">// 2.x v-bind object order compat</span>
                            <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)) {</span>
                                <span class="s0">const </span><span class="s1">hasOverridableKeys = mergeArgs.some(arg =&gt; {</span>
                                    <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
                                        <span class="s0">return </span><span class="s1">arg.properties.some(({ key }) =&gt; {</span>
                                            <span class="s0">if </span><span class="s1">(key.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
                                                <span class="s1">!key.isStatic) {</span>
                                                <span class="s0">return true;</span>
                                            <span class="s1">}</span>
                                            <span class="s0">return </span><span class="s1">(key.content !== </span><span class="s2">'class' </span><span class="s1">&amp;&amp;</span>
                                                <span class="s1">key.content !== </span><span class="s2">'style' </span><span class="s1">&amp;&amp;</span>
                                                <span class="s1">!isOn(key.content))</span><span class="s0">;</span>
                                        <span class="s1">})</span><span class="s0">;</span>
                                    <span class="s1">}</span>
                                    <span class="s0">else </span><span class="s1">{</span>
                                        <span class="s3">// dynamic expression</span>
                                        <span class="s0">return true;</span>
                                    <span class="s1">}</span>
                                <span class="s1">})</span><span class="s0">;</span>
                                <span class="s0">if </span><span class="s1">(hasOverridableKeys) {</span>
                                    <span class="s1">checkCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s0">if </span><span class="s1">(isCompatEnabled(</span><span class="s2">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s0">, </span><span class="s1">context)) {</span>
                                <span class="s1">mergeArgs.unshift(exp)</span><span class="s0">;</span>
                                <span class="s0">continue;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s1">mergeArgs.push(exp)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else </span><span class="s1">{</span>
                        <span class="s3">// v-on=&quot;obj&quot; -&gt; toHandlers(obj)</span>
                        <span class="s1">pushMergeArg({</span>
                            <span class="s1">type: </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s0">,</span>
                            <span class="s1">loc</span><span class="s0">,</span>
                            <span class="s1">callee: context.helper(TO_HANDLERS)</span><span class="s0">,</span>
                            <span class="s1">arguments: isComponent ? [exp] : [exp</span><span class="s0">, </span><span class="s2">`true`</span><span class="s1">]</span>
                        <span class="s1">})</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">context.onError(createCompilerError(isVBind</span>
                        <span class="s1">? </span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span>
                        <span class="s1">: </span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">continue;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">directiveTransform = context.directiveTransforms[name]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(directiveTransform) {</span>
                <span class="s3">// has built-in directive transform.</span>
                <span class="s0">const </span><span class="s1">{ props</span><span class="s0">, </span><span class="s1">needRuntime } = directiveTransform(prop</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">!ssr &amp;&amp; props.forEach(analyzePatchFlag)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isVOn &amp;&amp; arg &amp;&amp; !isStaticExp(arg)) {</span>
                    <span class="s1">pushMergeArg(createObjectExpression(props</span><span class="s0">, </span><span class="s1">elementLoc))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">properties.push(...props)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(needRuntime) {</span>
                    <span class="s1">runtimeDirectives.push(prop)</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(isSymbol(needRuntime)) {</span>
                        <span class="s1">directiveImportMap.set(prop</span><span class="s0">, </span><span class="s1">needRuntime)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(!isBuiltInDirective(name)) {</span>
                <span class="s3">// no built-in transform, this is a user custom directive.</span>
                <span class="s1">runtimeDirectives.push(prop)</span><span class="s0">;</span>
                <span class="s3">// custom dirs may use beforeUpdate so they need to force blocks</span>
                <span class="s3">// to ensure before-update gets called before children update</span>
                <span class="s0">if </span><span class="s1">(hasChildren) {</span>
                    <span class="s1">shouldUseBlock = </span><span class="s0">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">propsExpression = undefined</span><span class="s0">;</span>
    <span class="s3">// has v-bind=&quot;object&quot; or v-on=&quot;object&quot;, wrap with mergeProps</span>
    <span class="s0">if </span><span class="s1">(mergeArgs.length) {</span>
        <span class="s3">// close up any not-yet-merged props</span>
        <span class="s1">pushMergeArg()</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(mergeArgs.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">propsExpression = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s0">, </span><span class="s1">mergeArgs</span><span class="s0">, </span><span class="s1">elementLoc)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// single v-bind with nothing else - no need for a mergeProps call</span>
            <span class="s1">propsExpression = mergeArgs[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(properties.length) {</span>
        <span class="s1">propsExpression = createObjectExpression(dedupeProperties(properties)</span><span class="s0">, </span><span class="s1">elementLoc)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// patchFlag analysis</span>
    <span class="s0">if </span><span class="s1">(hasDynamicKeys) {</span>
        <span class="s1">patchFlag |= </span><span class="s4">16 </span><span class="s3">/* PatchFlags.FULL_PROPS */</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(hasClassBinding &amp;&amp; !isComponent) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">2 </span><span class="s3">/* PatchFlags.CLASS */</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hasStyleBinding &amp;&amp; !isComponent) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">4 </span><span class="s3">/* PatchFlags.STYLE */</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(dynamicPropNames.length) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">8 </span><span class="s3">/* PatchFlags.PROPS */</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hasHydrationEventBinding) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!shouldUseBlock &amp;&amp;</span>
        <span class="s1">(patchFlag === </span><span class="s4">0 </span><span class="s1">|| patchFlag === </span><span class="s4">32 </span><span class="s3">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(hasRef || hasVnodeHook || runtimeDirectives.length &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">patchFlag |= </span><span class="s4">512 </span><span class="s3">/* PatchFlags.NEED_PATCH */</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// pre-normalize props, SSR is skipped for now</span>
    <span class="s0">if </span><span class="s1">(!context.inSSR &amp;&amp; propsExpression) {</span>
        <span class="s0">switch </span><span class="s1">(propsExpression.type) {</span>
            <span class="s0">case </span><span class="s4">15 </span><span class="s3">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
                <span class="s3">// means that there is no v-bind,</span>
                <span class="s3">// but still need to deal with dynamic key binding</span>
                <span class="s0">let </span><span class="s1">classKeyIndex = -</span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">let </span><span class="s1">styleKeyIndex = -</span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">let </span><span class="s1">hasDynamicKey = </span><span class="s0">false;</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; propsExpression.properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                    <span class="s0">const </span><span class="s1">key = propsExpression.properties[i].key</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(isStaticExp(key)) {</span>
                        <span class="s0">if </span><span class="s1">(key.content === </span><span class="s2">'class'</span><span class="s1">) {</span>
                            <span class="s1">classKeyIndex = i</span><span class="s0">;</span>
                        <span class="s1">}</span>
                        <span class="s0">else if </span><span class="s1">(key.content === </span><span class="s2">'style'</span><span class="s1">) {</span>
                            <span class="s1">styleKeyIndex = i</span><span class="s0">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(!key.isHandlerKey) {</span>
                        <span class="s1">hasDynamicKey = </span><span class="s0">true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">classProp = propsExpression.properties[classKeyIndex]</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">styleProp = propsExpression.properties[styleKeyIndex]</span><span class="s0">;</span>
                <span class="s3">// no dynamic key</span>
                <span class="s0">if </span><span class="s1">(!hasDynamicKey) {</span>
                    <span class="s0">if </span><span class="s1">(classProp &amp;&amp; !isStaticExp(classProp.value)) {</span>
                        <span class="s1">classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS)</span><span class="s0">, </span><span class="s1">[classProp.value])</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s0">if </span><span class="s1">(styleProp &amp;&amp;</span>
                        <span class="s3">// the static style is compiled into an object,</span>
                        <span class="s3">// so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
                        <span class="s1">(hasStyleBinding ||</span>
                            <span class="s1">(styleProp.value.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">styleProp.value.content.trim()[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">`[`</span><span class="s1">) ||</span>
                            <span class="s3">// v-bind:style and style both exist,</span>
                            <span class="s3">// v-bind:style with static literal object</span>
                            <span class="s1">styleProp.value.type === </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">)) {</span>
                        <span class="s1">styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE)</span><span class="s0">, </span><span class="s1">[styleProp.value])</span><span class="s0">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s3">// dynamic key binding, wrap with `normalizeProps`</span>
                    <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s0">, </span><span class="s1">[propsExpression])</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">break;</span>
            <span class="s0">case </span><span class="s4">14 </span><span class="s3">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
                <span class="s3">// mergeProps call, do nothing</span>
                <span class="s0">break;</span>
            <span class="s0">default</span><span class="s1">:</span>
                <span class="s3">// single v-bind</span>
                <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">createCallExpression(context.helper(GUARD_REACTIVE_PROPS)</span><span class="s0">, </span><span class="s1">[</span>
                        <span class="s1">propsExpression</span>
                    <span class="s1">])</span>
                <span class="s1">])</span><span class="s0">;</span>
                <span class="s0">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">props: propsExpression</span><span class="s0">,</span>
        <span class="s1">directives: runtimeDirectives</span><span class="s0">,</span>
        <span class="s1">patchFlag</span><span class="s0">,</span>
        <span class="s1">dynamicPropNames</span><span class="s0">,</span>
        <span class="s1">shouldUseBlock</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s3">// Dedupe props in an object literal.</span>
<span class="s3">// Literal duplicated attributes would have been warned during the parse phase,</span>
<span class="s3">// however, it's possible to encounter duplicated `onXXX` handlers with different</span>
<span class="s3">// modifiers. We also need to merge static and dynamic class / style attributes.</span>
<span class="s3">// - onXXX handlers / style: merge into array</span>
<span class="s3">// - class: merge into single expression with concatenation</span>
<span class="s0">function </span><span class="s1">dedupeProperties(properties) {</span>
    <span class="s0">const </span><span class="s1">knownProps = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">deduped = []</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; properties.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">prop = properties[i]</span><span class="s0">;</span>
        <span class="s3">// dynamic keys are always allowed</span>
        <span class="s0">if </span><span class="s1">(prop.key.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */ </span><span class="s1">|| !prop.key.isStatic) {</span>
            <span class="s1">deduped.push(prop)</span><span class="s0">;</span>
            <span class="s0">continue;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">name = prop.key.content</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">existing = knownProps.get(name)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(existing) {</span>
            <span class="s0">if </span><span class="s1">(name === </span><span class="s2">'style' </span><span class="s1">|| name === </span><span class="s2">'class' </span><span class="s1">|| isOn(name)) {</span>
                <span class="s1">mergeAsArray(existing</span><span class="s0">, </span><span class="s1">prop)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s3">// unexpected duplicate, should have emitted error during parse</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">knownProps.set(name</span><span class="s0">, </span><span class="s1">prop)</span><span class="s0">;</span>
            <span class="s1">deduped.push(prop)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">deduped</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mergeAsArray(existing</span><span class="s0">, </span><span class="s1">incoming) {</span>
    <span class="s0">if </span><span class="s1">(existing.value.type === </span><span class="s4">17 </span><span class="s3">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">existing.value.elements.push(incoming.value)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">existing.value = createArrayExpression([existing.value</span><span class="s0">, </span><span class="s1">incoming.value]</span><span class="s0">, </span><span class="s1">existing.loc)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">buildDirectiveArgs(dir</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">dirArgs = []</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">runtime = directiveImportMap.get(dir)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(runtime) {</span>
        <span class="s3">// built-in directive with runtime</span>
        <span class="s1">dirArgs.push(context.helperString(runtime))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">{</span>
            <span class="s3">// inject statement for resolving directive</span>
            <span class="s1">context.helper(RESOLVE_DIRECTIVE)</span><span class="s0">;</span>
            <span class="s1">context.directives.add(dir.name)</span><span class="s0">;</span>
            <span class="s1">dirArgs.push(toValidAssetId(dir.name</span><span class="s0">, </span><span class="s2">`directive`</span><span class="s1">))</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">{ loc } = dir</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(dir.exp)</span>
        <span class="s1">dirArgs.push(dir.exp)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(dir.arg) {</span>
        <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
            <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">dirArgs.push(dir.arg)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(Object.keys(dir.modifiers).length) {</span>
        <span class="s0">if </span><span class="s1">(!dir.arg) {</span>
            <span class="s0">if </span><span class="s1">(!dir.exp) {</span>
                <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">dirArgs.push(</span><span class="s2">`void 0`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">trueExpression = createSimpleExpression(</span><span class="s2">`true`</span><span class="s0">, false, </span><span class="s1">loc)</span><span class="s0">;</span>
        <span class="s1">dirArgs.push(createObjectExpression(dir.modifiers.map(modifier =&gt; createObjectProperty(modifier</span><span class="s0">, </span><span class="s1">trueExpression))</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">createArrayExpression(dirArgs</span><span class="s0">, </span><span class="s1">dir.loc)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">stringifyDynamicPropNames(props) {</span>
    <span class="s0">let </span><span class="s1">propsNamesString = </span><span class="s2">`[`</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">, </span><span class="s1">l = props.length</span><span class="s0">; </span><span class="s1">i &lt; l</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s1">propsNamesString += JSON.stringify(props[i])</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(i &lt; l - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">propsNamesString += </span><span class="s2">', '</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">propsNamesString + </span><span class="s2">`]`</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isComponentTag(tag) {</span>
    <span class="s0">return </span><span class="s1">tag === </span><span class="s2">'component' </span><span class="s1">|| tag === </span><span class="s2">'Component'</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)</span>
    <span class="s1">? Object.freeze({})</span>
    <span class="s1">: {}</span><span class="s0">;</span>
<span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? Object.freeze([]) : []</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">cacheStringFunction = (fn) =&gt; {</span>
    <span class="s0">const </span><span class="s1">cache = Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">((str) =&gt; {</span>
        <span class="s0">const </span><span class="s1">hit = cache[str]</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">hit || (cache[str] = fn(str))</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">camelizeRE = </span><span class="s4">/-(\w)/g</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">*/</span>
<span class="s0">const </span><span class="s1">camelize = cacheStringFunction((str) =&gt; {</span>
    <span class="s0">return </span><span class="s1">str.replace(camelizeRE</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">c) =&gt; (c ? c.toUpperCase() : </span><span class="s2">''</span><span class="s1">))</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">transformSlotOutlet = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(isSlotOutlet(node)) {</span>
        <span class="s0">const </span><span class="s1">{ children</span><span class="s0">, </span><span class="s1">loc } = node</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ slotName</span><span class="s0">, </span><span class="s1">slotProps } = processSlotOutlet(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">slotArgs = [</span>
            <span class="s1">context.prefixIdentifiers ? </span><span class="s2">`_ctx.$slots` </span><span class="s1">: </span><span class="s2">`$slots`</span><span class="s0">,</span>
            <span class="s1">slotName</span><span class="s0">,</span>
            <span class="s2">'{}'</span><span class="s0">,</span>
            <span class="s2">'undefined'</span><span class="s0">,</span>
            <span class="s2">'true'</span>
        <span class="s1">]</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">expectedLen = </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(slotProps) {</span>
            <span class="s1">slotArgs[</span><span class="s4">2</span><span class="s1">] = slotProps</span><span class="s0">;</span>
            <span class="s1">expectedLen = </span><span class="s4">3</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(children.length) {</span>
            <span class="s1">slotArgs[</span><span class="s4">3</span><span class="s1">] = createFunctionExpression([]</span><span class="s0">, </span><span class="s1">children</span><span class="s0">, false, false, </span><span class="s1">loc)</span><span class="s0">;</span>
            <span class="s1">expectedLen = </span><span class="s4">4</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(context.scopeId &amp;&amp; !context.slotted) {</span>
            <span class="s1">expectedLen = </span><span class="s4">5</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">slotArgs.splice(expectedLen)</span><span class="s0">; </span><span class="s3">// remove unused arguments</span>
        <span class="s1">node.codegenNode = createCallExpression(context.helper(RENDER_SLOT)</span><span class="s0">, </span><span class="s1">slotArgs</span><span class="s0">, </span><span class="s1">loc)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">processSlotOutlet(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">let </span><span class="s1">slotName = </span><span class="s2">`&quot;default&quot;`</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">slotProps = undefined</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">nonNameProps = []</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.props.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">p = node.props[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s3">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(p.value) {</span>
                <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'name'</span><span class="s1">) {</span>
                    <span class="s1">slotName = JSON.stringify(p.value.content)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">p.name = camelize(p.name)</span><span class="s0">;</span>
                    <span class="s1">nonNameProps.push(p)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; isStaticArgOf(p.arg</span><span class="s0">, </span><span class="s2">'name'</span><span class="s1">)) {</span>
                <span class="s0">if </span><span class="s1">(p.exp)</span>
                    <span class="s1">slotName = p.exp</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">if </span><span class="s1">(p.name === </span><span class="s2">'bind' </span><span class="s1">&amp;&amp; p.arg &amp;&amp; isStaticExp(p.arg)) {</span>
                    <span class="s1">p.arg.content = camelize(p.arg.content)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s1">nonNameProps.push(p)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(nonNameProps.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">{ props</span><span class="s0">, </span><span class="s1">directives } = buildProps(node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">nonNameProps</span><span class="s0">, false, false</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">slotProps = props</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(directives.length) {</span>
            <span class="s1">context.onError(createCompilerError(</span><span class="s4">36 </span><span class="s3">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s0">, </span><span class="s1">directives[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">slotName</span><span class="s0">,</span>
        <span class="s1">slotProps</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">fnExpRE = </span><span class="s4">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">transformOn = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">augmentor) =&gt; {</span>
    <span class="s0">const </span><span class="s1">{ loc</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">arg } = dir</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!dir.exp &amp;&amp; !modifiers.length) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">35 </span><span class="s3">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">eventName</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
            <span class="s0">let </span><span class="s1">rawName = arg.content</span><span class="s0">;</span>
            <span class="s3">// TODO deprecate @vnodeXXX usage</span>
            <span class="s0">if </span><span class="s1">(rawName.startsWith(</span><span class="s2">'vue:'</span><span class="s1">)) {</span>
                <span class="s1">rawName = </span><span class="s2">`vnode-</span><span class="s1">${rawName.slice(</span><span class="s4">4</span><span class="s1">)}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">eventString = node.tagType !== </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                <span class="s1">rawName.startsWith(</span><span class="s2">'vnode'</span><span class="s1">) ||</span>
                <span class="s1">!</span><span class="s4">/[A-Z]/</span><span class="s1">.test(rawName)</span>
                <span class="s1">? </span><span class="s3">// for non-element and vnode lifecycle event listeners, auto convert</span>
                    <span class="s3">// it to camelCase. See issue #2249</span>
                    <span class="s1">toHandlerKey(camelize$1(rawName))</span>
                <span class="s1">: </span><span class="s3">// preserve case for plain element listeners that have uppercase</span>
                    <span class="s3">// letters, as these may be custom elements' custom events</span>
                    <span class="s2">`on:</span><span class="s1">${rawName}</span><span class="s2">`</span><span class="s0">;</span>
            <span class="s1">eventName = createSimpleExpression(eventString</span><span class="s0">, true, </span><span class="s1">arg.loc)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s3">// #2388</span>
            <span class="s1">eventName = createCompoundExpression([</span>
                <span class="s2">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s2">(`</span><span class="s0">,</span>
                <span class="s1">arg</span><span class="s0">,</span>
                <span class="s2">`)`</span>
            <span class="s1">])</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s3">// already a compound expression.</span>
        <span class="s1">eventName = arg</span><span class="s0">;</span>
        <span class="s1">eventName.children.unshift(</span><span class="s2">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">eventName.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// handler processing</span>
    <span class="s0">let </span><span class="s1">exp = dir.exp</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(exp &amp;&amp; !exp.content.trim()) {</span>
        <span class="s1">exp = undefined</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">shouldCache = context.cacheHandlers &amp;&amp; !exp &amp;&amp; !context.inVOnce</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(exp) {</span>
        <span class="s0">const </span><span class="s1">isMemberExp = isMemberExpression(exp.content)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">hasMultipleStatements = exp.content.includes(</span><span class="s2">`;`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp; </span><span class="s0">true</span><span class="s1">) {</span>
            <span class="s1">validateBrowserExpression(exp</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, false, </span><span class="s1">hasMultipleStatements)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isInlineStatement || (shouldCache &amp;&amp; isMemberExp)) {</span>
            <span class="s3">// wrap inline statement in a function expression</span>
            <span class="s1">exp = createCompoundExpression([</span>
                <span class="s2">`</span><span class="s1">${isInlineStatement</span>
                    <span class="s1">? </span><span class="s2">`$event`</span>
                    <span class="s1">: </span><span class="s2">`</span><span class="s1">${</span><span class="s2">``</span><span class="s1">}</span><span class="s2">(...args)`</span><span class="s1">} </span><span class="s2">=&gt; </span><span class="s1">${hasMultipleStatements ? </span><span class="s2">`{` </span><span class="s1">: </span><span class="s2">`(`</span><span class="s1">}</span><span class="s2">`</span><span class="s0">,</span>
                <span class="s1">exp</span><span class="s0">,</span>
                <span class="s1">hasMultipleStatements ? </span><span class="s2">`}` </span><span class="s1">: </span><span class="s2">`)`</span>
            <span class="s1">])</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">ret = {</span>
        <span class="s1">props: [</span>
            <span class="s1">createObjectProperty(eventName</span><span class="s0">, </span><span class="s1">exp || createSimpleExpression(</span><span class="s2">`() =&gt; {}`</span><span class="s0">, false, </span><span class="s1">loc))</span>
        <span class="s1">]</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s3">// apply extended compiler augmentor</span>
    <span class="s0">if </span><span class="s1">(augmentor) {</span>
        <span class="s1">ret = augmentor(ret)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(shouldCache) {</span>
        <span class="s3">// cache handlers so that it's always the same handler being passed down.</span>
        <span class="s3">// this avoids unnecessary re-renders when users use inline handlers on</span>
        <span class="s3">// components.</span>
        <span class="s1">ret.props[</span><span class="s4">0</span><span class="s1">].value = context.cache(ret.props[</span><span class="s4">0</span><span class="s1">].value)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// mark the key as handler for props normalization check</span>
    <span class="s1">ret.props.forEach(p =&gt; (p.key.isHandlerKey = </span><span class="s0">true</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s3">// v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
<span class="s3">// codegen for the entire props object. This transform here is only for v-bind</span>
<span class="s3">// *with* args.</span>
<span class="s0">const </span><span class="s1">transformBind = (dir</span><span class="s0">, </span><span class="s1">_node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">modifiers</span><span class="s0">, </span><span class="s1">loc } = dir</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">arg = dir.arg</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(arg.type !== </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">arg.children.unshift(</span><span class="s2">`(`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">arg.children.push(</span><span class="s2">`) || &quot;&quot;`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(!arg.isStatic) {</span>
        <span class="s1">arg.content = </span><span class="s2">`</span><span class="s1">${arg.content} </span><span class="s2">|| &quot;&quot;`</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// .sync is replaced by v-model:arg</span>
    <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'camel'</span><span class="s1">)) {</span>
        <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
                <span class="s1">arg.content = camelize$1(arg.content)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">arg.content = </span><span class="s2">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s2">(</span><span class="s1">${arg.content}</span><span class="s2">)`</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">arg.children.unshift(</span><span class="s2">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s2">(`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">arg.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!context.inSSR) {</span>
        <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'prop'</span><span class="s1">)) {</span>
            <span class="s1">injectPrefix(arg</span><span class="s0">, </span><span class="s2">'.'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(modifiers.includes(</span><span class="s2">'attr'</span><span class="s1">)) {</span>
            <span class="s1">injectPrefix(arg</span><span class="s0">, </span><span class="s2">'^'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!exp ||</span>
        <span class="s1">(exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !exp.content.trim())) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">34 </span><span class="s3">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">loc))</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">props: [createObjectProperty(arg</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">''</span><span class="s0">, true, </span><span class="s1">loc))]</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">props: [createObjectProperty(arg</span><span class="s0">, </span><span class="s1">exp)]</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">injectPrefix = (arg</span><span class="s0">, </span><span class="s1">prefix) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(arg.isStatic) {</span>
            <span class="s1">arg.content = prefix + arg.content</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">arg.content = </span><span class="s2">`</span><span class="s0">\`</span><span class="s1">${prefix}</span><span class="s0">\$</span><span class="s2">{</span><span class="s1">${arg.content}</span><span class="s2">}</span><span class="s0">\`</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">arg.children.unshift(</span><span class="s2">`'</span><span class="s1">${prefix}</span><span class="s2">' + (`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">arg.children.push(</span><span class="s2">`)`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s3">// Merge adjacent text nodes and expressions into a single expression</span>
<span class="s3">// e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
<span class="s0">const </span><span class="s1">transformText = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">11 </span><span class="s3">/* NodeTypes.FOR */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">10 </span><span class="s3">/* NodeTypes.IF_BRANCH */</span><span class="s1">) {</span>
        <span class="s3">// perform the transform on node exit so that all expressions have already</span>
        <span class="s3">// been processed.</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s0">const </span><span class="s1">children = node.children</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">currentContainer = undefined</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">hasText = </span><span class="s0">false;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isText$1(child)) {</span>
                    <span class="s1">hasText = </span><span class="s0">true;</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s0">; </span><span class="s1">j &lt; children.length</span><span class="s0">; </span><span class="s1">j++) {</span>
                        <span class="s0">const </span><span class="s1">next = children[j]</span><span class="s0">;</span>
                        <span class="s0">if </span><span class="s1">(isText$1(next)) {</span>
                            <span class="s0">if </span><span class="s1">(!currentContainer) {</span>
                                <span class="s1">currentContainer = children[i] = createCompoundExpression([child]</span><span class="s0">, </span><span class="s1">child.loc)</span><span class="s0">;</span>
                            <span class="s1">}</span>
                            <span class="s3">// merge adjacent text node into current</span>
                            <span class="s1">currentContainer.children.push(</span><span class="s2">` + `</span><span class="s0">, </span><span class="s1">next)</span><span class="s0">;</span>
                            <span class="s1">children.splice(j</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                            <span class="s1">j--</span><span class="s0">;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s1">currentContainer = undefined</span><span class="s0">;</span>
                            <span class="s0">break;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(!hasText ||</span>
                <span class="s3">// if this is a plain element with a single text child, leave it</span>
                <span class="s3">// as-is since the runtime has dedicated fast path for this by directly</span>
                <span class="s3">// setting textContent of the element.</span>
                <span class="s3">// for component root it's always normalized anyway.</span>
                <span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">(node.type === </span><span class="s4">0 </span><span class="s3">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
                        <span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s3">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                            <span class="s3">// #3756</span>
                            <span class="s3">// custom directives can potentially add DOM elements arbitrarily,</span>
                            <span class="s3">// we need to avoid setting textContent of the element at runtime</span>
                            <span class="s3">// to avoid accidentally overwriting the DOM elements added</span>
                            <span class="s3">// by the user through custom directives.</span>
                            <span class="s1">!node.props.find(p =&gt; p.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">!context.directiveTransforms[p.name]) &amp;&amp;</span>
                            <span class="s3">// in compat mode, &lt;template&gt; tags with no special directives</span>
                            <span class="s3">// will be rendered as a fragment so its children must be</span>
                            <span class="s3">// converted into vnodes.</span>
                            <span class="s1">!(node.tag === </span><span class="s2">'template'</span><span class="s1">))))) {</span>
                <span class="s0">return;</span>
            <span class="s1">}</span>
            <span class="s3">// pre-convert text nodes into createTextVNode(text) calls to avoid</span>
            <span class="s3">// runtime normalization.</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                <span class="s0">const </span><span class="s1">child = children[i]</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(isText$1(child) || child.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
                    <span class="s0">const </span><span class="s1">callArgs = []</span><span class="s0">;</span>
                    <span class="s3">// createTextVNode defaults to single whitespace, so if it is a</span>
                    <span class="s3">// single space the code could be an empty call to save bytes.</span>
                    <span class="s0">if </span><span class="s1">(child.type !== </span><span class="s4">2 </span><span class="s3">/* NodeTypes.TEXT */ </span><span class="s1">|| child.content !== </span><span class="s2">' '</span><span class="s1">) {</span>
                        <span class="s1">callArgs.push(child)</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// mark dynamic text with flag so it gets patched inside a block</span>
                    <span class="s0">if </span><span class="s1">(!context.ssr &amp;&amp;</span>
                        <span class="s1">getConstantType(child</span><span class="s0">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s3">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                        <span class="s1">callArgs.push(</span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */ </span><span class="s1">+</span>
                            <span class="s1">((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) ? </span><span class="s2">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">1 </span><span class="s3">/* PatchFlags.TEXT */</span><span class="s1">]} </span><span class="s2">*/` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">))</span><span class="s0">;</span>
                    <span class="s1">}</span>
                    <span class="s1">children[i] = {</span>
                        <span class="s1">type: </span><span class="s4">12 </span><span class="s3">/* NodeTypes.TEXT_CALL */</span><span class="s0">,</span>
                        <span class="s1">content: child</span><span class="s0">,</span>
                        <span class="s1">loc: child.loc</span><span class="s0">,</span>
                        <span class="s1">codegenNode: createCallExpression(context.helper(CREATE_TEXT)</span><span class="s0">, </span><span class="s1">callArgs)</span>
                    <span class="s1">}</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">seen$1 = </span><span class="s0">new </span><span class="s1">WeakSet()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">transformOnce = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; findDir(node</span><span class="s0">, </span><span class="s2">'once'</span><span class="s0">, true</span><span class="s1">)) {</span>
        <span class="s0">if </span><span class="s1">(seen$1.has(node) || context.inVOnce) {</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s1">seen$1.add(node)</span><span class="s0">;</span>
        <span class="s1">context.inVOnce = </span><span class="s0">true;</span>
        <span class="s1">context.helper(SET_BLOCK_TRACKING)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s1">context.inVOnce = </span><span class="s0">false;</span>
            <span class="s0">const </span><span class="s1">cur = context.currentNode</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(cur.codegenNode) {</span>
                <span class="s1">cur.codegenNode = context.cache(cur.codegenNode</span><span class="s0">, true </span><span class="s3">/* isVNode */</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">transformModel = (dir</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">const </span><span class="s1">{ exp</span><span class="s0">, </span><span class="s1">arg } = dir</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!exp) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">41 </span><span class="s3">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s0">, </span><span class="s1">dir.loc))</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">rawExp = exp.loc.source</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">expString = exp.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">? exp.content : rawExp</span><span class="s0">;</span>
    <span class="s3">// im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
    <span class="s3">// _unref(exp)</span>
    <span class="s0">const </span><span class="s1">bindingType = context.bindingMetadata[rawExp]</span><span class="s0">;</span>
    <span class="s3">// check props</span>
    <span class="s0">if </span><span class="s1">(bindingType === </span><span class="s2">&quot;props&quot; </span><span class="s3">/* BindingTypes.PROPS */ </span><span class="s1">||</span>
        <span class="s1">bindingType === </span><span class="s2">&quot;props-aliased&quot; </span><span class="s3">/* BindingTypes.PROPS_ALIASED */</span><span class="s1">) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">44 </span><span class="s3">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s0">, </span><span class="s1">exp.loc))</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">maybeRef = !</span><span class="s0">true  ;</span>
    <span class="s0">if </span><span class="s1">(!expString.trim() ||</span>
        <span class="s1">(!isMemberExpression(expString) &amp;&amp; !maybeRef)) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">42 </span><span class="s3">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s0">, </span><span class="s1">exp.loc))</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">createTransformProps()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">propName = arg ? arg : createSimpleExpression(</span><span class="s2">'modelValue'</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">eventName = arg</span>
        <span class="s1">? isStaticExp(arg)</span>
            <span class="s1">? </span><span class="s2">`onUpdate:</span><span class="s1">${camelize$1(arg.content)}</span><span class="s2">`</span>
            <span class="s1">: createCompoundExpression([</span><span class="s2">'&quot;onUpdate:&quot; + '</span><span class="s0">, </span><span class="s1">arg])</span>
        <span class="s1">: </span><span class="s2">`onUpdate:modelValue`</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">assignmentExp</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">eventArg = context.isTS ? </span><span class="s2">`($event: any)` </span><span class="s1">: </span><span class="s2">`$event`</span><span class="s0">;</span>
    <span class="s1">{</span>
        <span class="s1">assignmentExp = createCompoundExpression([</span>
            <span class="s2">`</span><span class="s1">${eventArg} </span><span class="s2">=&gt; ((`</span><span class="s0">,</span>
            <span class="s1">exp</span><span class="s0">,</span>
            <span class="s2">`) = $event)`</span>
        <span class="s1">])</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">props = [</span>
        <span class="s3">// modelValue: foo</span>
        <span class="s1">createObjectProperty(propName</span><span class="s0">, </span><span class="s1">dir.exp)</span><span class="s0">,</span>
        <span class="s3">// &quot;onUpdate:modelValue&quot;: $event =&gt; (foo = $event)</span>
        <span class="s1">createObjectProperty(eventName</span><span class="s0">, </span><span class="s1">assignmentExp)</span>
    <span class="s1">]</span><span class="s0">;</span>
    <span class="s3">// modelModifiers: { foo: true, &quot;bar-baz&quot;: true }</span>
    <span class="s0">if </span><span class="s1">(dir.modifiers.length &amp;&amp; node.tagType === </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">modifiers = dir.modifiers</span>
            <span class="s1">.map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + </span><span class="s2">`: true`</span><span class="s1">)</span>
            <span class="s1">.join(</span><span class="s2">`, `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">modifiersKey = arg</span>
            <span class="s1">? isStaticExp(arg)</span>
                <span class="s1">? </span><span class="s2">`</span><span class="s1">${arg.content}</span><span class="s2">Modifiers`</span>
                <span class="s1">: createCompoundExpression([arg</span><span class="s0">, </span><span class="s2">' + &quot;Modifiers&quot;'</span><span class="s1">])</span>
            <span class="s1">: </span><span class="s2">`modelModifiers`</span><span class="s0">;</span>
        <span class="s1">props.push(createObjectProperty(modifiersKey</span><span class="s0">, </span><span class="s1">createSimpleExpression(</span><span class="s2">`{ </span><span class="s1">${modifiers} </span><span class="s2">}`</span><span class="s0">, false, </span><span class="s1">dir.loc</span><span class="s0">, </span><span class="s4">2 </span><span class="s3">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">createTransformProps(props)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createTransformProps(props = []) {</span>
    <span class="s0">return </span><span class="s1">{ props }</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">validDivisionCharRE = </span><span class="s4">/[\w).+\-_$\]]/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">transformFilter = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(!isCompatEnabled(</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s0">, </span><span class="s1">context)) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
        <span class="s3">// filter rewrite is applied before expression transform so only</span>
        <span class="s3">// simple expressions are possible at this stage</span>
        <span class="s1">rewriteFilter(node.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s1">node.props.forEach((prop) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(prop.type === </span><span class="s4">7 </span><span class="s3">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">prop.name !== </span><span class="s2">'for' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">prop.exp) {</span>
                <span class="s1">rewriteFilter(prop.exp</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">rewriteFilter(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">parseFilter(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; node.children.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">child = node.children[i]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">child !== </span><span class="s2">'object'</span><span class="s1">)</span>
                <span class="s0">continue;</span>
            <span class="s0">if </span><span class="s1">(child.type === </span><span class="s4">4 </span><span class="s3">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">parseFilter(child</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">8 </span><span class="s3">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">rewriteFilter(node</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(child.type === </span><span class="s4">5 </span><span class="s3">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
                <span class="s1">rewriteFilter(child.content</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseFilter(node</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s0">const </span><span class="s1">exp = node.content</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">inSingle = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">inDouble = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">inTemplateString = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">inRegex = </span><span class="s0">false;</span>
    <span class="s0">let </span><span class="s1">curly = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">square = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">paren = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">lastFilterIndex = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">c</span><span class="s0">, </span><span class="s1">prev</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">expression</span><span class="s0">, </span><span class="s1">filters = []</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; exp.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s1">prev = c</span><span class="s0">;</span>
        <span class="s1">c = exp.charCodeAt(i)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(inSingle) {</span>
            <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x27 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                <span class="s1">inSingle = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(inDouble) {</span>
            <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x22 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                <span class="s1">inDouble = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(inTemplateString) {</span>
            <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x60 </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                <span class="s1">inTemplateString = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(inRegex) {</span>
            <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x2f </span><span class="s1">&amp;&amp; prev !== </span><span class="s4">0x5c</span><span class="s1">)</span>
                <span class="s1">inRegex = </span><span class="s0">false;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(c === </span><span class="s4">0x7c </span><span class="s1">&amp;&amp; </span><span class="s3">// pipe</span>
            <span class="s1">exp.charCodeAt(i + </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0x7c </span><span class="s1">&amp;&amp;</span>
            <span class="s1">exp.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0x7c </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!curly &amp;&amp;</span>
            <span class="s1">!square &amp;&amp;</span>
            <span class="s1">!paren) {</span>
            <span class="s0">if </span><span class="s1">(expression === undefined) {</span>
                <span class="s3">// first filter, end of expression</span>
                <span class="s1">lastFilterIndex = i + </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s1">expression = exp.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i).trim()</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">pushFilter()</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">switch </span><span class="s1">(c) {</span>
                <span class="s0">case </span><span class="s4">0x22</span><span class="s1">:</span>
                    <span class="s1">inDouble = </span><span class="s0">true;</span>
                    <span class="s0">break; </span><span class="s3">// &quot;</span>
                <span class="s0">case </span><span class="s4">0x27</span><span class="s1">:</span>
                    <span class="s1">inSingle = </span><span class="s0">true;</span>
                    <span class="s0">break; </span><span class="s3">// '</span>
                <span class="s0">case </span><span class="s4">0x60</span><span class="s1">:</span>
                    <span class="s1">inTemplateString = </span><span class="s0">true;</span>
                    <span class="s0">break; </span><span class="s3">// `</span>
                <span class="s0">case </span><span class="s4">0x28</span><span class="s1">:</span>
                    <span class="s1">paren++</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// (</span>
                <span class="s0">case </span><span class="s4">0x29</span><span class="s1">:</span>
                    <span class="s1">paren--</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// )</span>
                <span class="s0">case </span><span class="s4">0x5b</span><span class="s1">:</span>
                    <span class="s1">square++</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// [</span>
                <span class="s0">case </span><span class="s4">0x5d</span><span class="s1">:</span>
                    <span class="s1">square--</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// ]</span>
                <span class="s0">case </span><span class="s4">0x7b</span><span class="s1">:</span>
                    <span class="s1">curly++</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// {</span>
                <span class="s0">case </span><span class="s4">0x7d</span><span class="s1">:</span>
                    <span class="s1">curly--</span><span class="s0">;</span>
                    <span class="s0">break; </span><span class="s3">// }</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(c === </span><span class="s4">0x2f</span><span class="s1">) {</span>
                <span class="s3">// /</span>
                <span class="s0">let </span><span class="s1">j = i - </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">let </span><span class="s1">p</span><span class="s0">;</span>
                <span class="s3">// find first non-whitespace prev char</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">; </span><span class="s1">j &gt;= </span><span class="s4">0</span><span class="s0">; </span><span class="s1">j--) {</span>
                    <span class="s1">p = exp.charAt(j)</span><span class="s0">;</span>
                    <span class="s0">if </span><span class="s1">(p !== </span><span class="s2">' '</span><span class="s1">)</span>
                        <span class="s0">break;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(!p || !validDivisionCharRE.test(p)) {</span>
                    <span class="s1">inRegex = </span><span class="s0">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(expression === undefined) {</span>
        <span class="s1">expression = exp.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i).trim()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(lastFilterIndex !== </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">pushFilter()</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">function </span><span class="s1">pushFilter() {</span>
        <span class="s1">filters.push(exp.slice(lastFilterIndex</span><span class="s0">, </span><span class="s1">i).trim())</span><span class="s0">;</span>
        <span class="s1">lastFilterIndex = i + </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(filters.length) {</span>
        <span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">warnDeprecation(</span><span class="s2">&quot;COMPILER_FILTER&quot; </span><span class="s3">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">node.loc)</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; filters.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s1">expression = wrapFilter(expression</span><span class="s0">, </span><span class="s1">filters[i]</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">node.content = expression</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">wrapFilter(exp</span><span class="s0">, </span><span class="s1">filter</span><span class="s0">, </span><span class="s1">context) {</span>
    <span class="s1">context.helper(RESOLVE_FILTER)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">i = filter.indexOf(</span><span class="s2">'('</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(i &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">context.filters.add(filter)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s2">`</span><span class="s1">${toValidAssetId(filter</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s1">)}</span><span class="s2">(</span><span class="s1">${exp}</span><span class="s2">)`</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">name = filter.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">args = filter.slice(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">context.filters.add(name)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s2">`</span><span class="s1">${toValidAssetId(name</span><span class="s0">, </span><span class="s2">'filter'</span><span class="s1">)}</span><span class="s2">(</span><span class="s1">${exp}${args !== </span><span class="s2">')' </span><span class="s1">? </span><span class="s2">',' </span><span class="s1">+ args : args}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">seen = </span><span class="s0">new </span><span class="s1">WeakSet()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">transformMemo = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s3">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">dir = findDir(node</span><span class="s0">, </span><span class="s2">'memo'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!dir || seen.has(node)) {</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s1">seen.add(node)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">() =&gt; {</span>
            <span class="s0">const </span><span class="s1">codegenNode = node.codegenNode ||</span>
                <span class="s1">context.currentNode.codegenNode</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(codegenNode &amp;&amp; codegenNode.type === </span><span class="s4">13 </span><span class="s3">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s3">// non-component sub tree should be turned into a block</span>
                <span class="s0">if </span><span class="s1">(node.tagType !== </span><span class="s4">1 </span><span class="s3">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
                    <span class="s1">makeBlock(codegenNode</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s1">node.codegenNode = createCallExpression(context.helper(WITH_MEMO)</span><span class="s0">, </span><span class="s1">[</span>
                    <span class="s1">dir.exp</span><span class="s0">,</span>
                    <span class="s1">createFunctionExpression(undefined</span><span class="s0">, </span><span class="s1">codegenNode)</span><span class="s0">,</span>
                    <span class="s2">`_cache`</span><span class="s0">,</span>
                    <span class="s1">String(context.cached++)</span>
                <span class="s1">])</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">getBaseTransformPreset(prefixIdentifiers) {</span>
    <span class="s0">return </span><span class="s1">[</span>
        <span class="s1">[</span>
            <span class="s1">transformOnce</span><span class="s0">,</span>
            <span class="s1">transformIf</span><span class="s0">,</span>
            <span class="s1">transformMemo</span><span class="s0">,</span>
            <span class="s1">transformFor</span><span class="s0">,</span>
            <span class="s1">...([transformFilter] )</span><span class="s0">,</span>
            <span class="s1">...((process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">)</span>
                    <span class="s1">? [transformExpression]</span>
                    <span class="s1">: [])</span><span class="s0">,</span>
            <span class="s1">transformSlotOutlet</span><span class="s0">,</span>
            <span class="s1">transformElement</span><span class="s0">,</span>
            <span class="s1">trackSlotScopes</span><span class="s0">,</span>
            <span class="s1">transformText</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">{</span>
            <span class="s1">on: transformOn</span><span class="s0">,</span>
            <span class="s1">bind: transformBind</span><span class="s0">,</span>
            <span class="s1">model: transformModel</span>
        <span class="s1">}</span>
    <span class="s1">]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s3">// we name it `baseCompile` so that higher order compilers like</span>
<span class="s3">// @vue/compiler-dom can export `compile` while re-exporting everything else.</span>
<span class="s0">function </span><span class="s1">baseCompile(template</span><span class="s0">, </span><span class="s1">options = {}) {</span>
    <span class="s0">const </span><span class="s1">onError = options.onError || defaultOnError</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isModuleMode = options.mode === </span><span class="s2">'module'</span><span class="s0">;</span>
    <span class="s3">/* istanbul ignore if */</span>
    <span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(options.prefixIdentifiers === </span><span class="s0">true</span><span class="s1">) {</span>
            <span class="s1">onError(createCompilerError(</span><span class="s4">47 </span><span class="s3">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(isModuleMode) {</span>
            <span class="s1">onError(createCompilerError(</span><span class="s4">48 </span><span class="s3">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">prefixIdentifiers = !</span><span class="s0">true ;</span>
    <span class="s0">if </span><span class="s1">(options.cacheHandlers) {</span>
        <span class="s1">onError(createCompilerError(</span><span class="s4">49 </span><span class="s3">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(options.scopeId &amp;&amp; !isModuleMode) {</span>
        <span class="s1">onError(createCompilerError(</span><span class="s4">50 </span><span class="s3">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">ast = isString(template) ? baseParse(template</span><span class="s0">, </span><span class="s1">options) : template</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">[nodeTransforms</span><span class="s0">, </span><span class="s1">directiveTransforms] = getBaseTransformPreset()</span><span class="s0">;</span>
    <span class="s1">transform(ast</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">{</span>
        <span class="s1">prefixIdentifiers</span><span class="s0">,</span>
        <span class="s1">nodeTransforms: [</span>
            <span class="s1">...nodeTransforms</span><span class="s0">,</span>
            <span class="s1">...(options.nodeTransforms || []) </span><span class="s3">// user transforms</span>
        <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">directiveTransforms: extend({}</span><span class="s0">, </span><span class="s1">directiveTransforms</span><span class="s0">, </span><span class="s1">options.directiveTransforms || {} </span><span class="s3">// user transforms</span>
        <span class="s1">)</span>
    <span class="s1">}))</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">generate(ast</span><span class="s0">, </span><span class="s1">extend({}</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">{</span>
        <span class="s1">prefixIdentifiers</span>
    <span class="s1">}))</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">noopDirectiveTransform = () =&gt; ({ props: [] })</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ BASE_TRANSITION</span><span class="s0">, </span><span class="s1">CAMELIZE</span><span class="s0">, </span><span class="s1">CAPITALIZE</span><span class="s0">, </span><span class="s1">CREATE_BLOCK</span><span class="s0">, </span><span class="s1">CREATE_COMMENT</span><span class="s0">, </span><span class="s1">CREATE_ELEMENT_BLOCK</span><span class="s0">, </span><span class="s1">CREATE_ELEMENT_VNODE</span><span class="s0">, </span><span class="s1">CREATE_SLOTS</span><span class="s0">, </span><span class="s1">CREATE_STATIC</span><span class="s0">, </span><span class="s1">CREATE_TEXT</span><span class="s0">, </span><span class="s1">CREATE_VNODE</span><span class="s0">, </span><span class="s1">FRAGMENT</span><span class="s0">, </span><span class="s1">GUARD_REACTIVE_PROPS</span><span class="s0">, </span><span class="s1">IS_MEMO_SAME</span><span class="s0">, </span><span class="s1">IS_REF</span><span class="s0">, </span><span class="s1">KEEP_ALIVE</span><span class="s0">, </span><span class="s1">MERGE_PROPS</span><span class="s0">, </span><span class="s1">NORMALIZE_CLASS</span><span class="s0">, </span><span class="s1">NORMALIZE_PROPS</span><span class="s0">, </span><span class="s1">NORMALIZE_STYLE</span><span class="s0">, </span><span class="s1">OPEN_BLOCK</span><span class="s0">, </span><span class="s1">POP_SCOPE_ID</span><span class="s0">, </span><span class="s1">PUSH_SCOPE_ID</span><span class="s0">, </span><span class="s1">RENDER_LIST</span><span class="s0">, </span><span class="s1">RENDER_SLOT</span><span class="s0">, </span><span class="s1">RESOLVE_COMPONENT</span><span class="s0">, </span><span class="s1">RESOLVE_DIRECTIVE</span><span class="s0">, </span><span class="s1">RESOLVE_DYNAMIC_COMPONENT</span><span class="s0">, </span><span class="s1">RESOLVE_FILTER</span><span class="s0">, </span><span class="s1">SET_BLOCK_TRACKING</span><span class="s0">, </span><span class="s1">SUSPENSE</span><span class="s0">, </span><span class="s1">TELEPORT</span><span class="s0">, </span><span class="s1">TO_DISPLAY_STRING</span><span class="s0">, </span><span class="s1">TO_HANDLERS</span><span class="s0">, </span><span class="s1">TO_HANDLER_KEY</span><span class="s0">, </span><span class="s1">UNREF</span><span class="s0">, </span><span class="s1">WITH_CTX</span><span class="s0">, </span><span class="s1">WITH_DIRECTIVES</span><span class="s0">, </span><span class="s1">WITH_MEMO</span><span class="s0">, </span><span class="s1">advancePositionWithClone</span><span class="s0">, </span><span class="s1">advancePositionWithMutation</span><span class="s0">, </span><span class="s1">assert</span><span class="s0">, </span><span class="s1">baseCompile</span><span class="s0">, </span><span class="s1">baseParse</span><span class="s0">, </span><span class="s1">buildDirectiveArgs</span><span class="s0">, </span><span class="s1">buildProps</span><span class="s0">, </span><span class="s1">buildSlots</span><span class="s0">, </span><span class="s1">checkCompatEnabled</span><span class="s0">, </span><span class="s1">createArrayExpression</span><span class="s0">, </span><span class="s1">createAssignmentExpression</span><span class="s0">, </span><span class="s1">createBlockStatement</span><span class="s0">, </span><span class="s1">createCacheExpression</span><span class="s0">, </span><span class="s1">createCallExpression</span><span class="s0">, </span><span class="s1">createCompilerError</span><span class="s0">, </span><span class="s1">createCompoundExpression</span><span class="s0">, </span><span class="s1">createConditionalExpression</span><span class="s0">, </span><span class="s1">createForLoopParams</span><span class="s0">, </span><span class="s1">createFunctionExpression</span><span class="s0">, </span><span class="s1">createIfStatement</span><span class="s0">, </span><span class="s1">createInterpolation</span><span class="s0">, </span><span class="s1">createObjectExpression</span><span class="s0">, </span><span class="s1">createObjectProperty</span><span class="s0">, </span><span class="s1">createReturnStatement</span><span class="s0">, </span><span class="s1">createRoot</span><span class="s0">, </span><span class="s1">createSequenceExpression</span><span class="s0">, </span><span class="s1">createSimpleExpression</span><span class="s0">, </span><span class="s1">createStructuralDirectiveTransform</span><span class="s0">, </span><span class="s1">createTemplateLiteral</span><span class="s0">, </span><span class="s1">createTransformContext</span><span class="s0">, </span><span class="s1">createVNodeCall</span><span class="s0">, </span><span class="s1">extractIdentifiers</span><span class="s0">, </span><span class="s1">findDir</span><span class="s0">, </span><span class="s1">findProp</span><span class="s0">, </span><span class="s1">generate</span><span class="s0">, </span><span class="s1">getBaseTransformPreset</span><span class="s0">, </span><span class="s1">getConstantType</span><span class="s0">, </span><span class="s1">getInnerRange</span><span class="s0">, </span><span class="s1">getMemoedVNodeCall</span><span class="s0">, </span><span class="s1">getVNodeBlockHelper</span><span class="s0">, </span><span class="s1">getVNodeHelper</span><span class="s0">, </span><span class="s1">hasDynamicKeyVBind</span><span class="s0">, </span><span class="s1">hasScopeRef</span><span class="s0">, </span><span class="s1">helperNameMap</span><span class="s0">, </span><span class="s1">injectProp</span><span class="s0">, </span><span class="s1">isBuiltInType</span><span class="s0">, </span><span class="s1">isCoreComponent</span><span class="s0">, </span><span class="s1">isFunctionType</span><span class="s0">, </span><span class="s1">isInDestructureAssignment</span><span class="s0">, </span><span class="s1">isMemberExpression</span><span class="s0">, </span><span class="s1">isMemberExpressionBrowser</span><span class="s0">, </span><span class="s1">isMemberExpressionNode</span><span class="s0">, </span><span class="s1">isReferencedIdentifier</span><span class="s0">, </span><span class="s1">isSimpleIdentifier</span><span class="s0">, </span><span class="s1">isSlotOutlet</span><span class="s0">, </span><span class="s1">isStaticArgOf</span><span class="s0">, </span><span class="s1">isStaticExp</span><span class="s0">, </span><span class="s1">isStaticProperty</span><span class="s0">, </span><span class="s1">isStaticPropertyKey</span><span class="s0">, </span><span class="s1">isTemplateNode</span><span class="s0">, </span><span class="s1">isText$1 as isText</span><span class="s0">, </span><span class="s1">isVSlot</span><span class="s0">, </span><span class="s1">locStub</span><span class="s0">, </span><span class="s1">makeBlock</span><span class="s0">, </span><span class="s1">noopDirectiveTransform</span><span class="s0">, </span><span class="s1">processExpression</span><span class="s0">, </span><span class="s1">processFor</span><span class="s0">, </span><span class="s1">processIf</span><span class="s0">, </span><span class="s1">processSlotOutlet</span><span class="s0">, </span><span class="s1">registerRuntimeHelpers</span><span class="s0">, </span><span class="s1">resolveComponentType</span><span class="s0">, </span><span class="s1">stringifyExpression</span><span class="s0">, </span><span class="s1">toValidAssetId</span><span class="s0">, </span><span class="s1">trackSlotScopes</span><span class="s0">, </span><span class="s1">trackVForSlotScopes</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">transformBind</span><span class="s0">, </span><span class="s1">transformElement</span><span class="s0">, </span><span class="s1">transformExpression</span><span class="s0">, </span><span class="s1">transformModel</span><span class="s0">, </span><span class="s1">transformOn</span><span class="s0">, </span><span class="s1">traverseNode</span><span class="s0">, </span><span class="s1">walkBlockDeclarations</span><span class="s0">, </span><span class="s1">walkFunctionParams</span><span class="s0">, </span><span class="s1">walkIdentifiers</span><span class="s0">, </span><span class="s1">warnDeprecation }</span><span class="s0">;</span>
</pre>
</body>
</html>