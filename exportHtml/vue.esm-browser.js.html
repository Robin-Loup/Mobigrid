<html>
<head>
<title>vue.esm-browser.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vue.esm-browser.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Make a map and return a function for checking if a key</span>
 <span class="s0">* is in that map.</span>
 <span class="s0">* IMPORTANT: all calls of this function must be prefixed with</span>
 <span class="s0">* \/\*#\_\_PURE\_\_\*\/</span>
 <span class="s0">* So that rollup can tree-shake them if necessary.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">makeMap(str</span><span class="s2">, </span><span class="s1">expectsLowerCase) {</span>
    <span class="s2">const </span><span class="s1">map = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">list = str.split(</span><span class="s3">','</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">map[list[i]] = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* dev only flag -&gt; name mapping</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">PatchFlagNames = {</span>
    <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">]: </span><span class="s3">`TEXT`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* PatchFlags.CLASS */</span><span class="s1">]: </span><span class="s3">`CLASS`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">4 </span><span class="s5">/* PatchFlags.STYLE */</span><span class="s1">]: </span><span class="s3">`STYLE`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s1">]: </span><span class="s3">`PROPS`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s1">]: </span><span class="s3">`FULL_PROPS`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">]: </span><span class="s3">`HYDRATE_EVENTS`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]: </span><span class="s3">`STABLE_FRAGMENT`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s1">]: </span><span class="s3">`KEYED_FRAGMENT`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s1">]: </span><span class="s3">`UNKEYED_FRAGMENT`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */</span><span class="s1">]: </span><span class="s3">`NEED_PATCH`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">]: </span><span class="s3">`DYNAMIC_SLOTS`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]: </span><span class="s3">`DEV_ROOT_FRAGMENT`</span><span class="s2">,</span>
    <span class="s1">[-</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */</span><span class="s1">]: </span><span class="s3">`HOISTED`</span><span class="s2">,</span>
    <span class="s1">[-</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s1">]: </span><span class="s3">`BAIL`</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">/**</span>
 <span class="s0">* Dev only</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">slotFlagsText = {</span>
    <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s1">]: </span><span class="s3">'STABLE'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* SlotFlags.DYNAMIC */</span><span class="s1">]: </span><span class="s3">'DYNAMIC'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">3 </span><span class="s5">/* SlotFlags.FORWARDED */</span><span class="s1">]: </span><span class="s3">'FORWARDED'</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">GLOBALS_WHITE_LISTED = </span><span class="s3">'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' </span><span class="s1">+</span>
    <span class="s3">'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' </span><span class="s1">+</span>
    <span class="s3">'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isGloballyWhitelisted = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(GLOBALS_WHITE_LISTED)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">range = </span><span class="s4">2</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">generateCodeFrame(source</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">end = source.length) {</span>
    <span class="s5">// Split the content into individual lines but capture the newline sequence</span>
    <span class="s5">// that separated each line. This is important because the actual sequence is</span>
    <span class="s5">// needed to properly take into account the full line length for offset</span>
    <span class="s5">// comparison</span>
    <span class="s2">let </span><span class="s1">lines = source.split(</span><span class="s4">/(\r?\n)/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s5">// Separate the lines and newline sequences into separate arrays for easier referencing</span>
    <span class="s2">const </span><span class="s1">newlineSequences = lines.filter((_</span><span class="s2">, </span><span class="s1">idx) =&gt; idx % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">lines = lines.filter((_</span><span class="s2">, </span><span class="s1">idx) =&gt; idx % </span><span class="s4">2 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">count = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">res = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; lines.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">count +=</span>
            <span class="s1">lines[i].length +</span>
                <span class="s1">((newlineSequences[i] &amp;&amp; newlineSequences[i].length) || </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(count &gt;= start) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = i - range</span><span class="s2">; </span><span class="s1">j &lt;= i + range || end &gt; count</span><span class="s2">; </span><span class="s1">j++) {</span>
                <span class="s2">if </span><span class="s1">(j &lt; </span><span class="s4">0 </span><span class="s1">|| j &gt;= lines.length)</span>
                    <span class="s2">continue;</span>
                <span class="s2">const </span><span class="s1">line = j + </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s1">res.push(</span><span class="s3">`</span><span class="s1">${line}${</span><span class="s3">' '</span><span class="s1">.repeat(Math.max(</span><span class="s4">3 </span><span class="s1">- String(line).length</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))}</span><span class="s3">|  </span><span class="s1">${lines[j]}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">lineLength = lines[j].length</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">newLineSeqLength = (newlineSequences[j] &amp;&amp; newlineSequences[j].length) || </span><span class="s4">0</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(j === i) {</span>
                    <span class="s5">// push underline</span>
                    <span class="s2">const </span><span class="s1">pad = start - (count - (lineLength + newLineSeqLength))</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">length = Math.max(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">end &gt; count ? lineLength - pad : end - start)</span><span class="s2">;</span>
                    <span class="s1">res.push(</span><span class="s3">`   |  ` </span><span class="s1">+ </span><span class="s3">' '</span><span class="s1">.repeat(pad) + </span><span class="s3">'^'</span><span class="s1">.repeat(length))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(j &gt; i) {</span>
                    <span class="s2">if </span><span class="s1">(end &gt; count) {</span>
                        <span class="s2">const </span><span class="s1">length = Math.max(Math.min(end - count</span><span class="s2">, </span><span class="s1">lineLength)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">res.push(</span><span class="s3">`   |  ` </span><span class="s1">+ </span><span class="s3">'^'</span><span class="s1">.repeat(length))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">count += lineLength + newLineSeqLength</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">normalizeStyle(value) {</span>
    <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">item = value[i]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">normalized = isString(item)</span>
                <span class="s1">? parseStringStyle(item)</span>
                <span class="s1">: normalizeStyle(item)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(normalized) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">normalized) {</span>
                    <span class="s1">res[key] = normalized[key]</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isString(value)) {</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(value)) {</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">listDelimiterRE = </span><span class="s4">/;(?![^(]*\))/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">propertyDelimiterRE = </span><span class="s4">/:([^]+)/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">styleCommentRE = </span><span class="s4">/\/\*.*?\*\//gs</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseStringStyle(cssText) {</span>
    <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
    <span class="s1">cssText</span>
        <span class="s1">.replace(styleCommentRE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">.split(listDelimiterRE)</span>
        <span class="s1">.forEach(item =&gt; {</span>
        <span class="s2">if </span><span class="s1">(item) {</span>
            <span class="s2">const </span><span class="s1">tmp = item.split(propertyDelimiterRE)</span><span class="s2">;</span>
            <span class="s1">tmp.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; (ret[tmp[</span><span class="s4">0</span><span class="s1">].trim()] = tmp[</span><span class="s4">1</span><span class="s1">].trim())</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeClass(value) {</span>
    <span class="s2">let </span><span class="s1">res = </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isString(value)) {</span>
        <span class="s1">res = value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">normalized = normalizeClass(value[i])</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(normalized) {</span>
                <span class="s1">res += normalized + </span><span class="s3">' '</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(value)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name </span><span class="s2">in </span><span class="s1">value) {</span>
            <span class="s2">if </span><span class="s1">(value[name]) {</span>
                <span class="s1">res += name + </span><span class="s3">' '</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res.trim()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeProps(props) {</span>
    <span class="s2">if </span><span class="s1">(!props)</span>
        <span class="s2">return null;</span>
    <span class="s2">let </span><span class="s1">{ </span><span class="s2">class</span><span class="s1">: klass</span><span class="s2">, </span><span class="s1">style } = props</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(klass &amp;&amp; !isString(klass)) {</span>
        <span class="s1">props.class = normalizeClass(klass)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(style) {</span>
        <span class="s1">props.style = normalizeStyle(style)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">props</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// These tag configs are shared between compiler-dom and runtime-dom, so they</span>
<span class="s5">// https://developer.mozilla.org/en-US/docs/Web/HTML/Element</span>
<span class="s2">const </span><span class="s1">HTML_TAGS = </span><span class="s3">'html,body,base,head,link,meta,style,title,address,article,aside,footer,' </span><span class="s1">+</span>
    <span class="s3">'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' </span><span class="s1">+</span>
    <span class="s3">'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' </span><span class="s1">+</span>
    <span class="s3">'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' </span><span class="s1">+</span>
    <span class="s3">'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' </span><span class="s1">+</span>
    <span class="s3">'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' </span><span class="s1">+</span>
    <span class="s3">'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' </span><span class="s1">+</span>
    <span class="s3">'option,output,progress,select,textarea,details,dialog,menu,' </span><span class="s1">+</span>
    <span class="s3">'summary,template,blockquote,iframe,tfoot'</span><span class="s2">;</span>
<span class="s5">// https://developer.mozilla.org/en-US/docs/Web/SVG/Element</span>
<span class="s2">const </span><span class="s1">SVG_TAGS = </span><span class="s3">'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' </span><span class="s1">+</span>
    <span class="s3">'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' </span><span class="s1">+</span>
    <span class="s3">'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' </span><span class="s1">+</span>
    <span class="s3">'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' </span><span class="s1">+</span>
    <span class="s3">'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' </span><span class="s1">+</span>
    <span class="s3">'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' </span><span class="s1">+</span>
    <span class="s3">'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' </span><span class="s1">+</span>
    <span class="s3">'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' </span><span class="s1">+</span>
    <span class="s3">'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' </span><span class="s1">+</span>
    <span class="s3">'text,textPath,title,tspan,unknown,use,view'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">VOID_TAGS = </span><span class="s3">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `true` flag.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">isHTMLTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(HTML_TAGS)</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `true` flag.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">isSVGTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(SVG_TAGS)</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `true` flag.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">isVoidTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(VOID_TAGS)</span><span class="s2">;</span>

<span class="s0">/**</span>
 <span class="s0">* On the client we only need to offer special cases for boolean attributes that</span>
 <span class="s0">* have different names from their corresponding dom properties:</span>
 <span class="s0">* - itemscope -&gt; N/A</span>
 <span class="s0">* - allowfullscreen -&gt; allowFullscreen</span>
 <span class="s0">* - formnovalidate -&gt; formNoValidate</span>
 <span class="s0">* - ismap -&gt; isMap</span>
 <span class="s0">* - nomodule -&gt; noModule</span>
 <span class="s0">* - novalidate -&gt; noValidate</span>
 <span class="s0">* - readonly -&gt; readOnly</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">specialBooleanAttrs = </span><span class="s3">`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isSpecialBooleanAttr = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(specialBooleanAttrs)</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Boolean attributes should be included if the value is truthy or ''.</span>
 <span class="s0">* e.g. `&lt;select multiple&gt;` compiles to `{ multiple: '' }`</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">includeBooleanAttr(value) {</span>
    <span class="s2">return </span><span class="s1">!!value || value === </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">looseCompareArrays(a</span><span class="s2">, </span><span class="s1">b) {</span>
    <span class="s2">if </span><span class="s1">(a.length !== b.length)</span>
        <span class="s2">return false;</span>
    <span class="s2">let </span><span class="s1">equal = </span><span class="s2">true;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">equal &amp;&amp; i &lt; a.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">equal = looseEqual(a[i]</span><span class="s2">, </span><span class="s1">b[i])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">equal</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">looseEqual(a</span><span class="s2">, </span><span class="s1">b) {</span>
    <span class="s2">if </span><span class="s1">(a === b)</span>
        <span class="s2">return true;</span>
    <span class="s2">let </span><span class="s1">aValidType = isDate(a)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">bValidType = isDate(b)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
        <span class="s2">return </span><span class="s1">aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">aValidType = isSymbol(a)</span><span class="s2">;</span>
    <span class="s1">bValidType = isSymbol(b)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
        <span class="s2">return </span><span class="s1">a === b</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">aValidType = isArray(a)</span><span class="s2">;</span>
    <span class="s1">bValidType = isArray(b)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
        <span class="s2">return </span><span class="s1">aValidType &amp;&amp; bValidType ? looseCompareArrays(a</span><span class="s2">, </span><span class="s1">b) : </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">aValidType = isObject(a)</span><span class="s2">;</span>
    <span class="s1">bValidType = isObject(b)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
        <span class="s5">/* istanbul ignore if: this if will probably never be called */</span>
        <span class="s2">if </span><span class="s1">(!aValidType || !bValidType) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">aKeysCount = Object.keys(a).length</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">bKeysCount = Object.keys(b).length</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(aKeysCount !== bKeysCount) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">a) {</span>
            <span class="s2">const </span><span class="s1">aHasKey = a.hasOwnProperty(key)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">bHasKey = b.hasOwnProperty(key)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">((aHasKey &amp;&amp; !bHasKey) ||</span>
                <span class="s1">(!aHasKey &amp;&amp; bHasKey) ||</span>
                <span class="s1">!looseEqual(a[key]</span><span class="s2">, </span><span class="s1">b[key])) {</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">String(a) === String(b)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">looseIndexOf(arr</span><span class="s2">, </span><span class="s1">val) {</span>
    <span class="s2">return </span><span class="s1">arr.findIndex(item =&gt; looseEqual(item</span><span class="s2">, </span><span class="s1">val))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* For converting {{ interpolation }} values to displayed strings.</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">toDisplayString = (val) =&gt; {</span>
    <span class="s2">return </span><span class="s1">isString(val)</span>
        <span class="s1">? val</span>
        <span class="s1">: val == </span><span class="s2">null</span>
            <span class="s1">? </span><span class="s3">''</span>
            <span class="s1">: isArray(val) ||</span>
                <span class="s1">(isObject(val) &amp;&amp;</span>
                    <span class="s1">(val.toString === objectToString || !isFunction(val.toString)))</span>
                <span class="s1">? JSON.stringify(val</span><span class="s2">, </span><span class="s1">replacer</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s1">: String(val)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">replacer = (_key</span><span class="s2">, </span><span class="s1">val) =&gt; {</span>
    <span class="s5">// can't use isRef here since @vue/shared has no deps</span>
    <span class="s2">if </span><span class="s1">(val &amp;&amp; val.__v_isRef) {</span>
        <span class="s2">return </span><span class="s1">replacer(_key</span><span class="s2">, </span><span class="s1">val.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isMap(val)) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">[</span><span class="s3">`Map(</span><span class="s1">${val.size}</span><span class="s3">)`</span><span class="s1">]: [...val.entries()].reduce((entries</span><span class="s2">, </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">val]) =&gt; {</span>
                <span class="s1">entries[</span><span class="s3">`</span><span class="s1">${key} </span><span class="s3">=&gt;`</span><span class="s1">] = val</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">entries</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isSet(val)) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">[</span><span class="s3">`Set(</span><span class="s1">${val.size}</span><span class="s3">)`</span><span class="s1">]: [...val.values()]</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(val) &amp;&amp; !isArray(val) &amp;&amp; !isPlainObject(val)) {</span>
        <span class="s2">return </span><span class="s1">String(val)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">val</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">EMPTY_OBJ = Object.freeze({})</span>
    <span class="s2">;</span>
<span class="s2">const </span><span class="s1">EMPTY_ARR = Object.freeze([]) </span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NOOP = () =&gt; { }</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Always return false.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">NO = () =&gt; </span><span class="s2">false;</span>
<span class="s2">const </span><span class="s1">onRE = </span><span class="s4">/^on[^a-z]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isOn = (key) =&gt; onRE.test(key)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isModelListener = (key) =&gt; key.startsWith(</span><span class="s3">'onUpdate:'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">extend = Object.assign</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">remove = (arr</span><span class="s2">, </span><span class="s1">el) =&gt; {</span>
    <span class="s2">const </span><span class="s1">i = arr.indexOf(el)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(i &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">arr.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hasOwnProperty$1 = Object.prototype.hasOwnProperty</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hasOwn = (val</span><span class="s2">, </span><span class="s1">key) =&gt; hasOwnProperty$1.call(val</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isArray = Array.isArray</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isMap = (val) =&gt; toTypeString(val) === </span><span class="s3">'[object Map]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isSet = (val) =&gt; toTypeString(val) === </span><span class="s3">'[object Set]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isDate = (val) =&gt; toTypeString(val) === </span><span class="s3">'[object Date]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isRegExp = (val) =&gt; toTypeString(val) === </span><span class="s3">'[object RegExp]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isFunction = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'function'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isString = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'string'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isSymbol = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'symbol'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isObject = (val) =&gt; val !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'object'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isPromise = (val) =&gt; {</span>
    <span class="s2">return </span><span class="s1">isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">objectToString = Object.prototype.toString</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">toTypeString = (value) =&gt; objectToString.call(value)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">toRawType = (value) =&gt; {</span>
    <span class="s5">// extract &quot;RawType&quot; from strings like &quot;[object RawType]&quot;</span>
    <span class="s2">return </span><span class="s1">toTypeString(value).slice(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isPlainObject = (val) =&gt; toTypeString(val) === </span><span class="s3">'[object Object]'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isIntegerKey = (key) =&gt; isString(key) &amp;&amp;</span>
    <span class="s1">key !== </span><span class="s3">'NaN' </span><span class="s1">&amp;&amp;</span>
    <span class="s1">key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'-' </span><span class="s1">&amp;&amp;</span>
    <span class="s3">'' </span><span class="s1">+ parseInt(key</span><span class="s2">, </span><span class="s4">10</span><span class="s1">) === key</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isReservedProp = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span>
<span class="s5">// the leading comma is intentional so empty string &quot;&quot; is also included</span>
<span class="s3">',key,ref,ref_for,ref_key,' </span><span class="s1">+</span>
    <span class="s3">'onVnodeBeforeMount,onVnodeMounted,' </span><span class="s1">+</span>
    <span class="s3">'onVnodeBeforeUpdate,onVnodeUpdated,' </span><span class="s1">+</span>
    <span class="s3">'onVnodeBeforeUnmount,onVnodeUnmounted'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isBuiltInDirective = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">cacheStringFunction = (fn) =&gt; {</span>
    <span class="s2">const </span><span class="s1">cache = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">((str) =&gt; {</span>
        <span class="s2">const </span><span class="s1">hit = cache[str]</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">hit || (cache[str] = fn(str))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">camelizeRE = </span><span class="s4">/-(\w)/g</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">camelize = cacheStringFunction((str) =&gt; {</span>
    <span class="s2">return </span><span class="s1">str.replace(camelizeRE</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">c) =&gt; (c ? c.toUpperCase() : </span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hyphenateRE = </span><span class="s4">/\B([A-Z])/g</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">hyphenate = cacheStringFunction((str) =&gt; str.replace(hyphenateRE</span><span class="s2">, </span><span class="s3">'-$1'</span><span class="s1">).toLowerCase())</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">capitalize = cacheStringFunction((str) =&gt; str.charAt(</span><span class="s4">0</span><span class="s1">).toUpperCase() + str.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">toHandlerKey = cacheStringFunction((str) =&gt; str ? </span><span class="s3">`on</span><span class="s1">${capitalize(str)}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// compare whether a value has changed, accounting for NaN.</span>
<span class="s2">const </span><span class="s1">hasChanged = (value</span><span class="s2">, </span><span class="s1">oldValue) =&gt; !Object.is(value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">invokeArrayFns = (fns</span><span class="s2">, </span><span class="s1">arg) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; fns.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">fns[i](arg)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">def = (obj</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) =&gt; {</span>
    <span class="s1">Object.defineProperty(obj</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">configurable: </span><span class="s2">true,</span>
        <span class="s1">enumerable: </span><span class="s2">false,</span>
        <span class="s1">value</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* &quot;123-foo&quot; will be parsed to 123</span>
 <span class="s0">* This is used for the .number modifier in v-model</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">looseToNumber = (val) =&gt; {</span>
    <span class="s2">const </span><span class="s1">n = parseFloat(val)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">isNaN(n) ? val : n</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Only conerces number-like strings</span>
 <span class="s0">* &quot;123-foo&quot; will be returned as-is</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">toNumber = (val) =&gt; {</span>
    <span class="s2">const </span><span class="s1">n = isString(val) ? Number(val) : NaN</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">isNaN(n) ? val : n</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">_globalThis</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getGlobalThis = () =&gt; {</span>
    <span class="s2">return </span><span class="s1">(_globalThis ||</span>
        <span class="s1">(_globalThis =</span>
            <span class="s2">typeof </span><span class="s1">globalThis !== </span><span class="s3">'undefined'</span>
                <span class="s1">? globalThis</span>
                <span class="s1">: </span><span class="s2">typeof </span><span class="s1">self !== </span><span class="s3">'undefined'</span>
                    <span class="s1">? self</span>
                    <span class="s1">: </span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined'</span>
                        <span class="s1">? window</span>
                        <span class="s1">: </span><span class="s2">typeof </span><span class="s1">global !== </span><span class="s3">'undefined'</span>
                            <span class="s1">? global</span>
                            <span class="s1">: {}))</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">warn$1(msg</span><span class="s2">, </span><span class="s1">...args) {</span>
    <span class="s1">console.warn(</span><span class="s3">`[Vue warn] </span><span class="s1">${msg}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">activeEffectScope</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">EffectScope {</span>
    <span class="s1">constructor(detached = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.detached = detached</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s6">@internal</span>
         <span class="s0">*/</span>
        <span class="s2">this</span><span class="s1">._active = </span><span class="s2">true;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s6">@internal</span>
         <span class="s0">*/</span>
        <span class="s2">this</span><span class="s1">.effects = []</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s6">@internal</span>
         <span class="s0">*/</span>
        <span class="s2">this</span><span class="s1">.cleanups = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent = activeEffectScope</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!detached &amp;&amp; activeEffectScope) {</span>
            <span class="s2">this</span><span class="s1">.index =</span>
                <span class="s1">(activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(</span><span class="s2">this</span><span class="s1">) - </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">get active() {</span>
        <span class="s2">return this</span><span class="s1">._active</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">run(fn) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._active) {</span>
            <span class="s2">const </span><span class="s1">currentEffectScope = activeEffectScope</span><span class="s2">;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">activeEffectScope = </span><span class="s2">this;</span>
                <span class="s2">return </span><span class="s1">fn()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">finally </span><span class="s1">{</span>
                <span class="s1">activeEffectScope = currentEffectScope</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn$1(</span><span class="s3">`cannot run an inactive effect scope.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This should only be called on non-detached scopes</span>
     <span class="s0">* </span><span class="s6">@internal</span>
     <span class="s0">*/</span>
    <span class="s1">on() {</span>
        <span class="s1">activeEffectScope = </span><span class="s2">this;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This should only be called on non-detached scopes</span>
     <span class="s0">* </span><span class="s6">@internal</span>
     <span class="s0">*/</span>
    <span class="s1">off() {</span>
        <span class="s1">activeEffectScope = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">stop(fromParent) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._active) {</span>
            <span class="s2">let </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.effects.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">this</span><span class="s1">.effects[i].stop()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.cleanups.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">this</span><span class="s1">.cleanups[i]()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopes) {</span>
                <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.scopes.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">this</span><span class="s1">.scopes[i].stop(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// nested scope, dereference from parent to avoid memory leaks</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.detached &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent &amp;&amp; !fromParent) {</span>
                <span class="s5">// optimized O(1) removal</span>
                <span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.parent.scopes.pop()</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(last &amp;&amp; last !== </span><span class="s2">this</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.parent.scopes[</span><span class="s2">this</span><span class="s1">.index] = last</span><span class="s2">;</span>
                    <span class="s1">last.index = </span><span class="s2">this</span><span class="s1">.index</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.parent = undefined</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">._active = </span><span class="s2">false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">effectScope(detached) {</span>
    <span class="s2">return new </span><span class="s1">EffectScope(detached)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">recordEffectScope(effect</span><span class="s2">, </span><span class="s1">scope = activeEffectScope) {</span>
    <span class="s2">if </span><span class="s1">(scope &amp;&amp; scope.active) {</span>
        <span class="s1">scope.effects.push(effect)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCurrentScope() {</span>
    <span class="s2">return </span><span class="s1">activeEffectScope</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onScopeDispose(fn) {</span>
    <span class="s2">if </span><span class="s1">(activeEffectScope) {</span>
        <span class="s1">activeEffectScope.cleanups.push(fn)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warn$1(</span><span class="s3">`onScopeDispose() is called when there is no active effect scope` </span><span class="s1">+</span>
            <span class="s3">` to be associated with.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createDep = (effects) =&gt; {</span>
    <span class="s2">const </span><span class="s1">dep = </span><span class="s2">new </span><span class="s1">Set(effects)</span><span class="s2">;</span>
    <span class="s1">dep.w = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">dep.n = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">dep</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">wasTracked = (dep) =&gt; (dep.w &amp; trackOpBit) &gt; </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">newTracked = (dep) =&gt; (dep.n &amp; trackOpBit) &gt; </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">initDepMarkers = ({ deps }) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(deps.length) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">deps[i].w |= trackOpBit</span><span class="s2">; </span><span class="s5">// set was tracked</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">finalizeDepMarkers = (effect) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ deps } = effect</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(deps.length) {</span>
        <span class="s2">let </span><span class="s1">ptr = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">dep = deps[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(wasTracked(dep) &amp;&amp; !newTracked(dep)) {</span>
                <span class="s1">dep.delete(effect)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">deps[ptr++] = dep</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// clear bits</span>
            <span class="s1">dep.w &amp;= ~trackOpBit</span><span class="s2">;</span>
            <span class="s1">dep.n &amp;= ~trackOpBit</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">deps.length = ptr</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">targetMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s5">// The number of effects currently being tracked recursively.</span>
<span class="s2">let </span><span class="s1">effectTrackDepth = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">trackOpBit = </span><span class="s4">1</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* The bitwise track markers support at most 30 levels of recursion.</span>
 <span class="s0">* This value is chosen to enable modern JS engines to use a SMI on all platforms.</span>
 <span class="s0">* When recursion depth is greater, fall back to using a full cleanup.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">maxMarkerBits = </span><span class="s4">30</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">activeEffect</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ITERATE_KEY = Symbol(</span><span class="s3">'iterate' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">MAP_KEY_ITERATE_KEY = Symbol(</span><span class="s3">'Map key iterate' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ReactiveEffect {</span>
    <span class="s1">constructor(fn</span><span class="s2">, </span><span class="s1">scheduler = </span><span class="s2">null, </span><span class="s1">scope) {</span>
        <span class="s2">this</span><span class="s1">.fn = fn</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.scheduler = scheduler</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.active = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.deps = []</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.parent = undefined</span><span class="s2">;</span>
        <span class="s1">recordEffectScope(</span><span class="s2">this, </span><span class="s1">scope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">run() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.active) {</span>
            <span class="s2">return this</span><span class="s1">.fn()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">parent = activeEffect</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">lastShouldTrack = shouldTrack</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(parent) {</span>
            <span class="s2">if </span><span class="s1">(parent === </span><span class="s2">this</span><span class="s1">) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s1">parent = parent.parent</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.parent = activeEffect</span><span class="s2">;</span>
            <span class="s1">activeEffect = </span><span class="s2">this;</span>
            <span class="s1">shouldTrack = </span><span class="s2">true;</span>
            <span class="s1">trackOpBit = </span><span class="s4">1 </span><span class="s1">&lt;&lt; ++effectTrackDepth</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
                <span class="s1">initDepMarkers(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">cleanupEffect(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">.fn()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
                <span class="s1">finalizeDepMarkers(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">trackOpBit = </span><span class="s4">1 </span><span class="s1">&lt;&lt; --effectTrackDepth</span><span class="s2">;</span>
            <span class="s1">activeEffect = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
            <span class="s1">shouldTrack = lastShouldTrack</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">.parent = undefined</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deferStop) {</span>
                <span class="s2">this</span><span class="s1">.stop()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">stop() {</span>
        <span class="s5">// stopped while running itself - defer the cleanup</span>
        <span class="s2">if </span><span class="s1">(activeEffect === </span><span class="s2">this</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.deferStop = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.active) {</span>
            <span class="s1">cleanupEffect(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.onStop) {</span>
                <span class="s2">this</span><span class="s1">.onStop()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.active = </span><span class="s2">false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cleanupEffect(effect) {</span>
    <span class="s2">const </span><span class="s1">{ deps } = effect</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(deps.length) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">deps[i].delete(effect)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">deps.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">effect(fn</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(fn.effect) {</span>
        <span class="s1">fn = fn.effect.fn</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">_effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(fn)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options) {</span>
        <span class="s1">extend(_effect</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(options.scope)</span>
            <span class="s1">recordEffectScope(_effect</span><span class="s2">, </span><span class="s1">options.scope)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!options || !options.lazy) {</span>
        <span class="s1">_effect.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">runner = _effect.run.bind(_effect)</span><span class="s2">;</span>
    <span class="s1">runner.effect = _effect</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">runner</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">stop(runner) {</span>
    <span class="s1">runner.effect.stop()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">shouldTrack = </span><span class="s2">true;</span>
<span class="s2">const </span><span class="s1">trackStack = []</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">pauseTracking() {</span>
    <span class="s1">trackStack.push(shouldTrack)</span><span class="s2">;</span>
    <span class="s1">shouldTrack = </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetTracking() {</span>
    <span class="s2">const </span><span class="s1">last = trackStack.pop()</span><span class="s2">;</span>
    <span class="s1">shouldTrack = last === undefined ? </span><span class="s2">true </span><span class="s1">: last</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">track(target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">if </span><span class="s1">(shouldTrack &amp;&amp; activeEffect) {</span>
        <span class="s2">let </span><span class="s1">depsMap = targetMap.get(target)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!depsMap) {</span>
            <span class="s1">targetMap.set(target</span><span class="s2">, </span><span class="s1">(depsMap = </span><span class="s2">new </span><span class="s1">Map()))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">dep = depsMap.get(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!dep) {</span>
            <span class="s1">depsMap.set(key</span><span class="s2">, </span><span class="s1">(dep = createDep()))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">eventInfo = { effect: activeEffect</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key }</span>
            <span class="s2">;</span>
        <span class="s1">trackEffects(dep</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">trackEffects(dep</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
    <span class="s2">let </span><span class="s1">shouldTrack = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
        <span class="s2">if </span><span class="s1">(!newTracked(dep)) {</span>
            <span class="s1">dep.n |= trackOpBit</span><span class="s2">; </span><span class="s5">// set newly tracked</span>
            <span class="s1">shouldTrack = !wasTracked(dep)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// Full cleanup mode.</span>
        <span class="s1">shouldTrack = !dep.has(activeEffect)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shouldTrack) {</span>
        <span class="s1">dep.add(activeEffect)</span><span class="s2">;</span>
        <span class="s1">activeEffect.deps.push(dep)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(activeEffect.onTrack) {</span>
            <span class="s1">activeEffect.onTrack(Object.assign({ effect: activeEffect }</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">trigger(target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">newValue</span><span class="s2">, </span><span class="s1">oldValue</span><span class="s2">, </span><span class="s1">oldTarget) {</span>
    <span class="s2">const </span><span class="s1">depsMap = targetMap.get(target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!depsMap) {</span>
        <span class="s5">// never been tracked</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">deps = []</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">&quot;clear&quot; </span><span class="s5">/* TriggerOpTypes.CLEAR */</span><span class="s1">) {</span>
        <span class="s5">// collection being cleared</span>
        <span class="s5">// trigger all effects for target</span>
        <span class="s1">deps = [...depsMap.values()]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">'length' </span><span class="s1">&amp;&amp; isArray(target)) {</span>
        <span class="s2">const </span><span class="s1">newLength = Number(newValue)</span><span class="s2">;</span>
        <span class="s1">depsMap.forEach((dep</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'length' </span><span class="s1">|| key &gt;= newLength) {</span>
                <span class="s1">deps.push(dep)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// schedule runs for SET | ADD | DELETE</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">deps.push(depsMap.get(key))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// also run for iteration key on ADD | DELETE | Map.SET</span>
        <span class="s2">switch </span><span class="s1">(type) {</span>
            <span class="s2">case </span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(!isArray(target)) {</span>
                    <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
                        <span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(isIntegerKey(key)) {</span>
                    <span class="s5">// new index added to array -&gt; length changes</span>
                    <span class="s1">deps.push(depsMap.get(</span><span class="s3">'length'</span><span class="s1">))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(!isArray(target)) {</span>
                    <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
                        <span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
                    <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">eventInfo = { target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">newValue</span><span class="s2">, </span><span class="s1">oldValue</span><span class="s2">, </span><span class="s1">oldTarget }</span>
        <span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(deps.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(deps[</span><span class="s4">0</span><span class="s1">]) {</span>
            <span class="s1">{</span>
                <span class="s1">triggerEffects(deps[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">effects = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of deps) {</span>
            <span class="s2">if </span><span class="s1">(dep) {</span>
                <span class="s1">effects.push(...dep)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">triggerEffects(createDep(effects)</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerEffects(dep</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
    <span class="s5">// spread into array for stabilization</span>
    <span class="s2">const </span><span class="s1">effects = isArray(dep) ? dep : [...dep]</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">effect of effects) {</span>
        <span class="s2">if </span><span class="s1">(effect.computed) {</span>
            <span class="s1">triggerEffect(effect</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">effect of effects) {</span>
        <span class="s2">if </span><span class="s1">(!effect.computed) {</span>
            <span class="s1">triggerEffect(effect</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerEffect(effect</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
    <span class="s2">if </span><span class="s1">(effect !== activeEffect || effect.allowRecurse) {</span>
        <span class="s2">if </span><span class="s1">(effect.onTrigger) {</span>
            <span class="s1">effect.onTrigger(extend({ effect }</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(effect.scheduler) {</span>
            <span class="s1">effect.scheduler()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">effect.run()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDepFromReactive(object</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">var </span><span class="s1">_a</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(_a = targetMap.get(object)) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a.get(key)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isNonTrackableKeys = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">`__proto__,__v_isRef,__isVue`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">builtInSymbols = </span><span class="s2">new </span><span class="s1">Set(</span>
<span class="s5">/*#__PURE__*/</span>
<span class="s1">Object.getOwnPropertyNames(Symbol)</span>
    <span class="s5">// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'</span>
    <span class="s5">// but accessing them on Symbol leads to TypeError because Symbol is a strict mode</span>
    <span class="s5">// function</span>
    <span class="s1">.filter(key =&gt; key !== </span><span class="s3">'arguments' </span><span class="s1">&amp;&amp; key !== </span><span class="s3">'caller'</span><span class="s1">)</span>
    <span class="s1">.map(key =&gt; Symbol[key])</span>
    <span class="s1">.filter(isSymbol))</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">get$1 = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createGetter()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowGet = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createGetter(</span><span class="s2">false, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">readonlyGet = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createGetter(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowReadonlyGet = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createGetter(</span><span class="s2">true, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">arrayInstrumentations = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createArrayInstrumentations()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createArrayInstrumentations() {</span>
    <span class="s2">const </span><span class="s1">instrumentations = {}</span><span class="s2">;</span>
    <span class="s1">[</span><span class="s3">'includes'</span><span class="s2">, </span><span class="s3">'indexOf'</span><span class="s2">, </span><span class="s3">'lastIndexOf'</span><span class="s1">].forEach(key =&gt; {</span>
        <span class="s1">instrumentations[key] = </span><span class="s2">function </span><span class="s1">(...args) {</span>
            <span class="s2">const </span><span class="s1">arr = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">track(arr</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s1">i + </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// we run the method using the original args first (which may be reactive)</span>
            <span class="s2">const </span><span class="s1">res = arr[key](...args)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(res === -</span><span class="s4">1 </span><span class="s1">|| res === </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s5">// if that didn't work, run it again using raw values.</span>
                <span class="s2">return </span><span class="s1">arr[key](...args.map(toRaw))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">[</span><span class="s3">'push'</span><span class="s2">, </span><span class="s3">'pop'</span><span class="s2">, </span><span class="s3">'shift'</span><span class="s2">, </span><span class="s3">'unshift'</span><span class="s2">, </span><span class="s3">'splice'</span><span class="s1">].forEach(key =&gt; {</span>
        <span class="s1">instrumentations[key] = </span><span class="s2">function </span><span class="s1">(...args) {</span>
            <span class="s1">pauseTracking()</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">res = toRaw(</span><span class="s2">this</span><span class="s1">)[key].apply(</span><span class="s2">this, </span><span class="s1">args)</span><span class="s2">;</span>
            <span class="s1">resetTracking()</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">instrumentations</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasOwnProperty(key) {</span>
    <span class="s2">const </span><span class="s1">obj = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">track(obj</span><span class="s2">, </span><span class="s3">&quot;has&quot; </span><span class="s5">/* TrackOpTypes.HAS */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">obj.hasOwnProperty(key)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createGetter(isReadonly = </span><span class="s2">false, </span><span class="s1">shallow = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return function </span><span class="s1">get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReactive&quot; </span><span class="s5">/* ReactiveFlags.IS_REACTIVE */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">!isReadonly</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReadonly&quot; </span><span class="s5">/* ReactiveFlags.IS_READONLY */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">isReadonly</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isShallow&quot; </span><span class="s5">/* ReactiveFlags.IS_SHALLOW */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">shallow</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">receiver ===</span>
                <span class="s1">(isReadonly</span>
                    <span class="s1">? shallow</span>
                        <span class="s1">? shallowReadonlyMap</span>
                        <span class="s1">: readonlyMap</span>
                    <span class="s1">: shallow</span>
                        <span class="s1">? shallowReactiveMap</span>
                        <span class="s1">: reactiveMap).get(target)) {</span>
            <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">targetIsArray = isArray(target)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isReadonly) {</span>
            <span class="s2">if </span><span class="s1">(targetIsArray &amp;&amp; hasOwn(arrayInstrumentations</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s2">return </span><span class="s1">Reflect.get(arrayInstrumentations</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'hasOwnProperty'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">hasOwnProperty</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">res = Reflect.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {</span>
            <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isReadonly) {</span>
            <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shallow) {</span>
            <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isRef(res)) {</span>
            <span class="s5">// ref unwrapping - skip unwrap for Array + integer key.</span>
            <span class="s2">return </span><span class="s1">targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isObject(res)) {</span>
            <span class="s5">// Convert returned value into a proxy as well. we do the isObject check</span>
            <span class="s5">// here to avoid invalid value warning. Also need to lazy access readonly</span>
            <span class="s5">// and reactive here to avoid circular dependency.</span>
            <span class="s2">return </span><span class="s1">isReadonly ? readonly(res) : reactive(res)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">set$1 = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createSetter()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowSet = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createSetter(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createSetter(shallow = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return function </span><span class="s1">set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver) {</span>
        <span class="s2">let </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isReadonly(oldValue) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!shallow) {</span>
            <span class="s2">if </span><span class="s1">(!isShallow(value) &amp;&amp; !isReadonly(value)) {</span>
                <span class="s1">oldValue = toRaw(oldValue)</span><span class="s2">;</span>
                <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
                <span class="s1">oldValue.value = value</span><span class="s2">;</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">hadKey = isArray(target) &amp;&amp; isIntegerKey(key)</span>
            <span class="s1">? Number(key) &lt; target.length</span>
            <span class="s1">: hasOwn(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">result = Reflect.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
        <span class="s5">// don't trigger if target is something up in the prototype chain of original</span>
        <span class="s2">if </span><span class="s1">(target === toRaw(receiver)) {</span>
            <span class="s2">if </span><span class="s1">(!hadKey) {</span>
                <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(hasChanged(value</span><span class="s2">, </span><span class="s1">oldValue)) {</span>
                <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deleteProperty(target</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">hadKey = hasOwn(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = Reflect.deleteProperty(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(result &amp;&amp; hadKey) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">has$1(target</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">result = Reflect.has(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isSymbol(key) || !builtInSymbols.has(key)) {</span>
        <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;has&quot; </span><span class="s5">/* TrackOpTypes.HAS */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ownKeys(target) {</span>
    <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;iterate&quot; </span><span class="s5">/* TrackOpTypes.ITERATE */</span><span class="s2">, </span><span class="s1">isArray(target) ? </span><span class="s3">'length' </span><span class="s1">: ITERATE_KEY)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">Reflect.ownKeys(target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">mutableHandlers = {</span>
    <span class="s1">get: get$1</span><span class="s2">,</span>
    <span class="s1">set: set$1</span><span class="s2">,</span>
    <span class="s1">deleteProperty</span><span class="s2">,</span>
    <span class="s1">has: has$1</span><span class="s2">,</span>
    <span class="s1">ownKeys</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">readonlyHandlers = {</span>
    <span class="s1">get: readonlyGet</span><span class="s2">,</span>
    <span class="s1">set(target</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s1">{</span>
            <span class="s1">warn$1(</span><span class="s3">`Set operation on key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; failed: target is readonly.`</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">deleteProperty(target</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s1">{</span>
            <span class="s1">warn$1(</span><span class="s3">`Delete operation on key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; failed: target is readonly.`</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowReactiveHandlers = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">mutableHandlers</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">get: shallowGet</span><span class="s2">,</span>
    <span class="s1">set: shallowSet</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s5">// Props handlers are special in the sense that it should not unwrap top-level</span>
<span class="s5">// refs (in order to allow refs to be explicitly passed down), but should</span>
<span class="s5">// retain the reactivity of the normal readonly object.</span>
<span class="s2">const </span><span class="s1">shallowReadonlyHandlers = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">readonlyHandlers</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">get: shallowReadonlyGet</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">toShallow = (value) =&gt; value</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getProto = (v) =&gt; Reflect.getPrototypeOf(v)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">isReadonly = </span><span class="s2">false, </span><span class="s1">isShallow = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s5">// #1772: readonly(reactive(Map)) should return readonly + reactive version</span>
    <span class="s5">// of the value</span>
    <span class="s1">target = target[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isReadonly) {</span>
        <span class="s2">if </span><span class="s1">(key !== rawKey) {</span>
            <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s1">rawKey)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ has } = getProto(rawTarget)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(has.call(rawTarget</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s2">return </span><span class="s1">wrap(target.get(key))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(has.call(rawTarget</span><span class="s2">, </span><span class="s1">rawKey)) {</span>
        <span class="s2">return </span><span class="s1">wrap(target.get(rawKey))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(target !== rawTarget) {</span>
        <span class="s5">// #3602 readonly(reactive(Map))</span>
        <span class="s5">// ensure that the nested reactive `Map` can do tracking for itself</span>
        <span class="s1">target.get(key)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">has(key</span><span class="s2">, </span><span class="s1">isReadonly = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isReadonly) {</span>
        <span class="s2">if </span><span class="s1">(key !== rawKey) {</span>
            <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;has&quot; </span><span class="s5">/* TrackOpTypes.HAS */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;has&quot; </span><span class="s5">/* TrackOpTypes.HAS */</span><span class="s2">, </span><span class="s1">rawKey)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">key === rawKey</span>
        <span class="s1">? target.has(key)</span>
        <span class="s1">: target.has(key) || target.has(rawKey)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">size(target</span><span class="s2">, </span><span class="s1">isReadonly = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">target = target[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">!isReadonly &amp;&amp; track(toRaw(target)</span><span class="s2">, </span><span class="s3">&quot;iterate&quot; </span><span class="s5">/* TrackOpTypes.ITERATE */</span><span class="s2">, </span><span class="s1">ITERATE_KEY)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">Reflect.get(target</span><span class="s2">, </span><span class="s3">'size'</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">add(value) {</span>
    <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">proto = getProto(target)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hadKey = proto.has.call(target</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hadKey) {</span>
        <span class="s1">target.add(value)</span><span class="s2">;</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return this;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">set(key</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ has</span><span class="s2">, </span><span class="s1">get } = getProto(target)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hadKey = has.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hadKey) {</span>
        <span class="s1">key = toRaw(key)</span><span class="s2">;</span>
        <span class="s1">hadKey = has.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">oldValue = get.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">target.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hadKey) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(hasChanged(value</span><span class="s2">, </span><span class="s1">oldValue)) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return this;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deleteEntry(key) {</span>
    <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ has</span><span class="s2">, </span><span class="s1">get } = getProto(target)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hadKey = has.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hadKey) {</span>
        <span class="s1">key = toRaw(key)</span><span class="s2">;</span>
        <span class="s1">hadKey = has.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">oldValue = get ? get.call(target</span><span class="s2">, </span><span class="s1">key) : undefined</span><span class="s2">;</span>
    <span class="s5">// forward the operation before queueing reactions</span>
    <span class="s2">const </span><span class="s1">result = target.delete(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hadKey) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clear() {</span>
    <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hadItems = target.size !== </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">oldTarget = isMap(target)</span>
            <span class="s1">? </span><span class="s2">new </span><span class="s1">Map(target)</span>
            <span class="s1">: </span><span class="s2">new </span><span class="s1">Set(target)</span>
        <span class="s2">;</span>
    <span class="s5">// forward the operation before queueing reactions</span>
    <span class="s2">const </span><span class="s1">result = target.clear()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hadItems) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;clear&quot; </span><span class="s5">/* TriggerOpTypes.CLEAR */</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">oldTarget)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createForEach(isReadonly</span><span class="s2">, </span><span class="s1">isShallow) {</span>
    <span class="s2">return function </span><span class="s1">forEach(callback</span><span class="s2">, </span><span class="s1">thisArg) {</span>
        <span class="s2">const </span><span class="s1">observed = </span><span class="s2">this;</span>
        <span class="s2">const </span><span class="s1">target = observed[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive</span><span class="s2">;</span>
        <span class="s1">!isReadonly &amp;&amp; track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;iterate&quot; </span><span class="s5">/* TrackOpTypes.ITERATE */</span><span class="s2">, </span><span class="s1">ITERATE_KEY)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">target.forEach((value</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
            <span class="s5">// important: make sure the callback is</span>
            <span class="s5">// 1. invoked with the reactive map as `this` and 3rd arg</span>
            <span class="s5">// 2. the value received should be a corresponding reactive/readonly.</span>
            <span class="s2">return </span><span class="s1">callback.call(thisArg</span><span class="s2">, </span><span class="s1">wrap(value)</span><span class="s2">, </span><span class="s1">wrap(key)</span><span class="s2">, </span><span class="s1">observed)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createIterableMethod(method</span><span class="s2">, </span><span class="s1">isReadonly</span><span class="s2">, </span><span class="s1">isShallow) {</span>
    <span class="s2">return function </span><span class="s1">(...args) {</span>
        <span class="s2">const </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">targetIsMap = isMap(rawTarget)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isPair = method === </span><span class="s3">'entries' </span><span class="s1">|| (method === Symbol.iterator &amp;&amp; targetIsMap)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isKeyOnly = method === </span><span class="s3">'keys' </span><span class="s1">&amp;&amp; targetIsMap</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">innerIterator = target[method](...args)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive</span><span class="s2">;</span>
        <span class="s1">!isReadonly &amp;&amp;</span>
            <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;iterate&quot; </span><span class="s5">/* TrackOpTypes.ITERATE */</span><span class="s2">, </span><span class="s1">isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY)</span><span class="s2">;</span>
        <span class="s5">// return a wrapped iterator which returns observed versions of the</span>
        <span class="s5">// values emitted from the real iterator</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s5">// iterator protocol</span>
            <span class="s1">next() {</span>
                <span class="s2">const </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">done } = innerIterator.next()</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">done</span>
                    <span class="s1">? { value</span><span class="s2">, </span><span class="s1">done }</span>
                    <span class="s1">: {</span>
                        <span class="s1">value: isPair ? [wrap(value[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">wrap(value[</span><span class="s4">1</span><span class="s1">])] : wrap(value)</span><span class="s2">,</span>
                        <span class="s1">done</span>
                    <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s5">// iterable protocol</span>
            <span class="s1">[Symbol.iterator]() {</span>
                <span class="s2">return this;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createReadonlyMethod(type) {</span>
    <span class="s2">return function </span><span class="s1">(...args) {</span>
        <span class="s1">{</span>
            <span class="s2">const </span><span class="s1">key = args[</span><span class="s4">0</span><span class="s1">] ? </span><span class="s3">`on key &quot;</span><span class="s1">${args[</span><span class="s4">0</span><span class="s1">]}</span><span class="s3">&quot; ` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
            <span class="s1">console.warn(</span><span class="s3">`</span><span class="s1">${capitalize(type)} </span><span class="s3">operation </span><span class="s1">${key}</span><span class="s3">failed: target is readonly.`</span><span class="s2">, </span><span class="s1">toRaw(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">type === </span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */ </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: </span><span class="s2">this;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createInstrumentations() {</span>
    <span class="s2">const </span><span class="s1">mutableInstrumentations = {</span>
        <span class="s1">get(key) {</span>
            <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get size() {</span>
            <span class="s2">return </span><span class="s1">size(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has</span><span class="s2">,</span>
        <span class="s1">add</span><span class="s2">,</span>
        <span class="s1">set</span><span class="s2">,</span>
        <span class="s2">delete</span><span class="s1">: deleteEntry</span><span class="s2">,</span>
        <span class="s1">clear</span><span class="s2">,</span>
        <span class="s1">forEach: createForEach(</span><span class="s2">false, false</span><span class="s1">)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">shallowInstrumentations = {</span>
        <span class="s1">get(key) {</span>
            <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get size() {</span>
            <span class="s2">return </span><span class="s1">size(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has</span><span class="s2">,</span>
        <span class="s1">add</span><span class="s2">,</span>
        <span class="s1">set</span><span class="s2">,</span>
        <span class="s2">delete</span><span class="s1">: deleteEntry</span><span class="s2">,</span>
        <span class="s1">clear</span><span class="s2">,</span>
        <span class="s1">forEach: createForEach(</span><span class="s2">false, true</span><span class="s1">)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">readonlyInstrumentations = {</span>
        <span class="s1">get(key) {</span>
            <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get size() {</span>
            <span class="s2">return </span><span class="s1">size(</span><span class="s2">this, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has(key) {</span>
            <span class="s2">return </span><span class="s1">has.call(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">add: createReadonlyMethod(</span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">set: createReadonlyMethod(</span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s2">delete</span><span class="s1">: createReadonlyMethod(</span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">clear: createReadonlyMethod(</span><span class="s3">&quot;clear&quot; </span><span class="s5">/* TriggerOpTypes.CLEAR */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">forEach: createForEach(</span><span class="s2">true, false</span><span class="s1">)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">shallowReadonlyInstrumentations = {</span>
        <span class="s1">get(key) {</span>
            <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">get size() {</span>
            <span class="s2">return </span><span class="s1">size(</span><span class="s2">this, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">has(key) {</span>
            <span class="s2">return </span><span class="s1">has.call(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">add: createReadonlyMethod(</span><span class="s3">&quot;add&quot; </span><span class="s5">/* TriggerOpTypes.ADD */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">set: createReadonlyMethod(</span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s2">delete</span><span class="s1">: createReadonlyMethod(</span><span class="s3">&quot;delete&quot; </span><span class="s5">/* TriggerOpTypes.DELETE */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">clear: createReadonlyMethod(</span><span class="s3">&quot;clear&quot; </span><span class="s5">/* TriggerOpTypes.CLEAR */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">forEach: createForEach(</span><span class="s2">true, true</span><span class="s1">)</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">iteratorMethods = [</span><span class="s3">'keys'</span><span class="s2">, </span><span class="s3">'values'</span><span class="s2">, </span><span class="s3">'entries'</span><span class="s2">, </span><span class="s1">Symbol.iterator]</span><span class="s2">;</span>
    <span class="s1">iteratorMethods.forEach(method =&gt; {</span>
        <span class="s1">mutableInstrumentations[method] = createIterableMethod(method</span><span class="s2">, false, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">readonlyInstrumentations[method] = createIterableMethod(method</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">shallowInstrumentations[method] = createIterableMethod(method</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">shallowReadonlyInstrumentations[method] = createIterableMethod(method</span><span class="s2">, true, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">mutableInstrumentations</span><span class="s2">,</span>
        <span class="s1">readonlyInstrumentations</span><span class="s2">,</span>
        <span class="s1">shallowInstrumentations</span><span class="s2">,</span>
        <span class="s1">shallowReadonlyInstrumentations</span>
    <span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">[mutableInstrumentations</span><span class="s2">, </span><span class="s1">readonlyInstrumentations</span><span class="s2">, </span><span class="s1">shallowInstrumentations</span><span class="s2">, </span><span class="s1">shallowReadonlyInstrumentations] = </span><span class="s5">/* #__PURE__*/ </span><span class="s1">createInstrumentations()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createInstrumentationGetter(isReadonly</span><span class="s2">, </span><span class="s1">shallow) {</span>
    <span class="s2">const </span><span class="s1">instrumentations = shallow</span>
        <span class="s1">? isReadonly</span>
            <span class="s1">? shallowReadonlyInstrumentations</span>
            <span class="s1">: shallowInstrumentations</span>
        <span class="s1">: isReadonly</span>
            <span class="s1">? readonlyInstrumentations</span>
            <span class="s1">: mutableInstrumentations</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReactive&quot; </span><span class="s5">/* ReactiveFlags.IS_REACTIVE */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">!isReadonly</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReadonly&quot; </span><span class="s5">/* ReactiveFlags.IS_READONLY */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">isReadonly</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Reflect.get(hasOwn(instrumentations</span><span class="s2">, </span><span class="s1">key) &amp;&amp; key </span><span class="s2">in </span><span class="s1">target</span>
            <span class="s1">? instrumentations</span>
            <span class="s1">: target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">mutableCollectionHandlers = {</span>
    <span class="s1">get: </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createInstrumentationGetter(</span><span class="s2">false, false</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowCollectionHandlers = {</span>
    <span class="s1">get: </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createInstrumentationGetter(</span><span class="s2">false, true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">readonlyCollectionHandlers = {</span>
    <span class="s1">get: </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createInstrumentationGetter(</span><span class="s2">true, false</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowReadonlyCollectionHandlers = {</span>
    <span class="s1">get: </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createInstrumentationGetter(</span><span class="s2">true, true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(rawKey !== key &amp;&amp; has.call(target</span><span class="s2">, </span><span class="s1">rawKey)) {</span>
        <span class="s2">const </span><span class="s1">type = toRawType(target)</span><span class="s2">;</span>
        <span class="s1">console.warn(</span><span class="s3">`Reactive </span><span class="s1">${type} </span><span class="s3">contains both the raw and reactive ` </span><span class="s1">+</span>
            <span class="s3">`versions of the same object</span><span class="s1">${type === </span><span class="s3">`Map` </span><span class="s1">? </span><span class="s3">` as keys` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">, ` </span><span class="s1">+</span>
            <span class="s3">`which can lead to inconsistencies. ` </span><span class="s1">+</span>
            <span class="s3">`Avoid differentiating between the raw and reactive versions ` </span><span class="s1">+</span>
            <span class="s3">`of an object and only use the reactive version if possible.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">reactiveMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowReactiveMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">readonlyMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">shallowReadonlyMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">targetTypeMap(rawType) {</span>
    <span class="s2">switch </span><span class="s1">(rawType) {</span>
        <span class="s2">case </span><span class="s3">'Object'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'Array'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">1 </span><span class="s5">/* TargetType.COMMON */</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s3">'Map'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'Set'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'WeakMap'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s3">'WeakSet'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">2 </span><span class="s5">/* TargetType.COLLECTION */</span><span class="s2">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* TargetType.INVALID */</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTargetType(value) {</span>
    <span class="s2">return </span><span class="s1">value[</span><span class="s3">&quot;__v_skip&quot; </span><span class="s5">/* ReactiveFlags.SKIP */</span><span class="s1">] || !Object.isExtensible(value)</span>
        <span class="s1">? </span><span class="s4">0 </span><span class="s5">/* TargetType.INVALID */</span>
        <span class="s1">: targetTypeMap(toRawType(value))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reactive(target) {</span>
    <span class="s5">// if trying to observe a readonly proxy, return the readonly version.</span>
    <span class="s2">if </span><span class="s1">(isReadonly(target)) {</span>
        <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, false, </span><span class="s1">mutableHandlers</span><span class="s2">, </span><span class="s1">mutableCollectionHandlers</span><span class="s2">, </span><span class="s1">reactiveMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Return a shallowly-reactive copy of the original object, where only the root</span>
 <span class="s0">* level properties are reactive. It also does not auto-unwrap refs (even at the</span>
 <span class="s0">* root level).</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">shallowReactive(target) {</span>
    <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, false, </span><span class="s1">shallowReactiveHandlers</span><span class="s2">, </span><span class="s1">shallowCollectionHandlers</span><span class="s2">, </span><span class="s1">shallowReactiveMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Creates a readonly copy of the original object. Note the returned copy is not</span>
 <span class="s0">* made reactive, but `readonly` can be called on an already reactive object.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">readonly(target) {</span>
    <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, true, </span><span class="s1">readonlyHandlers</span><span class="s2">, </span><span class="s1">readonlyCollectionHandlers</span><span class="s2">, </span><span class="s1">readonlyMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Returns a reactive-copy of the original object, where only the root level</span>
 <span class="s0">* properties are readonly, and does NOT unwrap refs nor recursively convert</span>
 <span class="s0">* returned properties.</span>
 <span class="s0">* This is used for creating the props proxy object for stateful components.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">shallowReadonly(target) {</span>
    <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, true, </span><span class="s1">shallowReadonlyHandlers</span><span class="s2">, </span><span class="s1">shallowReadonlyCollectionHandlers</span><span class="s2">, </span><span class="s1">shallowReadonlyMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createReactiveObject(target</span><span class="s2">, </span><span class="s1">isReadonly</span><span class="s2">, </span><span class="s1">baseHandlers</span><span class="s2">, </span><span class="s1">collectionHandlers</span><span class="s2">, </span><span class="s1">proxyMap) {</span>
    <span class="s2">if </span><span class="s1">(!isObject(target)) {</span>
        <span class="s1">{</span>
            <span class="s1">console.warn(</span><span class="s3">`value cannot be made reactive: </span><span class="s1">${String(target)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// target is already a Proxy, return it.</span>
    <span class="s5">// exception: calling readonly() on a reactive object</span>
    <span class="s2">if </span><span class="s1">(target[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">] &amp;&amp;</span>
        <span class="s1">!(isReadonly &amp;&amp; target[</span><span class="s3">&quot;__v_isReactive&quot; </span><span class="s5">/* ReactiveFlags.IS_REACTIVE */</span><span class="s1">])) {</span>
        <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// target already has corresponding Proxy</span>
    <span class="s2">const </span><span class="s1">existingProxy = proxyMap.get(target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(existingProxy) {</span>
        <span class="s2">return </span><span class="s1">existingProxy</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// only specific value types can be observed.</span>
    <span class="s2">const </span><span class="s1">targetType = getTargetType(target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(targetType === </span><span class="s4">0 </span><span class="s5">/* TargetType.INVALID */</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">proxy = </span><span class="s2">new </span><span class="s1">Proxy(target</span><span class="s2">, </span><span class="s1">targetType === </span><span class="s4">2 </span><span class="s5">/* TargetType.COLLECTION */ </span><span class="s1">? collectionHandlers : baseHandlers)</span><span class="s2">;</span>
    <span class="s1">proxyMap.set(target</span><span class="s2">, </span><span class="s1">proxy)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">proxy</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isReactive(value) {</span>
    <span class="s2">if </span><span class="s1">(isReadonly(value)) {</span>
        <span class="s2">return </span><span class="s1">isReactive(value[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span><span class="s3">&quot;__v_isReactive&quot; </span><span class="s5">/* ReactiveFlags.IS_REACTIVE */</span><span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isReadonly(value) {</span>
    <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span><span class="s3">&quot;__v_isReadonly&quot; </span><span class="s5">/* ReactiveFlags.IS_READONLY */</span><span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isShallow(value) {</span>
    <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span><span class="s3">&quot;__v_isShallow&quot; </span><span class="s5">/* ReactiveFlags.IS_SHALLOW */</span><span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isProxy(value) {</span>
    <span class="s2">return </span><span class="s1">isReactive(value) || isReadonly(value)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toRaw(observed) {</span>
    <span class="s2">const </span><span class="s1">raw = observed &amp;&amp; observed[</span><span class="s3">&quot;__v_raw&quot; </span><span class="s5">/* ReactiveFlags.RAW */</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">raw ? toRaw(raw) : observed</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">markRaw(value) {</span>
    <span class="s1">def(value</span><span class="s2">, </span><span class="s3">&quot;__v_skip&quot; </span><span class="s5">/* ReactiveFlags.SKIP */</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">toReactive = (value) =&gt; isObject(value) ? reactive(value) : value</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">toReadonly = (value) =&gt; isObject(value) ? readonly(value) : value</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">trackRefValue(ref) {</span>
    <span class="s2">if </span><span class="s1">(shouldTrack &amp;&amp; activeEffect) {</span>
        <span class="s1">ref = toRaw(ref)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">trackEffects(ref.dep || (ref.dep = createDep())</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">target: ref</span><span class="s2">,</span>
                <span class="s1">type: </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">,</span>
                <span class="s1">key: </span><span class="s3">'value'</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerRefValue(ref</span><span class="s2">, </span><span class="s1">newVal) {</span>
    <span class="s1">ref = toRaw(ref)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dep = ref.dep</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dep) {</span>
        <span class="s1">{</span>
            <span class="s1">triggerEffects(dep</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">target: ref</span><span class="s2">,</span>
                <span class="s1">type: </span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s2">,</span>
                <span class="s1">key: </span><span class="s3">'value'</span><span class="s2">,</span>
                <span class="s1">newValue: newVal</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRef(r) {</span>
    <span class="s2">return </span><span class="s1">!!(r &amp;&amp; r.__v_isRef === </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ref(value) {</span>
    <span class="s2">return </span><span class="s1">createRef(value</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shallowRef(value) {</span>
    <span class="s2">return </span><span class="s1">createRef(value</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRef(rawValue</span><span class="s2">, </span><span class="s1">shallow) {</span>
    <span class="s2">if </span><span class="s1">(isRef(rawValue)) {</span>
        <span class="s2">return </span><span class="s1">rawValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return new </span><span class="s1">RefImpl(rawValue</span><span class="s2">, </span><span class="s1">shallow)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">RefImpl {</span>
    <span class="s1">constructor(value</span><span class="s2">, </span><span class="s1">__v_isShallow) {</span>
        <span class="s2">this</span><span class="s1">.__v_isShallow = __v_isShallow</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dep = undefined</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">._rawValue = __v_isShallow ? value : toRaw(value)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._value = __v_isShallow ? value : toReactive(value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">get value() {</span>
        <span class="s1">trackRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return this</span><span class="s1">._value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">set value(newVal) {</span>
        <span class="s2">const </span><span class="s1">useDirectValue = </span><span class="s2">this</span><span class="s1">.__v_isShallow || isShallow(newVal) || isReadonly(newVal)</span><span class="s2">;</span>
        <span class="s1">newVal = useDirectValue ? newVal : toRaw(newVal)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hasChanged(newVal</span><span class="s2">, this</span><span class="s1">._rawValue)) {</span>
            <span class="s2">this</span><span class="s1">._rawValue = newVal</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">._value = useDirectValue ? newVal : toReactive(newVal)</span><span class="s2">;</span>
            <span class="s1">triggerRefValue(</span><span class="s2">this, </span><span class="s1">newVal)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerRef(ref) {</span>
    <span class="s1">triggerRefValue(ref</span><span class="s2">, </span><span class="s1">ref.value )</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unref(ref) {</span>
    <span class="s2">return </span><span class="s1">isRef(ref) ? ref.value : ref</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">shallowUnwrapHandlers = {</span>
    <span class="s1">get: (target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) =&gt; unref(Reflect.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver))</span><span class="s2">,</span>
    <span class="s1">set: (target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver) =&gt; {</span>
        <span class="s2">const </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
            <span class="s1">oldValue.value = value</span><span class="s2">;</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">Reflect.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">proxyRefs(objectWithRefs) {</span>
    <span class="s2">return </span><span class="s1">isReactive(objectWithRefs)</span>
        <span class="s1">? objectWithRefs</span>
        <span class="s1">: </span><span class="s2">new </span><span class="s1">Proxy(objectWithRefs</span><span class="s2">, </span><span class="s1">shallowUnwrapHandlers)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">CustomRefImpl {</span>
    <span class="s1">constructor(factory) {</span>
        <span class="s2">this</span><span class="s1">.dep = undefined</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ get</span><span class="s2">, </span><span class="s1">set } = factory(() =&gt; trackRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">, </span><span class="s1">() =&gt; triggerRefValue(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._get = get</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._set = set</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">get value() {</span>
        <span class="s2">return this</span><span class="s1">._get()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">set value(newVal) {</span>
        <span class="s2">this</span><span class="s1">._set(newVal)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">customRef(factory) {</span>
    <span class="s2">return new </span><span class="s1">CustomRefImpl(factory)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toRefs(object) {</span>
    <span class="s2">if </span><span class="s1">(!isProxy(object)) {</span>
        <span class="s1">console.warn(</span><span class="s3">`toRefs() expects a reactive object but received a plain one.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">ret = isArray(object) ? </span><span class="s2">new </span><span class="s1">Array(object.length) : {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">object) {</span>
        <span class="s1">ret[key] = toRef(object</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">ObjectRefImpl {</span>
    <span class="s1">constructor(_object</span><span class="s2">, </span><span class="s1">_key</span><span class="s2">, </span><span class="s1">_defaultValue) {</span>
        <span class="s2">this</span><span class="s1">._object = _object</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._key = _key</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._defaultValue = _defaultValue</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s1">get value() {</span>
        <span class="s2">const </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">._object[</span><span class="s2">this</span><span class="s1">._key]</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">val === undefined ? </span><span class="s2">this</span><span class="s1">._defaultValue : val</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">set value(newVal) {</span>
        <span class="s2">this</span><span class="s1">._object[</span><span class="s2">this</span><span class="s1">._key] = newVal</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">get dep() {</span>
        <span class="s2">return </span><span class="s1">getDepFromReactive(toRaw(</span><span class="s2">this</span><span class="s1">._object)</span><span class="s2">, this</span><span class="s1">._key)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toRef(object</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">defaultValue) {</span>
    <span class="s2">const </span><span class="s1">val = object[key]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">isRef(val)</span>
        <span class="s1">? val</span>
        <span class="s1">: </span><span class="s2">new </span><span class="s1">ObjectRefImpl(object</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">defaultValue)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">_a</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">ComputedRefImpl {</span>
    <span class="s1">constructor(getter</span><span class="s2">, </span><span class="s1">_setter</span><span class="s2">, </span><span class="s1">isReadonly</span><span class="s2">, </span><span class="s1">isSSR) {</span>
        <span class="s2">this</span><span class="s1">._setter = _setter</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.dep = undefined</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">[_a] = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">._dirty = </span><span class="s2">true;</span>
        <span class="s2">this</span><span class="s1">.effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(getter</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._dirty) {</span>
                <span class="s2">this</span><span class="s1">._dirty = </span><span class="s2">true;</span>
                <span class="s1">triggerRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.effect.computed = </span><span class="s2">this;</span>
        <span class="s2">this</span><span class="s1">.effect.active = </span><span class="s2">this</span><span class="s1">._cacheable = !isSSR</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">[</span><span class="s3">&quot;__v_isReadonly&quot; </span><span class="s5">/* ReactiveFlags.IS_READONLY */</span><span class="s1">] = isReadonly</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">get value() {</span>
        <span class="s5">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span>
        <span class="s2">const </span><span class="s1">self = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">trackRefValue(self)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(self._dirty || !self._cacheable) {</span>
            <span class="s1">self._dirty = </span><span class="s2">false;</span>
            <span class="s1">self._value = self.effect.run()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self._value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">set value(newValue) {</span>
        <span class="s2">this</span><span class="s1">._setter(newValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">_a = </span><span class="s3">&quot;__v_isReadonly&quot; </span><span class="s5">/* ReactiveFlags.IS_READONLY */</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">computed$1(getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions</span><span class="s2">, </span><span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">getter</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">setter</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">onlyGetter = isFunction(getterOrOptions)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(onlyGetter) {</span>
        <span class="s1">getter = getterOrOptions</span><span class="s2">;</span>
        <span class="s1">setter = () =&gt; {</span>
                <span class="s1">console.warn(</span><span class="s3">'Write operation failed: computed value is readonly'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">getter = getterOrOptions.get</span><span class="s2">;</span>
        <span class="s1">setter = getterOrOptions.set</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">cRef = </span><span class="s2">new </span><span class="s1">ComputedRefImpl(getter</span><span class="s2">, </span><span class="s1">setter</span><span class="s2">, </span><span class="s1">onlyGetter || !setter</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(debugOptions &amp;&amp; !isSSR) {</span>
        <span class="s1">cRef.effect.onTrack = debugOptions.onTrack</span><span class="s2">;</span>
        <span class="s1">cRef.effect.onTrigger = debugOptions.onTrigger</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">cRef</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">stack = []</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">pushWarningContext(vnode) {</span>
    <span class="s1">stack.push(vnode)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">popWarningContext() {</span>
    <span class="s1">stack.pop()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">warn(msg</span><span class="s2">, </span><span class="s1">...args) {</span>
    <span class="s5">// avoid props formatting or warn handler tracking deps that might be mutated</span>
    <span class="s5">// during patch, leading to infinite recursion.</span>
    <span class="s1">pauseTracking()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">instance = stack.length ? stack[stack.length - </span><span class="s4">1</span><span class="s1">].component : </span><span class="s2">null;</span>
    <span class="s2">const </span><span class="s1">appWarnHandler = instance &amp;&amp; instance.appContext.config.warnHandler</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">trace = getComponentTrace()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(appWarnHandler) {</span>
        <span class="s1">callWithErrorHandling(appWarnHandler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">11 </span><span class="s5">/* ErrorCodes.APP_WARN_HANDLER */</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">msg + args.join(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">instance &amp;&amp; instance.proxy</span><span class="s2">,</span>
            <span class="s1">trace</span>
                <span class="s1">.map(({ vnode }) =&gt; </span><span class="s3">`at &lt;</span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">vnode.type)}</span><span class="s3">&gt;`</span><span class="s1">)</span>
                <span class="s1">.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">trace</span>
        <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">warnArgs = [</span><span class="s3">`[Vue warn]: </span><span class="s1">${msg}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">...args]</span><span class="s2">;</span>
        <span class="s5">/* istanbul ignore if */</span>
        <span class="s2">if </span><span class="s1">(trace.length &amp;&amp;</span>
            <span class="s5">// avoid spamming console during tests</span>
            <span class="s1">!</span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">warnArgs.push(</span><span class="s3">`</span><span class="s2">\n</span><span class="s3">`</span><span class="s2">, </span><span class="s1">...formatTrace(trace))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">console.warn(...warnArgs)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">resetTracking()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getComponentTrace() {</span>
    <span class="s2">let </span><span class="s1">currentVNode = stack[stack.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!currentVNode) {</span>
        <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// we can't just use the stack because it will be incomplete during updates</span>
    <span class="s5">// that did not start from the root. Re-construct the parent chain using</span>
    <span class="s5">// instance parent pointers.</span>
    <span class="s2">const </span><span class="s1">normalizedStack = []</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(currentVNode) {</span>
        <span class="s2">const </span><span class="s1">last = normalizedStack[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(last &amp;&amp; last.vnode === currentVNode) {</span>
            <span class="s1">last.recurseCount++</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">normalizedStack.push({</span>
                <span class="s1">vnode: currentVNode</span><span class="s2">,</span>
                <span class="s1">recurseCount: </span><span class="s4">0</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">parentInstance = currentVNode.component &amp;&amp; currentVNode.component.parent</span><span class="s2">;</span>
        <span class="s1">currentVNode = parentInstance &amp;&amp; parentInstance.vnode</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">normalizedStack</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/* istanbul ignore next */</span>
<span class="s2">function </span><span class="s1">formatTrace(trace) {</span>
    <span class="s2">const </span><span class="s1">logs = []</span><span class="s2">;</span>
    <span class="s1">trace.forEach((entry</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
        <span class="s1">logs.push(...(i === </span><span class="s4">0 </span><span class="s1">? [] : [</span><span class="s3">`</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">])</span><span class="s2">, </span><span class="s1">...formatTraceEntry(entry))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">logs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatTraceEntry({ vnode</span><span class="s2">, </span><span class="s1">recurseCount }) {</span>
    <span class="s2">const </span><span class="s1">postfix = recurseCount &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`... (</span><span class="s1">${recurseCount} </span><span class="s3">recursive calls)` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isRoot = vnode.component ? vnode.component.parent == </span><span class="s2">null </span><span class="s1">: </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">open = </span><span class="s3">` at &lt;</span><span class="s1">${formatComponentName(vnode.component</span><span class="s2">, </span><span class="s1">vnode.type</span><span class="s2">, </span><span class="s1">isRoot)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">close = </span><span class="s3">`&gt;` </span><span class="s1">+ postfix</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">vnode.props</span>
        <span class="s1">? [open</span><span class="s2">, </span><span class="s1">...formatProps(vnode.props)</span><span class="s2">, </span><span class="s1">close]</span>
        <span class="s1">: [open + close]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/* istanbul ignore next */</span>
<span class="s2">function </span><span class="s1">formatProps(props) {</span>
    <span class="s2">const </span><span class="s1">res = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">keys = Object.keys(props)</span><span class="s2">;</span>
    <span class="s1">keys.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">).forEach(key =&gt; {</span>
        <span class="s1">res.push(...formatProp(key</span><span class="s2">, </span><span class="s1">props[key]))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(keys.length &gt; </span><span class="s4">3</span><span class="s1">) {</span>
        <span class="s1">res.push(</span><span class="s3">` ...`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/* istanbul ignore next */</span>
<span class="s2">function </span><span class="s1">formatProp(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">raw) {</span>
    <span class="s2">if </span><span class="s1">(isString(value)) {</span>
        <span class="s1">value = JSON.stringify(value)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=</span><span class="s1">${value}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'number' </span><span class="s1">||</span>
        <span class="s2">typeof </span><span class="s1">value === </span><span class="s3">'boolean' </span><span class="s1">||</span>
        <span class="s1">value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=</span><span class="s1">${value}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isRef(value)) {</span>
        <span class="s1">value = formatProp(key</span><span class="s2">, </span><span class="s1">toRaw(value.value)</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=Ref&lt;`</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s3">`&gt;`</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isFunction(value)) {</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=fn</span><span class="s1">${value.name ? </span><span class="s3">`&lt;</span><span class="s1">${value.name}</span><span class="s3">&gt;` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=`</span><span class="s2">, </span><span class="s1">value]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">assertNumber(val</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">if </span><span class="s1">(val === undefined) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">val !== </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s1">warn(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">is not a valid number - ` </span><span class="s1">+ </span><span class="s3">`got </span><span class="s1">${JSON.stringify(val)}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isNaN(val)) {</span>
        <span class="s1">warn(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">is NaN - ` </span><span class="s1">+ </span><span class="s3">'the duration expression might be incorrect.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">ErrorTypeStrings = {</span>
    <span class="s1">[</span><span class="s3">&quot;sp&quot; </span><span class="s5">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s1">]: </span><span class="s3">'serverPrefetch hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;bc&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_CREATE */</span><span class="s1">]: </span><span class="s3">'beforeCreate hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;c&quot; </span><span class="s5">/* LifecycleHooks.CREATED */</span><span class="s1">]: </span><span class="s3">'created hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;bm&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_MOUNT */</span><span class="s1">]: </span><span class="s3">'beforeMount hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;m&quot; </span><span class="s5">/* LifecycleHooks.MOUNTED */</span><span class="s1">]: </span><span class="s3">'mounted hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;bu&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_UPDATE */</span><span class="s1">]: </span><span class="s3">'beforeUpdate hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;u&quot; </span><span class="s5">/* LifecycleHooks.UPDATED */</span><span class="s1">]: </span><span class="s3">'updated'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;bum&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_UNMOUNT */</span><span class="s1">]: </span><span class="s3">'beforeUnmount hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;um&quot; </span><span class="s5">/* LifecycleHooks.UNMOUNTED */</span><span class="s1">]: </span><span class="s3">'unmounted hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;a&quot; </span><span class="s5">/* LifecycleHooks.ACTIVATED */</span><span class="s1">]: </span><span class="s3">'activated hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;da&quot; </span><span class="s5">/* LifecycleHooks.DEACTIVATED */</span><span class="s1">]: </span><span class="s3">'deactivated hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;ec&quot; </span><span class="s5">/* LifecycleHooks.ERROR_CAPTURED */</span><span class="s1">]: </span><span class="s3">'errorCaptured hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;rtc&quot; </span><span class="s5">/* LifecycleHooks.RENDER_TRACKED */</span><span class="s1">]: </span><span class="s3">'renderTracked hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;rtg&quot; </span><span class="s5">/* LifecycleHooks.RENDER_TRIGGERED */</span><span class="s1">]: </span><span class="s3">'renderTriggered hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">0 </span><span class="s5">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s1">]: </span><span class="s3">'setup function'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* ErrorCodes.RENDER_FUNCTION */</span><span class="s1">]: </span><span class="s3">'render function'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* ErrorCodes.WATCH_GETTER */</span><span class="s1">]: </span><span class="s3">'watcher getter'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">3 </span><span class="s5">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">]: </span><span class="s3">'watcher callback'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">4 </span><span class="s5">/* ErrorCodes.WATCH_CLEANUP */</span><span class="s1">]: </span><span class="s3">'watcher cleanup function'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">5 </span><span class="s5">/* ErrorCodes.NATIVE_EVENT_HANDLER */</span><span class="s1">]: </span><span class="s3">'native event handler'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">6 </span><span class="s5">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s1">]: </span><span class="s3">'component event handler'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">7 </span><span class="s5">/* ErrorCodes.VNODE_HOOK */</span><span class="s1">]: </span><span class="s3">'vnode hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">8 </span><span class="s5">/* ErrorCodes.DIRECTIVE_HOOK */</span><span class="s1">]: </span><span class="s3">'directive hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">9 </span><span class="s5">/* ErrorCodes.TRANSITION_HOOK */</span><span class="s1">]: </span><span class="s3">'transition hook'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">10 </span><span class="s5">/* ErrorCodes.APP_ERROR_HANDLER */</span><span class="s1">]: </span><span class="s3">'app errorHandler'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">11 </span><span class="s5">/* ErrorCodes.APP_WARN_HANDLER */</span><span class="s1">]: </span><span class="s3">'app warnHandler'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">12 </span><span class="s5">/* ErrorCodes.FUNCTION_REF */</span><span class="s1">]: </span><span class="s3">'ref function'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">13 </span><span class="s5">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span><span class="s1">]: </span><span class="s3">'async component loader'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">14 </span><span class="s5">/* ErrorCodes.SCHEDULER */</span><span class="s1">]: </span><span class="s3">'scheduler flush. This is likely a Vue internals bug. ' </span><span class="s1">+</span>
        <span class="s3">'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">callWithErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args) {</span>
    <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">res = args ? fn(...args) : fn()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callWithAsyncErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args) {</span>
    <span class="s2">if </span><span class="s1">(isFunction(fn)) {</span>
        <span class="s2">const </span><span class="s1">res = callWithErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(res &amp;&amp; isPromise(res)) {</span>
            <span class="s1">res.catch(err =&gt; {</span>
                <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">values = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; fn.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">values.push(callWithAsyncErrorHandling(fn[i]</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">values</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">throwInDev = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">contextVNode = instance ? instance.vnode : </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(instance) {</span>
        <span class="s2">let </span><span class="s1">cur = instance.parent</span><span class="s2">;</span>
        <span class="s5">// the exposed instance is the render proxy to keep it consistent with 2.x</span>
        <span class="s2">const </span><span class="s1">exposedInstance = instance.proxy</span><span class="s2">;</span>
        <span class="s5">// in production the hook receives only the error code</span>
        <span class="s2">const </span><span class="s1">errorInfo = ErrorTypeStrings[type] </span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(cur) {</span>
            <span class="s2">const </span><span class="s1">errorCapturedHooks = cur.ec</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(errorCapturedHooks) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; errorCapturedHooks.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">if </span><span class="s1">(errorCapturedHooks[i](err</span><span class="s2">, </span><span class="s1">exposedInstance</span><span class="s2">, </span><span class="s1">errorInfo) === </span><span class="s2">false</span><span class="s1">) {</span>
                        <span class="s2">return;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">cur = cur.parent</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// app-level handling</span>
        <span class="s2">const </span><span class="s1">appErrorHandler = instance.appContext.config.errorHandler</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(appErrorHandler) {</span>
            <span class="s1">callWithErrorHandling(appErrorHandler</span><span class="s2">, null, </span><span class="s4">10 </span><span class="s5">/* ErrorCodes.APP_ERROR_HANDLER */</span><span class="s2">, </span><span class="s1">[err</span><span class="s2">, </span><span class="s1">exposedInstance</span><span class="s2">, </span><span class="s1">errorInfo])</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">logError(err</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">contextVNode</span><span class="s2">, </span><span class="s1">throwInDev)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">logError(err</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">contextVNode</span><span class="s2">, </span><span class="s1">throwInDev = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">info = ErrorTypeStrings[type]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(contextVNode) {</span>
            <span class="s1">pushWarningContext(contextVNode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">warn(</span><span class="s3">`Unhandled error</span><span class="s1">${info ? </span><span class="s3">` during execution of </span><span class="s1">${info}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(contextVNode) {</span>
            <span class="s1">popWarningContext()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// crash in dev by default so it's more noticeable</span>
        <span class="s2">if </span><span class="s1">(throwInDev) {</span>
            <span class="s2">throw </span><span class="s1">err</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">console.error(err)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">isFlushing = </span><span class="s2">false;</span>
<span class="s2">let </span><span class="s1">isFlushPending = </span><span class="s2">false;</span>
<span class="s2">const </span><span class="s1">queue = []</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">flushIndex = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">pendingPostFlushCbs = []</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">activePostFlushCbs = </span><span class="s2">null;</span>
<span class="s2">let </span><span class="s1">postFlushIndex = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">resolvedPromise = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">Promise.resolve()</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">currentFlushPromise = </span><span class="s2">null;</span>
<span class="s2">const </span><span class="s1">RECURSION_LIMIT = </span><span class="s4">100</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">nextTick(fn) {</span>
    <span class="s2">const </span><span class="s1">p = currentFlushPromise || resolvedPromise</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">fn ? p.then(</span><span class="s2">this </span><span class="s1">? fn.bind(</span><span class="s2">this</span><span class="s1">) : fn) : p</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// #2768</span>
<span class="s5">// Use binary-search to find a suitable position in the queue,</span>
<span class="s5">// so that the queue maintains the increasing order of job's id,</span>
<span class="s5">// which can prevent the job from being skipped and also can avoid repeated patching.</span>
<span class="s2">function </span><span class="s1">findInsertionIndex(id) {</span>
    <span class="s5">// the start index should be `flushIndex + 1`</span>
    <span class="s2">let </span><span class="s1">start = flushIndex + </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">end = queue.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(start &lt; end) {</span>
        <span class="s2">const </span><span class="s1">middle = (start + end) &gt;&gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">middleJobId = getId(queue[middle])</span><span class="s2">;</span>
        <span class="s1">middleJobId &lt; id ? (start = middle + </span><span class="s4">1</span><span class="s1">) : (end = middle)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">start</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueJob(job) {</span>
    <span class="s5">// the dedupe search uses the startIndex argument of Array.includes()</span>
    <span class="s5">// by default the search index includes the current job that is being run</span>
    <span class="s5">// so it cannot recursively trigger itself again.</span>
    <span class="s5">// if the job is a watch() callback, the search will start with a +1 index to</span>
    <span class="s5">// allow it recursively trigger itself - it is the user's responsibility to</span>
    <span class="s5">// ensure it doesn't end up in an infinite loop.</span>
    <span class="s2">if </span><span class="s1">(!queue.length ||</span>
        <span class="s1">!queue.includes(job</span><span class="s2">, </span><span class="s1">isFlushing &amp;&amp; job.allowRecurse ? flushIndex + </span><span class="s4">1 </span><span class="s1">: flushIndex)) {</span>
        <span class="s2">if </span><span class="s1">(job.id == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">queue.push(job)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">queue.splice(findInsertionIndex(job.id)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">job)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">queueFlush()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueFlush() {</span>
    <span class="s2">if </span><span class="s1">(!isFlushing &amp;&amp; !isFlushPending) {</span>
        <span class="s1">isFlushPending = </span><span class="s2">true;</span>
        <span class="s1">currentFlushPromise = resolvedPromise.then(flushJobs)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invalidateJob(job) {</span>
    <span class="s2">const </span><span class="s1">i = queue.indexOf(job)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(i &gt; flushIndex) {</span>
        <span class="s1">queue.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queuePostFlushCb(cb) {</span>
    <span class="s2">if </span><span class="s1">(!isArray(cb)) {</span>
        <span class="s2">if </span><span class="s1">(!activePostFlushCbs ||</span>
            <span class="s1">!activePostFlushCbs.includes(cb</span><span class="s2">, </span><span class="s1">cb.allowRecurse ? postFlushIndex + </span><span class="s4">1 </span><span class="s1">: postFlushIndex)) {</span>
            <span class="s1">pendingPostFlushCbs.push(cb)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// if cb is an array, it is a component lifecycle hook which can only be</span>
        <span class="s5">// triggered by a job, which is already deduped in the main queue, so</span>
        <span class="s5">// we can skip duplicate check here to improve perf</span>
        <span class="s1">pendingPostFlushCbs.push(...cb)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">queueFlush()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">flushPreFlushCbs(seen</span><span class="s2">, </span>
<span class="s5">// if currently flushing, skip the current job itself</span>
<span class="s1">i = isFlushing ? flushIndex + </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">{</span>
        <span class="s1">seen = seen || </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">; </span><span class="s1">i &lt; queue.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">cb = queue[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cb &amp;&amp; cb.pre) {</span>
            <span class="s2">if </span><span class="s1">(checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">cb)) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">queue.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">i--</span><span class="s2">;</span>
            <span class="s1">cb()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">flushPostFlushCbs(seen) {</span>
    <span class="s2">if </span><span class="s1">(pendingPostFlushCbs.length) {</span>
        <span class="s2">const </span><span class="s1">deduped = [...</span><span class="s2">new </span><span class="s1">Set(pendingPostFlushCbs)]</span><span class="s2">;</span>
        <span class="s1">pendingPostFlushCbs.length = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s5">// #1947 already has active queue, nested flushPostFlushCbs call</span>
        <span class="s2">if </span><span class="s1">(activePostFlushCbs) {</span>
            <span class="s1">activePostFlushCbs.push(...deduped)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">activePostFlushCbs = deduped</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">seen = seen || </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">activePostFlushCbs.sort((a</span><span class="s2">, </span><span class="s1">b) =&gt; getId(a) - getId(b))</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(postFlushIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">postFlushIndex &lt; activePostFlushCbs.length</span><span class="s2">; </span><span class="s1">postFlushIndex++) {</span>
            <span class="s2">if </span><span class="s1">(checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">activePostFlushCbs[postFlushIndex])) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">activePostFlushCbs[postFlushIndex]()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">activePostFlushCbs = </span><span class="s2">null;</span>
        <span class="s1">postFlushIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getId = (job) =&gt; job.id == </span><span class="s2">null </span><span class="s1">? Infinity : job.id</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">comparator = (a</span><span class="s2">, </span><span class="s1">b) =&gt; {</span>
    <span class="s2">const </span><span class="s1">diff = getId(a) - getId(b)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(diff === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(a.pre &amp;&amp; !b.pre)</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(b.pre &amp;&amp; !a.pre)</span>
            <span class="s2">return </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">diff</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">flushJobs(seen) {</span>
    <span class="s1">isFlushPending = </span><span class="s2">false;</span>
    <span class="s1">isFlushing = </span><span class="s2">true;</span>
    <span class="s1">{</span>
        <span class="s1">seen = seen || </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// Sort queue before flush.</span>
    <span class="s5">// This ensures that:</span>
    <span class="s5">// 1. Components are updated from parent to child. (because parent is always</span>
    <span class="s5">//    created before the child so its render effect will have smaller</span>
    <span class="s5">//    priority number)</span>
    <span class="s5">// 2. If a component is unmounted during a parent component's update,</span>
    <span class="s5">//    its update can be skipped.</span>
    <span class="s1">queue.sort(comparator)</span><span class="s2">;</span>
    <span class="s5">// conditional usage of checkRecursiveUpdate must be determined out of</span>
    <span class="s5">// try ... catch block since Rollup by default de-optimizes treeshaking</span>
    <span class="s5">// inside try-catch. This can leave all warning code unshaked. Although</span>
    <span class="s5">// they would get eventually shaken by a minifier like terser, some minifiers</span>
    <span class="s5">// would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)</span>
    <span class="s2">const </span><span class="s1">check = (job) =&gt; checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">job)</span>
        <span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">for </span><span class="s1">(flushIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">flushIndex &lt; queue.length</span><span class="s2">; </span><span class="s1">flushIndex++) {</span>
            <span class="s2">const </span><span class="s1">job = queue[flushIndex]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(job &amp;&amp; job.active !== </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">true </span><span class="s1">&amp;&amp; check(job)) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s5">// console.log(`running:`, job.id)</span>
                <span class="s1">callWithErrorHandling(job</span><span class="s2">, null, </span><span class="s4">14 </span><span class="s5">/* ErrorCodes.SCHEDULER */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">flushIndex = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">queue.length = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">flushPostFlushCbs(seen)</span><span class="s2">;</span>
        <span class="s1">isFlushing = </span><span class="s2">false;</span>
        <span class="s1">currentFlushPromise = </span><span class="s2">null;</span>
        <span class="s5">// some postFlushCb queued jobs!</span>
        <span class="s5">// keep flushing until it drains.</span>
        <span class="s2">if </span><span class="s1">(queue.length || pendingPostFlushCbs.length) {</span>
            <span class="s1">flushJobs(seen)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">fn) {</span>
    <span class="s2">if </span><span class="s1">(!seen.has(fn)) {</span>
        <span class="s1">seen.set(fn</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">count = seen.get(fn)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(count &gt; RECURSION_LIMIT) {</span>
            <span class="s2">const </span><span class="s1">instance = fn.ownerInstance</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">componentName = instance &amp;&amp; getComponentName(instance.type)</span><span class="s2">;</span>
            <span class="s1">warn(</span><span class="s3">`Maximum recursive updates exceeded</span><span class="s1">${componentName ? </span><span class="s3">` in component &lt;</span><span class="s1">${componentName}</span><span class="s3">&gt;` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">. ` </span><span class="s1">+</span>
                <span class="s3">`This means you have a reactive effect that is mutating its own ` </span><span class="s1">+</span>
                <span class="s3">`dependencies and thus recursively triggering itself. Possible sources ` </span><span class="s1">+</span>
                <span class="s3">`include component template, render function, updated hook or ` </span><span class="s1">+</span>
                <span class="s3">`watcher source function.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">seen.set(fn</span><span class="s2">, </span><span class="s1">count + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">/* eslint-disable no-restricted-globals */</span>
<span class="s2">let </span><span class="s1">isHmrUpdating = </span><span class="s2">false;</span>
<span class="s2">const </span><span class="s1">hmrDirtyComponents = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
<span class="s5">// Expose the HMR runtime on the global object</span>
<span class="s5">// This makes it entirely tree-shakable without polluting the exports and makes</span>
<span class="s5">// it easier to be used in toolings like vue-loader</span>
<span class="s5">// Note: for a component to be eligible for HMR it also needs the __hmrId option</span>
<span class="s5">// to be set so that its instances can be registered / removed.</span>
<span class="s1">{</span>
    <span class="s1">getGlobalThis().__VUE_HMR_RUNTIME__ = {</span>
        <span class="s1">createRecord: tryWrap(createRecord)</span><span class="s2">,</span>
        <span class="s1">rerender: tryWrap(rerender)</span><span class="s2">,</span>
        <span class="s1">reload: tryWrap(reload)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">map = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">registerHMR(instance) {</span>
    <span class="s2">const </span><span class="s1">id = instance.type.__hmrId</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!record) {</span>
        <span class="s1">createRecord(id</span><span class="s2">, </span><span class="s1">instance.type)</span><span class="s2">;</span>
        <span class="s1">record = map.get(id)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">record.instances.add(instance)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unregisterHMR(instance) {</span>
    <span class="s1">map.get(instance.type.__hmrId).instances.delete(instance)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRecord(id</span><span class="s2">, </span><span class="s1">initialDef) {</span>
    <span class="s2">if </span><span class="s1">(map.has(id)) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">map.set(id</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">initialDef: normalizeClassComponent(initialDef)</span><span class="s2">,</span>
        <span class="s1">instances: </span><span class="s2">new </span><span class="s1">Set()</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeClassComponent(component) {</span>
    <span class="s2">return </span><span class="s1">isClassComponent(component) ? component.__vccOpts : component</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">rerender(id</span><span class="s2">, </span><span class="s1">newRender) {</span>
    <span class="s2">const </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!record) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s5">// update initial record (for not-yet-rendered component)</span>
    <span class="s1">record.initialDef.render = newRender</span><span class="s2">;</span>
    <span class="s1">[...record.instances].forEach(instance =&gt; {</span>
        <span class="s2">if </span><span class="s1">(newRender) {</span>
            <span class="s1">instance.render = newRender</span><span class="s2">;</span>
            <span class="s1">normalizeClassComponent(instance.type).render = newRender</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">instance.renderCache = []</span><span class="s2">;</span>
        <span class="s5">// this flag forces child components with slot content to update</span>
        <span class="s1">isHmrUpdating = </span><span class="s2">true;</span>
        <span class="s1">instance.update()</span><span class="s2">;</span>
        <span class="s1">isHmrUpdating = </span><span class="s2">false;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reload(id</span><span class="s2">, </span><span class="s1">newComp) {</span>
    <span class="s2">const </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!record)</span>
        <span class="s2">return;</span>
    <span class="s1">newComp = normalizeClassComponent(newComp)</span><span class="s2">;</span>
    <span class="s5">// update initial def (for not-yet-rendered components)</span>
    <span class="s1">updateComponentDef(record.initialDef</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
    <span class="s5">// create a snapshot which avoids the set being mutated during updates</span>
    <span class="s2">const </span><span class="s1">instances = [...record.instances]</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">instance of instances) {</span>
        <span class="s2">const </span><span class="s1">oldComp = normalizeClassComponent(instance.type)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!hmrDirtyComponents.has(oldComp)) {</span>
            <span class="s5">// 1. Update existing comp definition to match new one</span>
            <span class="s2">if </span><span class="s1">(oldComp !== record.initialDef) {</span>
                <span class="s1">updateComponentDef(oldComp</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// 2. mark definition dirty. This forces the renderer to replace the</span>
            <span class="s5">// component on patch.</span>
            <span class="s1">hmrDirtyComponents.add(oldComp)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// 3. invalidate options resolution cache</span>
        <span class="s1">instance.appContext.optionsCache.delete(instance.type)</span><span class="s2">;</span>
        <span class="s5">// 4. actually update</span>
        <span class="s2">if </span><span class="s1">(instance.ceReload) {</span>
            <span class="s5">// custom element</span>
            <span class="s1">hmrDirtyComponents.add(oldComp)</span><span class="s2">;</span>
            <span class="s1">instance.ceReload(newComp.styles)</span><span class="s2">;</span>
            <span class="s1">hmrDirtyComponents.delete(oldComp)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(instance.parent) {</span>
            <span class="s5">// 4. Force the parent instance to re-render. This will cause all updated</span>
            <span class="s5">// components to be unmounted and re-mounted. Queue the update so that we</span>
            <span class="s5">// don't end up forcing the same parent to re-render multiple times.</span>
            <span class="s1">queueJob(instance.parent.update)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(instance.appContext.reload) {</span>
            <span class="s5">// root instance mounted via createApp() has a reload method</span>
            <span class="s1">instance.appContext.reload()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
            <span class="s5">// root instance inside tree created via raw render(). Force reload.</span>
            <span class="s1">window.location.reload()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">console.warn(</span><span class="s3">'[HMR] Root or manually mounted instance modified. Full reload required.'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// 5. make sure to cleanup dirty hmr components after update</span>
    <span class="s1">queuePostFlushCb(() =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">instance of instances) {</span>
            <span class="s1">hmrDirtyComponents.delete(normalizeClassComponent(instance.type))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateComponentDef(oldComp</span><span class="s2">, </span><span class="s1">newComp) {</span>
    <span class="s1">extend(oldComp</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">oldComp) {</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s3">'__file' </span><span class="s1">&amp;&amp; !(key </span><span class="s2">in </span><span class="s1">newComp)) {</span>
            <span class="s2">delete </span><span class="s1">oldComp[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">tryWrap(fn) {</span>
    <span class="s2">return </span><span class="s1">(id</span><span class="s2">, </span><span class="s1">arg) =&gt; {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">fn(id</span><span class="s2">, </span><span class="s1">arg)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(e) {</span>
            <span class="s1">console.error(e)</span><span class="s2">;</span>
            <span class="s1">console.warn(</span><span class="s3">`[HMR] Something went wrong during Vue component hot-reload. ` </span><span class="s1">+</span>
                <span class="s3">`Full reload required.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">devtools</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">buffer = []</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">devtoolsNotInstalled = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">emit$1(event</span><span class="s2">, </span><span class="s1">...args) {</span>
    <span class="s2">if </span><span class="s1">(devtools) {</span>
        <span class="s1">devtools.emit(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!devtoolsNotInstalled) {</span>
        <span class="s1">buffer.push({ event</span><span class="s2">, </span><span class="s1">args })</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setDevtoolsHook(hook</span><span class="s2">, </span><span class="s1">target) {</span>
    <span class="s2">var </span><span class="s1">_a</span><span class="s2">, </span><span class="s1">_b</span><span class="s2">;</span>
    <span class="s1">devtools = hook</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(devtools) {</span>
        <span class="s1">devtools.enabled = </span><span class="s2">true;</span>
        <span class="s1">buffer.forEach(({ event</span><span class="s2">, </span><span class="s1">args }) =&gt; devtools.emit(event</span><span class="s2">, </span><span class="s1">...args))</span><span class="s2">;</span>
        <span class="s1">buffer = []</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span>
    <span class="s5">// handle late devtools injection - only do this if we are in an actual</span>
    <span class="s5">// browser environment to avoid the timer handle stalling test runner exit</span>
    <span class="s5">// (#4815)</span>
    <span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp;</span>
        <span class="s5">// some envs mock window but not fully</span>
        <span class="s1">window.HTMLElement &amp;&amp;</span>
        <span class="s5">// also exclude jsdom</span>
        <span class="s1">!((_b = (_a = window.navigator) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a.userAgent) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _b.includes(</span><span class="s3">'jsdom'</span><span class="s1">))) {</span>
        <span class="s2">const </span><span class="s1">replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =</span>
            <span class="s1">target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [])</span><span class="s2">;</span>
        <span class="s1">replay.push((newHook) =&gt; {</span>
            <span class="s1">setDevtoolsHook(newHook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s5">// clear buffer after 3s - the user probably doesn't have devtools installed</span>
        <span class="s5">// at all, and keeping the buffer will cause memory leaks (#4738)</span>
        <span class="s1">setTimeout(() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!devtools) {</span>
                <span class="s1">target.__VUE_DEVTOOLS_HOOK_REPLAY__ = </span><span class="s2">null;</span>
                <span class="s1">devtoolsNotInstalled = </span><span class="s2">true;</span>
                <span class="s1">buffer = []</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s4">3000</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// non-browser env, assume not installed</span>
        <span class="s1">devtoolsNotInstalled = </span><span class="s2">true;</span>
        <span class="s1">buffer = []</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsInitApp(app</span><span class="s2">, </span><span class="s1">version) {</span>
    <span class="s1">emit$1(</span><span class="s3">&quot;app:init&quot; </span><span class="s5">/* DevtoolsHooks.APP_INIT */</span><span class="s2">, </span><span class="s1">app</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">Fragment</span><span class="s2">,</span>
        <span class="s1">Text</span><span class="s2">,</span>
        <span class="s1">Comment</span><span class="s2">,</span>
        <span class="s1">Static</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsUnmountApp(app) {</span>
    <span class="s1">emit$1(</span><span class="s3">&quot;app:unmount&quot; </span><span class="s5">/* DevtoolsHooks.APP_UNMOUNT */</span><span class="s2">, </span><span class="s1">app)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">devtoolsComponentAdded = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createDevtoolsComponentHook(</span><span class="s3">&quot;component:added&quot; </span><span class="s5">/* DevtoolsHooks.COMPONENT_ADDED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">devtoolsComponentUpdated = </span>
<span class="s5">/*#__PURE__*/ </span><span class="s1">createDevtoolsComponentHook(</span><span class="s3">&quot;component:updated&quot; </span><span class="s5">/* DevtoolsHooks.COMPONENT_UPDATED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">_devtoolsComponentRemoved = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createDevtoolsComponentHook(</span><span class="s3">&quot;component:removed&quot; </span><span class="s5">/* DevtoolsHooks.COMPONENT_REMOVED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">devtoolsComponentRemoved = (component) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(devtools &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">devtools.cleanupBuffer === </span><span class="s3">'function' </span><span class="s1">&amp;&amp;</span>
        <span class="s5">// remove the component if it wasn't buffered</span>
        <span class="s1">!devtools.cleanupBuffer(component)) {</span>
        <span class="s1">_devtoolsComponentRemoved(component)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createDevtoolsComponentHook(hook) {</span>
    <span class="s2">return </span><span class="s1">(component) =&gt; {</span>
        <span class="s1">emit$1(hook</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component.uid</span><span class="s2">, </span><span class="s1">component.parent ? component.parent.uid : undefined</span><span class="s2">, </span><span class="s1">component)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">devtoolsPerfStart = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createDevtoolsPerformanceHook(</span><span class="s3">&quot;perf:start&quot; </span><span class="s5">/* DevtoolsHooks.PERFORMANCE_START */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">devtoolsPerfEnd = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">createDevtoolsPerformanceHook(</span><span class="s3">&quot;perf:end&quot; </span><span class="s5">/* DevtoolsHooks.PERFORMANCE_END */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createDevtoolsPerformanceHook(hook) {</span>
    <span class="s2">return </span><span class="s1">(component</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">time) =&gt; {</span>
        <span class="s1">emit$1(hook</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component.uid</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">time)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsComponentEmit(component</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">params) {</span>
    <span class="s1">emit$1(</span><span class="s3">&quot;component:emit&quot; </span><span class="s5">/* DevtoolsHooks.COMPONENT_EMIT */</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">emit(instance</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">...rawArgs) {</span>
    <span class="s2">if </span><span class="s1">(instance.isUnmounted)</span>
        <span class="s2">return;</span>
    <span class="s2">const </span><span class="s1">props = instance.vnode.props || EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">{ emitsOptions</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions] } = instance</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(emitsOptions) {</span>
            <span class="s2">if </span><span class="s1">(!(event </span><span class="s2">in </span><span class="s1">emitsOptions) &amp;&amp;</span>
                <span class="s1">!(</span><span class="s2">false </span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!propsOptions || !(toHandlerKey(event) </span><span class="s2">in </span><span class="s1">propsOptions)) {</span>
                    <span class="s1">warn(</span><span class="s3">`Component emitted event &quot;</span><span class="s1">${event}</span><span class="s3">&quot; but it is neither declared in ` </span><span class="s1">+</span>
                        <span class="s3">`the emits option nor as an &quot;</span><span class="s1">${toHandlerKey(event)}</span><span class="s3">&quot; prop.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">validator = emitsOptions[event]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isFunction(validator)) {</span>
                    <span class="s2">const </span><span class="s1">isValid = validator(...rawArgs)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(!isValid) {</span>
                        <span class="s1">warn(</span><span class="s3">`Invalid event arguments: event validation failed for event &quot;</span><span class="s1">${event}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">args = rawArgs</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isModelListener = event.startsWith(</span><span class="s3">'update:'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s5">// for v-model update:xxx events, apply modifiers on args</span>
    <span class="s2">const </span><span class="s1">modelArg = isModelListener &amp;&amp; event.slice(</span><span class="s4">7</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(modelArg &amp;&amp; modelArg </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s2">const </span><span class="s1">modifiersKey = </span><span class="s3">`</span><span class="s1">${modelArg === </span><span class="s3">'modelValue' </span><span class="s1">? </span><span class="s3">'model' </span><span class="s1">: modelArg}</span><span class="s3">Modifiers`</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ number</span><span class="s2">, </span><span class="s1">trim } = props[modifiersKey] || EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trim) {</span>
            <span class="s1">args = rawArgs.map(a =&gt; (isString(a) ? a.trim() : a))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(number) {</span>
            <span class="s1">args = rawArgs.map(looseToNumber)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s1">devtoolsComponentEmit(instance</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">lowerCaseEvent = event.toLowerCase()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(lowerCaseEvent !== event &amp;&amp; props[toHandlerKey(lowerCaseEvent)]) {</span>
            <span class="s1">warn(</span><span class="s3">`Event &quot;</span><span class="s1">${lowerCaseEvent}</span><span class="s3">&quot; is emitted in component ` </span><span class="s1">+</span>
                <span class="s3">`</span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">instance.type)} </span><span class="s3">but the handler is registered for &quot;</span><span class="s1">${event}</span><span class="s3">&quot;. ` </span><span class="s1">+</span>
                <span class="s3">`Note that HTML attributes are case-insensitive and you cannot use ` </span><span class="s1">+</span>
                <span class="s3">`v-on to listen to camelCase events when using in-DOM templates. ` </span><span class="s1">+</span>
                <span class="s3">`You should probably use &quot;</span><span class="s1">${hyphenate(event)}</span><span class="s3">&quot; instead of &quot;</span><span class="s1">${event}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">handlerName</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">handler = props[(handlerName = toHandlerKey(event))] ||</span>
        <span class="s5">// also try camelCase event handler (#2249)</span>
        <span class="s1">props[(handlerName = toHandlerKey(camelize(event)))]</span><span class="s2">;</span>
    <span class="s5">// for v-model update:xxx events, also trigger kebab-case equivalent</span>
    <span class="s5">// for props passed via kebab-case</span>
    <span class="s2">if </span><span class="s1">(!handler &amp;&amp; isModelListener) {</span>
        <span class="s1">handler = props[(handlerName = toHandlerKey(hyphenate(event)))]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(handler) {</span>
        <span class="s1">callWithAsyncErrorHandling(handler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">6 </span><span class="s5">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">onceHandler = props[handlerName + </span><span class="s3">`Once`</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(onceHandler) {</span>
        <span class="s2">if </span><span class="s1">(!instance.emitted) {</span>
            <span class="s1">instance.emitted = {}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(instance.emitted[handlerName]) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">instance.emitted[handlerName] = </span><span class="s2">true;</span>
        <span class="s1">callWithAsyncErrorHandling(onceHandler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">6 </span><span class="s5">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeEmitsOptions(comp</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">cache = appContext.emitsCache</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cached = cache.get(comp)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached !== undefined) {</span>
        <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">raw = comp.emits</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">normalized = {}</span><span class="s2">;</span>
    <span class="s5">// apply mixin/extends props</span>
    <span class="s2">let </span><span class="s1">hasExtends = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(!isFunction(comp)) {</span>
        <span class="s2">const </span><span class="s1">extendEmits = (raw) =&gt; {</span>
            <span class="s2">const </span><span class="s1">normalizedFromExtend = normalizeEmitsOptions(raw</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(normalizedFromExtend) {</span>
                <span class="s1">hasExtends = </span><span class="s2">true;</span>
                <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">normalizedFromExtend)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s1">appContext.mixins.forEach(extendEmits)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(comp.extends) {</span>
            <span class="s1">extendEmits(comp.extends)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(comp.mixins) {</span>
            <span class="s1">comp.mixins.forEach(extendEmits)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
            <span class="s1">cache.set(comp</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
        <span class="s1">raw.forEach(key =&gt; (normalized[key] = </span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
        <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">normalized)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">normalized</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// Check if an incoming prop key is a declared emit event listener.</span>
<span class="s5">// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are</span>
<span class="s5">// both considered matched listeners.</span>
<span class="s2">function </span><span class="s1">isEmitListener(options</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">if </span><span class="s1">(!options || !isOn(key)) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s1">key = key.slice(</span><span class="s4">2</span><span class="s1">).replace(</span><span class="s4">/Once$/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(hasOwn(options</span><span class="s2">, </span><span class="s1">key[</span><span class="s4">0</span><span class="s1">].toLowerCase() + key.slice(</span><span class="s4">1</span><span class="s1">)) ||</span>
        <span class="s1">hasOwn(options</span><span class="s2">, </span><span class="s1">hyphenate(key)) ||</span>
        <span class="s1">hasOwn(options</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* mark the current rendering instance for asset resolution (e.g.</span>
 <span class="s0">* resolveComponent, resolveDirective) during render</span>
 <span class="s0">*/</span>
<span class="s2">let </span><span class="s1">currentRenderingInstance = </span><span class="s2">null;</span>
<span class="s2">let </span><span class="s1">currentScopeId = </span><span class="s2">null;</span>
<span class="s0">/**</span>
 <span class="s0">* Note: rendering calls maybe nested. The function returns the parent rendering</span>
 <span class="s0">* instance if present, which should be restored after the render is done:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* const prev = setCurrentRenderingInstance(i)</span>
 <span class="s0">* // ...render</span>
 <span class="s0">* setCurrentRenderingInstance(prev)</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">setCurrentRenderingInstance(instance) {</span>
    <span class="s2">const </span><span class="s1">prev = currentRenderingInstance</span><span class="s2">;</span>
    <span class="s1">currentRenderingInstance = instance</span><span class="s2">;</span>
    <span class="s1">currentScopeId = (instance &amp;&amp; instance.type.__scopeId) || </span><span class="s2">null;</span>
    <span class="s2">return </span><span class="s1">prev</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Set scope id when creating hoisted vnodes.</span>
 <span class="s0">* </span><span class="s6">@private </span><span class="s0">compiler helper</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">pushScopeId(id) {</span>
    <span class="s1">currentScopeId = id</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Technically we no longer need this after 3.0.8 but we need to keep the same</span>
 <span class="s0">* API for backwards compat w/ code generated by compilers.</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">popScopeId() {</span>
    <span class="s1">currentScopeId = </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Only for backwards compat</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">withScopeId = (_id) =&gt; withCtx</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Wrap a slot function to memoize current rendering instance</span>
 <span class="s0">* </span><span class="s6">@private </span><span class="s0">compiler helper</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">withCtx(fn</span><span class="s2">, </span><span class="s1">ctx = currentRenderingInstance</span><span class="s2">, </span><span class="s1">isNonScopedSlot </span><span class="s5">// false only</span>
<span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!ctx)</span>
        <span class="s2">return </span><span class="s1">fn</span><span class="s2">;</span>
    <span class="s5">// already normalized</span>
    <span class="s2">if </span><span class="s1">(fn._n) {</span>
        <span class="s2">return </span><span class="s1">fn</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">renderFnWithContext = (...args) =&gt; {</span>
        <span class="s5">// If a user calls a compiled slot inside a template expression (#1745), it</span>
        <span class="s5">// can mess up block tracking, so by default we disable block tracking and</span>
        <span class="s5">// force bail out when invoking a compiled slot (indicated by the ._d flag).</span>
        <span class="s5">// This isn't necessary if rendering a compiled `&lt;slot&gt;`, so we flip the</span>
        <span class="s5">// ._d flag off when invoking the wrapped fn inside `renderSlot`.</span>
        <span class="s2">if </span><span class="s1">(renderFnWithContext._d) {</span>
            <span class="s1">setBlockTracking(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">prevInstance = setCurrentRenderingInstance(ctx)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">res = fn(...args)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">finally </span><span class="s1">{</span>
            <span class="s1">setCurrentRenderingInstance(prevInstance)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(renderFnWithContext._d) {</span>
                <span class="s1">setBlockTracking(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">devtoolsComponentUpdated(ctx)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// mark normalized to avoid duplicated wrapping</span>
    <span class="s1">renderFnWithContext._n = </span><span class="s2">true;</span>
    <span class="s5">// mark this as compiled by default</span>
    <span class="s5">// this is used in vnode.ts -&gt; normalizeChildren() to set the slot</span>
    <span class="s5">// rendering flag.</span>
    <span class="s1">renderFnWithContext._c = </span><span class="s2">true;</span>
    <span class="s5">// disable block tracking by default</span>
    <span class="s1">renderFnWithContext._d = </span><span class="s2">true;</span>
    <span class="s2">return </span><span class="s1">renderFnWithContext</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* dev only flag to track whether $attrs was used during render.</span>
 <span class="s0">* If $attrs was used during render then the warning for failed attrs</span>
 <span class="s0">* fallthrough can be suppressed.</span>
 <span class="s0">*/</span>
<span class="s2">let </span><span class="s1">accessedAttrs = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">markAttrsAccessed() {</span>
    <span class="s1">accessedAttrs = </span><span class="s2">true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderComponentRoot(instance) {</span>
    <span class="s2">const </span><span class="s1">{ type: Component</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">proxy</span><span class="s2">, </span><span class="s1">withProxy</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions]</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">emit</span><span class="s2">, </span><span class="s1">render</span><span class="s2">, </span><span class="s1">renderCache</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">inheritAttrs } = instance</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">fallthroughAttrs</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">prev = setCurrentRenderingInstance(instance)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">accessedAttrs = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s1">) {</span>
            <span class="s5">// withProxy is a proxy with a different `has` trap only for</span>
            <span class="s5">// runtime-compiled render functions using `with` block.</span>
            <span class="s2">const </span><span class="s1">proxyToUse = withProxy || proxy</span><span class="s2">;</span>
            <span class="s1">result = normalizeVNode(render.call(proxyToUse</span><span class="s2">, </span><span class="s1">proxyToUse</span><span class="s2">, </span><span class="s1">renderCache</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ctx))</span><span class="s2">;</span>
            <span class="s1">fallthroughAttrs = attrs</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// functional</span>
            <span class="s2">const </span><span class="s1">render = Component</span><span class="s2">;</span>
            <span class="s5">// in dev, mark attrs accessed if optional props (attrs === props)</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">true </span><span class="s1">&amp;&amp; attrs === props) {</span>
                <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">result = normalizeVNode(render.length &gt; </span><span class="s4">1</span>
                <span class="s1">? render(props</span><span class="s2">, true</span>
                    <span class="s1">? {</span>
                        <span class="s1">get attrs() {</span>
                            <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
                            <span class="s2">return </span><span class="s1">attrs</span><span class="s2">;</span>
                        <span class="s1">}</span><span class="s2">,</span>
                        <span class="s1">slots</span><span class="s2">,</span>
                        <span class="s1">emit</span>
                    <span class="s1">}</span>
                    <span class="s1">: { attrs</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">emit })</span>
                <span class="s1">: render(props</span><span class="s2">, null </span><span class="s5">/* we know it doesn't need it */</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">fallthroughAttrs = Component.props</span>
                <span class="s1">? attrs</span>
                <span class="s1">: getFunctionalFallthrough(attrs)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s1">blockStack.length = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* ErrorCodes.RENDER_FUNCTION */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">result = createVNode(Comment)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// attr merging</span>
    <span class="s5">// in dev mode, comments are preserved, and it's possible for a template</span>
    <span class="s5">// to have comments along side the root element which makes it a fragment</span>
    <span class="s2">let </span><span class="s1">root = result</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">setRoot = undefined</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(result.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">result.patchFlag &amp; </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">) {</span>
        <span class="s1">[root</span><span class="s2">, </span><span class="s1">setRoot] = getChildRoot(result)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(fallthroughAttrs &amp;&amp; inheritAttrs !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">keys = Object.keys(fallthroughAttrs)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ shapeFlag } = root</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(keys.length) {</span>
            <span class="s2">if </span><span class="s1">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">| </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(propsOptions &amp;&amp; keys.some(isModelListener)) {</span>
                    <span class="s5">// If a v-model listener (onUpdate:xxx) has a corresponding declared</span>
                    <span class="s5">// prop, it indicates this component expects to handle v-model and</span>
                    <span class="s5">// it should not fallthrough.</span>
                    <span class="s5">// related: #1543, #1643, #1989</span>
                    <span class="s1">fallthroughAttrs = filterModelListeners(fallthroughAttrs</span><span class="s2">, </span><span class="s1">propsOptions)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">root = cloneVNode(root</span><span class="s2">, </span><span class="s1">fallthroughAttrs)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!accessedAttrs &amp;&amp; root.type !== Comment) {</span>
                <span class="s2">const </span><span class="s1">allAttrs = Object.keys(attrs)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">eventAttrs = []</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">extraAttrs = []</span><span class="s2">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = allAttrs.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">const </span><span class="s1">key = allAttrs[i]</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isOn(key)) {</span>
                        <span class="s5">// ignore v-model handlers when they fail to fallthrough</span>
                        <span class="s2">if </span><span class="s1">(!isModelListener(key)) {</span>
                            <span class="s5">// remove `on`, lowercase first letter to reflect event casing</span>
                            <span class="s5">// accurately</span>
                            <span class="s1">eventAttrs.push(key[</span><span class="s4">2</span><span class="s1">].toLowerCase() + key.slice(</span><span class="s4">3</span><span class="s1">))</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">extraAttrs.push(key)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(extraAttrs.length) {</span>
                    <span class="s1">warn(</span><span class="s3">`Extraneous non-props attributes (` </span><span class="s1">+</span>
                        <span class="s3">`</span><span class="s1">${extraAttrs.join(</span><span class="s3">', '</span><span class="s1">)}</span><span class="s3">) ` </span><span class="s1">+</span>
                        <span class="s3">`were passed to component but could not be automatically inherited ` </span><span class="s1">+</span>
                        <span class="s3">`because component renders fragment or text root nodes.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(eventAttrs.length) {</span>
                    <span class="s1">warn(</span><span class="s3">`Extraneous non-emits event listeners (` </span><span class="s1">+</span>
                        <span class="s3">`</span><span class="s1">${eventAttrs.join(</span><span class="s3">', '</span><span class="s1">)}</span><span class="s3">) ` </span><span class="s1">+</span>
                        <span class="s3">`were passed to component but could not be automatically inherited ` </span><span class="s1">+</span>
                        <span class="s3">`because component renders fragment or text root nodes. ` </span><span class="s1">+</span>
                        <span class="s3">`If the listener is intended to be a component custom event listener only, ` </span><span class="s1">+</span>
                        <span class="s3">`declare it using the &quot;emits&quot; option.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// inherit directives</span>
    <span class="s2">if </span><span class="s1">(vnode.dirs) {</span>
        <span class="s2">if </span><span class="s1">(!isElementRoot(root)) {</span>
            <span class="s1">warn(</span><span class="s3">`Runtime directive used on component with non-element root node. ` </span><span class="s1">+</span>
                <span class="s3">`The directives will not function as intended.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// clone before mutating since the root may be a hoisted vnode</span>
        <span class="s1">root = cloneVNode(root)</span><span class="s2">;</span>
        <span class="s1">root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// inherit transition data</span>
    <span class="s2">if </span><span class="s1">(vnode.transition) {</span>
        <span class="s2">if </span><span class="s1">(!isElementRoot(root)) {</span>
            <span class="s1">warn(</span><span class="s3">`Component inside &lt;Transition&gt; renders non-element root node ` </span><span class="s1">+</span>
                <span class="s3">`that cannot be animated.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">root.transition = vnode.transition</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(setRoot) {</span>
        <span class="s1">setRoot(root)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result = root</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setCurrentRenderingInstance(prev)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">* In dev mode, template root level comments are rendered, which turns the</span>
 <span class="s0">* template into a fragment root, but we need to locate the single element</span>
 <span class="s0">* root for attrs and scope id processing.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">getChildRoot = (vnode) =&gt; {</span>
    <span class="s2">const </span><span class="s1">rawChildren = vnode.children</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicChildren = vnode.dynamicChildren</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">childRoot = filterSingleRoot(rawChildren)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!childRoot) {</span>
        <span class="s2">return </span><span class="s1">[vnode</span><span class="s2">, </span><span class="s1">undefined]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">index = rawChildren.indexOf(childRoot)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setRoot = (updatedRoot) =&gt; {</span>
        <span class="s1">rawChildren[index] = updatedRoot</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
            <span class="s2">if </span><span class="s1">(dynamicIndex &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">dynamicChildren[dynamicIndex] = updatedRoot</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(updatedRoot.patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">vnode.dynamicChildren = [...dynamicChildren</span><span class="s2">, </span><span class="s1">updatedRoot]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[normalizeVNode(childRoot)</span><span class="s2">, </span><span class="s1">setRoot]</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">filterSingleRoot(children) {</span>
    <span class="s2">let </span><span class="s1">singleRoot</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isVNode(child)) {</span>
            <span class="s5">// ignore user comment</span>
            <span class="s2">if </span><span class="s1">(child.type !== Comment || child.children === </span><span class="s3">'v-if'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(singleRoot) {</span>
                    <span class="s5">// has more than 1 non-comment child, return now</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">singleRoot = child</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">singleRoot</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">getFunctionalFallthrough = (attrs) =&gt; {</span>
    <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'class' </span><span class="s1">|| key === </span><span class="s3">'style' </span><span class="s1">|| isOn(key)) {</span>
            <span class="s1">(res || (res = {}))[key] = attrs[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">filterModelListeners = (attrs</span><span class="s2">, </span><span class="s1">props) =&gt; {</span>
    <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
        <span class="s2">if </span><span class="s1">(!isModelListener(key) || !(key.slice(</span><span class="s4">9</span><span class="s1">) </span><span class="s2">in </span><span class="s1">props)) {</span>
            <span class="s1">res[key] = attrs[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isElementRoot = (vnode) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(vnode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */ </span><span class="s1">| </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */</span><span class="s1">) ||</span>
        <span class="s1">vnode.type === Comment </span><span class="s5">// potential v-if branch switch</span>
    <span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">shouldUpdateComponent(prevVNode</span><span class="s2">, </span><span class="s1">nextVNode</span><span class="s2">, </span><span class="s1">optimized) {</span>
    <span class="s2">const </span><span class="s1">{ props: prevProps</span><span class="s2">, </span><span class="s1">children: prevChildren</span><span class="s2">, </span><span class="s1">component } = prevVNode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ props: nextProps</span><span class="s2">, </span><span class="s1">children: nextChildren</span><span class="s2">, </span><span class="s1">patchFlag } = nextVNode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">emits = component.emitsOptions</span><span class="s2">;</span>
    <span class="s5">// Parent component's render function was hot-updated. Since this may have</span>
    <span class="s5">// caused the child component's slots content to have changed, we need to</span>
    <span class="s5">// force the child to update as well.</span>
    <span class="s2">if </span><span class="s1">((prevChildren || nextChildren) &amp;&amp; isHmrUpdating) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s5">// force child update for runtime directive or transition on component vnode.</span>
    <span class="s2">if </span><span class="s1">(nextVNode.dirs || nextVNode.transition) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(optimized &amp;&amp; patchFlag &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">) {</span>
            <span class="s5">// slot content that references values that might have changed,</span>
            <span class="s5">// e.g. in a v-for</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(!prevProps) {</span>
                <span class="s2">return </span><span class="s1">!!nextProps</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// presence of this flag indicates props are always non-null</span>
            <span class="s2">return </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emits)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">dynamicProps = nextVNode.dynamicProps</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; dynamicProps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">key = dynamicProps[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
                    <span class="s1">!isEmitListener(emits</span><span class="s2">, </span><span class="s1">key)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// this path is only taken by manually written render functions</span>
        <span class="s5">// so presence of any children leads to a forced update</span>
        <span class="s2">if </span><span class="s1">(prevChildren || nextChildren) {</span>
            <span class="s2">if </span><span class="s1">(!nextChildren || !nextChildren.$stable) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prevProps === nextProps) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!prevProps) {</span>
            <span class="s2">return </span><span class="s1">!!nextProps</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!nextProps) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emits)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emitsOptions) {</span>
    <span class="s2">const </span><span class="s1">nextKeys = Object.keys(nextProps)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextKeys.length !== Object.keys(prevProps).length) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; nextKeys.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">key = nextKeys[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
            <span class="s1">!isEmitListener(emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateHOCHostEl({ vnode</span><span class="s2">, </span><span class="s1">parent }</span><span class="s2">, </span><span class="s1">el </span><span class="s5">// HostNode</span>
<span class="s1">) {</span>
    <span class="s2">while </span><span class="s1">(parent &amp;&amp; parent.subTree === vnode) {</span>
        <span class="s1">(vnode = parent.vnode).el = el</span><span class="s2">;</span>
        <span class="s1">parent = parent.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isSuspense = (type) =&gt; type.__isSuspense</span><span class="s2">;</span>
<span class="s5">// Suspense exposes a component-like API, and is treated like a component</span>
<span class="s5">// in the compiler, but internally it's a special built-in type that hooks</span>
<span class="s5">// directly into the renderer.</span>
<span class="s2">const </span><span class="s1">SuspenseImpl = {</span>
    <span class="s1">name: </span><span class="s3">'Suspense'</span><span class="s2">,</span>
    <span class="s5">// In order to make Suspense tree-shakable, we need to avoid importing it</span>
    <span class="s5">// directly in the renderer. The renderer checks for the __isSuspense flag</span>
    <span class="s5">// on a vnode's type and calls the `process` method, passing in renderer</span>
    <span class="s5">// internals.</span>
    <span class="s1">__isSuspense: </span><span class="s2">true,</span>
    <span class="s1">process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span>
    <span class="s5">// platform-specific impl passed from renderer</span>
    <span class="s1">rendererInternals) {</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">mountSuspense(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">patchSuspense(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">hydrate: hydrateSuspense</span><span class="s2">,</span>
    <span class="s1">create: createSuspenseBoundary</span><span class="s2">,</span>
    <span class="s1">normalize: normalizeSuspenseChildren</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s5">// Force-casted public typing for h and TSX props inference</span>
<span class="s2">const </span><span class="s1">Suspense = (SuspenseImpl</span>
    <span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">const </span><span class="s1">eventListener = vnode.props &amp;&amp; vnode.props[name]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(eventListener)) {</span>
        <span class="s1">eventListener()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mountSuspense(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals) {</span>
    <span class="s2">const </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">o: { createElement } } = rendererInternals</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hiddenContainer = createElement(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals))</span><span class="s2">;</span>
    <span class="s5">// start mounting the content subtree in an off-dom container</span>
    <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">(suspense.pendingBranch = vnode.ssContent)</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
    <span class="s5">// now check if we have encountered any async deps</span>
    <span class="s2">if </span><span class="s1">(suspense.deps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s5">// has async</span>
        <span class="s5">// invoke @fallback event</span>
        <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">'onPending'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">'onFallback'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s5">// mount the fallback tree</span>
        <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode.ssFallback</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, null, </span><span class="s5">// fallback tree will not have suspense context</span>
        <span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
        <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">vnode.ssFallback)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// Suspense has no async deps. Just resolve.</span>
        <span class="s1">suspense.resolve()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchSuspense(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">um: unmount</span><span class="s2">, </span><span class="s1">o: { createElement } }) {</span>
    <span class="s2">const </span><span class="s1">suspense = (n2.suspense = n1.suspense)</span><span class="s2">;</span>
    <span class="s1">suspense.vnode = n2</span><span class="s2">;</span>
    <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newBranch = n2.ssContent</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newFallback = n2.ssFallback</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ activeBranch</span><span class="s2">, </span><span class="s1">pendingBranch</span><span class="s2">, </span><span class="s1">isInFallback</span><span class="s2">, </span><span class="s1">isHydrating } = suspense</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pendingBranch) {</span>
        <span class="s1">suspense.pendingBranch = newBranch</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">pendingBranch)) {</span>
            <span class="s5">// same root type but content may have changed.</span>
            <span class="s1">patch(pendingBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">suspense.resolve()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isInFallback) {</span>
                <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newFallback</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, null, </span><span class="s5">// fallback tree will not have suspense context</span>
                <span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newFallback)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// toggled before pending tree is resolved</span>
            <span class="s1">suspense.pendingId++</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isHydrating) {</span>
                <span class="s5">// if toggled before hydration is finished, the current DOM tree is</span>
                <span class="s5">// no longer valid. set it as the active branch so it will be unmounted</span>
                <span class="s5">// when resolved</span>
                <span class="s1">suspense.isHydrating = </span><span class="s2">false;</span>
                <span class="s1">suspense.activeBranch = pendingBranch</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">unmount(pendingBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// increment pending ID. this is used to invalidate async callbacks</span>
            <span class="s5">// reset suspense state</span>
            <span class="s1">suspense.deps = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s5">// discard effects from pending branch</span>
            <span class="s1">suspense.effects.length = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s5">// discard previous container</span>
            <span class="s1">suspense.hiddenContainer = createElement(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isInFallback) {</span>
                <span class="s5">// already in fallback state</span>
                <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">suspense.resolve()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newFallback</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, null, </span><span class="s5">// fallback tree will not have suspense context</span>
                    <span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                    <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newFallback)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">activeBranch)) {</span>
                <span class="s5">// toggled &quot;back&quot; to current active branch</span>
                <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s5">// force resolve</span>
                <span class="s1">suspense.resolve(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// switched to a 3rd branch</span>
                <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">suspense.resolve()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">activeBranch)) {</span>
            <span class="s5">// root did not change, just normal patch</span>
            <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newBranch)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// root node toggled</span>
            <span class="s5">// invoke @pending event</span>
            <span class="s1">triggerEvent(n2</span><span class="s2">, </span><span class="s3">'onPending'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s5">// mount pending branch in off-dom container</span>
            <span class="s1">suspense.pendingBranch = newBranch</span><span class="s2">;</span>
            <span class="s1">suspense.pendingId++</span><span class="s2">;</span>
            <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s5">// incoming branch has no async deps, resolve now.</span>
                <span class="s1">suspense.resolve()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">{ timeout</span><span class="s2">, </span><span class="s1">pendingId } = suspense</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(timeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">setTimeout(() =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(suspense.pendingId === pendingId) {</span>
                            <span class="s1">suspense.fallback(newFallback)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(timeout === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">suspense.fallback(newFallback)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">hasWarned = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">createSuspenseBoundary(vnode</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">isHydrating = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s5">/* istanbul ignore if */</span>
    <span class="s2">if </span><span class="s1">(!hasWarned) {</span>
        <span class="s1">hasWarned = </span><span class="s2">true;</span>
        <span class="s5">// @ts-ignore `console.info` cannot be null error</span>
        <span class="s1">console[console.info ? </span><span class="s3">'info' </span><span class="s1">: </span><span class="s3">'log'</span><span class="s1">](</span><span class="s3">`&lt;Suspense&gt; is an experimental feature and its API will likely change.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">m: move</span><span class="s2">, </span><span class="s1">um: unmount</span><span class="s2">, </span><span class="s1">n: next</span><span class="s2">, </span><span class="s1">o: { parentNode</span><span class="s2">, </span><span class="s1">remove } } = rendererInternals</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">timeout = vnode.props ? toNumber(vnode.props.timeout) : undefined</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">assertNumber(timeout</span><span class="s2">, </span><span class="s3">`Suspense timeout`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">suspense = {</span>
        <span class="s1">vnode</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">,</span>
        <span class="s1">parentComponent</span><span class="s2">,</span>
        <span class="s1">isSVG</span><span class="s2">,</span>
        <span class="s1">container</span><span class="s2">,</span>
        <span class="s1">hiddenContainer</span><span class="s2">,</span>
        <span class="s1">anchor</span><span class="s2">,</span>
        <span class="s1">deps: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">pendingId: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">timeout: </span><span class="s2">typeof </span><span class="s1">timeout === </span><span class="s3">'number' </span><span class="s1">? timeout : -</span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">activeBranch: </span><span class="s2">null,</span>
        <span class="s1">pendingBranch: </span><span class="s2">null,</span>
        <span class="s1">isInFallback: </span><span class="s2">true,</span>
        <span class="s1">isHydrating</span><span class="s2">,</span>
        <span class="s1">isUnmounted: </span><span class="s2">false,</span>
        <span class="s1">effects: []</span><span class="s2">,</span>
        <span class="s1">resolve(resume = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(!resume &amp;&amp; !suspense.pendingBranch) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`suspense.resolve() is called without a pending branch.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(suspense.isUnmounted) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`suspense.resolve() is called on an already unmounted suspense boundary.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">activeBranch</span><span class="s2">, </span><span class="s1">pendingBranch</span><span class="s2">, </span><span class="s1">pendingId</span><span class="s2">, </span><span class="s1">effects</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container } = suspense</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(suspense.isHydrating) {</span>
                <span class="s1">suspense.isHydrating = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!resume) {</span>
                <span class="s2">const </span><span class="s1">delayEnter = activeBranch &amp;&amp;</span>
                    <span class="s1">pendingBranch.transition &amp;&amp;</span>
                    <span class="s1">pendingBranch.transition.mode === </span><span class="s3">'out-in'</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(delayEnter) {</span>
                    <span class="s1">activeBranch.transition.afterLeave = () =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(pendingId === suspense.pendingId) {</span>
                            <span class="s1">move(pendingBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* MoveType.ENTER */</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// this is initial anchor on mount</span>
                <span class="s2">let </span><span class="s1">{ anchor } = suspense</span><span class="s2">;</span>
                <span class="s5">// unmount current active tree</span>
                <span class="s2">if </span><span class="s1">(activeBranch) {</span>
                    <span class="s5">// if the fallback tree was mounted, it may have been moved</span>
                    <span class="s5">// as part of a parent suspense. get the latest anchor for insertion</span>
                    <span class="s1">anchor = next(activeBranch)</span><span class="s2">;</span>
                    <span class="s1">unmount(activeBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!delayEnter) {</span>
                    <span class="s5">// move content from off-dom container to actual container</span>
                    <span class="s1">move(pendingBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* MoveType.ENTER */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">pendingBranch)</span><span class="s2">;</span>
            <span class="s1">suspense.pendingBranch = </span><span class="s2">null;</span>
            <span class="s1">suspense.isInFallback = </span><span class="s2">false;</span>
            <span class="s5">// flush buffered effects</span>
            <span class="s5">// check if there is a pending parent suspense</span>
            <span class="s2">let </span><span class="s1">parent = suspense.parent</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hasUnresolvedAncestor = </span><span class="s2">false;</span>
            <span class="s2">while </span><span class="s1">(parent) {</span>
                <span class="s2">if </span><span class="s1">(parent.pendingBranch) {</span>
                    <span class="s5">// found a pending parent suspense, merge buffered post jobs</span>
                    <span class="s5">// into that parent</span>
                    <span class="s1">parent.effects.push(...effects)</span><span class="s2">;</span>
                    <span class="s1">hasUnresolvedAncestor = </span><span class="s2">true;</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
                <span class="s1">parent = parent.parent</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// no pending parent suspense, flush all jobs</span>
            <span class="s2">if </span><span class="s1">(!hasUnresolvedAncestor) {</span>
                <span class="s1">queuePostFlushCb(effects)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">suspense.effects = []</span><span class="s2">;</span>
            <span class="s5">// invoke @resolve event</span>
            <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">'onResolve'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">fallback(fallbackVNode) {</span>
            <span class="s2">if </span><span class="s1">(!suspense.pendingBranch) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">activeBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG } = suspense</span><span class="s2">;</span>
            <span class="s5">// invoke @fallback event</span>
            <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">'onFallback'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">anchor = next(activeBranch)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">mountFallback = () =&gt; {</span>
                <span class="s2">if </span><span class="s1">(!suspense.isInFallback) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s5">// mount the fallback tree</span>
                <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">fallbackVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, null, </span><span class="s5">// fallback tree will not have suspense context</span>
                <span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">fallbackVNode)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">delayEnter = fallbackVNode.transition &amp;&amp; fallbackVNode.transition.mode === </span><span class="s3">'out-in'</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(delayEnter) {</span>
                <span class="s1">activeBranch.transition.afterLeave = mountFallback</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">suspense.isInFallback = </span><span class="s2">true;</span>
            <span class="s5">// unmount current active branch</span>
            <span class="s1">unmount(activeBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, null, </span><span class="s5">// no suspense so unmount hooks fire now</span>
            <span class="s2">true </span><span class="s5">// shouldRemove</span>
            <span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!delayEnter) {</span>
                <span class="s1">mountFallback()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">move(container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">type) {</span>
            <span class="s1">suspense.activeBranch &amp;&amp;</span>
                <span class="s1">move(suspense.activeBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
            <span class="s1">suspense.container = container</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">next() {</span>
            <span class="s2">return </span><span class="s1">suspense.activeBranch &amp;&amp; next(suspense.activeBranch)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">registerDep(instance</span><span class="s2">, </span><span class="s1">setupRenderEffect) {</span>
            <span class="s2">const </span><span class="s1">isInPendingSuspense = !!suspense.pendingBranch</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isInPendingSuspense) {</span>
                <span class="s1">suspense.deps++</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">hydratedEl = instance.vnode.el</span><span class="s2">;</span>
            <span class="s1">instance</span>
                <span class="s1">.asyncDep.catch(err =&gt; {</span>
                <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">})</span>
                <span class="s1">.then(asyncSetupResult =&gt; {</span>
                <span class="s5">// retry when the setup() promise resolves.</span>
                <span class="s5">// component may have been unmounted before resolve.</span>
                <span class="s2">if </span><span class="s1">(instance.isUnmounted ||</span>
                    <span class="s1">suspense.isUnmounted ||</span>
                    <span class="s1">suspense.pendingId !== instance.suspenseId) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s5">// retry from this component</span>
                <span class="s1">instance.asyncResolved = </span><span class="s2">true;</span>
                <span class="s2">const </span><span class="s1">{ vnode } = instance</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">pushWarningContext(vnode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">asyncSetupResult</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hydratedEl) {</span>
                    <span class="s5">// vnode may have been replaced if an update happened before the</span>
                    <span class="s5">// async dep is resolved.</span>
                    <span class="s1">vnode.el = hydratedEl</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">placeholder = !hydratedEl &amp;&amp; instance.subTree.el</span><span class="s2">;</span>
                <span class="s1">setupRenderEffect(instance</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span>
                <span class="s5">// component may have been moved before resolve.</span>
                <span class="s5">// if this is not a hydration, instance.subTree will be the comment</span>
                <span class="s5">// placeholder.</span>
                <span class="s1">parentNode(hydratedEl || instance.subTree.el)</span><span class="s2">, </span>
                <span class="s5">// anchor will not be used if this is hydration, so only need to</span>
                <span class="s5">// consider the comment placeholder case.</span>
                <span class="s1">hydratedEl ? </span><span class="s2">null </span><span class="s1">: next(instance.subTree)</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(placeholder) {</span>
                    <span class="s1">remove(placeholder)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">updateHOCHostEl(instance</span><span class="s2">, </span><span class="s1">vnode.el)</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">popWarningContext()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// only decrease deps count if suspense is not already resolved</span>
                <span class="s2">if </span><span class="s1">(isInPendingSuspense &amp;&amp; --suspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">suspense.resolve()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">unmount(parentSuspense</span><span class="s2">, </span><span class="s1">doRemove) {</span>
            <span class="s1">suspense.isUnmounted = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(suspense.activeBranch) {</span>
                <span class="s1">unmount(suspense.activeBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(suspense.pendingBranch) {</span>
                <span class="s1">unmount(suspense.pendingBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">suspense</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hydrateSuspense(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateNode) {</span>
    <span class="s5">/* eslint-disable no-restricted-globals */</span>
    <span class="s2">const </span><span class="s1">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">node.parentNode</span><span class="s2">, </span><span class="s1">document.createElement(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">, null, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, true </span><span class="s5">/* hydrating */</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s5">// there are two possible scenarios for server-rendered suspense:</span>
    <span class="s5">// - success: ssr content should be fully resolved</span>
    <span class="s5">// - failure: ssr content should be the fallback branch.</span>
    <span class="s5">// however, on the client we don't really know if it has failed or not</span>
    <span class="s5">// attempt to hydrate the DOM assuming it has succeeded, but we still</span>
    <span class="s5">// need to construct a suspense boundary first</span>
    <span class="s2">const </span><span class="s1">result = hydrateNode(node</span><span class="s2">, </span><span class="s1">(suspense.pendingBranch = vnode.ssContent)</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(suspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">suspense.resolve()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s5">/* eslint-enable no-restricted-globals */</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeSuspenseChildren(vnode) {</span>
    <span class="s2">const </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children } = vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isSlotChildren = shapeFlag &amp; </span><span class="s4">32 </span><span class="s5">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">;</span>
    <span class="s1">vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children)</span><span class="s2">;</span>
    <span class="s1">vnode.ssFallback = isSlotChildren</span>
        <span class="s1">? normalizeSuspenseSlot(children.fallback)</span>
        <span class="s1">: createVNode(Comment)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeSuspenseSlot(s) {</span>
    <span class="s2">let </span><span class="s1">block</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(s)) {</span>
        <span class="s2">const </span><span class="s1">trackBlock = isBlockTreeEnabled &amp;&amp; s._c</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trackBlock) {</span>
            <span class="s5">// disableTracking: false</span>
            <span class="s5">// allow block tracking for compiled slots</span>
            <span class="s5">// (see ./componentRenderContext.ts)</span>
            <span class="s1">s._d = </span><span class="s2">false;</span>
            <span class="s1">openBlock()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">s = s()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trackBlock) {</span>
            <span class="s1">s._d = </span><span class="s2">true;</span>
            <span class="s1">block = currentBlock</span><span class="s2">;</span>
            <span class="s1">closeBlock()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isArray(s)) {</span>
        <span class="s2">const </span><span class="s1">singleChild = filterSingleRoot(s)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!singleChild) {</span>
            <span class="s1">warn(</span><span class="s3">`&lt;Suspense&gt; slots expect a single root node.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">s = singleChild</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">s = normalizeVNode(s)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(block &amp;&amp; !s.dynamicChildren) {</span>
        <span class="s1">s.dynamicChildren = block.filter(c =&gt; c !== s)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">s</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueEffectWithSuspense(fn</span><span class="s2">, </span><span class="s1">suspense) {</span>
    <span class="s2">if </span><span class="s1">(suspense &amp;&amp; suspense.pendingBranch) {</span>
        <span class="s2">if </span><span class="s1">(isArray(fn)) {</span>
            <span class="s1">suspense.effects.push(...fn)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">suspense.effects.push(fn)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">queuePostFlushCb(fn)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">branch) {</span>
    <span class="s1">suspense.activeBranch = branch</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">parentComponent } = suspense</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">el = (vnode.el = branch.el)</span><span class="s2">;</span>
    <span class="s5">// in case suspense is the root node of a component,</span>
    <span class="s5">// recursively update the HOC el</span>
    <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.subTree === vnode) {</span>
        <span class="s1">parentComponent.vnode.el = el</span><span class="s2">;</span>
        <span class="s1">updateHOCHostEl(parentComponent</span><span class="s2">, </span><span class="s1">el)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">provide(key</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">if </span><span class="s1">(!currentInstance) {</span>
        <span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`provide() can only be used inside setup().`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">provides = currentInstance.provides</span><span class="s2">;</span>
        <span class="s5">// by default an instance inherits its parent's provides object</span>
        <span class="s5">// but when it needs to provide values of its own, it creates its</span>
        <span class="s5">// own provides object using parent provides object as prototype.</span>
        <span class="s5">// this way in `inject` we can simply look up injections from direct</span>
        <span class="s5">// parent and let the prototype chain do the work.</span>
        <span class="s2">const </span><span class="s1">parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parentProvides === provides) {</span>
            <span class="s1">provides = currentInstance.provides = Object.create(parentProvides)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// TS doesn't allow symbol as index type</span>
        <span class="s1">provides[key] = value</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">inject(key</span><span class="s2">, </span><span class="s1">defaultValue</span><span class="s2">, </span><span class="s1">treatDefaultAsFactory = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s5">// fallback to `currentRenderingInstance` so that this can be called in</span>
    <span class="s5">// a functional component</span>
    <span class="s2">const </span><span class="s1">instance = currentInstance || currentRenderingInstance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance) {</span>
        <span class="s5">// #2400</span>
        <span class="s5">// to support `app.use` plugins,</span>
        <span class="s5">// fallback to appContext's `provides` if the instance is at root</span>
        <span class="s2">const </span><span class="s1">provides = instance.parent == </span><span class="s2">null</span>
            <span class="s1">? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span>
            <span class="s1">: instance.parent.provides</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(provides &amp;&amp; key </span><span class="s2">in </span><span class="s1">provides) {</span>
            <span class="s5">// TS doesn't allow symbol as index type</span>
            <span class="s2">return </span><span class="s1">provides[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(arguments.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">treatDefaultAsFactory &amp;&amp; isFunction(defaultValue)</span>
                <span class="s1">? defaultValue.call(instance.proxy)</span>
                <span class="s1">: defaultValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`injection &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; not found.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warn(</span><span class="s3">`inject() can only be used inside setup() or functional components.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">// Simple effect.</span>
<span class="s2">function </span><span class="s1">watchEffect(effect</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">return </span><span class="s1">doWatch(effect</span><span class="s2">, null, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">watchPostEffect(effect</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">return </span><span class="s1">doWatch(effect</span><span class="s2">, null, </span><span class="s1">Object.assign(Object.assign({}</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">, </span><span class="s1">{ flush: </span><span class="s3">'post' </span><span class="s1">}) )</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">watchSyncEffect(effect</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">return </span><span class="s1">doWatch(effect</span><span class="s2">, null, </span><span class="s1">Object.assign(Object.assign({}</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">, </span><span class="s1">{ flush: </span><span class="s3">'sync' </span><span class="s1">}) )</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// initial value for watchers to trigger on undefined initial values</span>
<span class="s2">const </span><span class="s1">INITIAL_WATCHER_VALUE = {}</span><span class="s2">;</span>
<span class="s5">// implementation</span>
<span class="s2">function </span><span class="s1">watch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(!isFunction(cb)) {</span>
        <span class="s1">warn(</span><span class="s3">`</span><span class="s2">\`</span><span class="s3">watch(fn, options?)</span><span class="s2">\` </span><span class="s3">signature has been moved to a separate API. ` </span><span class="s1">+</span>
            <span class="s3">`Use </span><span class="s2">\`</span><span class="s3">watchEffect(fn, options?)</span><span class="s2">\` </span><span class="s3">instead. </span><span class="s2">\`</span><span class="s3">watch</span><span class="s2">\` </span><span class="s3">now only ` </span><span class="s1">+</span>
            <span class="s3">`supports </span><span class="s2">\`</span><span class="s3">watch(source, cb, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">doWatch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">doWatch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">{ immediate</span><span class="s2">, </span><span class="s1">deep</span><span class="s2">, </span><span class="s1">flush</span><span class="s2">, </span><span class="s1">onTrack</span><span class="s2">, </span><span class="s1">onTrigger } = EMPTY_OBJ) {</span>
    <span class="s2">if </span><span class="s1">(!cb) {</span>
        <span class="s2">if </span><span class="s1">(immediate !== undefined) {</span>
            <span class="s1">warn(</span><span class="s3">`watch() &quot;immediate&quot; option is only respected when using the ` </span><span class="s1">+</span>
                <span class="s3">`watch(source, callback, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(deep !== undefined) {</span>
            <span class="s1">warn(</span><span class="s3">`watch() &quot;deep&quot; option is only respected when using the ` </span><span class="s1">+</span>
                <span class="s3">`watch(source, callback, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">warnInvalidSource = (s) =&gt; {</span>
        <span class="s1">warn(</span><span class="s3">`Invalid watch source: `</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s3">`A watch source can only be a getter/effect function, a ref, ` </span><span class="s1">+</span>
            <span class="s3">`a reactive object, or an array of these types.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentScope() === (currentInstance === </span><span class="s2">null </span><span class="s1">|| currentInstance === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: currentInstance.scope) ? currentInstance : </span><span class="s2">null;</span>
    <span class="s5">// const instance = currentInstance</span>
    <span class="s2">let </span><span class="s1">getter</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">forceTrigger = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">isMultiSource = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(isRef(source)) {</span>
        <span class="s1">getter = () =&gt; source.value</span><span class="s2">;</span>
        <span class="s1">forceTrigger = isShallow(source)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isReactive(source)) {</span>
        <span class="s1">getter = () =&gt; source</span><span class="s2">;</span>
        <span class="s1">deep = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isArray(source)) {</span>
        <span class="s1">isMultiSource = </span><span class="s2">true;</span>
        <span class="s1">forceTrigger = source.some(s =&gt; isReactive(s) || isShallow(s))</span><span class="s2">;</span>
        <span class="s1">getter = () =&gt; source.map(s =&gt; {</span>
            <span class="s2">if </span><span class="s1">(isRef(s)) {</span>
                <span class="s2">return </span><span class="s1">s.value</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isReactive(s)) {</span>
                <span class="s2">return </span><span class="s1">traverse(s)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isFunction(s)) {</span>
                <span class="s2">return </span><span class="s1">callWithErrorHandling(s</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ErrorCodes.WATCH_GETTER */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">warnInvalidSource(s)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isFunction(source)) {</span>
        <span class="s2">if </span><span class="s1">(cb) {</span>
            <span class="s5">// getter with cb</span>
            <span class="s1">getter = () =&gt; callWithErrorHandling(source</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ErrorCodes.WATCH_GETTER */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// no cb -&gt; simple effect</span>
            <span class="s1">getter = () =&gt; {</span>
                <span class="s2">if </span><span class="s1">(instance &amp;&amp; instance.isUnmounted) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(cleanup) {</span>
                    <span class="s1">cleanup()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">callWithAsyncErrorHandling(source</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">3 </span><span class="s5">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s2">, </span><span class="s1">[onCleanup])</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">getter = NOOP</span><span class="s2">;</span>
        <span class="s1">warnInvalidSource(source)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(cb &amp;&amp; deep) {</span>
        <span class="s2">const </span><span class="s1">baseGetter = getter</span><span class="s2">;</span>
        <span class="s1">getter = () =&gt; traverse(baseGetter())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">cleanup</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">onCleanup = (fn) =&gt; {</span>
        <span class="s1">cleanup = effect.onStop = () =&gt; {</span>
            <span class="s1">callWithErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">4 </span><span class="s5">/* ErrorCodes.WATCH_CLEANUP */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">oldValue = isMultiSource</span>
        <span class="s1">? </span><span class="s2">new </span><span class="s1">Array(source.length).fill(INITIAL_WATCHER_VALUE)</span>
        <span class="s1">: INITIAL_WATCHER_VALUE</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">job = () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!effect.active) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(cb) {</span>
            <span class="s5">// watch(source, cb)</span>
            <span class="s2">const </span><span class="s1">newValue = effect.run()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(deep ||</span>
                <span class="s1">forceTrigger ||</span>
                <span class="s1">(isMultiSource</span>
                    <span class="s1">? newValue.some((v</span><span class="s2">, </span><span class="s1">i) =&gt; hasChanged(v</span><span class="s2">, </span><span class="s1">oldValue[i]))</span>
                    <span class="s1">: hasChanged(newValue</span><span class="s2">, </span><span class="s1">oldValue)) ||</span>
                <span class="s1">(</span><span class="s2">false  </span><span class="s1">)) {</span>
                <span class="s5">// cleanup before running cb again</span>
                <span class="s2">if </span><span class="s1">(cleanup) {</span>
                    <span class="s1">cleanup()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">callWithAsyncErrorHandling(cb</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">3 </span><span class="s5">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">newValue</span><span class="s2">,</span>
                    <span class="s5">// pass undefined as the old value when it's changed for the first time</span>
                    <span class="s1">oldValue === INITIAL_WATCHER_VALUE</span>
                        <span class="s1">? undefined</span>
                        <span class="s1">: isMultiSource &amp;&amp; oldValue[</span><span class="s4">0</span><span class="s1">] === INITIAL_WATCHER_VALUE</span>
                            <span class="s1">? []</span>
                            <span class="s1">: oldValue</span><span class="s2">,</span>
                    <span class="s1">onCleanup</span>
                <span class="s1">])</span><span class="s2">;</span>
                <span class="s1">oldValue = newValue</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// watchEffect</span>
            <span class="s1">effect.run()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// important: mark the job as a watcher callback so that scheduler knows</span>
    <span class="s5">// it is allowed to self-trigger (#1727)</span>
    <span class="s1">job.allowRecurse = !!cb</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">scheduler</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(flush === </span><span class="s3">'sync'</span><span class="s1">) {</span>
        <span class="s1">scheduler = job</span><span class="s2">; </span><span class="s5">// the scheduler function gets called directly</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(flush === </span><span class="s3">'post'</span><span class="s1">) {</span>
        <span class="s1">scheduler = () =&gt; queuePostRenderEffect(job</span><span class="s2">, </span><span class="s1">instance &amp;&amp; instance.suspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// default: 'pre'</span>
        <span class="s1">job.pre = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(instance)</span>
            <span class="s1">job.id = instance.uid</span><span class="s2">;</span>
        <span class="s1">scheduler = () =&gt; queueJob(job)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(getter</span><span class="s2">, </span><span class="s1">scheduler)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">effect.onTrack = onTrack</span><span class="s2">;</span>
        <span class="s1">effect.onTrigger = onTrigger</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// initial run</span>
    <span class="s2">if </span><span class="s1">(cb) {</span>
        <span class="s2">if </span><span class="s1">(immediate) {</span>
            <span class="s1">job()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">oldValue = effect.run()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(flush === </span><span class="s3">'post'</span><span class="s1">) {</span>
        <span class="s1">queuePostRenderEffect(effect.run.bind(effect)</span><span class="s2">, </span><span class="s1">instance &amp;&amp; instance.suspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">effect.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">unwatch = () =&gt; {</span>
        <span class="s1">effect.stop()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(instance &amp;&amp; instance.scope) {</span>
            <span class="s1">remove(instance.scope.effects</span><span class="s2">, </span><span class="s1">effect)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">unwatch</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// this.$watch</span>
<span class="s2">function </span><span class="s1">instanceWatch(source</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">const </span><span class="s1">publicThis = </span><span class="s2">this</span><span class="s1">.proxy</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getter = isString(source)</span>
        <span class="s1">? source.includes(</span><span class="s3">'.'</span><span class="s1">)</span>
            <span class="s1">? createPathGetter(publicThis</span><span class="s2">, </span><span class="s1">source)</span>
            <span class="s1">: () =&gt; publicThis[source]</span>
        <span class="s1">: source.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">cb</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
        <span class="s1">cb = value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">cb = value.handler</span><span class="s2">;</span>
        <span class="s1">options = value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">cur = currentInstance</span><span class="s2">;</span>
    <span class="s1">setCurrentInstance(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">res = doWatch(getter</span><span class="s2">, </span><span class="s1">cb.bind(publicThis)</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cur) {</span>
        <span class="s1">setCurrentInstance(cur)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPathGetter(ctx</span><span class="s2">, </span><span class="s1">path) {</span>
    <span class="s2">const </span><span class="s1">segments = path.split(</span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
        <span class="s2">let </span><span class="s1">cur = ctx</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; segments.length &amp;&amp; cur</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">cur = cur[segments[i]]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">cur</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traverse(value</span><span class="s2">, </span><span class="s1">seen) {</span>
    <span class="s2">if </span><span class="s1">(!isObject(value) || value[</span><span class="s3">&quot;__v_skip&quot; </span><span class="s5">/* ReactiveFlags.SKIP */</span><span class="s1">]) {</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">seen = seen || </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(seen.has(value)) {</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">seen.add(value)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isRef(value)) {</span>
        <span class="s1">traverse(value.value</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">traverse(value[i]</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isSet(value) || isMap(value)) {</span>
        <span class="s1">value.forEach((v) =&gt; {</span>
            <span class="s1">traverse(v</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isPlainObject(value)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">value) {</span>
            <span class="s1">traverse(value[key]</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useTransitionState() {</span>
    <span class="s2">const </span><span class="s1">state = {</span>
        <span class="s1">isMounted: </span><span class="s2">false,</span>
        <span class="s1">isLeaving: </span><span class="s2">false,</span>
        <span class="s1">isUnmounting: </span><span class="s2">false,</span>
        <span class="s1">leavingVNodes: </span><span class="s2">new </span><span class="s1">Map()</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">onMounted(() =&gt; {</span>
        <span class="s1">state.isMounted = </span><span class="s2">true;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">onBeforeUnmount(() =&gt; {</span>
        <span class="s1">state.isUnmounting = </span><span class="s2">true;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">TransitionHookValidator = [Function</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">BaseTransitionImpl = {</span>
    <span class="s1">name: </span><span class="s3">`BaseTransition`</span><span class="s2">,</span>
    <span class="s1">props: {</span>
        <span class="s1">mode: String</span><span class="s2">,</span>
        <span class="s1">appear: Boolean</span><span class="s2">,</span>
        <span class="s1">persisted: Boolean</span><span class="s2">,</span>
        <span class="s5">// enter</span>
        <span class="s1">onBeforeEnter: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onEnter: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onAfterEnter: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onEnterCancelled: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s5">// leave</span>
        <span class="s1">onBeforeLeave: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onLeave: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onAfterLeave: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onLeaveCancelled: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s5">// appear</span>
        <span class="s1">onBeforeAppear: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onAppear: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onAfterAppear: TransitionHookValidator</span><span class="s2">,</span>
        <span class="s1">onAppearCancelled: TransitionHookValidator</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
        <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">state = useTransitionState()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">prevTransitionKey</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">children = slots.default &amp;&amp; getTransitionRawChildren(slots.default()</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!children || !children.length) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">let </span><span class="s1">hasFound = </span><span class="s2">false;</span>
                <span class="s5">// locate first non-comment child</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">c of children) {</span>
                    <span class="s2">if </span><span class="s1">(c.type !== Comment) {</span>
                        <span class="s2">if </span><span class="s1">(hasFound) {</span>
                            <span class="s5">// warn more than one non-comment child</span>
                            <span class="s1">warn(</span><span class="s3">'&lt;transition&gt; can only be used on a single element or component. ' </span><span class="s1">+</span>
                                <span class="s3">'Use &lt;transition-group&gt; for lists.'</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s1">}</span>
                        <span class="s1">child = c</span><span class="s2">;</span>
                        <span class="s1">hasFound = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// there's no need to track reactivity for these props so use the raw</span>
            <span class="s5">// props for a bit better perf</span>
            <span class="s2">const </span><span class="s1">rawProps = toRaw(props)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ mode } = rawProps</span><span class="s2">;</span>
            <span class="s5">// check mode</span>
            <span class="s2">if </span><span class="s1">(mode &amp;&amp;</span>
                <span class="s1">mode !== </span><span class="s3">'in-out' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">mode !== </span><span class="s3">'out-in' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">mode !== </span><span class="s3">'default'</span><span class="s1">) {</span>
                <span class="s1">warn(</span><span class="s3">`invalid &lt;transition&gt; mode: </span><span class="s1">${mode}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(state.isLeaving) {</span>
                <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// in the case of &lt;transition&gt;&lt;keep-alive/&gt;&lt;/transition&gt;, we need to</span>
            <span class="s5">// compare the type of the kept-alive children.</span>
            <span class="s2">const </span><span class="s1">innerChild = getKeepAliveChild(child)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!innerChild) {</span>
                <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">enterHooks = resolveTransitionHooks(innerChild</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
            <span class="s1">setTransitionHooks(innerChild</span><span class="s2">, </span><span class="s1">enterHooks)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">oldChild = instance.subTree</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild)</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">transitionKeyChanged = </span><span class="s2">false;</span>
            <span class="s2">const </span><span class="s1">{ getTransitionKey } = innerChild.type</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(getTransitionKey) {</span>
                <span class="s2">const </span><span class="s1">key = getTransitionKey()</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(prevTransitionKey === undefined) {</span>
                    <span class="s1">prevTransitionKey = key</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(key !== prevTransitionKey) {</span>
                    <span class="s1">prevTransitionKey = key</span><span class="s2">;</span>
                    <span class="s1">transitionKeyChanged = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// handle mode</span>
            <span class="s2">if </span><span class="s1">(oldInnerChild &amp;&amp;</span>
                <span class="s1">oldInnerChild.type !== Comment &amp;&amp;</span>
                <span class="s1">(!isSameVNodeType(innerChild</span><span class="s2">, </span><span class="s1">oldInnerChild) || transitionKeyChanged)) {</span>
                <span class="s2">const </span><span class="s1">leavingHooks = resolveTransitionHooks(oldInnerChild</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
                <span class="s5">// update old tree's hooks in case of dynamic transition</span>
                <span class="s1">setTransitionHooks(oldInnerChild</span><span class="s2">, </span><span class="s1">leavingHooks)</span><span class="s2">;</span>
                <span class="s5">// switching between different views</span>
                <span class="s2">if </span><span class="s1">(mode === </span><span class="s3">'out-in'</span><span class="s1">) {</span>
                    <span class="s1">state.isLeaving = </span><span class="s2">true;</span>
                    <span class="s5">// return placeholder node and queue update when leave finishes</span>
                    <span class="s1">leavingHooks.afterLeave = () =&gt; {</span>
                        <span class="s1">state.isLeaving = </span><span class="s2">false;</span>
                        <span class="s5">// #6835</span>
                        <span class="s5">// it also needs to be updated when active is undefined</span>
                        <span class="s2">if </span><span class="s1">(instance.update.active !== </span><span class="s2">false</span><span class="s1">) {</span>
                            <span class="s1">instance.update()</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(mode === </span><span class="s3">'in-out' </span><span class="s1">&amp;&amp; innerChild.type !== Comment) {</span>
                    <span class="s1">leavingHooks.delayLeave = (el</span><span class="s2">, </span><span class="s1">earlyRemove</span><span class="s2">, </span><span class="s1">delayedLeave) =&gt; {</span>
                        <span class="s2">const </span><span class="s1">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">oldInnerChild)</span><span class="s2">;</span>
                        <span class="s1">leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild</span><span class="s2">;</span>
                        <span class="s5">// early removal callback</span>
                        <span class="s1">el._leaveCb = () =&gt; {</span>
                            <span class="s1">earlyRemove()</span><span class="s2">;</span>
                            <span class="s1">el._leaveCb = undefined</span><span class="s2">;</span>
                            <span class="s2">delete </span><span class="s1">enterHooks.delayedLeave</span><span class="s2">;</span>
                        <span class="s1">}</span><span class="s2">;</span>
                        <span class="s1">enterHooks.delayedLeave = delayedLeave</span><span class="s2">;</span>
                    <span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">child</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s5">// export the public type for h/tsx inference</span>
<span class="s5">// also to avoid inline import() in generated d.ts files</span>
<span class="s2">const </span><span class="s1">BaseTransition = BaseTransitionImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s2">const </span><span class="s1">{ leavingVNodes } = state</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">leavingVNodesCache = leavingVNodes.get(vnode.type)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!leavingVNodesCache) {</span>
        <span class="s1">leavingVNodesCache = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">leavingVNodes.set(vnode.type</span><span class="s2">, </span><span class="s1">leavingVNodesCache)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">leavingVNodesCache</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// The transition hooks are attached to the vnode as vnode.transition</span>
<span class="s5">// and will be called at appropriate timing in the renderer.</span>
<span class="s2">function </span><span class="s1">resolveTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance) {</span>
    <span class="s2">const </span><span class="s1">{ appear</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">persisted = </span><span class="s2">false, </span><span class="s1">onBeforeEnter</span><span class="s2">, </span><span class="s1">onEnter</span><span class="s2">, </span><span class="s1">onAfterEnter</span><span class="s2">, </span><span class="s1">onEnterCancelled</span><span class="s2">, </span><span class="s1">onBeforeLeave</span><span class="s2">, </span><span class="s1">onLeave</span><span class="s2">, </span><span class="s1">onAfterLeave</span><span class="s2">, </span><span class="s1">onLeaveCancelled</span><span class="s2">, </span><span class="s1">onBeforeAppear</span><span class="s2">, </span><span class="s1">onAppear</span><span class="s2">, </span><span class="s1">onAfterAppear</span><span class="s2">, </span><span class="s1">onAppearCancelled } = props</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">key = String(vnode.key)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">callHook = (hook</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
        <span class="s1">hook &amp;&amp;</span>
            <span class="s1">callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">9 </span><span class="s5">/* ErrorCodes.TRANSITION_HOOK */</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">callAsyncHook = (hook</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
        <span class="s2">const </span><span class="s1">done = args[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">callHook(hook</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
            <span class="s2">if </span><span class="s1">(hook.every(hook =&gt; hook.length &lt;= </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">done()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(hook.length &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">done()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hooks = {</span>
        <span class="s1">mode</span><span class="s2">,</span>
        <span class="s1">persisted</span><span class="s2">,</span>
        <span class="s1">beforeEnter(el) {</span>
            <span class="s2">let </span><span class="s1">hook = onBeforeEnter</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!state.isMounted) {</span>
                <span class="s2">if </span><span class="s1">(appear) {</span>
                    <span class="s1">hook = onBeforeAppear || onBeforeEnter</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// for same element (v-show)</span>
            <span class="s2">if </span><span class="s1">(el._leaveCb) {</span>
                <span class="s1">el._leaveCb(</span><span class="s2">true </span><span class="s5">/* cancelled */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// for toggled element with same key (v-if)</span>
            <span class="s2">const </span><span class="s1">leavingVNode = leavingVNodesCache[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(leavingVNode &amp;&amp;</span>
                <span class="s1">isSameVNodeType(vnode</span><span class="s2">, </span><span class="s1">leavingVNode) &amp;&amp;</span>
                <span class="s1">leavingVNode.el._leaveCb) {</span>
                <span class="s5">// force early removal (not cancelled)</span>
                <span class="s1">leavingVNode.el._leaveCb()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">callHook(hook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">enter(el) {</span>
            <span class="s2">let </span><span class="s1">hook = onEnter</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">afterHook = onAfterEnter</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">cancelHook = onEnterCancelled</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!state.isMounted) {</span>
                <span class="s2">if </span><span class="s1">(appear) {</span>
                    <span class="s1">hook = onAppear || onEnter</span><span class="s2">;</span>
                    <span class="s1">afterHook = onAfterAppear || onAfterEnter</span><span class="s2">;</span>
                    <span class="s1">cancelHook = onAppearCancelled || onEnterCancelled</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">called = </span><span class="s2">false;</span>
            <span class="s2">const </span><span class="s1">done = (el._enterCb = (cancelled) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(called)</span>
                    <span class="s2">return;</span>
                <span class="s1">called = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(cancelled) {</span>
                    <span class="s1">callHook(cancelHook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">callHook(afterHook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(hooks.delayedLeave) {</span>
                    <span class="s1">hooks.delayedLeave()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">el._enterCb = undefined</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(hook) {</span>
                <span class="s1">callAsyncHook(hook</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">done])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">done()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">leave(el</span><span class="s2">, </span><span class="s1">remove) {</span>
            <span class="s2">const </span><span class="s1">key = String(vnode.key)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(el._enterCb) {</span>
                <span class="s1">el._enterCb(</span><span class="s2">true </span><span class="s5">/* cancelled */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(state.isUnmounting) {</span>
                <span class="s2">return </span><span class="s1">remove()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">callHook(onBeforeLeave</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">called = </span><span class="s2">false;</span>
            <span class="s2">const </span><span class="s1">done = (el._leaveCb = (cancelled) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(called)</span>
                    <span class="s2">return;</span>
                <span class="s1">called = </span><span class="s2">true;</span>
                <span class="s1">remove()</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(cancelled) {</span>
                    <span class="s1">callHook(onLeaveCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">callHook(onAfterLeave</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">el._leaveCb = undefined</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(leavingVNodesCache[key] === vnode) {</span>
                    <span class="s2">delete </span><span class="s1">leavingVNodesCache[key]</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">leavingVNodesCache[key] = vnode</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(onLeave) {</span>
                <span class="s1">callAsyncHook(onLeave</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">done])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">done()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">clone(vnode) {</span>
            <span class="s2">return </span><span class="s1">resolveTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">hooks</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// the placeholder really only handles one special case: KeepAlive</span>
<span class="s5">// in the case of a KeepAlive in a leave phase we need to return a KeepAlive</span>
<span class="s5">// placeholder with empty content to avoid the KeepAlive instance from being</span>
<span class="s5">// unmounted.</span>
<span class="s2">function </span><span class="s1">emptyPlaceholder(vnode) {</span>
    <span class="s2">if </span><span class="s1">(isKeepAlive(vnode)) {</span>
        <span class="s1">vnode = cloneVNode(vnode)</span><span class="s2">;</span>
        <span class="s1">vnode.children = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getKeepAliveChild(vnode) {</span>
    <span class="s2">return </span><span class="s1">isKeepAlive(vnode)</span>
        <span class="s1">? vnode.children</span>
            <span class="s1">? vnode.children[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">: undefined</span>
        <span class="s1">: vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">hooks) {</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */ </span><span class="s1">&amp;&amp; vnode.component) {</span>
        <span class="s1">setTransitionHooks(vnode.component.subTree</span><span class="s2">, </span><span class="s1">hooks)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
        <span class="s1">vnode.ssContent.transition = hooks.clone(vnode.ssContent)</span><span class="s2">;</span>
        <span class="s1">vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">vnode.transition = hooks</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTransitionRawChildren(children</span><span class="s2">, </span><span class="s1">keepComment = </span><span class="s2">false, </span><span class="s1">parentKey) {</span>
    <span class="s2">let </span><span class="s1">ret = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">keyedFragmentCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">let </span><span class="s1">child = children[i]</span><span class="s2">;</span>
        <span class="s5">// #5360 inherit parent key in case of &lt;template v-for&gt;</span>
        <span class="s2">const </span><span class="s1">key = parentKey == </span><span class="s2">null</span>
            <span class="s1">? child.key</span>
            <span class="s1">: String(parentKey) + String(child.key != </span><span class="s2">null </span><span class="s1">? child.key : i)</span><span class="s2">;</span>
        <span class="s5">// handle fragment children case, e.g. v-for</span>
        <span class="s2">if </span><span class="s1">(child.type === Fragment) {</span>
            <span class="s2">if </span><span class="s1">(child.patchFlag &amp; </span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s1">)</span>
                <span class="s1">keyedFragmentCount++</span><span class="s2">;</span>
            <span class="s1">ret = ret.concat(getTransitionRawChildren(child.children</span><span class="s2">, </span><span class="s1">keepComment</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// comment placeholders should be skipped, e.g. v-if</span>
        <span class="s2">else if </span><span class="s1">(keepComment || child.type !== Comment) {</span>
            <span class="s1">ret.push(key != </span><span class="s2">null </span><span class="s1">? cloneVNode(child</span><span class="s2">, </span><span class="s1">{ key }) : child)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// #1126 if a transition children list contains multiple sub fragments, these</span>
    <span class="s5">// fragments will be merged into a flat children array. Since each v-for</span>
    <span class="s5">// fragment may contain different static bindings inside, we need to de-op</span>
    <span class="s5">// these children to force full diffs to ensure correct behavior.</span>
    <span class="s2">if </span><span class="s1">(keyedFragmentCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; ret.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">ret[i].patchFlag = -</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// implementation, close to no-op</span>
<span class="s2">function </span><span class="s1">defineComponent(options) {</span>
    <span class="s2">return </span><span class="s1">isFunction(options) ? { setup: options</span><span class="s2">, </span><span class="s1">name: options.name } : options</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isAsyncWrapper = (i) =&gt; !!i.type.__asyncLoader</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">defineAsyncComponent(source) {</span>
    <span class="s2">if </span><span class="s1">(isFunction(source)) {</span>
        <span class="s1">source = { loader: source }</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ loader</span><span class="s2">, </span><span class="s1">loadingComponent</span><span class="s2">, </span><span class="s1">errorComponent</span><span class="s2">, </span><span class="s1">delay = </span><span class="s4">200</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s5">// undefined = never times out</span>
    <span class="s1">suspensible = </span><span class="s2">true, </span><span class="s1">onError: userOnError } = source</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">pendingRequest = </span><span class="s2">null;</span>
    <span class="s2">let </span><span class="s1">resolvedComp</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">retries = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">retry = () =&gt; {</span>
        <span class="s1">retries++</span><span class="s2">;</span>
        <span class="s1">pendingRequest = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">load()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">load = () =&gt; {</span>
        <span class="s2">let </span><span class="s1">thisRequest</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(pendingRequest ||</span>
            <span class="s1">(thisRequest = pendingRequest =</span>
                <span class="s1">loader()</span>
                    <span class="s1">.catch(err =&gt; {</span>
                    <span class="s1">err = err </span><span class="s2">instanceof </span><span class="s1">Error ? err : </span><span class="s2">new </span><span class="s1">Error(String(err))</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(userOnError) {</span>
                        <span class="s2">return new </span><span class="s1">Promise((resolve</span><span class="s2">, </span><span class="s1">reject) =&gt; {</span>
                            <span class="s2">const </span><span class="s1">userRetry = () =&gt; resolve(retry())</span><span class="s2">;</span>
                            <span class="s2">const </span><span class="s1">userFail = () =&gt; reject(err)</span><span class="s2">;</span>
                            <span class="s1">userOnError(err</span><span class="s2">, </span><span class="s1">userRetry</span><span class="s2">, </span><span class="s1">userFail</span><span class="s2">, </span><span class="s1">retries + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">throw </span><span class="s1">err</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">})</span>
                    <span class="s1">.then((comp) =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span>
                        <span class="s2">return </span><span class="s1">pendingRequest</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!comp) {</span>
                        <span class="s1">warn(</span><span class="s3">`Async component loader resolved to undefined. ` </span><span class="s1">+</span>
                            <span class="s3">`If you are using retry(), make sure to return its return value.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s5">// interop module default</span>
                    <span class="s2">if </span><span class="s1">(comp &amp;&amp;</span>
                        <span class="s1">(comp.__esModule || comp[Symbol.toStringTag] === </span><span class="s3">'Module'</span><span class="s1">)) {</span>
                        <span class="s1">comp = comp.default</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(comp &amp;&amp; !isObject(comp) &amp;&amp; !isFunction(comp)) {</span>
                        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Invalid async component load result: </span><span class="s1">${comp}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">resolvedComp = comp</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">comp</span><span class="s2">;</span>
                <span class="s1">})))</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">defineComponent({</span>
        <span class="s1">name: </span><span class="s3">'AsyncComponentWrapper'</span><span class="s2">,</span>
        <span class="s1">__asyncLoader: load</span><span class="s2">,</span>
        <span class="s1">get __asyncResolved() {</span>
            <span class="s2">return </span><span class="s1">resolvedComp</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">setup() {</span>
            <span class="s2">const </span><span class="s1">instance = currentInstance</span><span class="s2">;</span>
            <span class="s5">// already resolved</span>
            <span class="s2">if </span><span class="s1">(resolvedComp) {</span>
                <span class="s2">return </span><span class="s1">() =&gt; createInnerComp(resolvedComp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">onError = (err) =&gt; {</span>
                <span class="s1">pendingRequest = </span><span class="s2">null;</span>
                <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">13 </span><span class="s5">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span><span class="s2">, </span><span class="s1">!errorComponent </span><span class="s5">/* do not throw in dev if user provided error component */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s5">// suspense-controlled or SSR.</span>
            <span class="s2">if </span><span class="s1">((suspensible &amp;&amp; instance.suspense) ||</span>
                <span class="s1">(</span><span class="s2">false </span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">load()</span>
                    <span class="s1">.then(comp =&gt; {</span>
                    <span class="s2">return </span><span class="s1">() =&gt; createInnerComp(comp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
                <span class="s1">})</span>
                    <span class="s1">.catch(err =&gt; {</span>
                    <span class="s1">onError(err)</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">() =&gt; errorComponent</span>
                        <span class="s1">? createVNode(errorComponent</span><span class="s2">, </span><span class="s1">{</span>
                            <span class="s1">error: err</span>
                        <span class="s1">})</span>
                        <span class="s1">: </span><span class="s2">null;</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">loaded = ref(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">error = ref()</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">delayed = ref(!!delay)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(delay) {</span>
                <span class="s1">setTimeout(() =&gt; {</span>
                    <span class="s1">delayed.value = </span><span class="s2">false;</span>
                <span class="s1">}</span><span class="s2">, </span><span class="s1">delay)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(timeout != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">setTimeout(() =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(!loaded.value &amp;&amp; !error.value) {</span>
                        <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">`Async component timed out after </span><span class="s1">${timeout}</span><span class="s3">ms.`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">onError(err)</span><span class="s2">;</span>
                        <span class="s1">error.value = err</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">load()</span>
                <span class="s1">.then(() =&gt; {</span>
                <span class="s1">loaded.value = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(instance.parent &amp;&amp; isKeepAlive(instance.parent.vnode)) {</span>
                    <span class="s5">// parent is keep-alive, force update so the loaded component's</span>
                    <span class="s5">// name is taken into account</span>
                    <span class="s1">queueJob(instance.parent.update)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span>
                <span class="s1">.catch(err =&gt; {</span>
                <span class="s1">onError(err)</span><span class="s2">;</span>
                <span class="s1">error.value = err</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(loaded.value &amp;&amp; resolvedComp) {</span>
                    <span class="s2">return </span><span class="s1">createInnerComp(resolvedComp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(error.value &amp;&amp; errorComponent) {</span>
                    <span class="s2">return </span><span class="s1">createVNode(errorComponent</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">error: error.value</span>
                    <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(loadingComponent &amp;&amp; !delayed.value) {</span>
                    <span class="s2">return </span><span class="s1">createVNode(loadingComponent)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createInnerComp(comp</span><span class="s2">, </span><span class="s1">parent) {</span>
    <span class="s2">const </span><span class="s1">{ ref</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">ce } = parent.vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">vnode = createVNode(comp</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s5">// ensure inner component inherits the async wrapper's ref owner</span>
    <span class="s1">vnode.ref = ref</span><span class="s2">;</span>
    <span class="s5">// pass the custom element callback on to the inner comp</span>
    <span class="s5">// and remove it from the async wrapper</span>
    <span class="s1">vnode.ce = ce</span><span class="s2">;</span>
    <span class="s2">delete </span><span class="s1">parent.vnode.ce</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">KeepAliveImpl = {</span>
    <span class="s1">name: </span><span class="s3">`KeepAlive`</span><span class="s2">,</span>
    <span class="s5">// Marker for special handling inside the renderer. We are not using a ===</span>
    <span class="s5">// check directly on KeepAlive in the renderer, because importing it directly</span>
    <span class="s5">// would prevent it from being tree-shaken.</span>
    <span class="s1">__isKeepAlive: </span><span class="s2">true,</span>
    <span class="s1">props: {</span>
        <span class="s1">include: [String</span><span class="s2">, </span><span class="s1">RegExp</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">,</span>
        <span class="s1">exclude: [String</span><span class="s2">, </span><span class="s1">RegExp</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">,</span>
        <span class="s1">max: [String</span><span class="s2">, </span><span class="s1">Number]</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
        <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
        <span class="s5">// KeepAlive communicates with the instantiated renderer via the</span>
        <span class="s5">// ctx where the renderer passes in its internals,</span>
        <span class="s5">// and the KeepAlive instance exposes activate/deactivate implementations.</span>
        <span class="s5">// The whole point of this is to avoid importing KeepAlive directly in the</span>
        <span class="s5">// renderer to facilitate tree-shaking.</span>
        <span class="s2">const </span><span class="s1">sharedContext = instance.ctx</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">cache = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keys = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">current = </span><span class="s2">null;</span>
        <span class="s1">{</span>
            <span class="s1">instance.__v_cache = cache</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">parentSuspense = instance.suspense</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ renderer: { p: patch</span><span class="s2">, </span><span class="s1">m: move</span><span class="s2">, </span><span class="s1">um: _unmount</span><span class="s2">, </span><span class="s1">o: { createElement } } } = sharedContext</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">storageContainer = createElement(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">sharedContext.activate = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
            <span class="s2">const </span><span class="s1">instance = vnode.component</span><span class="s2">;</span>
            <span class="s1">move(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* MoveType.ENTER */</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s5">// in case props have changed</span>
            <span class="s1">patch(instance.vnode</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">instance.isDeactivated = </span><span class="s2">false;</span>
                <span class="s2">if </span><span class="s1">(instance.a) {</span>
                    <span class="s1">invokeArrayFns(instance.a)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(vnodeHook) {</span>
                    <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">instance.parent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s5">// Update components tree</span>
                <span class="s1">devtoolsComponentAdded(instance)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">sharedContext.deactivate = (vnode) =&gt; {</span>
            <span class="s2">const </span><span class="s1">instance = vnode.component</span><span class="s2">;</span>
            <span class="s1">move(vnode</span><span class="s2">, </span><span class="s1">storageContainer</span><span class="s2">, null, </span><span class="s4">1 </span><span class="s5">/* MoveType.LEAVE */</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(instance.da) {</span>
                    <span class="s1">invokeArrayFns(instance.da)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(vnodeHook) {</span>
                    <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">instance.parent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">instance.isDeactivated = </span><span class="s2">true;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s5">// Update components tree</span>
                <span class="s1">devtoolsComponentAdded(instance)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">function </span><span class="s1">unmount(vnode) {</span>
            <span class="s5">// reset the shapeFlag so it can be properly unmounted</span>
            <span class="s1">resetShapeFlag(vnode)</span><span class="s2">;</span>
            <span class="s1">_unmount(vnode</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">pruneCache(filter) {</span>
            <span class="s1">cache.forEach((vnode</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
                <span class="s2">const </span><span class="s1">name = getComponentName(vnode.type)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(name &amp;&amp; (!filter || !filter(name))) {</span>
                    <span class="s1">pruneCacheEntry(key)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">pruneCacheEntry(key) {</span>
            <span class="s2">const </span><span class="s1">cached = cache.get(key)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!current || !isSameVNodeType(cached</span><span class="s2">, </span><span class="s1">current)) {</span>
                <span class="s1">unmount(cached)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(current) {</span>
                <span class="s5">// current active instance should no longer be kept-alive.</span>
                <span class="s5">// we can't unmount it now but it might be later, so reset its flag now.</span>
                <span class="s1">resetShapeFlag(current)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">cache.delete(key)</span><span class="s2">;</span>
            <span class="s1">keys.delete(key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// prune cache on include/exclude prop change</span>
        <span class="s1">watch(() =&gt; [props.include</span><span class="s2">, </span><span class="s1">props.exclude]</span><span class="s2">, </span><span class="s1">([include</span><span class="s2">, </span><span class="s1">exclude]) =&gt; {</span>
            <span class="s1">include &amp;&amp; pruneCache(name =&gt; matches(include</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
            <span class="s1">exclude &amp;&amp; pruneCache(name =&gt; !matches(exclude</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span>
        <span class="s5">// prune post-render after `current` has been updated</span>
        <span class="s1">{ flush: </span><span class="s3">'post'</span><span class="s2">, </span><span class="s1">deep: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s5">// cache sub tree after render</span>
        <span class="s2">let </span><span class="s1">pendingCacheKey = </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">cacheSubtree = () =&gt; {</span>
            <span class="s5">// fix #1621, the pendingCacheKey could be 0</span>
            <span class="s2">if </span><span class="s1">(pendingCacheKey != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s1">cache.set(pendingCacheKey</span><span class="s2">, </span><span class="s1">getInnerChild(instance.subTree))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">onMounted(cacheSubtree)</span><span class="s2">;</span>
        <span class="s1">onUpdated(cacheSubtree)</span><span class="s2">;</span>
        <span class="s1">onBeforeUnmount(() =&gt; {</span>
            <span class="s1">cache.forEach(cached =&gt; {</span>
                <span class="s2">const </span><span class="s1">{ subTree</span><span class="s2">, </span><span class="s1">suspense } = instance</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">vnode = getInnerChild(subTree)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(cached.type === vnode.type &amp;&amp; cached.key === vnode.key) {</span>
                    <span class="s5">// current instance will be unmounted as part of keep-alive's unmount</span>
                    <span class="s1">resetShapeFlag(vnode)</span><span class="s2">;</span>
                    <span class="s5">// but invoke its deactivated hook here</span>
                    <span class="s2">const </span><span class="s1">da = vnode.component.da</span><span class="s2">;</span>
                    <span class="s1">da &amp;&amp; queuePostRenderEffect(da</span><span class="s2">, </span><span class="s1">suspense)</span><span class="s2">;</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s1">unmount(cached)</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s1">pendingCacheKey = </span><span class="s2">null;</span>
            <span class="s2">if </span><span class="s1">(!slots.default) {</span>
                <span class="s2">return null;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">children = slots.default()</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">rawVNode = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`KeepAlive should contain exactly one component child.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">current = </span><span class="s2">null;</span>
                <span class="s2">return </span><span class="s1">children</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isVNode(rawVNode) ||</span>
                <span class="s1">(!(rawVNode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">!(rawVNode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">))) {</span>
                <span class="s1">current = </span><span class="s2">null;</span>
                <span class="s2">return </span><span class="s1">rawVNode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">vnode = getInnerChild(rawVNode)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">comp = vnode.type</span><span class="s2">;</span>
            <span class="s5">// for async components, name check should be based in its loaded</span>
            <span class="s5">// inner component if available</span>
            <span class="s2">const </span><span class="s1">name = getComponentName(isAsyncWrapper(vnode)</span>
                <span class="s1">? vnode.type.__asyncResolved || {}</span>
                <span class="s1">: comp)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ include</span><span class="s2">, </span><span class="s1">exclude</span><span class="s2">, </span><span class="s1">max } = props</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">((include &amp;&amp; (!name || !matches(include</span><span class="s2">, </span><span class="s1">name))) ||</span>
                <span class="s1">(exclude &amp;&amp; name &amp;&amp; matches(exclude</span><span class="s2">, </span><span class="s1">name))) {</span>
                <span class="s1">current = vnode</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">rawVNode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">key = vnode.key == </span><span class="s2">null </span><span class="s1">? comp : vnode.key</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">cachedVNode = cache.get(key)</span><span class="s2">;</span>
            <span class="s5">// clone vnode if it's reused because we are going to mutate it</span>
            <span class="s2">if </span><span class="s1">(vnode.el) {</span>
                <span class="s1">vnode = cloneVNode(vnode)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(rawVNode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
                    <span class="s1">rawVNode.ssContent = vnode</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// #1513 it's possible for the returned vnode to be cloned due to attr</span>
            <span class="s5">// fallthrough or scopeId, so the vnode here may not be the final vnode</span>
            <span class="s5">// that is mounted. Instead of caching it directly, we store the pending</span>
            <span class="s5">// key and cache `instance.subTree` (the normalized vnode) in</span>
            <span class="s5">// beforeMount/beforeUpdate hooks.</span>
            <span class="s1">pendingCacheKey = key</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(cachedVNode) {</span>
                <span class="s5">// copy over mounted state</span>
                <span class="s1">vnode.el = cachedVNode.el</span><span class="s2">;</span>
                <span class="s1">vnode.component = cachedVNode.component</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(vnode.transition) {</span>
                    <span class="s5">// recursively update transition hooks on subTree</span>
                    <span class="s1">setTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">vnode.transition)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// avoid vnode being mounted as fresh</span>
                <span class="s1">vnode.shapeFlag |= </span><span class="s4">512 </span><span class="s5">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s2">;</span>
                <span class="s5">// make this key the freshest</span>
                <span class="s1">keys.delete(key)</span><span class="s2">;</span>
                <span class="s1">keys.add(key)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">keys.add(key)</span><span class="s2">;</span>
                <span class="s5">// prune oldest entry</span>
                <span class="s2">if </span><span class="s1">(max &amp;&amp; keys.size &gt; parseInt(max</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)) {</span>
                    <span class="s1">pruneCacheEntry(keys.values().next().value)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// avoid vnode being unmounted</span>
            <span class="s1">vnode.shapeFlag |= </span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">;</span>
            <span class="s1">current = vnode</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">isSuspense(rawVNode.type) ? rawVNode : vnode</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s5">// export the public type for h/tsx inference</span>
<span class="s5">// also to avoid inline import() in generated d.ts files</span>
<span class="s2">const </span><span class="s1">KeepAlive = KeepAliveImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">matches(pattern</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">if </span><span class="s1">(isArray(pattern)) {</span>
        <span class="s2">return </span><span class="s1">pattern.some((p) =&gt; matches(p</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isString(pattern)) {</span>
        <span class="s2">return </span><span class="s1">pattern.split(</span><span class="s3">','</span><span class="s1">).includes(name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isRegExp(pattern)) {</span>
        <span class="s2">return </span><span class="s1">pattern.test(name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">/* istanbul ignore next */</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onActivated(hook</span><span class="s2">, </span><span class="s1">target) {</span>
    <span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s3">&quot;a&quot; </span><span class="s5">/* LifecycleHooks.ACTIVATED */</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onDeactivated(hook</span><span class="s2">, </span><span class="s1">target) {</span>
    <span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s3">&quot;da&quot; </span><span class="s5">/* LifecycleHooks.DEACTIVATED */</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target = currentInstance) {</span>
    <span class="s5">// cache the deactivate branch check wrapper for injected hooks so the same</span>
    <span class="s5">// hook can be properly deduped by the scheduler. &quot;__wdc&quot; stands for &quot;with</span>
    <span class="s5">// deactivation check&quot;.</span>
    <span class="s2">const </span><span class="s1">wrappedHook = hook.__wdc ||</span>
        <span class="s1">(hook.__wdc = () =&gt; {</span>
            <span class="s5">// only fire the hook if the target instance is NOT in a deactivated branch.</span>
            <span class="s2">let </span><span class="s1">current = target</span><span class="s2">;</span>
            <span class="s2">while </span><span class="s1">(current) {</span>
                <span class="s2">if </span><span class="s1">(current.isDeactivated) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s1">current = current.parent</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">hook()</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">injectHook(type</span><span class="s2">, </span><span class="s1">wrappedHook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s5">// In addition to registering it on the target instance, we walk up the parent</span>
    <span class="s5">// chain and register it on all ancestor instances that are keep-alive roots.</span>
    <span class="s5">// This avoids the need to walk the entire component tree when invoking these</span>
    <span class="s5">// hooks, and more importantly, avoids the need to track child components in</span>
    <span class="s5">// arrays.</span>
    <span class="s2">if </span><span class="s1">(target) {</span>
        <span class="s2">let </span><span class="s1">current = target.parent</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(current &amp;&amp; current.parent) {</span>
            <span class="s2">if </span><span class="s1">(isKeepAlive(current.parent.vnode)) {</span>
                <span class="s1">injectToKeepAliveRoot(wrappedHook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">current)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">current = current.parent</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">injectToKeepAliveRoot(hook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">keepAliveRoot) {</span>
    <span class="s5">// injectHook wraps the original for error handling, so make sure to remove</span>
    <span class="s5">// the wrapped version.</span>
    <span class="s2">const </span><span class="s1">injected = injectHook(type</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">keepAliveRoot</span><span class="s2">, true </span><span class="s5">/* prepend */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">onUnmounted(() =&gt; {</span>
        <span class="s1">remove(keepAliveRoot[type]</span><span class="s2">, </span><span class="s1">injected)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetShapeFlag(vnode) {</span>
    <span class="s5">// bitwise operations to remove keep alive flags</span>
    <span class="s1">vnode.shapeFlag &amp;= ~</span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">;</span>
    <span class="s1">vnode.shapeFlag &amp;= ~</span><span class="s4">512 </span><span class="s5">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getInnerChild(vnode) {</span>
    <span class="s2">return </span><span class="s1">vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */ </span><span class="s1">? vnode.ssContent : vnode</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">injectHook(type</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">target = currentInstance</span><span class="s2">, </span><span class="s1">prepend = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(target) {</span>
        <span class="s2">const </span><span class="s1">hooks = target[type] || (target[type] = [])</span><span class="s2">;</span>
        <span class="s5">// cache the error handling wrapper for injected hooks so the same hook</span>
        <span class="s5">// can be properly deduped by the scheduler. &quot;__weh&quot; stands for &quot;with error</span>
        <span class="s5">// handling&quot;.</span>
        <span class="s2">const </span><span class="s1">wrappedHook = hook.__weh ||</span>
            <span class="s1">(hook.__weh = (...args) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(target.isUnmounted) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s5">// disable tracking inside all lifecycle hooks</span>
                <span class="s5">// since they can potentially be called inside effects.</span>
                <span class="s1">pauseTracking()</span><span class="s2">;</span>
                <span class="s5">// Set currentInstance during hook invocation.</span>
                <span class="s5">// This assumes the hook does not synchronously trigger other hooks, which</span>
                <span class="s5">// can only be false when the user does something really funky.</span>
                <span class="s1">setCurrentInstance(target)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">res = callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
                <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
                <span class="s1">resetTracking()</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prepend) {</span>
            <span class="s1">hooks.unshift(wrappedHook)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hooks.push(wrappedHook)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">wrappedHook</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">apiName = toHandlerKey(ErrorTypeStrings[type].replace(</span><span class="s4">/ hook$/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">warn(</span><span class="s3">`</span><span class="s1">${apiName} </span><span class="s3">is called when there is no active component instance to be ` </span><span class="s1">+</span>
            <span class="s3">`associated with. ` </span><span class="s1">+</span>
            <span class="s3">`Lifecycle injection APIs can only be used during execution of setup().` </span><span class="s1">+</span>
            <span class="s1">(</span><span class="s3">` If you are using async setup(), make sure to register lifecycle ` </span><span class="s1">+</span>
                    <span class="s3">`hooks before the first await statement.`</span>
                <span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createHook = (lifecycle) =&gt; (hook</span><span class="s2">, </span><span class="s1">target = currentInstance) =&gt; </span>
<span class="s5">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span>
<span class="s1">(!isInSSRComponentSetup || lifecycle === </span><span class="s3">&quot;sp&quot; </span><span class="s5">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s1">) &amp;&amp;</span>
    <span class="s1">injectHook(lifecycle</span><span class="s2">, </span><span class="s1">(...args) =&gt; hook(...args)</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onBeforeMount = createHook(</span><span class="s3">&quot;bm&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_MOUNT */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onMounted = createHook(</span><span class="s3">&quot;m&quot; </span><span class="s5">/* LifecycleHooks.MOUNTED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onBeforeUpdate = createHook(</span><span class="s3">&quot;bu&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_UPDATE */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onUpdated = createHook(</span><span class="s3">&quot;u&quot; </span><span class="s5">/* LifecycleHooks.UPDATED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onBeforeUnmount = createHook(</span><span class="s3">&quot;bum&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_UNMOUNT */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onUnmounted = createHook(</span><span class="s3">&quot;um&quot; </span><span class="s5">/* LifecycleHooks.UNMOUNTED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onServerPrefetch = createHook(</span><span class="s3">&quot;sp&quot; </span><span class="s5">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onRenderTriggered = createHook(</span><span class="s3">&quot;rtg&quot; </span><span class="s5">/* LifecycleHooks.RENDER_TRIGGERED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">onRenderTracked = createHook(</span><span class="s3">&quot;rtc&quot; </span><span class="s5">/* LifecycleHooks.RENDER_TRACKED */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">onErrorCaptured(hook</span><span class="s2">, </span><span class="s1">target = currentInstance) {</span>
    <span class="s1">injectHook(</span><span class="s3">&quot;ec&quot; </span><span class="s5">/* LifecycleHooks.ERROR_CAPTURED */</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
<span class="s0">Runtime helper for applying directives to a vnode. Example usage:</span>

<span class="s0">const comp = resolveComponent('comp')</span>
<span class="s0">const foo = resolveDirective('foo')</span>
<span class="s0">const bar = resolveDirective('bar')</span>

<span class="s0">return withDirectives(h(comp), [</span>
  <span class="s0">[foo, this.x],</span>
  <span class="s0">[bar, this.y]</span>
<span class="s0">])</span>
<span class="s0">*/</span>
<span class="s2">function </span><span class="s1">validateDirectiveName(name) {</span>
    <span class="s2">if </span><span class="s1">(isBuiltInDirective(name)) {</span>
        <span class="s1">warn(</span><span class="s3">'Do not use built-in directive ids as custom directive id: ' </span><span class="s1">+ name)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Adds directives to a VNode.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">withDirectives(vnode</span><span class="s2">, </span><span class="s1">directives) {</span>
    <span class="s2">const </span><span class="s1">internalInstance = currentRenderingInstance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(internalInstance === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">warn(</span><span class="s3">`withDirectives can only be used inside render functions.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">instance = getExposeProxy(internalInstance) ||</span>
        <span class="s1">internalInstance.proxy</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">bindings = vnode.dirs || (vnode.dirs = [])</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; directives.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">let </span><span class="s1">[dir</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">modifiers = EMPTY_OBJ] = directives[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(dir) {</span>
            <span class="s2">if </span><span class="s1">(isFunction(dir)) {</span>
                <span class="s1">dir = {</span>
                    <span class="s1">mounted: dir</span><span class="s2">,</span>
                    <span class="s1">updated: dir</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(dir.deep) {</span>
                <span class="s1">traverse(value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">bindings.push({</span>
                <span class="s1">dir</span><span class="s2">,</span>
                <span class="s1">instance</span><span class="s2">,</span>
                <span class="s1">value</span><span class="s2">,</span>
                <span class="s1">oldValue: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s1">arg</span><span class="s2">,</span>
                <span class="s1">modifiers</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">const </span><span class="s1">bindings = vnode.dirs</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">oldBindings = prevVNode &amp;&amp; prevVNode.dirs</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; bindings.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">binding = bindings[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(oldBindings) {</span>
            <span class="s1">binding.oldValue = oldBindings[i].value</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">hook = binding.dir[name]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hook) {</span>
            <span class="s5">// disable tracking inside all lifecycle hooks</span>
            <span class="s5">// since they can potentially be called inside effects.</span>
            <span class="s1">pauseTracking()</span><span class="s2">;</span>
            <span class="s1">callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">8 </span><span class="s5">/* ErrorCodes.DIRECTIVE_HOOK */</span><span class="s2">, </span><span class="s1">[</span>
                <span class="s1">vnode.el</span><span class="s2">,</span>
                <span class="s1">binding</span><span class="s2">,</span>
                <span class="s1">vnode</span><span class="s2">,</span>
                <span class="s1">prevVNode</span>
            <span class="s1">])</span><span class="s2">;</span>
            <span class="s1">resetTracking()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">COMPONENTS = </span><span class="s3">'components'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">DIRECTIVES = </span><span class="s3">'directives'</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">resolveComponent(name</span><span class="s2">, </span><span class="s1">maybeSelfReference) {</span>
    <span class="s2">return </span><span class="s1">resolveAsset(COMPONENTS</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, true, </span><span class="s1">maybeSelfReference) || name</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">NULL_DYNAMIC_COMPONENT = Symbol()</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">resolveDynamicComponent(component) {</span>
    <span class="s2">if </span><span class="s1">(isString(component)) {</span>
        <span class="s2">return </span><span class="s1">resolveAsset(COMPONENTS</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, false</span><span class="s1">) || component</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// invalid types will fallthrough to createVNode and raise warning</span>
        <span class="s2">return </span><span class="s1">(component || NULL_DYNAMIC_COMPONENT)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">resolveDirective(name) {</span>
    <span class="s2">return </span><span class="s1">resolveAsset(DIRECTIVES</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// implementation</span>
<span class="s2">function </span><span class="s1">resolveAsset(type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">warnMissing = </span><span class="s2">true, </span><span class="s1">maybeSelfReference = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">instance = currentRenderingInstance || currentInstance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance) {</span>
        <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
        <span class="s5">// explicit self name has highest priority</span>
        <span class="s2">if </span><span class="s1">(type === COMPONENTS) {</span>
            <span class="s2">const </span><span class="s1">selfName = getComponentName(Component</span><span class="s2">, false </span><span class="s5">/* do not include inferred name to avoid breaking existing code */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(selfName &amp;&amp;</span>
                <span class="s1">(selfName === name ||</span>
                    <span class="s1">selfName === camelize(name) ||</span>
                    <span class="s1">selfName === capitalize(camelize(name)))) {</span>
                <span class="s2">return </span><span class="s1">Component</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">res = </span>
        <span class="s5">// local registration</span>
        <span class="s5">// check instance[type] first which is resolved for options API</span>
        <span class="s1">resolve(instance[type] || Component[type]</span><span class="s2">, </span><span class="s1">name) ||</span>
            <span class="s5">// global registration</span>
            <span class="s1">resolve(instance.appContext[type]</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!res &amp;&amp; maybeSelfReference) {</span>
            <span class="s5">// fallback to implicit self-reference</span>
            <span class="s2">return </span><span class="s1">Component</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(warnMissing &amp;&amp; !res) {</span>
            <span class="s2">const </span><span class="s1">extra = type === COMPONENTS</span>
                <span class="s1">? </span><span class="s3">`</span><span class="s2">\n</span><span class="s3">If this is a native custom element, make sure to exclude it from ` </span><span class="s1">+</span>
                    <span class="s3">`component resolution via compilerOptions.isCustomElement.`</span>
                <span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
            <span class="s1">warn(</span><span class="s3">`Failed to resolve </span><span class="s1">${type.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)}</span><span class="s3">: </span><span class="s1">${name}${extra}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warn(</span><span class="s3">`resolve</span><span class="s1">${capitalize(type.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))} </span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`can only be used in render() or setup().`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolve(registry</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">return </span><span class="s1">(registry &amp;&amp;</span>
        <span class="s1">(registry[name] ||</span>
            <span class="s1">registry[camelize(name)] ||</span>
            <span class="s1">registry[capitalize(camelize(name))]))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Actual implementation</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">renderList(source</span><span class="s2">, </span><span class="s1">renderItem</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s2">let </span><span class="s1">ret</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cached = (cache &amp;&amp; cache[index])</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(source) || isString(source)) {</span>
        <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(source.length)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = source.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">ret[i] = renderItem(source[i]</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">source === </span><span class="s3">'number'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!Number.isInteger(source)) {</span>
            <span class="s1">warn(</span><span class="s3">`The v-for range expect an integer value but got </span><span class="s1">${source}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(source)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; source</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">ret[i] = renderItem(i + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(source)) {</span>
        <span class="s2">if </span><span class="s1">(source[Symbol.iterator]) {</span>
            <span class="s1">ret = Array.from(source</span><span class="s2">, </span><span class="s1">(item</span><span class="s2">, </span><span class="s1">i) =&gt; renderItem(item</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i]))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">keys = Object.keys(source)</span><span class="s2">;</span>
            <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(keys.length)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = keys.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">key = keys[i]</span><span class="s2">;</span>
                <span class="s1">ret[i] = renderItem(source[key]</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ret = []</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache[index] = ret</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Compiler runtime helper for creating dynamic slots object</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createSlots(slots</span><span class="s2">, </span><span class="s1">dynamicSlots) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; dynamicSlots.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">slot = dynamicSlots[i]</span><span class="s2">;</span>
        <span class="s5">// array of dynamic slot generated by &lt;template v-for=&quot;...&quot; #[...]&gt;</span>
        <span class="s2">if </span><span class="s1">(isArray(slot)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">j &lt; slot.length</span><span class="s2">; </span><span class="s1">j++) {</span>
                <span class="s1">slots[slot[j].name] = slot[j].fn</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(slot) {</span>
            <span class="s5">// conditional single slot generated by &lt;template v-if=&quot;...&quot; #foo&gt;</span>
            <span class="s1">slots[slot.name] = slot.key</span>
                <span class="s1">? (...args) =&gt; {</span>
                    <span class="s2">const </span><span class="s1">res = slot.fn(...args)</span><span class="s2">;</span>
                    <span class="s5">// attach branch key so each conditional branch is considered a</span>
                    <span class="s5">// different fragment</span>
                    <span class="s2">if </span><span class="s1">(res)</span>
                        <span class="s1">res.key = slot.key</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">: slot.fn</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">slots</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Compiler runtime helper for rendering `&lt;slot/&gt;`</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">renderSlot(slots</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">props = {}</span><span class="s2">, </span>
<span class="s5">// this is not a user-facing function, so the fallback is always generated by</span>
<span class="s5">// the compiler and guaranteed to be a function returning an array</span>
<span class="s1">fallback</span><span class="s2">, </span><span class="s1">noSlotted) {</span>
    <span class="s2">if </span><span class="s1">(currentRenderingInstance.isCE ||</span>
        <span class="s1">(currentRenderingInstance.parent &amp;&amp;</span>
            <span class="s1">isAsyncWrapper(currentRenderingInstance.parent) &amp;&amp;</span>
            <span class="s1">currentRenderingInstance.parent.isCE)) {</span>
        <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">'default'</span><span class="s1">)</span>
            <span class="s1">props.name = name</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">createVNode(</span><span class="s3">'slot'</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">fallback &amp;&amp; fallback())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">slot = slots[name]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">warn(</span><span class="s3">`SSR-optimized slot function detected in a non-SSR-optimized render ` </span><span class="s1">+</span>
            <span class="s3">`function. You need to mark this component with $dynamic-slots in the ` </span><span class="s1">+</span>
            <span class="s3">`parent template.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">slot = () =&gt; []</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// a compiled slot disables block tracking by default to avoid manual</span>
    <span class="s5">// invocation interfering with template-based block tracking, but in</span>
    <span class="s5">// `renderSlot` we can be sure that it's template-based so we can force</span>
    <span class="s5">// enable it.</span>
    <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot._c) {</span>
        <span class="s1">slot._d = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s1">openBlock()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rendered = createBlock(Fragment</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">key: props.key ||</span>
            <span class="s5">// slot content array of a dynamic conditional slot may have a branch</span>
            <span class="s5">// key attached in the `createSlots` helper, respect that</span>
            <span class="s1">(validSlotContent &amp;&amp; validSlotContent.key) ||</span>
            <span class="s3">`_</span><span class="s1">${name}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">validSlotContent || (fallback ? fallback() : [])</span><span class="s2">, </span><span class="s1">validSlotContent &amp;&amp; slots._ === </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span>
        <span class="s1">? </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span>
        <span class="s1">: -</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!noSlotted &amp;&amp; rendered.scopeId) {</span>
        <span class="s1">rendered.slotScopeIds = [rendered.scopeId + </span><span class="s3">'-s'</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot._c) {</span>
        <span class="s1">slot._d = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">rendered</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ensureValidVNode(vnodes) {</span>
    <span class="s2">return </span><span class="s1">vnodes.some(child =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!isVNode(child))</span>
            <span class="s2">return true;</span>
        <span class="s2">if </span><span class="s1">(child.type === Comment)</span>
            <span class="s2">return false;</span>
        <span class="s2">if </span><span class="s1">(child.type === Fragment &amp;&amp;</span>
            <span class="s1">!ensureValidVNode(child.children))</span>
            <span class="s2">return false;</span>
        <span class="s2">return true;</span>
    <span class="s1">})</span>
        <span class="s1">? vnodes</span>
        <span class="s1">: </span><span class="s2">null;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* For prefixing keys in v-on=&quot;obj&quot; with &quot;on&quot;</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">toHandlers(obj</span><span class="s2">, </span><span class="s1">preserveCaseIfNecessary) {</span>
    <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isObject(obj)) {</span>
        <span class="s1">warn(</span><span class="s3">`v-on with no argument expects an object value.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
        <span class="s1">ret[preserveCaseIfNecessary &amp;&amp; </span><span class="s4">/[A-Z]/</span><span class="s1">.test(key)</span>
            <span class="s1">? </span><span class="s3">`on:</span><span class="s1">${key}</span><span class="s3">`</span>
            <span class="s1">: toHandlerKey(key)] = obj[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* #2437 In Vue 3, functional components do not have a public instance proxy but</span>
 <span class="s0">* they exist in the internal parent chain. For code that relies on traversing</span>
 <span class="s0">* public $parent chains, skip functional ones and go to the parent instead.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">getPublicInstance = (i) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!i)</span>
        <span class="s2">return null;</span>
    <span class="s2">if </span><span class="s1">(isStatefulComponent(i))</span>
        <span class="s2">return </span><span class="s1">getExposeProxy(i) || i.proxy</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">getPublicInstance(i.parent)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">publicPropertiesMap = </span>
<span class="s5">// Move PURE marker to new line to workaround compiler discarding it</span>
<span class="s5">// due to type annotation</span>
<span class="s5">/*#__PURE__*/ </span><span class="s1">extend(Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">$: i =&gt; i</span><span class="s2">,</span>
    <span class="s1">$el: i =&gt; i.vnode.el</span><span class="s2">,</span>
    <span class="s1">$data: i =&gt; i.data</span><span class="s2">,</span>
    <span class="s1">$props: i =&gt; (shallowReadonly(i.props) )</span><span class="s2">,</span>
    <span class="s1">$attrs: i =&gt; (shallowReadonly(i.attrs) )</span><span class="s2">,</span>
    <span class="s1">$slots: i =&gt; (shallowReadonly(i.slots) )</span><span class="s2">,</span>
    <span class="s1">$refs: i =&gt; (shallowReadonly(i.refs) )</span><span class="s2">,</span>
    <span class="s1">$parent: i =&gt; getPublicInstance(i.parent)</span><span class="s2">,</span>
    <span class="s1">$root: i =&gt; getPublicInstance(i.root)</span><span class="s2">,</span>
    <span class="s1">$emit: i =&gt; i.emit</span><span class="s2">,</span>
    <span class="s1">$options: i =&gt; (resolveMergedOptions(i) )</span><span class="s2">,</span>
    <span class="s1">$forceUpdate: i =&gt; i.f || (i.f = () =&gt; queueJob(i.update))</span><span class="s2">,</span>
    <span class="s1">$nextTick: i =&gt; i.n || (i.n = nextTick.bind(i.proxy))</span><span class="s2">,</span>
    <span class="s1">$watch: i =&gt; (instanceWatch.bind(i) )</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isReservedPrefix = (key) =&gt; key === </span><span class="s3">'_' </span><span class="s1">|| key === </span><span class="s3">'$'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hasSetupBinding = (state</span><span class="s2">, </span><span class="s1">key) =&gt; state !== EMPTY_OBJ &amp;&amp; !state.__isScriptSetup &amp;&amp; hasOwn(state</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">PublicInstanceProxyHandlers = {</span>
    <span class="s1">get({ _: instance }</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">accessCache</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">appContext } = instance</span><span class="s2">;</span>
        <span class="s5">// for internal formatters to know that this is a Vue instance</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'__isVue'</span><span class="s1">) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s5">// data / props / ctx</span>
        <span class="s5">// This getter gets called for every property access on the render context</span>
        <span class="s5">// during render and is a major hotspot. The most expensive part of this</span>
        <span class="s5">// is the multiple hasOwn() calls. It's much faster to do a simple property</span>
        <span class="s5">// access on a plain object, so we use an accessCache object (with null</span>
        <span class="s5">// prototype) to memoize what access type a key corresponds to.</span>
        <span class="s2">let </span><span class="s1">normalizedProps</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'$'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">n = accessCache[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(n !== undefined) {</span>
                <span class="s2">switch </span><span class="s1">(n) {</span>
                    <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* AccessTypes.SETUP */</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">setupState[key]</span><span class="s2">;</span>
                    <span class="s2">case </span><span class="s4">2 </span><span class="s5">/* AccessTypes.DATA */</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">data[key]</span><span class="s2">;</span>
                    <span class="s2">case </span><span class="s4">4 </span><span class="s5">/* AccessTypes.CONTEXT */</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
                    <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* AccessTypes.PROPS */</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">props[key]</span><span class="s2">;</span>
                    <span class="s5">// default: just fallthrough</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">accessCache[key] = </span><span class="s4">1 </span><span class="s5">/* AccessTypes.SETUP */</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">setupState[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">accessCache[key] = </span><span class="s4">2 </span><span class="s5">/* AccessTypes.DATA */</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">data[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span>
            <span class="s5">// only cache other properties when instance has declared (thus stable)</span>
            <span class="s5">// props</span>
            <span class="s1">(normalizedProps = instance.propsOptions[</span><span class="s4">0</span><span class="s1">]) &amp;&amp;</span>
                <span class="s1">hasOwn(normalizedProps</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">accessCache[key] = </span><span class="s4">3 </span><span class="s5">/* AccessTypes.PROPS */</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">props[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">accessCache[key] = </span><span class="s4">4 </span><span class="s5">/* AccessTypes.CONTEXT */</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(shouldCacheAccess) {</span>
                <span class="s1">accessCache[key] = </span><span class="s4">0 </span><span class="s5">/* AccessTypes.OTHER */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">publicGetter = publicPropertiesMap[key]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">cssModule</span><span class="s2">, </span><span class="s1">globalProperties</span><span class="s2">;</span>
        <span class="s5">// public $xxx properties</span>
        <span class="s2">if </span><span class="s1">(publicGetter) {</span>
            <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'$attrs'</span><span class="s1">) {</span>
                <span class="s1">track(instance</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
                <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">publicGetter(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span>
        <span class="s5">// css module (injected by vue-loader)</span>
        <span class="s1">(cssModule = type.__cssModules) &amp;&amp;</span>
            <span class="s1">(cssModule = cssModule[key])) {</span>
            <span class="s2">return </span><span class="s1">cssModule</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s5">// user may set custom properties to `this` that start with `$`</span>
            <span class="s1">accessCache[key] = </span><span class="s4">4 </span><span class="s5">/* AccessTypes.CONTEXT */</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span>
        <span class="s5">// global properties</span>
        <span class="s1">((globalProperties = appContext.config.globalProperties)</span><span class="s2">,</span>
            <span class="s1">hasOwn(globalProperties</span><span class="s2">, </span><span class="s1">key))) {</span>
            <span class="s1">{</span>
                <span class="s2">return </span><span class="s1">globalProperties[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(currentRenderingInstance &amp;&amp;</span>
            <span class="s1">(!isString(key) ||</span>
                <span class="s5">// #1091 avoid internal isRef/isVNode checks on component instance leading</span>
                <span class="s5">// to infinite warning loop</span>
                <span class="s1">key.indexOf(</span><span class="s3">'__v'</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s2">if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">warn(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">must be accessed via $data because it starts with a reserved ` </span><span class="s1">+</span>
                    <span class="s3">`character (&quot;$&quot; or &quot;_&quot;) and is not proxied on the render context.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(instance === currentRenderingInstance) {</span>
                <span class="s1">warn(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">was accessed during render ` </span><span class="s1">+</span>
                    <span class="s3">`but is not defined on instance.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">set({ _: instance }</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) {</span>
        <span class="s2">const </span><span class="s1">{ data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">ctx } = instance</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s1">setupState[key] = value</span><span class="s2">;</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(setupState.__isScriptSetup &amp;&amp;</span>
            <span class="s1">hasOwn(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s1">warn(</span><span class="s3">`Cannot mutate &lt;script setup&gt; binding &quot;</span><span class="s1">${key}</span><span class="s3">&quot; from Options API.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s1">data[key] = value</span><span class="s2">;</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(hasOwn(instance.props</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s1">warn(</span><span class="s3">`Attempting to mutate prop &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. Props are readonly.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'$' </span><span class="s1">&amp;&amp; key.slice(</span><span class="s4">1</span><span class="s1">) </span><span class="s2">in </span><span class="s1">instance) {</span>
            <span class="s1">warn(</span><span class="s3">`Attempting to mutate public property &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. ` </span><span class="s1">+</span>
                    <span class="s3">`Properties starting with $ are reserved and readonly.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">instance.appContext.config.globalProperties) {</span>
                <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">enumerable: </span><span class="s2">true,</span>
                    <span class="s1">configurable: </span><span class="s2">true,</span>
                    <span class="s1">value</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">ctx[key] = value</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has({ _: { data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">accessCache</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">propsOptions } }</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">let </span><span class="s1">normalizedProps</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">(!!accessCache[key] ||</span>
            <span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) ||</span>
            <span class="s1">hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key) ||</span>
            <span class="s1">((normalizedProps = propsOptions[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; hasOwn(normalizedProps</span><span class="s2">, </span><span class="s1">key)) ||</span>
            <span class="s1">hasOwn(ctx</span><span class="s2">, </span><span class="s1">key) ||</span>
            <span class="s1">hasOwn(publicPropertiesMap</span><span class="s2">, </span><span class="s1">key) ||</span>
            <span class="s1">hasOwn(appContext.config.globalProperties</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor) {</span>
        <span class="s2">if </span><span class="s1">(descriptor.get != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s5">// invalidate key cache of a getter based property #5417</span>
            <span class="s1">target._.accessCache[key] = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(hasOwn(descriptor</span><span class="s2">, </span><span class="s3">'value'</span><span class="s1">)) {</span>
            <span class="s2">this</span><span class="s1">.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor.value</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Reflect.defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">{</span>
    <span class="s1">PublicInstanceProxyHandlers.ownKeys = (target) =&gt; {</span>
        <span class="s1">warn(</span><span class="s3">`Avoid app logic that relies on enumerating keys on a component instance. ` </span><span class="s1">+</span>
            <span class="s3">`The keys will be empty in production mode to avoid performance overhead.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">Reflect.ownKeys(target)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">RuntimeCompiledPublicInstanceProxyHandlers = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">PublicInstanceProxyHandlers</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s5">// fast path for unscopables when using `with` block</span>
        <span class="s2">if </span><span class="s1">(key === Symbol.unscopables) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">PublicInstanceProxyHandlers.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has(_</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">const </span><span class="s1">has = key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'_' </span><span class="s1">&amp;&amp; !isGloballyWhitelisted(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!has &amp;&amp; PublicInstanceProxyHandlers.has(_</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s1">warn(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">should not start with _ which is a reserved prefix for Vue internals.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">has</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s5">// dev only</span>
<span class="s5">// In dev mode, the proxy target exposes the same properties as seen on `this`</span>
<span class="s5">// for easier console inspection. In prod mode it will be an empty object so</span>
<span class="s5">// these properties definitions can be skipped.</span>
<span class="s2">function </span><span class="s1">createDevRenderContext(instance) {</span>
    <span class="s2">const </span><span class="s1">target = {}</span><span class="s2">;</span>
    <span class="s5">// expose internal instance for proxy handlers</span>
    <span class="s1">Object.defineProperty(target</span><span class="s2">, </span><span class="s3">`_`</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">configurable: </span><span class="s2">true,</span>
        <span class="s1">enumerable: </span><span class="s2">false,</span>
        <span class="s1">get: () =&gt; instance</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s5">// expose public properties</span>
    <span class="s1">Object.keys(publicPropertiesMap).forEach(key =&gt; {</span>
        <span class="s1">Object.defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">configurable: </span><span class="s2">true,</span>
            <span class="s1">enumerable: </span><span class="s2">false,</span>
            <span class="s1">get: () =&gt; publicPropertiesMap[key](instance)</span><span class="s2">,</span>
            <span class="s5">// intercepted by the proxy so no need for implementation,</span>
            <span class="s5">// but needed to prevent set errors</span>
            <span class="s1">set: NOOP</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// dev only</span>
<span class="s2">function </span><span class="s1">exposePropsOnRenderContext(instance) {</span>
    <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions] } = instance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(propsOptions) {</span>
        <span class="s1">Object.keys(propsOptions).forEach(key =&gt; {</span>
            <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">enumerable: </span><span class="s2">true,</span>
                <span class="s1">configurable: </span><span class="s2">true,</span>
                <span class="s1">get: () =&gt; instance.props[key]</span><span class="s2">,</span>
                <span class="s1">set: NOOP</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// dev only</span>
<span class="s2">function </span><span class="s1">exposeSetupStateOnRenderContext(instance) {</span>
    <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">setupState } = instance</span><span class="s2">;</span>
    <span class="s1">Object.keys(toRaw(setupState)).forEach(key =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!setupState.__isScriptSetup) {</span>
            <span class="s2">if </span><span class="s1">(isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s1">warn(</span><span class="s3">`setup() return property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">should not start with &quot;$&quot; or &quot;_&quot; ` </span><span class="s1">+</span>
                    <span class="s3">`which are reserved prefixes for Vue internals.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">enumerable: </span><span class="s2">true,</span>
                <span class="s1">configurable: </span><span class="s2">true,</span>
                <span class="s1">get: () =&gt; setupState[key]</span><span class="s2">,</span>
                <span class="s1">set: NOOP</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">createDuplicateChecker() {</span>
    <span class="s2">const </span><span class="s1">cache = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(type</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(cache[key]) {</span>
            <span class="s1">warn(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is already defined in </span><span class="s1">${cache[key]}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">cache[key] = type</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">shouldCacheAccess = </span><span class="s2">true;</span>
<span class="s2">function </span><span class="s1">applyOptions(instance) {</span>
    <span class="s2">const </span><span class="s1">options = resolveMergedOptions(instance)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">publicThis = instance.proxy</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">ctx = instance.ctx</span><span class="s2">;</span>
    <span class="s5">// do not cache property access on public proxy during state initialization</span>
    <span class="s1">shouldCacheAccess = </span><span class="s2">false;</span>
    <span class="s5">// call beforeCreate first before accessing other options since</span>
    <span class="s5">// the hook may mutate resolved options (#2791)</span>
    <span class="s2">if </span><span class="s1">(options.beforeCreate) {</span>
        <span class="s1">callHook$1(options.beforeCreate</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s3">&quot;bc&quot; </span><span class="s5">/* LifecycleHooks.BEFORE_CREATE */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ </span>
    <span class="s5">// state</span>
    <span class="s1">data: dataOptions</span><span class="s2">, </span><span class="s1">computed: computedOptions</span><span class="s2">, </span><span class="s1">methods</span><span class="s2">, </span><span class="s1">watch: watchOptions</span><span class="s2">, </span><span class="s1">provide: provideOptions</span><span class="s2">, </span><span class="s1">inject: injectOptions</span><span class="s2">, </span>
    <span class="s5">// lifecycle</span>
    <span class="s1">created</span><span class="s2">, </span><span class="s1">beforeMount</span><span class="s2">, </span><span class="s1">mounted</span><span class="s2">, </span><span class="s1">beforeUpdate</span><span class="s2">, </span><span class="s1">updated</span><span class="s2">, </span><span class="s1">activated</span><span class="s2">, </span><span class="s1">deactivated</span><span class="s2">, </span><span class="s1">beforeDestroy</span><span class="s2">, </span><span class="s1">beforeUnmount</span><span class="s2">, </span><span class="s1">destroyed</span><span class="s2">, </span><span class="s1">unmounted</span><span class="s2">, </span><span class="s1">render</span><span class="s2">, </span><span class="s1">renderTracked</span><span class="s2">, </span><span class="s1">renderTriggered</span><span class="s2">, </span><span class="s1">errorCaptured</span><span class="s2">, </span><span class="s1">serverPrefetch</span><span class="s2">, </span>
    <span class="s5">// public API</span>
    <span class="s1">expose</span><span class="s2">, </span><span class="s1">inheritAttrs</span><span class="s2">, </span>
    <span class="s5">// assets</span>
    <span class="s1">components</span><span class="s2">, </span><span class="s1">directives</span><span class="s2">, </span><span class="s1">filters } = options</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">checkDuplicateProperties = createDuplicateChecker() </span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">[propsOptions] = instance.propsOptions</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(propsOptions) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">propsOptions) {</span>
                <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Props&quot; </span><span class="s5">/* OptionTypes.PROPS */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// options initialization order (to be consistent with Vue 2):</span>
    <span class="s5">// - props (already done outside of this function)</span>
    <span class="s5">// - inject</span>
    <span class="s5">// - methods</span>
    <span class="s5">// - data (deferred since it relies on `this` access)</span>
    <span class="s5">// - computed</span>
    <span class="s5">// - watch (deferred since it relies on `this` access)</span>
    <span class="s2">if </span><span class="s1">(injectOptions) {</span>
        <span class="s1">resolveInjections(injectOptions</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">checkDuplicateProperties</span><span class="s2">, </span><span class="s1">instance.appContext.config.unwrapInjectedRef)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(methods) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">methods) {</span>
            <span class="s2">const </span><span class="s1">methodHandler = methods[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isFunction(methodHandler)) {</span>
                <span class="s5">// In dev mode, we use the `createRenderContext` function to define</span>
                <span class="s5">// methods to the proxy target, and those are read-only but</span>
                <span class="s5">// reconfigurable, so it needs to be redefined here</span>
                <span class="s1">{</span>
                    <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">value: methodHandler.bind(publicThis)</span><span class="s2">,</span>
                        <span class="s1">configurable: </span><span class="s2">true,</span>
                        <span class="s1">enumerable: </span><span class="s2">true,</span>
                        <span class="s1">writable: </span><span class="s2">true</span>
                    <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">{</span>
                    <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Methods&quot; </span><span class="s5">/* OptionTypes.METHODS */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">warn(</span><span class="s3">`Method &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has type &quot;</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">methodHandler}</span><span class="s3">&quot; in the component definition. ` </span><span class="s1">+</span>
                    <span class="s3">`Did you reference the function correctly?`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dataOptions) {</span>
        <span class="s2">if </span><span class="s1">(!isFunction(dataOptions)) {</span>
            <span class="s1">warn(</span><span class="s3">`The data option must be a function. ` </span><span class="s1">+</span>
                <span class="s3">`Plain object usage is no longer supported.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">data = dataOptions.call(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPromise(data)) {</span>
            <span class="s1">warn(</span><span class="s3">`data() returned a Promise - note data() cannot be async; If you ` </span><span class="s1">+</span>
                <span class="s3">`intend to perform data fetching before component renders, use ` </span><span class="s1">+</span>
                <span class="s3">`async setup() + &lt;Suspense&gt;.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isObject(data)) {</span>
            <span class="s1">warn(</span><span class="s3">`data() should return an object.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">instance.data = reactive(data)</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">data) {</span>
                    <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Data&quot; </span><span class="s5">/* OptionTypes.DATA */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
                    <span class="s5">// expose data on ctx during dev</span>
                    <span class="s2">if </span><span class="s1">(!isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">])) {</span>
                        <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                            <span class="s1">configurable: </span><span class="s2">true,</span>
                            <span class="s1">enumerable: </span><span class="s2">true,</span>
                            <span class="s1">get: () =&gt; data[key]</span><span class="s2">,</span>
                            <span class="s1">set: NOOP</span>
                        <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// state initialization complete at this point - start caching access</span>
    <span class="s1">shouldCacheAccess = </span><span class="s2">true;</span>
    <span class="s2">if </span><span class="s1">(computedOptions) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">computedOptions) {</span>
            <span class="s2">const </span><span class="s1">opt = computedOptions[key]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">get = isFunction(opt)</span>
                <span class="s1">? opt.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span>
                <span class="s1">: isFunction(opt.get)</span>
                    <span class="s1">? opt.get.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span>
                    <span class="s1">: NOOP</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(get === NOOP) {</span>
                <span class="s1">warn(</span><span class="s3">`Computed property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has no getter.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">set = !isFunction(opt) &amp;&amp; isFunction(opt.set)</span>
                <span class="s1">? opt.set.bind(publicThis)</span>
                <span class="s1">: () =&gt; {</span>
                        <span class="s1">warn(</span><span class="s3">`Write operation failed: computed property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">;</span>
            <span class="s2">const </span><span class="s1">c = computed({</span>
                <span class="s1">get</span><span class="s2">,</span>
                <span class="s1">set</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">enumerable: </span><span class="s2">true,</span>
                <span class="s1">configurable: </span><span class="s2">true,</span>
                <span class="s1">get: () =&gt; c.value</span><span class="s2">,</span>
                <span class="s1">set: v =&gt; (c.value = v)</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Computed&quot; </span><span class="s5">/* OptionTypes.COMPUTED */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(watchOptions) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">watchOptions) {</span>
            <span class="s1">createWatcher(watchOptions[key]</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(provideOptions) {</span>
        <span class="s2">const </span><span class="s1">provides = isFunction(provideOptions)</span>
            <span class="s1">? provideOptions.call(publicThis)</span>
            <span class="s1">: provideOptions</span><span class="s2">;</span>
        <span class="s1">Reflect.ownKeys(provides).forEach(key =&gt; {</span>
            <span class="s1">provide(key</span><span class="s2">, </span><span class="s1">provides[key])</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(created) {</span>
        <span class="s1">callHook$1(created</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s3">&quot;c&quot; </span><span class="s5">/* LifecycleHooks.CREATED */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">registerLifecycleHook(register</span><span class="s2">, </span><span class="s1">hook) {</span>
        <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
            <span class="s1">hook.forEach(_hook =&gt; register(_hook.bind(publicThis)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(hook) {</span>
            <span class="s1">register(hook.bind(publicThis))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">registerLifecycleHook(onBeforeMount</span><span class="s2">, </span><span class="s1">beforeMount)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onMounted</span><span class="s2">, </span><span class="s1">mounted)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onBeforeUpdate</span><span class="s2">, </span><span class="s1">beforeUpdate)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onUpdated</span><span class="s2">, </span><span class="s1">updated)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onActivated</span><span class="s2">, </span><span class="s1">activated)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onDeactivated</span><span class="s2">, </span><span class="s1">deactivated)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onErrorCaptured</span><span class="s2">, </span><span class="s1">errorCaptured)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onRenderTracked</span><span class="s2">, </span><span class="s1">renderTracked)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onRenderTriggered</span><span class="s2">, </span><span class="s1">renderTriggered)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onBeforeUnmount</span><span class="s2">, </span><span class="s1">beforeUnmount)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onUnmounted</span><span class="s2">, </span><span class="s1">unmounted)</span><span class="s2">;</span>
    <span class="s1">registerLifecycleHook(onServerPrefetch</span><span class="s2">, </span><span class="s1">serverPrefetch)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(expose)) {</span>
        <span class="s2">if </span><span class="s1">(expose.length) {</span>
            <span class="s2">const </span><span class="s1">exposed = instance.exposed || (instance.exposed = {})</span><span class="s2">;</span>
            <span class="s1">expose.forEach(key =&gt; {</span>
                <span class="s1">Object.defineProperty(exposed</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">get: () =&gt; publicThis[key]</span><span class="s2">,</span>
                    <span class="s1">set: val =&gt; (publicThis[key] = val)</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!instance.exposed) {</span>
            <span class="s1">instance.exposed = {}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// options that are handled when creating the instance but also need to be</span>
    <span class="s5">// applied from mixins</span>
    <span class="s2">if </span><span class="s1">(render &amp;&amp; instance.render === NOOP) {</span>
        <span class="s1">instance.render = render</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(inheritAttrs != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">instance.inheritAttrs = inheritAttrs</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// asset options.</span>
    <span class="s2">if </span><span class="s1">(components)</span>
        <span class="s1">instance.components = components</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(directives)</span>
        <span class="s1">instance.directives = directives</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveInjections(injectOptions</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">checkDuplicateProperties = NOOP</span><span class="s2">, </span><span class="s1">unwrapRef = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(isArray(injectOptions)) {</span>
        <span class="s1">injectOptions = normalizeInject(injectOptions)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">injectOptions) {</span>
        <span class="s2">const </span><span class="s1">opt = injectOptions[key]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">injected</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isObject(opt)) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s3">'default' </span><span class="s2">in </span><span class="s1">opt) {</span>
                <span class="s1">injected = inject(opt.from || key</span><span class="s2">, </span><span class="s1">opt.default</span><span class="s2">, true </span><span class="s5">/* treat default function as factory */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">injected = inject(opt.from || key)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">injected = inject(opt)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isRef(injected)) {</span>
            <span class="s5">// TODO remove the check in 3.3</span>
            <span class="s2">if </span><span class="s1">(unwrapRef) {</span>
                <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                    <span class="s1">enumerable: </span><span class="s2">true,</span>
                    <span class="s1">configurable: </span><span class="s2">true,</span>
                    <span class="s1">get: () =&gt; injected.value</span><span class="s2">,</span>
                    <span class="s1">set: v =&gt; (injected.value = v)</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`injected property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is a ref and will be auto-unwrapped ` </span><span class="s1">+</span>
                        <span class="s3">`and no longer needs </span><span class="s2">\`</span><span class="s3">.value</span><span class="s2">\` </span><span class="s3">in the next minor release. ` </span><span class="s1">+</span>
                        <span class="s3">`To opt-in to the new behavior now, ` </span><span class="s1">+</span>
                        <span class="s3">`set </span><span class="s2">\`</span><span class="s3">app.config.unwrapInjectedRef = true</span><span class="s2">\` </span><span class="s3">(this config is ` </span><span class="s1">+</span>
                        <span class="s3">`temporary and will not be needed in the future.)`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">ctx[key] = injected</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">ctx[key] = injected</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Inject&quot; </span><span class="s5">/* OptionTypes.INJECT */</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callHook$1(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s1">callWithAsyncErrorHandling(isArray(hook)</span>
        <span class="s1">? hook.map(h =&gt; h.bind(instance.proxy))</span>
        <span class="s1">: hook.bind(instance.proxy)</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createWatcher(raw</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">getter = key.includes(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">? createPathGetter(publicThis</span><span class="s2">, </span><span class="s1">key)</span>
        <span class="s1">: () =&gt; publicThis[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isString(raw)) {</span>
        <span class="s2">const </span><span class="s1">handler = ctx[raw]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isFunction(handler)) {</span>
            <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`Invalid watch handler specified by key &quot;</span><span class="s1">${raw}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isFunction(raw)) {</span>
        <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">raw.bind(publicThis))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(raw)) {</span>
        <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
            <span class="s1">raw.forEach(r =&gt; createWatcher(r</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">handler = isFunction(raw.handler)</span>
                <span class="s1">? raw.handler.bind(publicThis)</span>
                <span class="s1">: ctx[raw.handler]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isFunction(handler)) {</span>
                <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">warn(</span><span class="s3">`Invalid watch handler specified by key &quot;</span><span class="s1">${raw.handler}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warn(</span><span class="s3">`Invalid watch option: &quot;</span><span class="s1">${key}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Resolve merged options and cache it on the component.</span>
 <span class="s0">* This is done only once per-component since the merging does not involve</span>
 <span class="s0">* instances.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">resolveMergedOptions(instance) {</span>
    <span class="s2">const </span><span class="s1">base = instance.type</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ mixins</span><span class="s2">, extends</span><span class="s1">: extendsOptions } = base</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ mixins: globalMixins</span><span class="s2">, </span><span class="s1">optionsCache: cache</span><span class="s2">, </span><span class="s1">config: { optionMergeStrategies } } = instance.appContext</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cached = cache.get(base)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">resolved</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached) {</span>
        <span class="s1">resolved = cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!globalMixins.length &amp;&amp; !mixins &amp;&amp; !extendsOptions) {</span>
        <span class="s1">{</span>
            <span class="s1">resolved = base</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">resolved = {}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(globalMixins.length) {</span>
            <span class="s1">globalMixins.forEach(m =&gt; mergeOptions(resolved</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">optionMergeStrategies</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">mergeOptions(resolved</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">optionMergeStrategies)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isObject(base)) {</span>
        <span class="s1">cache.set(base</span><span class="s2">, </span><span class="s1">resolved)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolved</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeOptions(to</span><span class="s2">, </span><span class="s1">from</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ mixins</span><span class="s2">, extends</span><span class="s1">: extendsOptions } = from</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(extendsOptions) {</span>
        <span class="s1">mergeOptions(to</span><span class="s2">, </span><span class="s1">extendsOptions</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(mixins) {</span>
        <span class="s1">mixins.forEach((m) =&gt; mergeOptions(to</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">from) {</span>
        <span class="s2">if </span><span class="s1">(asMixin &amp;&amp; key === </span><span class="s3">'expose'</span><span class="s1">) {</span>
            <span class="s1">warn(</span><span class="s3">`&quot;expose&quot; option is ignored when declared in mixins or extends. ` </span><span class="s1">+</span>
                    <span class="s3">`It should only be declared in the base component itself.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">strat = internalOptionMergeStrats[key] || (strats &amp;&amp; strats[key])</span><span class="s2">;</span>
            <span class="s1">to[key] = strat ? strat(to[key]</span><span class="s2">, </span><span class="s1">from[key]) : from[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">internalOptionMergeStrats = {</span>
    <span class="s1">data: mergeDataFn</span><span class="s2">,</span>
    <span class="s1">props: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s1">emits: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s5">// objects</span>
    <span class="s1">methods: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s1">computed: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s5">// lifecycle</span>
    <span class="s1">beforeCreate: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">created: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">beforeMount: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">mounted: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">beforeUpdate: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">updated: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">beforeDestroy: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">beforeUnmount: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">destroyed: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">unmounted: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">activated: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">deactivated: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">errorCaptured: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s1">serverPrefetch: mergeAsArray$1</span><span class="s2">,</span>
    <span class="s5">// assets</span>
    <span class="s1">components: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s1">directives: mergeObjectOptions</span><span class="s2">,</span>
    <span class="s5">// watch</span>
    <span class="s1">watch: mergeWatchOptions</span><span class="s2">,</span>
    <span class="s5">// provide / inject</span>
    <span class="s1">provide: mergeDataFn</span><span class="s2">,</span>
    <span class="s1">inject: mergeInject</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">mergeDataFn(to</span><span class="s2">, </span><span class="s1">from) {</span>
    <span class="s2">if </span><span class="s1">(!from) {</span>
        <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!to) {</span>
        <span class="s2">return </span><span class="s1">from</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return function </span><span class="s1">mergedDataFn() {</span>
        <span class="s2">return </span><span class="s1">(extend)(isFunction(to) ? to.call(</span><span class="s2">this, this</span><span class="s1">) : to</span><span class="s2">, </span><span class="s1">isFunction(from) ? from.call(</span><span class="s2">this, this</span><span class="s1">) : from)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeInject(to</span><span class="s2">, </span><span class="s1">from) {</span>
    <span class="s2">return </span><span class="s1">mergeObjectOptions(normalizeInject(to)</span><span class="s2">, </span><span class="s1">normalizeInject(from))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeInject(raw) {</span>
    <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
        <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; raw.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">res[raw[i]] = raw[i]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">raw</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeAsArray$1(to</span><span class="s2">, </span><span class="s1">from) {</span>
    <span class="s2">return </span><span class="s1">to ? [...</span><span class="s2">new </span><span class="s1">Set([].concat(to</span><span class="s2">, </span><span class="s1">from))] : from</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeObjectOptions(to</span><span class="s2">, </span><span class="s1">from) {</span>
    <span class="s2">return </span><span class="s1">to ? extend(extend(Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to)</span><span class="s2">, </span><span class="s1">from) : from</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeWatchOptions(to</span><span class="s2">, </span><span class="s1">from) {</span>
    <span class="s2">if </span><span class="s1">(!to)</span>
        <span class="s2">return </span><span class="s1">from</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!from)</span>
        <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">merged = extend(Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">from) {</span>
        <span class="s1">merged[key] = mergeAsArray$1(to[key]</span><span class="s2">, </span><span class="s1">from[key])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">merged</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">initProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">isStateful</span><span class="s2">, </span><span class="s5">// result of bitwise flag comparison</span>
<span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">props = {}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">attrs = {}</span><span class="s2">;</span>
    <span class="s1">def(attrs</span><span class="s2">, </span><span class="s1">InternalObjectKey</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">instance.propsDefaults = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs)</span><span class="s2">;</span>
    <span class="s5">// ensure all declared prop keys are present</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">instance.propsOptions[</span><span class="s4">0</span><span class="s1">]) {</span>
        <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">props)) {</span>
            <span class="s1">props[key] = undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// validation</span>
    <span class="s1">{</span>
        <span class="s1">validateProps(rawProps || {}</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isStateful) {</span>
        <span class="s5">// stateful</span>
        <span class="s1">instance.props = isSSR ? props : shallowReactive(props)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!instance.type.props) {</span>
            <span class="s5">// functional w/ optional props, props === attrs</span>
            <span class="s1">instance.props = attrs</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// functional w/ declared props</span>
            <span class="s1">instance.props = props</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">instance.attrs = attrs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isInHmrContext(instance) {</span>
    <span class="s2">while </span><span class="s1">(instance) {</span>
        <span class="s2">if </span><span class="s1">(instance.type.__hmrId)</span>
            <span class="s2">return true;</span>
        <span class="s1">instance = instance.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">rawPrevProps</span><span class="s2">, </span><span class="s1">optimized) {</span>
    <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">vnode: { patchFlag } } = instance</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawCurrentProps = toRaw(props)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">[options] = instance.propsOptions</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hasAttrsChanged = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(</span>
    <span class="s5">// always force full diff in dev</span>
    <span class="s5">// - #1942 if hmr is enabled with sfc component</span>
    <span class="s5">// - vite#872 non-sfc component used by sfc component</span>
    <span class="s1">!(isInHmrContext(instance)) &amp;&amp;</span>
        <span class="s1">(optimized || patchFlag &gt; </span><span class="s4">0</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">!(patchFlag &amp; </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s1">) {</span>
            <span class="s5">// Compiler-generated props &amp; no keys change, just set the updated</span>
            <span class="s5">// the props.</span>
            <span class="s2">const </span><span class="s1">propsToUpdate = instance.vnode.dynamicProps</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; propsToUpdate.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">let </span><span class="s1">key = propsToUpdate[i]</span><span class="s2">;</span>
                <span class="s5">// skip if the prop key is a declared emit event listener</span>
                <span class="s2">if </span><span class="s1">(isEmitListener(instance.emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s5">// PROPS flag guarantees rawProps to be non-null</span>
                <span class="s2">const </span><span class="s1">value = rawProps[key]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(options) {</span>
                    <span class="s5">// attr / props separation was done on init and will be consistent</span>
                    <span class="s5">// in this code path, so just check if attrs have it.</span>
                    <span class="s2">if </span><span class="s1">(hasOwn(attrs</span><span class="s2">, </span><span class="s1">key)) {</span>
                        <span class="s2">if </span><span class="s1">(value !== attrs[key]) {</span>
                            <span class="s1">attrs[key] = value</span><span class="s2">;</span>
                            <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">camelizedKey = camelize(key)</span><span class="s2">;</span>
                        <span class="s1">props[camelizedKey] = resolvePropValue(options</span><span class="s2">, </span><span class="s1">rawCurrentProps</span><span class="s2">, </span><span class="s1">camelizedKey</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, false </span><span class="s5">/* isAbsent */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(value !== attrs[key]) {</span>
                        <span class="s1">attrs[key] = value</span><span class="s2">;</span>
                        <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// full props update.</span>
        <span class="s2">if </span><span class="s1">(setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs)) {</span>
            <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s5">// in case of dynamic props, check if we need to delete keys from</span>
        <span class="s5">// the props object</span>
        <span class="s2">let </span><span class="s1">kebabKey</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawCurrentProps) {</span>
            <span class="s2">if </span><span class="s1">(!rawProps ||</span>
                <span class="s5">// for camelCase</span>
                <span class="s1">(!hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp;</span>
                    <span class="s5">// it's possible the original props was passed in as kebab-case</span>
                    <span class="s5">// and converted to camelCase (#955)</span>
                    <span class="s1">((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps</span><span class="s2">, </span><span class="s1">kebabKey)))) {</span>
                <span class="s2">if </span><span class="s1">(options) {</span>
                    <span class="s2">if </span><span class="s1">(rawPrevProps &amp;&amp;</span>
                        <span class="s5">// for camelCase</span>
                        <span class="s1">(rawPrevProps[key] !== undefined ||</span>
                            <span class="s5">// for kebab-case</span>
                            <span class="s1">rawPrevProps[kebabKey] !== undefined)) {</span>
                        <span class="s1">props[key] = resolvePropValue(options</span><span class="s2">, </span><span class="s1">rawCurrentProps</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, true </span><span class="s5">/* isAbsent */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">delete </span><span class="s1">props[key]</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// in the case of functional component w/o props declaration, props and</span>
        <span class="s5">// attrs point to the same object so it should already have been updated.</span>
        <span class="s2">if </span><span class="s1">(attrs !== rawCurrentProps) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
                <span class="s2">if </span><span class="s1">(!rawProps ||</span>
                    <span class="s1">(!hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp;</span>
                        <span class="s1">(!</span><span class="s2">false </span><span class="s1">))) {</span>
                    <span class="s2">delete </span><span class="s1">attrs[key]</span><span class="s2">;</span>
                    <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// trigger updates for $attrs in case it's used in component slots</span>
    <span class="s2">if </span><span class="s1">(hasAttrsChanged) {</span>
        <span class="s1">trigger(instance</span><span class="s2">, </span><span class="s3">&quot;set&quot; </span><span class="s5">/* TriggerOpTypes.SET */</span><span class="s2">, </span><span class="s3">'$attrs'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s1">validateProps(rawProps || {}</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs) {</span>
    <span class="s2">const </span><span class="s1">[options</span><span class="s2">, </span><span class="s1">needCastKeys] = instance.propsOptions</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hasAttrsChanged = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">rawCastValues</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(rawProps) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawProps) {</span>
            <span class="s5">// key, ref are reserved and never passed down</span>
            <span class="s2">if </span><span class="s1">(isReservedProp(key)) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">value = rawProps[key]</span><span class="s2">;</span>
            <span class="s5">// prop option names are camelized during normalization, so to support</span>
            <span class="s5">// kebab -&gt; camel conversion here we need to camelize the key.</span>
            <span class="s2">let </span><span class="s1">camelKey</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(options &amp;&amp; hasOwn(options</span><span class="s2">, </span><span class="s1">(camelKey = camelize(key)))) {</span>
                <span class="s2">if </span><span class="s1">(!needCastKeys || !needCastKeys.includes(camelKey)) {</span>
                    <span class="s1">props[camelKey] = value</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">(rawCastValues || (rawCastValues = {}))[camelKey] = value</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isEmitListener(instance.emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">attrs) || value !== attrs[key]) {</span>
                    <span class="s1">attrs[key] = value</span><span class="s2">;</span>
                    <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(needCastKeys) {</span>
        <span class="s2">const </span><span class="s1">rawCurrentProps = toRaw(props)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">castValues = rawCastValues || EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; needCastKeys.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">key = needCastKeys[i]</span><span class="s2">;</span>
            <span class="s1">props[key] = resolvePropValue(options</span><span class="s2">, </span><span class="s1">rawCurrentProps</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">castValues[key]</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">!hasOwn(castValues</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hasAttrsChanged</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolvePropValue(options</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">isAbsent) {</span>
    <span class="s2">const </span><span class="s1">opt = options[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(opt != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">hasDefault = hasOwn(opt</span><span class="s2">, </span><span class="s3">'default'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s5">// default values</span>
        <span class="s2">if </span><span class="s1">(hasDefault &amp;&amp; value === undefined) {</span>
            <span class="s2">const </span><span class="s1">defaultValue = opt.default</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(opt.type !== Function &amp;&amp; isFunction(defaultValue)) {</span>
                <span class="s2">const </span><span class="s1">{ propsDefaults } = instance</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">propsDefaults) {</span>
                    <span class="s1">value = propsDefaults[key]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
                    <span class="s1">value = propsDefaults[key] = defaultValue.call(</span><span class="s2">null, </span><span class="s1">props)</span><span class="s2">;</span>
                    <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">value = defaultValue</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// boolean casting</span>
        <span class="s2">if </span><span class="s1">(opt[</span><span class="s4">0 </span><span class="s5">/* BooleanFlags.shouldCast */</span><span class="s1">]) {</span>
            <span class="s2">if </span><span class="s1">(isAbsent &amp;&amp; !hasDefault) {</span>
                <span class="s1">value = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(opt[</span><span class="s4">1 </span><span class="s5">/* BooleanFlags.shouldCastTrue */</span><span class="s1">] &amp;&amp;</span>
                <span class="s1">(value === </span><span class="s3">'' </span><span class="s1">|| value === hyphenate(key))) {</span>
                <span class="s1">value = </span><span class="s2">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizePropsOptions(comp</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">cache = appContext.propsCache</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cached = cache.get(comp)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached) {</span>
        <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">raw = comp.props</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">normalized = {}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">needCastKeys = []</span><span class="s2">;</span>
    <span class="s5">// apply mixin/extends props</span>
    <span class="s2">let </span><span class="s1">hasExtends = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(!isFunction(comp)) {</span>
        <span class="s2">const </span><span class="s1">extendProps = (raw) =&gt; {</span>
            <span class="s1">hasExtends = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">[props</span><span class="s2">, </span><span class="s1">keys] = normalizePropsOptions(raw</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(keys)</span>
                <span class="s1">needCastKeys.push(...keys)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s1">appContext.mixins.forEach(extendProps)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(comp.extends) {</span>
            <span class="s1">extendProps(comp.extends)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(comp.mixins) {</span>
            <span class="s1">comp.mixins.forEach(extendProps)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
            <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">EMPTY_ARR)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">EMPTY_ARR</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; raw.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">if </span><span class="s1">(!isString(raw[i])) {</span>
                <span class="s1">warn(</span><span class="s3">`props must be strings when using array syntax.`</span><span class="s2">, </span><span class="s1">raw[i])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">normalizedKey = camelize(raw[i])</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(validatePropName(normalizedKey)) {</span>
                <span class="s1">normalized[normalizedKey] = EMPTY_OBJ</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(raw) {</span>
        <span class="s2">if </span><span class="s1">(!isObject(raw)) {</span>
            <span class="s1">warn(</span><span class="s3">`invalid props options`</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">raw) {</span>
            <span class="s2">const </span><span class="s1">normalizedKey = camelize(key)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(validatePropName(normalizedKey)) {</span>
                <span class="s2">const </span><span class="s1">opt = raw[key]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">prop = (normalized[normalizedKey] =</span>
                    <span class="s1">isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}</span><span class="s2">, </span><span class="s1">opt))</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(prop) {</span>
                    <span class="s2">const </span><span class="s1">booleanIndex = getTypeIndex(Boolean</span><span class="s2">, </span><span class="s1">prop.type)</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">stringIndex = getTypeIndex(String</span><span class="s2">, </span><span class="s1">prop.type)</span><span class="s2">;</span>
                    <span class="s1">prop[</span><span class="s4">0 </span><span class="s5">/* BooleanFlags.shouldCast */</span><span class="s1">] = booleanIndex &gt; -</span><span class="s4">1</span><span class="s2">;</span>
                    <span class="s1">prop[</span><span class="s4">1 </span><span class="s5">/* BooleanFlags.shouldCastTrue */</span><span class="s1">] =</span>
                        <span class="s1">stringIndex &lt; </span><span class="s4">0 </span><span class="s1">|| booleanIndex &lt; stringIndex</span><span class="s2">;</span>
                    <span class="s5">// if the prop needs boolean casting or default value</span>
                    <span class="s2">if </span><span class="s1">(booleanIndex &gt; -</span><span class="s4">1 </span><span class="s1">|| hasOwn(prop</span><span class="s2">, </span><span class="s3">'default'</span><span class="s1">)) {</span>
                        <span class="s1">needCastKeys.push(normalizedKey)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">res = [normalized</span><span class="s2">, </span><span class="s1">needCastKeys]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
        <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">res)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validatePropName(key) {</span>
    <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'$'</span><span class="s1">) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warn(</span><span class="s3">`Invalid prop name: &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is a reserved property.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s5">// use function string name to check type constructors</span>
<span class="s5">// so that it works across vms / iframes.</span>
<span class="s2">function </span><span class="s1">getType(ctor) {</span>
    <span class="s2">const </span><span class="s1">match = ctor &amp;&amp; ctor.toString().match(</span><span class="s4">/^\s*(function|class) (\w+)/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">match ? match[</span><span class="s4">2</span><span class="s1">] : ctor === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s3">''</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSameType(a</span><span class="s2">, </span><span class="s1">b) {</span>
    <span class="s2">return </span><span class="s1">getType(a) === getType(b)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTypeIndex(type</span><span class="s2">, </span><span class="s1">expectedTypes) {</span>
    <span class="s2">if </span><span class="s1">(isArray(expectedTypes)) {</span>
        <span class="s2">return </span><span class="s1">expectedTypes.findIndex(t =&gt; isSameType(t</span><span class="s2">, </span><span class="s1">type))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isFunction(expectedTypes)) {</span>
        <span class="s2">return </span><span class="s1">isSameType(expectedTypes</span><span class="s2">, </span><span class="s1">type) ? </span><span class="s4">0 </span><span class="s1">: -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">validateProps(rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance) {</span>
    <span class="s2">const </span><span class="s1">resolvedValues = toRaw(props)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">options = instance.propsOptions[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">options) {</span>
        <span class="s2">let </span><span class="s1">opt = options[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(opt == </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">continue;</span>
        <span class="s1">validateProp(key</span><span class="s2">, </span><span class="s1">resolvedValues[key]</span><span class="s2">, </span><span class="s1">opt</span><span class="s2">, </span><span class="s1">!hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp; !hasOwn(rawProps</span><span class="s2">, </span><span class="s1">hyphenate(key)))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">validateProp(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">isAbsent) {</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">required</span><span class="s2">, </span><span class="s1">validator } = prop</span><span class="s2">;</span>
    <span class="s5">// required!</span>
    <span class="s2">if </span><span class="s1">(required &amp;&amp; isAbsent) {</span>
        <span class="s1">warn(</span><span class="s3">'Missing required prop: &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot;'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s5">// missing but optional</span>
    <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">&amp;&amp; !prop.required) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s5">// type check</span>
    <span class="s2">if </span><span class="s1">(type != </span><span class="s2">null </span><span class="s1">&amp;&amp; type !== </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">isValid = </span><span class="s2">false;</span>
        <span class="s2">const </span><span class="s1">types = isArray(type) ? type : [type]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">expectedTypes = []</span><span class="s2">;</span>
        <span class="s5">// value is valid as long as one of the specified types match</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; types.length &amp;&amp; !isValid</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">{ valid</span><span class="s2">, </span><span class="s1">expectedType } = assertType(value</span><span class="s2">, </span><span class="s1">types[i])</span><span class="s2">;</span>
            <span class="s1">expectedTypes.push(expectedType || </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">isValid = valid</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isValid) {</span>
            <span class="s1">warn(getInvalidTypeMessage(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">expectedTypes))</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// custom validator</span>
    <span class="s2">if </span><span class="s1">(validator &amp;&amp; !validator(value)) {</span>
        <span class="s1">warn(</span><span class="s3">'Invalid prop: custom validator check failed for prop &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot;.'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">isSimpleType = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">'String,Number,Boolean,Function,Symbol,BigInt'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">assertType(value</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">let </span><span class="s1">valid</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">expectedType = getType(type)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isSimpleType(expectedType)) {</span>
        <span class="s2">const </span><span class="s1">t = </span><span class="s2">typeof </span><span class="s1">value</span><span class="s2">;</span>
        <span class="s1">valid = t === expectedType.toLowerCase()</span><span class="s2">;</span>
        <span class="s5">// for primitive wrapper objects</span>
        <span class="s2">if </span><span class="s1">(!valid &amp;&amp; t === </span><span class="s3">'object'</span><span class="s1">) {</span>
            <span class="s1">valid = value </span><span class="s2">instanceof </span><span class="s1">type</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">'Object'</span><span class="s1">) {</span>
        <span class="s1">valid = isObject(value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">'Array'</span><span class="s1">) {</span>
        <span class="s1">valid = isArray(value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">'null'</span><span class="s1">) {</span>
        <span class="s1">valid = value === </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">valid = value </span><span class="s2">instanceof </span><span class="s1">type</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">valid</span><span class="s2">,</span>
        <span class="s1">expectedType</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">getInvalidTypeMessage(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">expectedTypes) {</span>
    <span class="s2">let </span><span class="s1">message = </span><span class="s3">`Invalid prop: type check failed for prop &quot;</span><span class="s1">${name}</span><span class="s3">&quot;.` </span><span class="s1">+</span>
        <span class="s3">` Expected </span><span class="s1">${expectedTypes.map(capitalize).join(</span><span class="s3">' | '</span><span class="s1">)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">expectedType = expectedTypes[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">receivedType = toRawType(value)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">expectedValue = styleValue(value</span><span class="s2">, </span><span class="s1">expectedType)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">receivedValue = styleValue(value</span><span class="s2">, </span><span class="s1">receivedType)</span><span class="s2">;</span>
    <span class="s5">// check if we need to specify expected value</span>
    <span class="s2">if </span><span class="s1">(expectedTypes.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">isExplicable(expectedType) &amp;&amp;</span>
        <span class="s1">!isBoolean(expectedType</span><span class="s2">, </span><span class="s1">receivedType)) {</span>
        <span class="s1">message += </span><span class="s3">` with value </span><span class="s1">${expectedValue}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">message += </span><span class="s3">`, got </span><span class="s1">${receivedType} </span><span class="s3">`</span><span class="s2">;</span>
    <span class="s5">// check if we need to specify received value</span>
    <span class="s2">if </span><span class="s1">(isExplicable(receivedType)) {</span>
        <span class="s1">message += </span><span class="s3">`with value </span><span class="s1">${receivedValue}</span><span class="s3">.`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">message</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">styleValue(value</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">'String'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s3">`&quot;</span><span class="s1">${value}</span><span class="s3">&quot;`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">'Number'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${Number(value)}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s3">`</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">isExplicable(type) {</span>
    <span class="s2">const </span><span class="s1">explicitTypes = [</span><span class="s3">'string'</span><span class="s2">, </span><span class="s3">'number'</span><span class="s2">, </span><span class="s3">'boolean'</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">explicitTypes.some(elem =&gt; type.toLowerCase() === elem)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* dev only</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">isBoolean(...args) {</span>
    <span class="s2">return </span><span class="s1">args.some(elem =&gt; elem.toLowerCase() === </span><span class="s3">'boolean'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isInternalKey = (key) =&gt; key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'_' </span><span class="s1">|| key === </span><span class="s3">'$stable'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeSlotValue = (value) =&gt; isArray(value)</span>
    <span class="s1">? value.map(normalizeVNode)</span>
    <span class="s1">: [normalizeVNode(value)]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeSlot = (key</span><span class="s2">, </span><span class="s1">rawSlot</span><span class="s2">, </span><span class="s1">ctx) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(rawSlot._n) {</span>
        <span class="s5">// already normalized - #5353</span>
        <span class="s2">return </span><span class="s1">rawSlot</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">normalized = withCtx((...args) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true </span><span class="s1">&amp;&amp; currentInstance) {</span>
            <span class="s1">warn(</span><span class="s3">`Slot &quot;</span><span class="s1">${key}</span><span class="s3">&quot; invoked outside of the render function: ` </span><span class="s1">+</span>
                <span class="s3">`this will not track dependencies used in the slot. ` </span><span class="s1">+</span>
                <span class="s3">`Invoke the slot function inside the render function instead.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">normalizeSlotValue(rawSlot(...args))</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
    <span class="s1">normalized._c = </span><span class="s2">false;</span>
    <span class="s2">return </span><span class="s1">normalized</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeObjectSlots = (rawSlots</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">instance) =&gt; {</span>
    <span class="s2">const </span><span class="s1">ctx = rawSlots._ctx</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawSlots) {</span>
        <span class="s2">if </span><span class="s1">(isInternalKey(key))</span>
            <span class="s2">continue;</span>
        <span class="s2">const </span><span class="s1">value = rawSlots[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
            <span class="s1">slots[key] = normalizeSlot(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(value != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">{</span>
                <span class="s1">warn(</span><span class="s3">`Non-function value encountered for slot &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. ` </span><span class="s1">+</span>
                    <span class="s3">`Prefer function slots for better performance.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">normalized = normalizeSlotValue(value)</span><span class="s2">;</span>
            <span class="s1">slots[key] = () =&gt; normalized</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeVNodeSlots = (instance</span><span class="s2">, </span><span class="s1">children) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!isKeepAlive(instance.vnode) &amp;&amp;</span>
        <span class="s1">!(</span><span class="s2">false </span><span class="s1">)) {</span>
        <span class="s1">warn(</span><span class="s3">`Non-function value encountered for default slot. ` </span><span class="s1">+</span>
            <span class="s3">`Prefer function slots for better performance.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">normalized = normalizeSlotValue(children)</span><span class="s2">;</span>
    <span class="s1">instance.slots.default = () =&gt; normalized</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">initSlots = (instance</span><span class="s2">, </span><span class="s1">children) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(instance.vnode.shapeFlag &amp; </span><span class="s4">32 </span><span class="s5">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">type = children._</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type) {</span>
            <span class="s5">// users can get the shallow readonly version of the slots object through `this.$slots`,</span>
            <span class="s5">// we should avoid the proxy object polluting the slots of the internal instance</span>
            <span class="s1">instance.slots = toRaw(children)</span><span class="s2">;</span>
            <span class="s5">// make compiler marker non-enumerable</span>
            <span class="s1">def(children</span><span class="s2">, </span><span class="s3">'_'</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">normalizeObjectSlots(children</span><span class="s2">, </span><span class="s1">(instance.slots = {}))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">instance.slots = {}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(children) {</span>
            <span class="s1">normalizeVNodeSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">def(instance.slots</span><span class="s2">, </span><span class="s1">InternalObjectKey</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">updateSlots = (instance</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">slots } = instance</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">needDeletionCheck = </span><span class="s2">true;</span>
    <span class="s2">let </span><span class="s1">deletionComparisonTarget = EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">32 </span><span class="s5">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">type = children._</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type) {</span>
            <span class="s5">// compiled slots.</span>
            <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
                <span class="s5">// Parent was HMR updated so slot content may have changed.</span>
                <span class="s5">// force update slots and mark instance for hmr as well</span>
                <span class="s1">extend(slots</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(optimized &amp;&amp; type === </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s1">) {</span>
                <span class="s5">// compiled AND stable.</span>
                <span class="s5">// no need to update, and skip stale slots removal.</span>
                <span class="s1">needDeletionCheck = </span><span class="s2">false;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// compiled but dynamic (v-if/v-for on slots) - update slots, but skip</span>
                <span class="s5">// normalization.</span>
                <span class="s1">extend(slots</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
                <span class="s5">// #2893</span>
                <span class="s5">// when rendering the optimized slots by manually written render function,</span>
                <span class="s5">// we need to delete the `slots._` flag if necessary to make subsequent updates reliable,</span>
                <span class="s5">// i.e. let the `renderSlot` create the bailed Fragment</span>
                <span class="s2">if </span><span class="s1">(!optimized &amp;&amp; type === </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s1">) {</span>
                    <span class="s2">delete </span><span class="s1">slots._</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">needDeletionCheck = !children.$stable</span><span class="s2">;</span>
            <span class="s1">normalizeObjectSlots(children</span><span class="s2">, </span><span class="s1">slots)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">deletionComparisonTarget = children</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(children) {</span>
        <span class="s5">// non slot object children (direct value) passed to a component</span>
        <span class="s1">normalizeVNodeSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s1">deletionComparisonTarget = { </span><span class="s2">default</span><span class="s1">: </span><span class="s4">1 </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// delete stale slots</span>
    <span class="s2">if </span><span class="s1">(needDeletionCheck) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">slots) {</span>
            <span class="s2">if </span><span class="s1">(!isInternalKey(key) &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">deletionComparisonTarget)) {</span>
                <span class="s2">delete </span><span class="s1">slots[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">createAppContext() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">app: </span><span class="s2">null,</span>
        <span class="s1">config: {</span>
            <span class="s1">isNativeTag: NO</span><span class="s2">,</span>
            <span class="s1">performance: </span><span class="s2">false,</span>
            <span class="s1">globalProperties: {}</span><span class="s2">,</span>
            <span class="s1">optionMergeStrategies: {}</span><span class="s2">,</span>
            <span class="s1">errorHandler: undefined</span><span class="s2">,</span>
            <span class="s1">warnHandler: undefined</span><span class="s2">,</span>
            <span class="s1">compilerOptions: {}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">mixins: []</span><span class="s2">,</span>
        <span class="s1">components: {}</span><span class="s2">,</span>
        <span class="s1">directives: {}</span><span class="s2">,</span>
        <span class="s1">provides: Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">optionsCache: </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">,</span>
        <span class="s1">propsCache: </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">,</span>
        <span class="s1">emitsCache: </span><span class="s2">new </span><span class="s1">WeakMap()</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">uid$1 = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createAppAPI(render</span><span class="s2">, </span><span class="s1">hydrate) {</span>
    <span class="s2">return function </span><span class="s1">createApp(rootComponent</span><span class="s2">, </span><span class="s1">rootProps = </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!isFunction(rootComponent)) {</span>
            <span class="s1">rootComponent = Object.assign({}</span><span class="s2">, </span><span class="s1">rootComponent)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(rootProps != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isObject(rootProps)) {</span>
            <span class="s1">warn(</span><span class="s3">`root props passed to app.mount() must be an object.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">rootProps = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">context = createAppContext()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">installedPlugins = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">isMounted = </span><span class="s2">false;</span>
        <span class="s2">const </span><span class="s1">app = (context.app = {</span>
            <span class="s1">_uid: uid$1++</span><span class="s2">,</span>
            <span class="s1">_component: rootComponent</span><span class="s2">,</span>
            <span class="s1">_props: rootProps</span><span class="s2">,</span>
            <span class="s1">_container: </span><span class="s2">null,</span>
            <span class="s1">_context: context</span><span class="s2">,</span>
            <span class="s1">_instance: </span><span class="s2">null,</span>
            <span class="s1">version</span><span class="s2">,</span>
            <span class="s1">get config() {</span>
                <span class="s2">return </span><span class="s1">context.config</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">set config(v) {</span>
                <span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`app.config cannot be replaced. Modify individual options instead.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">use(plugin</span><span class="s2">, </span><span class="s1">...options) {</span>
                <span class="s2">if </span><span class="s1">(installedPlugins.has(plugin)) {</span>
                    <span class="s1">warn(</span><span class="s3">`Plugin has already been applied to target app.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(plugin &amp;&amp; isFunction(plugin.install)) {</span>
                    <span class="s1">installedPlugins.add(plugin)</span><span class="s2">;</span>
                    <span class="s1">plugin.install(app</span><span class="s2">, </span><span class="s1">...options)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(isFunction(plugin)) {</span>
                    <span class="s1">installedPlugins.add(plugin)</span><span class="s2">;</span>
                    <span class="s1">plugin(app</span><span class="s2">, </span><span class="s1">...options)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`A plugin must either be a function or an object with an &quot;install&quot; ` </span><span class="s1">+</span>
                        <span class="s3">`function.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">mixin(mixin) {</span>
                <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(!context.mixins.includes(mixin)) {</span>
                        <span class="s1">context.mixins.push(mixin)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">warn(</span><span class="s3">'Mixin has already been applied to target app' </span><span class="s1">+</span>
                            <span class="s1">(mixin.name ? </span><span class="s3">`: </span><span class="s1">${mixin.name}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">component(name</span><span class="s2">, </span><span class="s1">component) {</span>
                <span class="s1">{</span>
                    <span class="s1">validateComponentName(name</span><span class="s2">, </span><span class="s1">context.config)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!component) {</span>
                    <span class="s2">return </span><span class="s1">context.components[name]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(context.components[name]) {</span>
                    <span class="s1">warn(</span><span class="s3">`Component &quot;</span><span class="s1">${name}</span><span class="s3">&quot; has already been registered in target app.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">context.components[name] = component</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">directive(name</span><span class="s2">, </span><span class="s1">directive) {</span>
                <span class="s1">{</span>
                    <span class="s1">validateDirectiveName(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!directive) {</span>
                    <span class="s2">return </span><span class="s1">context.directives[name]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(context.directives[name]) {</span>
                    <span class="s1">warn(</span><span class="s3">`Directive &quot;</span><span class="s1">${name}</span><span class="s3">&quot; has already been registered in target app.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">context.directives[name] = directive</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">mount(rootContainer</span><span class="s2">, </span><span class="s1">isHydrate</span><span class="s2">, </span><span class="s1">isSVG) {</span>
                <span class="s2">if </span><span class="s1">(!isMounted) {</span>
                    <span class="s5">// #5571</span>
                    <span class="s2">if </span><span class="s1">(rootContainer.__vue_app__) {</span>
                        <span class="s1">warn(</span><span class="s3">`There is already an app instance mounted on the host container.</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                            <span class="s3">` If you want to mount another app on the same host container,` </span><span class="s1">+</span>
                            <span class="s3">` you need to unmount the previous app by calling </span><span class="s2">\`</span><span class="s3">app.unmount()</span><span class="s2">\` </span><span class="s3">first.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">vnode = createVNode(rootComponent</span><span class="s2">, </span><span class="s1">rootProps)</span><span class="s2">;</span>
                    <span class="s5">// store app context on the root VNode.</span>
                    <span class="s5">// this will be set on the root instance on initial mount.</span>
                    <span class="s1">vnode.appContext = context</span><span class="s2">;</span>
                    <span class="s5">// HMR root reload</span>
                    <span class="s1">{</span>
                        <span class="s1">context.reload = () =&gt; {</span>
                            <span class="s1">render(cloneVNode(vnode)</span><span class="s2">, </span><span class="s1">rootContainer</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                        <span class="s1">}</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(isHydrate &amp;&amp; hydrate) {</span>
                        <span class="s1">hydrate(vnode</span><span class="s2">, </span><span class="s1">rootContainer)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">render(vnode</span><span class="s2">, </span><span class="s1">rootContainer</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">isMounted = </span><span class="s2">true;</span>
                    <span class="s1">app._container = rootContainer</span><span class="s2">;</span>
                    <span class="s1">rootContainer.__vue_app__ = app</span><span class="s2">;</span>
                    <span class="s1">{</span>
                        <span class="s1">app._instance = vnode.component</span><span class="s2">;</span>
                        <span class="s1">devtoolsInitApp(app</span><span class="s2">, </span><span class="s1">version)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">getExposeProxy(vnode.component) || vnode.component.proxy</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`App has already been mounted.</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                        <span class="s3">`If you want to remount the same app, move your app creation logic ` </span><span class="s1">+</span>
                        <span class="s3">`into a factory function and create fresh app instances for each ` </span><span class="s1">+</span>
                        <span class="s3">`mount - e.g. </span><span class="s2">\`</span><span class="s3">const createMyApp = () =&gt; createApp(App)</span><span class="s2">\`</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">unmount() {</span>
                <span class="s2">if </span><span class="s1">(isMounted) {</span>
                    <span class="s1">render(</span><span class="s2">null, </span><span class="s1">app._container)</span><span class="s2">;</span>
                    <span class="s1">{</span>
                        <span class="s1">app._instance = </span><span class="s2">null;</span>
                        <span class="s1">devtoolsUnmountApp(app)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">delete </span><span class="s1">app._container.__vue_app__</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`Cannot unmount an app that is not mounted.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">provide(key</span><span class="s2">, </span><span class="s1">value) {</span>
                <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">context.provides) {</span>
                    <span class="s1">warn(</span><span class="s3">`App already provides property with key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot;. ` </span><span class="s1">+</span>
                        <span class="s3">`It will be overwritten with the new value.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">context.provides[key] = value</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Function for handling a template ref</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">setRef(rawRef</span><span class="s2">, </span><span class="s1">oldRawRef</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">isUnmount = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(isArray(rawRef)) {</span>
        <span class="s1">rawRef.forEach((r</span><span class="s2">, </span><span class="s1">i) =&gt; setRef(r</span><span class="s2">, </span><span class="s1">oldRawRef &amp;&amp; (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef)</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">isUnmount))</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isAsyncWrapper(vnode) &amp;&amp; !isUnmount) {</span>
        <span class="s5">// when mounting async components, nothing needs to be done,</span>
        <span class="s5">// because the template ref is forwarded to inner component</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">refValue = vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */</span>
        <span class="s1">? getExposeProxy(vnode.component) || vnode.component.proxy</span>
        <span class="s1">: vnode.el</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">value = isUnmount ? </span><span class="s2">null </span><span class="s1">: refValue</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ i: owner</span><span class="s2">, </span><span class="s1">r: ref } = rawRef</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!owner) {</span>
        <span class="s1">warn(</span><span class="s3">`Missing ref owner context. ref cannot be used on hoisted vnodes. ` </span><span class="s1">+</span>
            <span class="s3">`A vnode with ref must be created inside the render function.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">oldRef = oldRawRef &amp;&amp; oldRawRef.r</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setupState = owner.setupState</span><span class="s2">;</span>
    <span class="s5">// dynamic ref changed. unset old ref</span>
    <span class="s2">if </span><span class="s1">(oldRef != </span><span class="s2">null </span><span class="s1">&amp;&amp; oldRef !== ref) {</span>
        <span class="s2">if </span><span class="s1">(isString(oldRef)) {</span>
            <span class="s1">refs[oldRef] = </span><span class="s2">null;</span>
            <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">oldRef)) {</span>
                <span class="s1">setupState[oldRef] = </span><span class="s2">null;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isRef(oldRef)) {</span>
            <span class="s1">oldRef.value = </span><span class="s2">null;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isFunction(ref)) {</span>
        <span class="s1">callWithErrorHandling(ref</span><span class="s2">, </span><span class="s1">owner</span><span class="s2">, </span><span class="s4">12 </span><span class="s5">/* ErrorCodes.FUNCTION_REF */</span><span class="s2">, </span><span class="s1">[value</span><span class="s2">, </span><span class="s1">refs])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">_isString = isString(ref)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">_isRef = isRef(ref)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(_isString || _isRef) {</span>
            <span class="s2">const </span><span class="s1">doSet = () =&gt; {</span>
                <span class="s2">if </span><span class="s1">(rawRef.f) {</span>
                    <span class="s2">const </span><span class="s1">existing = _isString</span>
                        <span class="s1">? hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref)</span>
                            <span class="s1">? setupState[ref]</span>
                            <span class="s1">: refs[ref]</span>
                        <span class="s1">: ref.value</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isUnmount) {</span>
                        <span class="s1">isArray(existing) &amp;&amp; remove(existing</span><span class="s2">, </span><span class="s1">refValue)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">if </span><span class="s1">(!isArray(existing)) {</span>
                            <span class="s2">if </span><span class="s1">(_isString) {</span>
                                <span class="s1">refs[ref] = [refValue]</span><span class="s2">;</span>
                                <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref)) {</span>
                                    <span class="s1">setupState[ref] = refs[ref]</span><span class="s2">;</span>
                                <span class="s1">}</span>
                            <span class="s1">}</span>
                            <span class="s2">else </span><span class="s1">{</span>
                                <span class="s1">ref.value = [refValue]</span><span class="s2">;</span>
                                <span class="s2">if </span><span class="s1">(rawRef.k)</span>
                                    <span class="s1">refs[rawRef.k] = ref.value</span><span class="s2">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(!existing.includes(refValue)) {</span>
                            <span class="s1">existing.push(refValue)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(_isString) {</span>
                    <span class="s1">refs[ref] = value</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref)) {</span>
                        <span class="s1">setupState[ref] = value</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(_isRef) {</span>
                    <span class="s1">ref.value = value</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(rawRef.k)</span>
                        <span class="s1">refs[rawRef.k] = value</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">'Invalid template ref type:'</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">ref}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value) {</span>
                <span class="s1">doSet.id = -</span><span class="s4">1</span><span class="s2">;</span>
                <span class="s1">queuePostRenderEffect(doSet</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">doSet()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">'Invalid template ref type:'</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">ref}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">hasMismatch = </span><span class="s2">false;</span>
<span class="s2">const </span><span class="s1">isSVGContainer = (container) =&gt; </span><span class="s4">/svg/</span><span class="s1">.test(container.namespaceURI) &amp;&amp; container.tagName !== </span><span class="s3">'foreignObject'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isComment = (node) =&gt; node.nodeType === </span><span class="s4">8 </span><span class="s5">/* DOMNodeTypes.COMMENT */</span><span class="s2">;</span>
<span class="s5">// Note: hydration is DOM-specific</span>
<span class="s5">// But we have to place it in core due to tight coupling with core - splitting</span>
<span class="s5">// it out creates a ton of unnecessary complexity.</span>
<span class="s5">// Hydration also depends on some renderer internal logic which needs to be</span>
<span class="s5">// passed in via arguments.</span>
<span class="s2">function </span><span class="s1">createHydrationFunctions(rendererInternals) {</span>
    <span class="s2">const </span><span class="s1">{ mt: mountComponent</span><span class="s2">, </span><span class="s1">p: patch</span><span class="s2">, </span><span class="s1">o: { patchProp</span><span class="s2">, </span><span class="s1">createText</span><span class="s2">, </span><span class="s1">nextSibling</span><span class="s2">, </span><span class="s1">parentNode</span><span class="s2">, </span><span class="s1">remove</span><span class="s2">, </span><span class="s1">insert</span><span class="s2">, </span><span class="s1">createComment } } = rendererInternals</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hydrate = (vnode</span><span class="s2">, </span><span class="s1">container) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!container.hasChildNodes()) {</span>
            <span class="s1">warn(</span><span class="s3">`Attempting to hydrate existing markup but container is empty. ` </span><span class="s1">+</span>
                    <span class="s3">`Performing full mount instead.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container)</span><span class="s2">;</span>
            <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
            <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">hasMismatch = </span><span class="s2">false;</span>
        <span class="s1">hydrateNode(container.firstChild</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, null, null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
        <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hasMismatch &amp;&amp; !</span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s5">// this error should show up in production</span>
            <span class="s1">console.error(</span><span class="s3">`Hydration completed but contains mismatches.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hydrateNode = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
        <span class="s2">const </span><span class="s1">isFragmentStart = isComment(node) &amp;&amp; node.data === </span><span class="s3">'['</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">onMismatch = () =&gt; handleMismatch(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">isFragmentStart)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">patchFlag } = vnode</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">domType = node.nodeType</span><span class="s2">;</span>
        <span class="s1">vnode.el = node</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(patchFlag === -</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s1">) {</span>
            <span class="s1">optimized = </span><span class="s2">false;</span>
            <span class="s1">vnode.dynamicChildren = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">nextNode = </span><span class="s2">null;</span>
        <span class="s2">switch </span><span class="s1">(type) {</span>
            <span class="s2">case </span><span class="s1">Text:</span>
                <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">3 </span><span class="s5">/* DOMNodeTypes.TEXT */</span><span class="s1">) {</span>
                    <span class="s5">// #5728 empty text node inside a slot can cause hydration failure</span>
                    <span class="s5">// because the server rendered HTML won't contain a text node</span>
                    <span class="s2">if </span><span class="s1">(vnode.children === </span><span class="s3">''</span><span class="s1">) {</span>
                        <span class="s1">insert((vnode.el = createText(</span><span class="s3">''</span><span class="s1">))</span><span class="s2">, </span><span class="s1">parentNode(node)</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
                        <span class="s1">nextNode = node</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(node.data !== vnode.children) {</span>
                        <span class="s1">hasMismatch = </span><span class="s2">true;</span>
                        <span class="s1">warn(</span><span class="s3">`Hydration text mismatch:` </span><span class="s1">+</span>
                                <span class="s3">`</span><span class="s2">\n</span><span class="s3">- Client: </span><span class="s1">${JSON.stringify(node.data)}</span><span class="s3">` </span><span class="s1">+</span>
                                <span class="s3">`</span><span class="s2">\n</span><span class="s3">- Server: </span><span class="s1">${JSON.stringify(vnode.children)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">node.data = vnode.children</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">nextNode = nextSibling(node)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Comment:</span>
                <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">8 </span><span class="s5">/* DOMNodeTypes.COMMENT */ </span><span class="s1">|| isFragmentStart) {</span>
                    <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">nextNode = nextSibling(node)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Static:</span>
                <span class="s2">if </span><span class="s1">(isFragmentStart) {</span>
                    <span class="s5">// entire template is static but SSRed as a fragment</span>
                    <span class="s1">node = nextSibling(node)</span><span class="s2">;</span>
                    <span class="s1">domType = node.nodeType</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(domType === </span><span class="s4">1 </span><span class="s5">/* DOMNodeTypes.ELEMENT */ </span><span class="s1">|| domType === </span><span class="s4">3 </span><span class="s5">/* DOMNodeTypes.TEXT */</span><span class="s1">) {</span>
                    <span class="s5">// determine anchor, adopt content</span>
                    <span class="s1">nextNode = node</span><span class="s2">;</span>
                    <span class="s5">// if the static vnode has its content stripped during build,</span>
                    <span class="s5">// adopt it from the server-rendered HTML.</span>
                    <span class="s2">const </span><span class="s1">needToAdoptContent = !vnode.children.length</span><span class="s2">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; vnode.staticCount</span><span class="s2">; </span><span class="s1">i++) {</span>
                        <span class="s2">if </span><span class="s1">(needToAdoptContent)</span>
                            <span class="s1">vnode.children +=</span>
                                <span class="s1">nextNode.nodeType === </span><span class="s4">1 </span><span class="s5">/* DOMNodeTypes.ELEMENT */</span>
                                    <span class="s1">? nextNode.outerHTML</span>
                                    <span class="s1">: nextNode.data</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(i === vnode.staticCount - </span><span class="s4">1</span><span class="s1">) {</span>
                            <span class="s1">vnode.anchor = nextNode</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">nextNode = nextSibling(nextNode)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">isFragmentStart ? nextSibling(nextNode) : nextNode</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">onMismatch()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Fragment:</span>
                <span class="s2">if </span><span class="s1">(!isFragmentStart) {</span>
                    <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">nextNode = hydrateFragment(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">1 </span><span class="s5">/* DOMNodeTypes.ELEMENT */ </span><span class="s1">||</span>
                        <span class="s1">vnode.type.toLowerCase() !==</span>
                            <span class="s1">node.tagName.toLowerCase()) {</span>
                        <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">nextNode = hydrateElement(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
                    <span class="s5">// when setting up the render effect, if the initial vnode already</span>
                    <span class="s5">// has .el set, the component will perform hydration instead of mount</span>
                    <span class="s5">// on its sub-tree.</span>
                    <span class="s1">vnode.slotScopeIds = slotScopeIds</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
                    <span class="s1">mountComponent(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                    <span class="s5">// component may be async, so in the case of fragments we cannot rely</span>
                    <span class="s5">// on component's rendered output to determine the end of the fragment</span>
                    <span class="s5">// instead, we do a lookahead to find the end anchor node.</span>
                    <span class="s1">nextNode = isFragmentStart</span>
                        <span class="s1">? locateClosingAsyncAnchor(node)</span>
                        <span class="s1">: nextSibling(node)</span><span class="s2">;</span>
                    <span class="s5">// #4293 teleport as component root</span>
                    <span class="s2">if </span><span class="s1">(nextNode &amp;&amp;</span>
                        <span class="s1">isComment(nextNode) &amp;&amp;</span>
                        <span class="s1">nextNode.data === </span><span class="s3">'teleport end'</span><span class="s1">) {</span>
                        <span class="s1">nextNode = nextSibling(nextNode)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s5">// #3787</span>
                    <span class="s5">// if component is async, it may get moved / unmounted before its</span>
                    <span class="s5">// inner component is loaded, so we need to give it a placeholder</span>
                    <span class="s5">// vnode that matches its adopted DOM.</span>
                    <span class="s2">if </span><span class="s1">(isAsyncWrapper(vnode)) {</span>
                        <span class="s2">let </span><span class="s1">subTree</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(isFragmentStart) {</span>
                            <span class="s1">subTree = createVNode(Fragment)</span><span class="s2">;</span>
                            <span class="s1">subTree.anchor = nextNode</span>
                                <span class="s1">? nextNode.previousSibling</span>
                                <span class="s1">: container.lastChild</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">subTree =</span>
                                <span class="s1">node.nodeType === </span><span class="s4">3 </span><span class="s1">? createTextVNode(</span><span class="s3">''</span><span class="s1">) : createVNode(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">subTree.el = node</span><span class="s2">;</span>
                        <span class="s1">vnode.component.subTree = subTree</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">8 </span><span class="s5">/* DOMNodeTypes.COMMENT */</span><span class="s1">) {</span>
                        <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">nextNode = vnode.type.hydrate(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateChildren)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
                    <span class="s1">nextNode = vnode.type.hydrate(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(parentNode(node))</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateNode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">'Invalid HostVNode type:'</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">type}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(ref != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">setRef(ref</span><span class="s2">, null, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">nextNode</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hydrateElement = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">optimized = optimized || !!vnode.dynamicChildren</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
        <span class="s5">// #4006 for form elements with non-string v-model value bindings</span>
        <span class="s5">// e.g. &lt;option :value=&quot;obj&quot;&gt;, &lt;input type=&quot;checkbox&quot; :true-value=&quot;1&quot;&gt;</span>
        <span class="s2">const </span><span class="s1">forcePatchValue = (type === </span><span class="s3">'input' </span><span class="s1">&amp;&amp; dirs) || type === </span><span class="s3">'option'</span><span class="s2">;</span>
        <span class="s5">// skip props &amp; children if this is hoisted static nodes</span>
        <span class="s5">// #5405 in dev, always hydrate children for HMR</span>
        <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(dirs) {</span>
                <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'created'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// props</span>
            <span class="s2">if </span><span class="s1">(props) {</span>
                <span class="s2">if </span><span class="s1">(forcePatchValue ||</span>
                    <span class="s1">!optimized ||</span>
                    <span class="s1">patchFlag &amp; (</span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */ </span><span class="s1">| </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">)) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
                        <span class="s2">if </span><span class="s1">((forcePatchValue &amp;&amp; key.endsWith(</span><span class="s3">'value'</span><span class="s1">)) ||</span>
                            <span class="s1">(isOn(key) &amp;&amp; !isReservedProp(key))) {</span>
                            <span class="s1">patchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, null, </span><span class="s1">props[key]</span><span class="s2">, false, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(props.onClick) {</span>
                    <span class="s5">// Fast path for click listeners (which is most often) to avoid</span>
                    <span class="s5">// iterating through props.</span>
                    <span class="s1">patchProp(el</span><span class="s2">, </span><span class="s3">'onClick'</span><span class="s2">, null, </span><span class="s1">props.onClick</span><span class="s2">, false, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// vnode / directive hooks</span>
            <span class="s2">let </span><span class="s1">vnodeHooks</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">((vnodeHooks = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                <span class="s1">invokeVNodeHook(vnodeHooks</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(dirs) {</span>
                <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'beforeMount'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((vnodeHooks = props &amp;&amp; props.onVnodeMounted) || dirs) {</span>
                <span class="s1">queueEffectWithSuspense(() =&gt; {</span>
                    <span class="s1">vnodeHooks &amp;&amp; invokeVNodeHook(vnodeHooks</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                    <span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'mounted'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// children</span>
            <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */ </span><span class="s1">&amp;&amp;</span>
                <span class="s5">// skip if element has innerHTML / textContent</span>
                <span class="s1">!(props &amp;&amp; (props.innerHTML || props.textContent))) {</span>
                <span class="s2">let </span><span class="s1">next = hydrateChildren(el.firstChild</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">hasWarned = </span><span class="s2">false;</span>
                <span class="s2">while </span><span class="s1">(next) {</span>
                    <span class="s1">hasMismatch = </span><span class="s2">true;</span>
                    <span class="s2">if </span><span class="s1">(!hasWarned) {</span>
                        <span class="s1">warn(</span><span class="s3">`Hydration children mismatch in &lt;</span><span class="s1">${vnode.type}</span><span class="s3">&gt;: ` </span><span class="s1">+</span>
                            <span class="s3">`server rendered element contains more child nodes than client vdom.`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">hasWarned = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                    <span class="s5">// The SSRed DOM contains more nodes than it should. Remove them.</span>
                    <span class="s2">const </span><span class="s1">cur = next</span><span class="s2">;</span>
                    <span class="s1">next = next.nextSibling</span><span class="s2">;</span>
                    <span class="s1">remove(cur)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(el.textContent !== vnode.children) {</span>
                    <span class="s1">hasMismatch = </span><span class="s2">true;</span>
                    <span class="s1">warn(</span><span class="s3">`Hydration text content mismatch in &lt;</span><span class="s1">${vnode.type}</span><span class="s3">&gt;:</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                            <span class="s3">`- Client: </span><span class="s1">${el.textContent}</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                            <span class="s3">`- Server: </span><span class="s1">${vnode.children}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">el.textContent = vnode.children</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">el.nextSibling</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hydrateChildren = (node</span><span class="s2">, </span><span class="s1">parentVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">optimized = optimized || !!parentVNode.dynamicChildren</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">children = parentVNode.children</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">l = children.length</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hasWarned = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">vnode = optimized</span>
                <span class="s1">? children[i]</span>
                <span class="s1">: (children[i] = normalizeVNode(children[i]))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(node) {</span>
                <span class="s1">node = hydrateNode(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(vnode.type === Text &amp;&amp; !vnode.children) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">hasMismatch = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(!hasWarned) {</span>
                    <span class="s1">warn(</span><span class="s3">`Hydration children mismatch in &lt;</span><span class="s1">${container.tagName.toLowerCase()}</span><span class="s3">&gt;: ` </span><span class="s1">+</span>
                        <span class="s3">`server rendered element contains fewer child nodes than client vdom.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">hasWarned = </span><span class="s2">true;</span>
                <span class="s1">}</span>
                <span class="s5">// the SSRed DOM didn't contain enough nodes. Mount the missing ones.</span>
                <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hydrateFragment = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ slotScopeIds: fragmentSlotScopeIds } = vnode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(fragmentSlotScopeIds) {</span>
            <span class="s1">slotScopeIds = slotScopeIds</span>
                <span class="s1">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s1">: fragmentSlotScopeIds</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">next = hydrateChildren(nextSibling(node)</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(next &amp;&amp; isComment(next) &amp;&amp; next.data === </span><span class="s3">']'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">nextSibling((vnode.anchor = next))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// fragment didn't hydrate successfully, since we didn't get a end anchor</span>
            <span class="s5">// back. This should have led to node/children mismatch warnings.</span>
            <span class="s1">hasMismatch = </span><span class="s2">true;</span>
            <span class="s5">// since the anchor is missing, we need to create one and insert it</span>
            <span class="s1">insert((vnode.anchor = createComment(</span><span class="s3">`]`</span><span class="s1">))</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">next)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">next</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">handleMismatch = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">isFragment) =&gt; {</span>
        <span class="s1">hasMismatch = </span><span class="s2">true;</span>
        <span class="s1">warn(</span><span class="s3">`Hydration node mismatch:</span><span class="s2">\n</span><span class="s3">- Client vnode:`</span><span class="s2">, </span><span class="s1">vnode.type</span><span class="s2">, </span><span class="s3">`</span><span class="s2">\n</span><span class="s3">- Server rendered DOM:`</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">node.nodeType === </span><span class="s4">3 </span><span class="s5">/* DOMNodeTypes.TEXT */</span>
                <span class="s1">? </span><span class="s3">`(text)`</span>
                <span class="s1">: isComment(node) &amp;&amp; node.data === </span><span class="s3">'['</span>
                    <span class="s1">? </span><span class="s3">`(start of fragment)`</span>
                    <span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">vnode.el = </span><span class="s2">null;</span>
        <span class="s2">if </span><span class="s1">(isFragment) {</span>
            <span class="s5">// remove excessive fragment nodes</span>
            <span class="s2">const </span><span class="s1">end = locateClosingAsyncAnchor(node)</span><span class="s2">;</span>
            <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">next = nextSibling(node)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(next &amp;&amp; next !== end) {</span>
                    <span class="s1">remove(next)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">next = nextSibling(node)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
        <span class="s1">remove(node)</span><span class="s2">;</span>
        <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">next</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">locateClosingAsyncAnchor = (node) =&gt; {</span>
        <span class="s2">let </span><span class="s1">match = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(node) {</span>
            <span class="s1">node = nextSibling(node)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(node &amp;&amp; isComment(node)) {</span>
                <span class="s2">if </span><span class="s1">(node.data === </span><span class="s3">'['</span><span class="s1">)</span>
                    <span class="s1">match++</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(node.data === </span><span class="s3">']'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(match === </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s2">return </span><span class="s1">nextSibling(node)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">match--</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[hydrate</span><span class="s2">, </span><span class="s1">hydrateNode]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">/* eslint-disable no-restricted-globals */</span>
<span class="s2">let </span><span class="s1">supported</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">perf</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">if </span><span class="s1">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
        <span class="s1">perf.mark(</span><span class="s3">`vue-</span><span class="s1">${type}</span><span class="s3">-</span><span class="s1">${instance.uid}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s1">devtoolsPerfStart(instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">isSupported() ? perf.now() : Date.now())</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">if </span><span class="s1">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
        <span class="s2">const </span><span class="s1">startTag = </span><span class="s3">`vue-</span><span class="s1">${type}</span><span class="s3">-</span><span class="s1">${instance.uid}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">endTag = startTag + </span><span class="s3">`:end`</span><span class="s2">;</span>
        <span class="s1">perf.mark(endTag)</span><span class="s2">;</span>
        <span class="s1">perf.measure(</span><span class="s3">`&lt;</span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">instance.type)}</span><span class="s3">&gt; </span><span class="s1">${type}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">startTag</span><span class="s2">, </span><span class="s1">endTag)</span><span class="s2">;</span>
        <span class="s1">perf.clearMarks(startTag)</span><span class="s2">;</span>
        <span class="s1">perf.clearMarks(endTag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s1">devtoolsPerfEnd(instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">isSupported() ? perf.now() : Date.now())</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSupported() {</span>
    <span class="s2">if </span><span class="s1">(supported !== undefined) {</span>
        <span class="s2">return </span><span class="s1">supported</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; window.performance) {</span>
        <span class="s1">supported = </span><span class="s2">true;</span>
        <span class="s1">perf = window.performance</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">supported = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">supported</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">queuePostRenderEffect = queueEffectWithSuspense</span>
    <span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* The createRenderer function accepts two generic arguments:</span>
 <span class="s0">* HostNode and HostElement, corresponding to Node and Element types in the</span>
 <span class="s0">* host environment. For example, for runtime-dom, HostNode would be the DOM</span>
 <span class="s0">* `Node` interface and HostElement would be the DOM `Element` interface.</span>
 <span class="s0">*</span>
 <span class="s0">* Custom renderers can pass in the platform specific types like this:</span>
 <span class="s0">*</span>
 <span class="s0">* ``` js</span>
 <span class="s0">* const { render, createApp } = createRenderer&lt;Node, Element&gt;({</span>
 <span class="s0">*   patchProp,</span>
 <span class="s0">*   ...nodeOps</span>
 <span class="s0">* })</span>
 <span class="s0">* ```</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createRenderer(options) {</span>
    <span class="s2">return </span><span class="s1">baseCreateRenderer(options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// Separate API for creating hydration-enabled renderer.</span>
<span class="s5">// Hydration logic is only used when calling this function, making it</span>
<span class="s5">// tree-shakable.</span>
<span class="s2">function </span><span class="s1">createHydrationRenderer(options) {</span>
    <span class="s2">return </span><span class="s1">baseCreateRenderer(options</span><span class="s2">, </span><span class="s1">createHydrationFunctions)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// implementation</span>
<span class="s2">function </span><span class="s1">baseCreateRenderer(options</span><span class="s2">, </span><span class="s1">createHydrationFns) {</span>
    <span class="s2">const </span><span class="s1">target = getGlobalThis()</span><span class="s2">;</span>
    <span class="s1">target.__VUE__ = </span><span class="s2">true;</span>
    <span class="s1">{</span>
        <span class="s1">setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ insert: hostInsert</span><span class="s2">, </span><span class="s1">remove: hostRemove</span><span class="s2">, </span><span class="s1">patchProp: hostPatchProp</span><span class="s2">, </span><span class="s1">createElement: hostCreateElement</span><span class="s2">, </span><span class="s1">createText: hostCreateText</span><span class="s2">, </span><span class="s1">createComment: hostCreateComment</span><span class="s2">, </span><span class="s1">setText: hostSetText</span><span class="s2">, </span><span class="s1">setElementText: hostSetElementText</span><span class="s2">, </span><span class="s1">parentNode: hostParentNode</span><span class="s2">, </span><span class="s1">nextSibling: hostNextSibling</span><span class="s2">, </span><span class="s1">setScopeId: hostSetScopeId = NOOP</span><span class="s2">, </span><span class="s1">insertStaticContent: hostInsertStaticContent } = options</span><span class="s2">;</span>
    <span class="s5">// Note: functions inside this closure should use `const xxx = () =&gt; {}`</span>
    <span class="s5">// style in order to prevent being inlined by minifiers.</span>
    <span class="s2">const </span><span class="s1">patch = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor = </span><span class="s2">null, </span><span class="s1">parentComponent = </span><span class="s2">null, </span><span class="s1">parentSuspense = </span><span class="s2">null, </span><span class="s1">isSVG = </span><span class="s2">false, </span><span class="s1">slotScopeIds = </span><span class="s2">null, </span><span class="s1">optimized = isHmrUpdating ? </span><span class="s2">false </span><span class="s1">: !!n2.dynamicChildren) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(n1 === n2) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s5">// patching &amp; not same type, unmount old tree</span>
        <span class="s2">if </span><span class="s1">(n1 &amp;&amp; !isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
            <span class="s1">anchor = getNextHostNode(n1)</span><span class="s2">;</span>
            <span class="s1">unmount(n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">n1 = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(n2.patchFlag === -</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s1">) {</span>
            <span class="s1">optimized = </span><span class="s2">false;</span>
            <span class="s1">n2.dynamicChildren = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">shapeFlag } = n2</span><span class="s2">;</span>
        <span class="s2">switch </span><span class="s1">(type) {</span>
            <span class="s2">case </span><span class="s1">Text:</span>
                <span class="s1">processText(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Comment:</span>
                <span class="s1">processCommentNode(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Static:</span>
                <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">mountStaticNode(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">patchStaticNode(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s1">Fragment:</span>
                <span class="s1">processFragment(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">break;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */</span><span class="s1">) {</span>
                    <span class="s1">processElement(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
                    <span class="s1">processComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">) {</span>
                    <span class="s1">type.process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
                    <span class="s1">type.process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">'Invalid VNode type:'</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">type}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// set ref</span>
        <span class="s2">if </span><span class="s1">(ref != </span><span class="s2">null </span><span class="s1">&amp;&amp; parentComponent) {</span>
            <span class="s1">setRef(ref</span><span class="s2">, </span><span class="s1">n1 &amp;&amp; n1.ref</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">n2 || n1</span><span class="s2">, </span><span class="s1">!n2)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">processText = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">hostInsert((n2.el = hostCreateText(n2.children))</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">el = (n2.el = n1.el)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(n2.children !== n1.children) {</span>
                <span class="s1">hostSetText(el</span><span class="s2">, </span><span class="s1">n2.children)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">processCommentNode = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">hostInsert((n2.el = hostCreateComment(n2.children || </span><span class="s3">''</span><span class="s1">))</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// there's no support for dynamic comments</span>
            <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mountStaticNode = (n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
        <span class="s1">[n2.el</span><span class="s2">, </span><span class="s1">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">n2.el</span><span class="s2">, </span><span class="s1">n2.anchor)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Dev / HMR only</span>
     <span class="s0">*/</span>
    <span class="s2">const </span><span class="s1">patchStaticNode = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
        <span class="s5">// static nodes are only patched during dev for HMR</span>
        <span class="s2">if </span><span class="s1">(n2.children !== n1.children) {</span>
            <span class="s2">const </span><span class="s1">anchor = hostNextSibling(n1.anchor)</span><span class="s2">;</span>
            <span class="s5">// remove existing</span>
            <span class="s1">removeStaticNode(n1)</span><span class="s2">;</span>
            <span class="s1">[n2.el</span><span class="s2">, </span><span class="s1">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
            <span class="s1">n2.anchor = n1.anchor</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">moveStaticNode = ({ el</span><span class="s2">, </span><span class="s1">anchor }</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling) =&gt; {</span>
        <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(el &amp;&amp; el !== anchor) {</span>
            <span class="s1">next = hostNextSibling(el)</span><span class="s2">;</span>
            <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling)</span><span class="s2">;</span>
            <span class="s1">el = next</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">hostInsert(anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">removeStaticNode = ({ el</span><span class="s2">, </span><span class="s1">anchor }) =&gt; {</span>
        <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(el &amp;&amp; el !== anchor) {</span>
            <span class="s1">next = hostNextSibling(el)</span><span class="s2">;</span>
            <span class="s1">hostRemove(el)</span><span class="s2">;</span>
            <span class="s1">el = next</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">hostRemove(anchor)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">processElement = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">isSVG = isSVG || n2.type === </span><span class="s3">'svg'</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">mountElement(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">patchElement(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mountElement = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">let </span><span class="s1">el</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">transition</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
        <span class="s1">el = vnode.el = hostCreateElement(vnode.type</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">props &amp;&amp; props.is</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
        <span class="s5">// mount children first, since some props may rely on child content</span>
        <span class="s5">// being already rendered, e.g. `&lt;select value&gt;`</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">) {</span>
            <span class="s1">hostSetElementText(el</span><span class="s2">, </span><span class="s1">vnode.children)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
            <span class="s1">mountChildren(vnode.children</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG &amp;&amp; type !== </span><span class="s3">'foreignObject'</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(dirs) {</span>
            <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'created'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// scopeId</span>
        <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">vnode.scopeId</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
        <span class="s5">// props</span>
        <span class="s2">if </span><span class="s1">(props) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
                <span class="s2">if </span><span class="s1">(key !== </span><span class="s3">'value' </span><span class="s1">&amp;&amp; !isReservedProp(key)) {</span>
                    <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, null, </span><span class="s1">props[key]</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">/**</span>
             <span class="s0">* Special case for setting value on DOM elements:</span>
             <span class="s0">* - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)</span>
             <span class="s0">* - it needs to be forced (#1471)</span>
             <span class="s0">* #2353 proposes adding another renderer option to configure this, but</span>
             <span class="s0">* the properties affects are so finite it is worth special casing it</span>
             <span class="s0">* here to reduce the complexity. (Special casing it also should not</span>
             <span class="s0">* affect non-DOM renderers)</span>
             <span class="s0">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s3">'value' </span><span class="s2">in </span><span class="s1">props) {</span>
                <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, null, </span><span class="s1">props.value)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((vnodeHook = props.onVnodeBeforeMount)) {</span>
                <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">Object.defineProperty(el</span><span class="s2">, </span><span class="s3">'__vnode'</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">value: vnode</span><span class="s2">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">Object.defineProperty(el</span><span class="s2">, </span><span class="s3">'__vueParentComponent'</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">value: parentComponent</span><span class="s2">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(dirs) {</span>
            <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'beforeMount'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved</span>
        <span class="s5">// #1689 For inside suspense + suspense resolved case, just call it</span>
        <span class="s2">const </span><span class="s1">needCallTransitionHooks = (!parentSuspense || (parentSuspense &amp;&amp; !parentSuspense.pendingBranch)) &amp;&amp;</span>
            <span class="s1">transition &amp;&amp;</span>
            <span class="s1">!transition.persisted</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(needCallTransitionHooks) {</span>
            <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((vnodeHook = props &amp;&amp; props.onVnodeMounted) ||</span>
            <span class="s1">needCallTransitionHooks ||</span>
            <span class="s1">dirs) {</span>
            <span class="s1">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                <span class="s1">needCallTransitionHooks &amp;&amp; transition.enter(el)</span><span class="s2">;</span>
                <span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'mounted'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setScopeId = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">scopeId</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(scopeId) {</span>
            <span class="s1">hostSetScopeId(el</span><span class="s2">, </span><span class="s1">scopeId)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(slotScopeIds) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; slotScopeIds.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">hostSetScopeId(el</span><span class="s2">, </span><span class="s1">slotScopeIds[i])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parentComponent) {</span>
            <span class="s2">let </span><span class="s1">subTree = parentComponent.subTree</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(subTree.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">subTree.patchFlag &amp; </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">) {</span>
                <span class="s1">subTree =</span>
                    <span class="s1">filterSingleRoot(subTree.children) || subTree</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(vnode === subTree) {</span>
                <span class="s2">const </span><span class="s1">parentVNode = parentComponent.vnode</span><span class="s2">;</span>
                <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">parentVNode</span><span class="s2">, </span><span class="s1">parentVNode.scopeId</span><span class="s2">, </span><span class="s1">parentVNode.slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent.parent)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mountChildren = (children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">) =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = start</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">child = (children[i] = optimized</span>
                <span class="s1">? cloneIfMounted(children[i])</span>
                <span class="s1">: normalizeVNode(children[i]))</span><span class="s2">;</span>
            <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">patchElement = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">el = (n2.el = n1.el)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">dirs } = n2</span><span class="s2">;</span>
        <span class="s5">// #1426 take the old vnode's patch flag into account since user may clone a</span>
        <span class="s5">// compiler-generated vnode, which de-opts to FULL_PROPS</span>
        <span class="s1">patchFlag |= n1.patchFlag &amp; </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">oldProps = n1.props || EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">newProps = n2.props || EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
        <span class="s5">// disable recurse in beforeUpdate hooks</span>
        <span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((vnodeHook = newProps.onVnodeBeforeUpdate)) {</span>
            <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">n1)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(dirs) {</span>
            <span class="s1">invokeDirectiveHook(n2</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'beforeUpdate'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
            <span class="s5">// HMR updated, force full diff</span>
            <span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">optimized = </span><span class="s2">false;</span>
            <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">areChildrenSVG = isSVG &amp;&amp; n2.type !== </span><span class="s3">'foreignObject'</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
            <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">areChildrenSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
                <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!optimized) {</span>
            <span class="s5">// full diff</span>
            <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">areChildrenSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s5">// the presence of a patchFlag means this element's render code was</span>
            <span class="s5">// generated by the compiler and can take the fast path.</span>
            <span class="s5">// in this path old node and new node are guaranteed to have the same shape</span>
            <span class="s5">// (i.e. at the exact same position in the source template)</span>
            <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s1">) {</span>
                <span class="s5">// element props contain dynamic keys, full diff needed</span>
                <span class="s1">patchProps(el</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// class</span>
                <span class="s5">// this flag is matched when the element has dynamic class bindings.</span>
                <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">2 </span><span class="s5">/* PatchFlags.CLASS */</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(oldProps.class !== newProps.class) {</span>
                        <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">'class'</span><span class="s2">, null, </span><span class="s1">newProps.class</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s5">// style</span>
                <span class="s5">// this flag is matched when the element has dynamic style bindings</span>
                <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">4 </span><span class="s5">/* PatchFlags.STYLE */</span><span class="s1">) {</span>
                    <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">'style'</span><span class="s2">, </span><span class="s1">oldProps.style</span><span class="s2">, </span><span class="s1">newProps.style</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// props</span>
                <span class="s5">// This flag is matched when the element has dynamic prop/attr bindings</span>
                <span class="s5">// other than class and style. The keys of dynamic prop/attrs are saved for</span>
                <span class="s5">// faster iteration.</span>
                <span class="s5">// Note dynamic keys like :[foo]=&quot;bar&quot; will cause this optimization to</span>
                <span class="s5">// bail out and go through a full diff because we need to unset the old key</span>
                <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s1">) {</span>
                    <span class="s5">// if the flag is present then dynamicProps must be non-null</span>
                    <span class="s2">const </span><span class="s1">propsToUpdate = n2.dynamicProps</span><span class="s2">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; propsToUpdate.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                        <span class="s2">const </span><span class="s1">key = propsToUpdate[i]</span><span class="s2">;</span>
                        <span class="s2">const </span><span class="s1">prev = oldProps[key]</span><span class="s2">;</span>
                        <span class="s2">const </span><span class="s1">next = newProps[key]</span><span class="s2">;</span>
                        <span class="s5">// #1471 force patch value</span>
                        <span class="s2">if </span><span class="s1">(next !== prev || key === </span><span class="s3">'value'</span><span class="s1">) {</span>
                            <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">n1.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// text</span>
            <span class="s5">// This flag is matched when the element has only dynamic text children.</span>
            <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(n1.children !== n2.children) {</span>
                    <span class="s1">hostSetElementText(el</span><span class="s2">, </span><span class="s1">n2.children)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!optimized &amp;&amp; dynamicChildren == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s5">// unoptimized, full diff</span>
            <span class="s1">patchProps(el</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((vnodeHook = newProps.onVnodeUpdated) || dirs) {</span>
            <span class="s1">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">n1)</span><span class="s2">;</span>
                <span class="s1">dirs &amp;&amp; invokeDirectiveHook(n2</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'updated'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// The fast path for blocks.</span>
    <span class="s2">const </span><span class="s1">patchBlockChildren = (oldChildren</span><span class="s2">, </span><span class="s1">newChildren</span><span class="s2">, </span><span class="s1">fallbackContainer</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds) =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; newChildren.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">oldVNode = oldChildren[i]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">newVNode = newChildren[i]</span><span class="s2">;</span>
            <span class="s5">// Determine the container (parent element) for the patch.</span>
            <span class="s2">const </span><span class="s1">container = </span>
            <span class="s5">// oldVNode may be an errored async setup() component inside Suspense</span>
            <span class="s5">// which will not have a mounted element</span>
            <span class="s1">oldVNode.el &amp;&amp;</span>
                <span class="s5">// - In the case of a Fragment, we need to provide the actual parent</span>
                <span class="s5">// of the Fragment itself so it can move its children.</span>
                <span class="s1">(oldVNode.type === Fragment ||</span>
                    <span class="s5">// - In the case of different nodes, there is going to be a replacement</span>
                    <span class="s5">// which also requires the correct parent container</span>
                    <span class="s1">!isSameVNodeType(oldVNode</span><span class="s2">, </span><span class="s1">newVNode) ||</span>
                    <span class="s5">// - In the case of a component, it could contain anything.</span>
                    <span class="s1">oldVNode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */ </span><span class="s1">| </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">))</span>
                <span class="s1">? hostParentNode(oldVNode.el)</span>
                <span class="s1">: </span><span class="s5">// In other cases, the parent container is not actually used so we</span>
                    <span class="s5">// just pass the block element here to avoid a DOM parentNode call.</span>
                    <span class="s1">fallbackContainer</span><span class="s2">;</span>
            <span class="s1">patch(oldVNode</span><span class="s2">, </span><span class="s1">newVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">patchProps = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(oldProps !== newProps) {</span>
            <span class="s2">if </span><span class="s1">(oldProps !== EMPTY_OBJ) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">oldProps) {</span>
                    <span class="s2">if </span><span class="s1">(!isReservedProp(key) &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">newProps)) {</span>
                        <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">oldProps[key]</span><span class="s2">, null, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">newProps) {</span>
                <span class="s5">// empty string is not valid prop</span>
                <span class="s2">if </span><span class="s1">(isReservedProp(key))</span>
                    <span class="s2">continue;</span>
                <span class="s2">const </span><span class="s1">next = newProps[key]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">prev = oldProps[key]</span><span class="s2">;</span>
                <span class="s5">// defer patching value</span>
                <span class="s2">if </span><span class="s1">(next !== prev &amp;&amp; key !== </span><span class="s3">'value'</span><span class="s1">) {</span>
                    <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s3">'value' </span><span class="s2">in </span><span class="s1">newProps) {</span>
                <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">, </span><span class="s1">oldProps.value</span><span class="s2">, </span><span class="s1">newProps.value)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">processFragment = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(</span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(</span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">slotScopeIds: fragmentSlotScopeIds } = n2</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s5">// #5523 dev root fragment may inherit directives</span>
            <span class="s1">(isHmrUpdating || patchFlag &amp; </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">)) {</span>
            <span class="s5">// HMR updated / Dev root fragment (w/ comments), force full diff</span>
            <span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">optimized = </span><span class="s2">false;</span>
            <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s5">// check if this is a slot fragment with :slotted scope ids</span>
        <span class="s2">if </span><span class="s1">(fragmentSlotScopeIds) {</span>
            <span class="s1">slotScopeIds = slotScopeIds</span>
                <span class="s1">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s1">: fragmentSlotScopeIds</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">hostInsert(fragmentStartAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s1">hostInsert(fragmentEndAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s5">// a fragment can only have array children</span>
            <span class="s5">// since they are either generated by the compiler, or implicitly created</span>
            <span class="s5">// from arrays.</span>
            <span class="s1">mountChildren(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">fragmentEndAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">patchFlag &amp; </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">dynamicChildren &amp;&amp;</span>
                <span class="s5">// #2715 the previous fragment could've been a BAILed one as a result</span>
                <span class="s5">// of renderSlot() with no valid children</span>
                <span class="s1">n1.dynamicChildren) {</span>
                <span class="s5">// a stable fragment (template root or &lt;template v-for&gt;) doesn't need to</span>
                <span class="s5">// patch children order, but it may contain dynamicChildren.</span>
                <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
                    <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(</span>
                <span class="s5">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span>
                <span class="s5">//  get moved around. Make sure all root level vnodes inherit el.</span>
                <span class="s5">// #2134 or if it's a component root, it may also get moved around</span>
                <span class="s5">// as the component is being moved.</span>
                <span class="s1">n2.key != </span><span class="s2">null </span><span class="s1">||</span>
                    <span class="s1">(parentComponent &amp;&amp; n2 === parentComponent.subTree)) {</span>
                    <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, true </span><span class="s5">/* shallow */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// keyed / unkeyed, or manual fragments.</span>
                <span class="s5">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span>
                <span class="s5">// each child is guaranteed to be a block so the fragment will never</span>
                <span class="s5">// have dynamicChildren.</span>
                <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">fragmentEndAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">processComponent = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">n2.slotScopeIds = slotScopeIds</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(n2.shapeFlag &amp; </span><span class="s4">512 </span><span class="s5">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">) {</span>
                <span class="s1">parentComponent.ctx.activate(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">mountComponent(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">updateComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mountComponent = (initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">instance = (initialVNode.component = createComponentInstance(initialVNode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(instance.type.__hmrId) {</span>
            <span class="s1">registerHMR(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">pushWarningContext(initialVNode)</span><span class="s2">;</span>
            <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`mount`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// inject renderer internals for keepAlive</span>
        <span class="s2">if </span><span class="s1">(isKeepAlive(initialVNode)) {</span>
            <span class="s1">instance.ctx.renderer = internals</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// resolve props and slots for setup context</span>
        <span class="s1">{</span>
            <span class="s1">{</span>
                <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`init`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">setupComponent(instance)</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`init`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// setup() is async. This component relies on async logic to be resolved</span>
        <span class="s5">// before proceeding</span>
        <span class="s2">if </span><span class="s1">(instance.asyncDep) {</span>
            <span class="s1">parentSuspense &amp;&amp; parentSuspense.registerDep(instance</span><span class="s2">, </span><span class="s1">setupRenderEffect)</span><span class="s2">;</span>
            <span class="s5">// Give it a placeholder if this is not hydration</span>
            <span class="s5">// TODO handle self-defined fallback</span>
            <span class="s2">if </span><span class="s1">(!initialVNode.el) {</span>
                <span class="s2">const </span><span class="s1">placeholder = (instance.subTree = createVNode(Comment))</span><span class="s2">;</span>
                <span class="s1">processCommentNode(</span><span class="s2">null, </span><span class="s1">placeholder</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">setupRenderEffect(instance</span><span class="s2">, </span><span class="s1">initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">popWarningContext()</span><span class="s2">;</span>
            <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`mount`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">updateComponent = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">instance = (n2.component = n1.component)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(shouldUpdateComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)) {</span>
            <span class="s2">if </span><span class="s1">(instance.asyncDep &amp;&amp;</span>
                <span class="s1">!instance.asyncResolved) {</span>
                <span class="s5">// async &amp; still pending - just update props and slots</span>
                <span class="s5">// since the component's reactive effect for render isn't set-up yet</span>
                <span class="s1">{</span>
                    <span class="s1">pushWarningContext(n2)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">updateComponentPreRender(instance</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">popWarningContext()</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// normal update</span>
                <span class="s1">instance.next = n2</span><span class="s2">;</span>
                <span class="s5">// in case the child component is also queued, remove it to avoid</span>
                <span class="s5">// double updating the same child component in the same flush.</span>
                <span class="s1">invalidateJob(instance.update)</span><span class="s2">;</span>
                <span class="s5">// instance.update is the reactive effect.</span>
                <span class="s1">instance.update()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// no update needed. just copy over properties</span>
            <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
            <span class="s1">instance.vnode = n2</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setupRenderEffect = (instance</span><span class="s2">, </span><span class="s1">initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">const </span><span class="s1">componentUpdateFn = () =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!instance.isMounted) {</span>
                <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">props } = initialVNode</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">{ bm</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">parent } = instance</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><span class="s2">;</span>
                <span class="s1">toggleRecurse(instance</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s5">// beforeMount hook</span>
                <span class="s2">if </span><span class="s1">(bm) {</span>
                    <span class="s1">invokeArrayFns(bm)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// onVnodeBeforeMount</span>
                <span class="s2">if </span><span class="s1">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                    <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">initialVNode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(el &amp;&amp; hydrateNode) {</span>
                    <span class="s5">// vnode has adopted host node - perform hydration instead of mount.</span>
                    <span class="s2">const </span><span class="s1">hydrateSubTree = () =&gt; {</span>
                        <span class="s1">{</span>
                            <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">instance.subTree = renderComponentRoot(instance)</span><span class="s2">;</span>
                        <span class="s1">{</span>
                            <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">{</span>
                            <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`hydrate`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">hydrateNode(el</span><span class="s2">, </span><span class="s1">instance.subTree</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">{</span>
                            <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`hydrate`</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isAsyncWrapperVNode) {</span>
                        <span class="s1">initialVNode.type.__asyncLoader().then(</span>
                        <span class="s5">// note: we are moving the render call into an async callback,</span>
                        <span class="s5">// which means it won't track dependencies - but it's ok because</span>
                        <span class="s5">// a server-rendered async wrapper is already in resolved state</span>
                        <span class="s5">// and it will never need to change.</span>
                        <span class="s1">() =&gt; !instance.isUnmounted &amp;&amp; hydrateSubTree())</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">hydrateSubTree()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">{</span>
                        <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">const </span><span class="s1">subTree = (instance.subTree = renderComponentRoot(instance))</span><span class="s2">;</span>
                    <span class="s1">{</span>
                        <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">{</span>
                        <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">subTree</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                    <span class="s1">{</span>
                        <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">initialVNode.el = subTree.el</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// mounted hook</span>
                <span class="s2">if </span><span class="s1">(m) {</span>
                    <span class="s1">queuePostRenderEffect(m</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// onVnodeMounted</span>
                <span class="s2">if </span><span class="s1">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeMounted)) {</span>
                    <span class="s2">const </span><span class="s1">scopedInitialVNode = initialVNode</span><span class="s2">;</span>
                    <span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">scopedInitialVNode)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// activated hook for keep-alive roots.</span>
                <span class="s5">// #1742 activated hook must be accessed after first render</span>
                <span class="s5">// since the hook may be injected by a child keep-alive</span>
                <span class="s2">if </span><span class="s1">(initialVNode.shapeFlag &amp; </span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ </span><span class="s1">||</span>
                    <span class="s1">(parent &amp;&amp;</span>
                        <span class="s1">isAsyncWrapper(parent.vnode) &amp;&amp;</span>
                        <span class="s1">parent.vnode.shapeFlag &amp; </span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">)) {</span>
                    <span class="s1">instance.a &amp;&amp; queuePostRenderEffect(instance.a</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">instance.isMounted = </span><span class="s2">true;</span>
                <span class="s1">{</span>
                    <span class="s1">devtoolsComponentAdded(instance)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// #2458: deference mount-only object parameters to prevent memleaks</span>
                <span class="s1">initialVNode = container = anchor = </span><span class="s2">null;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// updateComponent</span>
                <span class="s5">// This is triggered by mutation of component's own state (next: null)</span>
                <span class="s5">// OR parent calling processComponent (next: VNode)</span>
                <span class="s2">let </span><span class="s1">{ next</span><span class="s2">, </span><span class="s1">bu</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">vnode } = instance</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">originNext = next</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">pushWarningContext(next || instance.vnode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// Disallow component effect recursion during pre-lifecycle hooks.</span>
                <span class="s1">toggleRecurse(instance</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(next) {</span>
                    <span class="s1">next.el = vnode.el</span><span class="s2">;</span>
                    <span class="s1">updateComponentPreRender(instance</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">next = vnode</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// beforeUpdate hook</span>
                <span class="s2">if </span><span class="s1">(bu) {</span>
                    <span class="s1">invokeArrayFns(bu)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// onVnodeBeforeUpdate</span>
                <span class="s2">if </span><span class="s1">((vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) {</span>
                    <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s5">// render</span>
                <span class="s1">{</span>
                    <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">nextTree = renderComponentRoot(instance)</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">prevTree = instance.subTree</span><span class="s2">;</span>
                <span class="s1">instance.subTree = nextTree</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">patch(prevTree</span><span class="s2">, </span><span class="s1">nextTree</span><span class="s2">, </span>
                <span class="s5">// parent may have changed if it's in a teleport</span>
                <span class="s1">hostParentNode(prevTree.el)</span><span class="s2">, </span>
                <span class="s5">// anchor may have changed if it's in a fragment</span>
                <span class="s1">getNextHostNode(prevTree)</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">next.el = nextTree.el</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(originNext === </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s5">// self-triggered update. In case of HOC, update parent component</span>
                    <span class="s5">// vnode el. HOC is indicated by parent instance's subTree pointing</span>
                    <span class="s5">// to child component's vnode</span>
                    <span class="s1">updateHOCHostEl(instance</span><span class="s2">, </span><span class="s1">nextTree.el)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// updated hook</span>
                <span class="s2">if </span><span class="s1">(u) {</span>
                    <span class="s1">queuePostRenderEffect(u</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// onVnodeUpdated</span>
                <span class="s2">if </span><span class="s1">((vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated)) {</span>
                    <span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">{</span>
                    <span class="s1">devtoolsComponentUpdated(instance)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">{</span>
                    <span class="s1">popWarningContext()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s5">// create reactive effect for rendering</span>
        <span class="s2">const </span><span class="s1">effect = (instance.effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(componentUpdateFn</span><span class="s2">, </span><span class="s1">() =&gt; queueJob(update)</span><span class="s2">, </span><span class="s1">instance.scope </span><span class="s5">// track it in component's effect scope</span>
        <span class="s1">))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">update = (instance.update = () =&gt; effect.run())</span><span class="s2">;</span>
        <span class="s1">update.id = instance.uid</span><span class="s2">;</span>
        <span class="s5">// allowRecurse</span>
        <span class="s5">// #1801, #2043 component render effects should allow recursive updates</span>
        <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">effect.onTrack = instance.rtc</span>
                <span class="s1">? e =&gt; invokeArrayFns(instance.rtc</span><span class="s2">, </span><span class="s1">e)</span>
                <span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">effect.onTrigger = instance.rtg</span>
                <span class="s1">? e =&gt; invokeArrayFns(instance.rtg</span><span class="s2">, </span><span class="s1">e)</span>
                <span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">update.ownerInstance = instance</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">update()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">updateComponentPreRender = (instance</span><span class="s2">, </span><span class="s1">nextVNode</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">nextVNode.component = instance</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">prevProps = instance.vnode.props</span><span class="s2">;</span>
        <span class="s1">instance.vnode = nextVNode</span><span class="s2">;</span>
        <span class="s1">instance.next = </span><span class="s2">null;</span>
        <span class="s1">updateProps(instance</span><span class="s2">, </span><span class="s1">nextVNode.props</span><span class="s2">, </span><span class="s1">prevProps</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">updateSlots(instance</span><span class="s2">, </span><span class="s1">nextVNode.children</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">pauseTracking()</span><span class="s2">;</span>
        <span class="s5">// props update may have triggered pre-flush watchers.</span>
        <span class="s5">// flush them before the render update.</span>
        <span class="s1">flushPreFlushCbs()</span><span class="s2">;</span>
        <span class="s1">resetTracking()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">patchChildren = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
        <span class="s2">const </span><span class="s1">c1 = n1 &amp;&amp; n1.children</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">prevShapeFlag = n1 ? n1.shapeFlag : </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">c2 = n2.children</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">shapeFlag } = n2</span><span class="s2">;</span>
        <span class="s5">// fast path</span>
        <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s1">) {</span>
                <span class="s5">// this could be either fully-keyed or mixed (some keyed some not)</span>
                <span class="s5">// presence of patchFlag means children are guaranteed to be arrays</span>
                <span class="s1">patchKeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(patchFlag &amp; </span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s1">) {</span>
                <span class="s5">// unkeyed</span>
                <span class="s1">patchUnkeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// children has 3 possibilities: text, array or no children.</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">) {</span>
            <span class="s5">// text children fast path</span>
            <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(c2 !== c1) {</span>
                <span class="s1">hostSetElementText(container</span><span class="s2">, </span><span class="s1">c2)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                <span class="s5">// prev children was array</span>
                <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                    <span class="s5">// two arrays, cannot assume anything, do full diff</span>
                    <span class="s1">patchKeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s5">// no new children, just unmount old</span>
                    <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// prev children was text OR null</span>
                <span class="s5">// new children is array OR null</span>
                <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">) {</span>
                    <span class="s1">hostSetElementText(container</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// mount new if array</span>
                <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                    <span class="s1">mountChildren(c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">patchUnkeyedChildren = (c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s1">c1 = c1 || EMPTY_ARR</span><span class="s2">;</span>
        <span class="s1">c2 = c2 || EMPTY_ARR</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">oldLength = c1.length</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">newLength = c2.length</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">commonLength = Math.min(oldLength</span><span class="s2">, </span><span class="s1">newLength)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">i</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; commonLength</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">nextChild = (c2[i] = optimized</span>
                <span class="s1">? cloneIfMounted(c2[i])</span>
                <span class="s1">: normalizeVNode(c2[i]))</span><span class="s2">;</span>
            <span class="s1">patch(c1[i]</span><span class="s2">, </span><span class="s1">nextChild</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(oldLength &gt; newLength) {</span>
            <span class="s5">// remove old</span>
            <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true, false, </span><span class="s1">commonLength)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// mount new</span>
            <span class="s1">mountChildren(c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">commonLength)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// can be all-keyed or mixed</span>
    <span class="s2">const </span><span class="s1">patchKeyedChildren = (c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
        <span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">l2 = c2.length</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">e1 = c1.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s5">// prev ending index</span>
        <span class="s2">let </span><span class="s1">e2 = l2 - </span><span class="s4">1</span><span class="s2">; </span><span class="s5">// next ending index</span>
        <span class="s5">// 1. sync from start</span>
        <span class="s5">// (a b) c</span>
        <span class="s5">// (a b) d e</span>
        <span class="s2">while </span><span class="s1">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s2">const </span><span class="s1">n1 = c1[i]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">n2 = (c2[i] = optimized</span>
                <span class="s1">? cloneIfMounted(c2[i])</span>
                <span class="s1">: normalizeVNode(c2[i]))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
                <span class="s1">patch(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s1">i++</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// 2. sync from end</span>
        <span class="s5">// a (b c)</span>
        <span class="s5">// d e (b c)</span>
        <span class="s2">while </span><span class="s1">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s2">const </span><span class="s1">n1 = c1[e1]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">n2 = (c2[e2] = optimized</span>
                <span class="s1">? cloneIfMounted(c2[e2])</span>
                <span class="s1">: normalizeVNode(c2[e2]))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
                <span class="s1">patch(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s1">e1--</span><span class="s2">;</span>
            <span class="s1">e2--</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// 3. common sequence + mount</span>
        <span class="s5">// (a b)</span>
        <span class="s5">// (a b) c</span>
        <span class="s5">// i = 2, e1 = 1, e2 = 2</span>
        <span class="s5">// (a b)</span>
        <span class="s5">// c (a b)</span>
        <span class="s5">// i = 0, e1 = -1, e2 = 0</span>
        <span class="s2">if </span><span class="s1">(i &gt; e1) {</span>
            <span class="s2">if </span><span class="s1">(i &lt;= e2) {</span>
                <span class="s2">const </span><span class="s1">nextPos = e2 + </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor</span><span class="s2">;</span>
                <span class="s2">while </span><span class="s1">(i &lt;= e2) {</span>
                    <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">(c2[i] = optimized</span>
                        <span class="s1">? cloneIfMounted(c2[i])</span>
                        <span class="s1">: normalizeVNode(c2[i]))</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                    <span class="s1">i++</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// 4. common sequence + unmount</span>
        <span class="s5">// (a b) c</span>
        <span class="s5">// (a b)</span>
        <span class="s5">// i = 2, e1 = 2, e2 = 1</span>
        <span class="s5">// a (b c)</span>
        <span class="s5">// (b c)</span>
        <span class="s5">// i = 0, e1 = 0, e2 = -1</span>
        <span class="s2">else if </span><span class="s1">(i &gt; e2) {</span>
            <span class="s2">while </span><span class="s1">(i &lt;= e1) {</span>
                <span class="s1">unmount(c1[i]</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">i++</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// 5. unknown sequence</span>
        <span class="s5">// [i ... e1 + 1]: a b [c d e] f g</span>
        <span class="s5">// [i ... e2 + 1]: a b [e d c h] f g</span>
        <span class="s5">// i = 2, e1 = 4, e2 = 5</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">s1 = i</span><span class="s2">; </span><span class="s5">// prev starting index</span>
            <span class="s2">const </span><span class="s1">s2 = i</span><span class="s2">; </span><span class="s5">// next starting index</span>
            <span class="s5">// 5.1 build key:index map for newChildren</span>
            <span class="s2">const </span><span class="s1">keyToNewIndexMap = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(i = s2</span><span class="s2">; </span><span class="s1">i &lt;= e2</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">nextChild = (c2[i] = optimized</span>
                    <span class="s1">? cloneIfMounted(c2[i])</span>
                    <span class="s1">: normalizeVNode(c2[i]))</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(nextChild.key != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(keyToNewIndexMap.has(nextChild.key)) {</span>
                        <span class="s1">warn(</span><span class="s3">`Duplicate keys found during update:`</span><span class="s2">, </span><span class="s1">JSON.stringify(nextChild.key)</span><span class="s2">, </span><span class="s3">`Make sure keys are unique.`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">keyToNewIndexMap.set(nextChild.key</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// 5.2 loop through old children left to be patched and try to patch</span>
            <span class="s5">// matching nodes &amp; remove nodes that are no longer present</span>
            <span class="s2">let </span><span class="s1">j</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">patched = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">toBePatched = e2 - s2 + </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">moved = </span><span class="s2">false;</span>
            <span class="s5">// used to track whether any node has moved</span>
            <span class="s2">let </span><span class="s1">maxNewIndexSoFar = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s5">// works as Map&lt;newIndex, oldIndex&gt;</span>
            <span class="s5">// Note that oldIndex is offset by +1</span>
            <span class="s5">// and oldIndex = 0 is a special value indicating the new node has</span>
            <span class="s5">// no corresponding old node.</span>
            <span class="s5">// used for determining longest stable subsequence</span>
            <span class="s2">const </span><span class="s1">newIndexToOldIndexMap = </span><span class="s2">new </span><span class="s1">Array(toBePatched)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; toBePatched</span><span class="s2">; </span><span class="s1">i++)</span>
                <span class="s1">newIndexToOldIndexMap[i] = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(i = s1</span><span class="s2">; </span><span class="s1">i &lt;= e1</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">prevChild = c1[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(patched &gt;= toBePatched) {</span>
                    <span class="s5">// all new children have been patched so this can only be a removal</span>
                    <span class="s1">unmount(prevChild</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">newIndex</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(prevChild.key != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">newIndex = keyToNewIndexMap.get(prevChild.key)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s5">// key-less node, try to locate a key-less node of the same type</span>
                    <span class="s2">for </span><span class="s1">(j = s2</span><span class="s2">; </span><span class="s1">j &lt;= e2</span><span class="s2">; </span><span class="s1">j++) {</span>
                        <span class="s2">if </span><span class="s1">(newIndexToOldIndexMap[j - s2] === </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">isSameVNodeType(prevChild</span><span class="s2">, </span><span class="s1">c2[j])) {</span>
                            <span class="s1">newIndex = j</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(newIndex === undefined) {</span>
                    <span class="s1">unmount(prevChild</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">newIndexToOldIndexMap[newIndex - s2] = i + </span><span class="s4">1</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(newIndex &gt;= maxNewIndexSoFar) {</span>
                        <span class="s1">maxNewIndexSoFar = newIndex</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">moved = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                    <span class="s1">patch(prevChild</span><span class="s2">, </span><span class="s1">c2[newIndex]</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                    <span class="s1">patched++</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// 5.3 move and mount</span>
            <span class="s5">// generate longest stable subsequence only when nodes have moved</span>
            <span class="s2">const </span><span class="s1">increasingNewIndexSequence = moved</span>
                <span class="s1">? getSequence(newIndexToOldIndexMap)</span>
                <span class="s1">: EMPTY_ARR</span><span class="s2">;</span>
            <span class="s1">j = increasingNewIndexSequence.length - </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s5">// looping backwards so that we can use last patched node as anchor</span>
            <span class="s2">for </span><span class="s1">(i = toBePatched - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
                <span class="s2">const </span><span class="s1">nextIndex = s2 + i</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">nextChild = c2[nextIndex]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">anchor = nextIndex + </span><span class="s4">1 </span><span class="s1">&lt; l2 ? c2[nextIndex + </span><span class="s4">1</span><span class="s1">].el : parentAnchor</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(newIndexToOldIndexMap[i] === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s5">// mount new</span>
                    <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">nextChild</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(moved) {</span>
                    <span class="s5">// move if:</span>
                    <span class="s5">// There is no stable subsequence (e.g. a reverse)</span>
                    <span class="s5">// OR current node is not among the stable sequence</span>
                    <span class="s2">if </span><span class="s1">(j &lt; </span><span class="s4">0 </span><span class="s1">|| i !== increasingNewIndexSequence[j]) {</span>
                        <span class="s1">move(nextChild</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* MoveType.REORDER */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">j--</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">move = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType</span><span class="s2">, </span><span class="s1">parentSuspense = </span><span class="s2">null</span><span class="s1">) =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">transition</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">shapeFlag } = vnode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
            <span class="s1">move(vnode.component.subTree</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
            <span class="s1">vnode.suspense.move(container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">) {</span>
            <span class="s1">type.move(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === Fragment) {</span>
            <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">move(children[i]</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">hostInsert(vnode.anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === Static) {</span>
            <span class="s1">moveStaticNode(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s5">// single nodes</span>
        <span class="s2">const </span><span class="s1">needTransition = moveType !== </span><span class="s4">2 </span><span class="s5">/* MoveType.REORDER */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">transition</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(needTransition) {</span>
            <span class="s2">if </span><span class="s1">(moveType === </span><span class="s4">0 </span><span class="s5">/* MoveType.ENTER */</span><span class="s1">) {</span>
                <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
                <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
                <span class="s1">queuePostRenderEffect(() =&gt; transition.enter(el)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">{ leave</span><span class="s2">, </span><span class="s1">delayLeave</span><span class="s2">, </span><span class="s1">afterLeave } = transition</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">remove = () =&gt; hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">performLeave = () =&gt; {</span>
                    <span class="s1">leave(el</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
                        <span class="s1">remove()</span><span class="s2">;</span>
                        <span class="s1">afterLeave &amp;&amp; afterLeave()</span><span class="s2">;</span>
                    <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(delayLeave) {</span>
                    <span class="s1">delayLeave(el</span><span class="s2">, </span><span class="s1">remove</span><span class="s2">, </span><span class="s1">performLeave)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">performLeave()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">unmount = (vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove = </span><span class="s2">false, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
        <span class="s5">// unset ref</span>
        <span class="s2">if </span><span class="s1">(ref != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">setRef(ref</span><span class="s2">, null, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">) {</span>
            <span class="s1">parentComponent.ctx.deactivate(vnode)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">shouldInvokeDirs = shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">&amp;&amp; dirs</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">shouldInvokeVnodeHook = !isAsyncWrapper(vnode)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {</span>
            <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
            <span class="s1">unmountComponent(vnode.component</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
                <span class="s1">vnode.suspense.unmount(parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(shouldInvokeDirs) {</span>
                <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'beforeUnmount'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">) {</span>
                <span class="s1">vnode.type.remove(vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(dynamicChildren &amp;&amp;</span>
                <span class="s5">// #1153: fast path should not be taken for non-stable (v-for) fragments</span>
                <span class="s1">(type !== Fragment ||</span>
                    <span class="s1">(patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">))) {</span>
                <span class="s5">// fast path for block nodes: only need to unmount dynamic children.</span>
                <span class="s1">unmountChildren(dynamicChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">((type === Fragment &amp;&amp;</span>
                <span class="s1">patchFlag &amp;</span>
                    <span class="s1">(</span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */ </span><span class="s1">| </span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s1">)) ||</span>
                <span class="s1">(!optimized &amp;&amp; shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">)) {</span>
                <span class="s1">unmountChildren(children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(doRemove) {</span>
                <span class="s1">remove(vnode)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeUnmounted)) ||</span>
            <span class="s1">shouldInvokeDirs) {</span>
            <span class="s1">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
                <span class="s1">shouldInvokeDirs &amp;&amp;</span>
                    <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">'unmounted'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">remove = vnode =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">transition } = vnode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type === Fragment) {</span>
            <span class="s2">if </span><span class="s1">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">vnode.patchFlag &amp; </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">transition &amp;&amp;</span>
                <span class="s1">!transition.persisted) {</span>
                <span class="s1">vnode.children.forEach(child =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(child.type === Comment) {</span>
                        <span class="s1">hostRemove(child.el)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">remove(child)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">removeFragment(el</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === Static) {</span>
            <span class="s1">removeStaticNode(vnode)</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">performRemove = () =&gt; {</span>
            <span class="s1">hostRemove(el)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) {</span>
                <span class="s1">transition.afterLeave()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">transition &amp;&amp;</span>
            <span class="s1">!transition.persisted) {</span>
            <span class="s2">const </span><span class="s1">{ leave</span><span class="s2">, </span><span class="s1">delayLeave } = transition</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">performLeave = () =&gt; leave(el</span><span class="s2">, </span><span class="s1">performRemove)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(delayLeave) {</span>
                <span class="s1">delayLeave(vnode.el</span><span class="s2">, </span><span class="s1">performRemove</span><span class="s2">, </span><span class="s1">performLeave)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">performLeave()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">performRemove()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">removeFragment = (cur</span><span class="s2">, </span><span class="s1">end) =&gt; {</span>
        <span class="s5">// For fragments, directly remove all contained DOM nodes.</span>
        <span class="s5">// (fragment child nodes cannot have transition)</span>
        <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(cur !== end) {</span>
            <span class="s1">next = hostNextSibling(cur)</span><span class="s2">;</span>
            <span class="s1">hostRemove(cur)</span><span class="s2">;</span>
            <span class="s1">cur = next</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">hostRemove(end)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">unmountComponent = (instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance.type.__hmrId) {</span>
            <span class="s1">unregisterHMR(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ bum</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">, </span><span class="s1">update</span><span class="s2">, </span><span class="s1">subTree</span><span class="s2">, </span><span class="s1">um } = instance</span><span class="s2">;</span>
        <span class="s5">// beforeUnmount hook</span>
        <span class="s2">if </span><span class="s1">(bum) {</span>
            <span class="s1">invokeArrayFns(bum)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// stop effects in component scope</span>
        <span class="s1">scope.stop()</span><span class="s2">;</span>
        <span class="s5">// update may be null if a component is unmounted before its async</span>
        <span class="s5">// setup has resolved.</span>
        <span class="s2">if </span><span class="s1">(update) {</span>
            <span class="s5">// so that scheduler will no longer invoke it</span>
            <span class="s1">update.active = </span><span class="s2">false;</span>
            <span class="s1">unmount(subTree</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// unmounted hook</span>
        <span class="s2">if </span><span class="s1">(um) {</span>
            <span class="s1">queuePostRenderEffect(um</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">queuePostRenderEffect(() =&gt; {</span>
            <span class="s1">instance.isUnmounted = </span><span class="s2">true;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s5">// A component with async dep inside a pending suspense is unmounted before</span>
        <span class="s5">// its async dep resolves. This should remove the dep from the suspense, and</span>
        <span class="s5">// cause the suspense to resolve immediately if that was the last dep.</span>
        <span class="s2">if </span><span class="s1">(parentSuspense &amp;&amp;</span>
            <span class="s1">parentSuspense.pendingBranch &amp;&amp;</span>
            <span class="s1">!parentSuspense.isUnmounted &amp;&amp;</span>
            <span class="s1">instance.asyncDep &amp;&amp;</span>
            <span class="s1">!instance.asyncResolved &amp;&amp;</span>
            <span class="s1">instance.suspenseId === parentSuspense.pendingId) {</span>
            <span class="s1">parentSuspense.deps--</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(parentSuspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">parentSuspense.resolve()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">{</span>
            <span class="s1">devtoolsComponentRemoved(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">unmountChildren = (children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove = </span><span class="s2">false, </span><span class="s1">optimized = </span><span class="s2">false, </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">) =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = start</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">unmount(children[i]</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">getNextHostNode = vnode =&gt; {</span>
        <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">getNextHostNode(vnode.component.subTree)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">vnode.suspense.next()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">hostNextSibling((vnode.anchor || vnode.el))</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">render = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(vnode == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(container._vnode) {</span>
                <span class="s1">unmount(container._vnode</span><span class="s2">, null, null, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">patch(container._vnode || </span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, null, null, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">flushPreFlushCbs()</span><span class="s2">;</span>
        <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
        <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">internals = {</span>
        <span class="s1">p: patch</span><span class="s2">,</span>
        <span class="s1">um: unmount</span><span class="s2">,</span>
        <span class="s1">m: move</span><span class="s2">,</span>
        <span class="s1">r: remove</span><span class="s2">,</span>
        <span class="s1">mt: mountComponent</span><span class="s2">,</span>
        <span class="s1">mc: mountChildren</span><span class="s2">,</span>
        <span class="s1">pc: patchChildren</span><span class="s2">,</span>
        <span class="s1">pbc: patchBlockChildren</span><span class="s2">,</span>
        <span class="s1">n: getNextHostNode</span><span class="s2">,</span>
        <span class="s1">o: options</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hydrate</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hydrateNode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(createHydrationFns) {</span>
        <span class="s1">[hydrate</span><span class="s2">, </span><span class="s1">hydrateNode] = createHydrationFns(internals)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">render</span><span class="s2">,</span>
        <span class="s1">hydrate</span><span class="s2">,</span>
        <span class="s1">createApp: createAppAPI(render</span><span class="s2">, </span><span class="s1">hydrate)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toggleRecurse({ effect</span><span class="s2">, </span><span class="s1">update }</span><span class="s2">, </span><span class="s1">allowed) {</span>
    <span class="s1">effect.allowRecurse = update.allowRecurse = allowed</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* #1156</span>
 <span class="s0">* When a component is HMR-enabled, we need to make sure that all static nodes</span>
 <span class="s0">* inside a block also inherit the DOM element from the previous tree so that</span>
 <span class="s0">* HMR updates (which are full updates) can retrieve the element for patching.</span>
 <span class="s0">*</span>
 <span class="s0">* #2080</span>
 <span class="s0">* Inside keyed `template` fragment static children, if a fragment is moved,</span>
 <span class="s0">* the children will always be moved. Therefore, in order to ensure correct move</span>
 <span class="s0">* position, el should be inherited from previous nodes.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">shallow = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">ch1 = n1.children</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">ch2 = n2.children</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(ch1) &amp;&amp; isArray(ch2)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; ch1.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s5">// this is only called in the optimized path so array children are</span>
            <span class="s5">// guaranteed to be vnodes</span>
            <span class="s2">const </span><span class="s1">c1 = ch1[i]</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">c2 = ch2[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(c2.shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">&amp;&amp; !c2.dynamicChildren) {</span>
                <span class="s2">if </span><span class="s1">(c2.patchFlag &lt;= </span><span class="s4">0 </span><span class="s1">|| c2.patchFlag === </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">) {</span>
                    <span class="s1">c2 = ch2[i] = cloneIfMounted(ch2[i])</span><span class="s2">;</span>
                    <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!shallow)</span>
                    <span class="s1">traverseStaticChildren(c1</span><span class="s2">, </span><span class="s1">c2)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// #6852 also inherit for text nodes</span>
            <span class="s2">if </span><span class="s1">(c2.type === Text) {</span>
                <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// also inherit for comment nodes, but not placeholders (e.g. v-if which</span>
            <span class="s5">// would have received .el during block patch)</span>
            <span class="s2">if </span><span class="s1">(c2.type === Comment &amp;&amp; !c2.el) {</span>
                <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
<span class="s2">function </span><span class="s1">getSequence(arr) {</span>
    <span class="s2">const </span><span class="s1">p = arr.slice()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">len = arr.length</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; len</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">arrI = arr[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(arrI !== </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">j = result[result.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(arr[j] &lt; arrI) {</span>
                <span class="s1">p[i] = j</span><span class="s2">;</span>
                <span class="s1">result.push(i)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">u = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">v = result.length - </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s2">while </span><span class="s1">(u &lt; v) {</span>
                <span class="s1">c = (u + v) &gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(arr[result[c]] &lt; arrI) {</span>
                    <span class="s1">u = c + </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">v = c</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(arrI &lt; arr[result[u]]) {</span>
                <span class="s2">if </span><span class="s1">(u &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">p[i] = result[u - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">result[u] = i</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">u = result.length</span><span class="s2">;</span>
    <span class="s1">v = result[u - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(u-- &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">result[u] = v</span><span class="s2">;</span>
        <span class="s1">v = p[v]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isTeleport = (type) =&gt; type.__isTeleport</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isTeleportDisabled = (props) =&gt; props &amp;&amp; (props.disabled || props.disabled === </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isTargetSVG = (target) =&gt; </span><span class="s2">typeof </span><span class="s1">SVGElement !== </span><span class="s3">'undefined' </span><span class="s1">&amp;&amp; target </span><span class="s2">instanceof </span><span class="s1">SVGElement</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">resolveTarget = (props</span><span class="s2">, </span><span class="s1">select) =&gt; {</span>
    <span class="s2">const </span><span class="s1">targetSelector = props &amp;&amp; props.to</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isString(targetSelector)) {</span>
        <span class="s2">if </span><span class="s1">(!select) {</span>
            <span class="s1">warn(</span><span class="s3">`Current renderer does not support string target for Teleports. ` </span><span class="s1">+</span>
                    <span class="s3">`(missing querySelector renderer option)`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">target = select(targetSelector)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!target) {</span>
                <span class="s1">warn(</span><span class="s3">`Failed to locate Teleport target with selector &quot;</span><span class="s1">${targetSelector}</span><span class="s3">&quot;. ` </span><span class="s1">+</span>
                        <span class="s3">`Note the target element must exist before the component is mounted - ` </span><span class="s1">+</span>
                        <span class="s3">`i.e. the target cannot be rendered by the component itself, and ` </span><span class="s1">+</span>
                        <span class="s3">`ideally should be outside of the entire Vue component tree.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!targetSelector &amp;&amp; !isTeleportDisabled(props)) {</span>
            <span class="s1">warn(</span><span class="s3">`Invalid Teleport target: </span><span class="s1">${targetSelector}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">targetSelector</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TeleportImpl = {</span>
    <span class="s1">__isTeleport: </span><span class="s2">true,</span>
    <span class="s1">process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals) {</span>
        <span class="s2">const </span><span class="s1">{ mc: mountChildren</span><span class="s2">, </span><span class="s1">pc: patchChildren</span><span class="s2">, </span><span class="s1">pbc: patchBlockChildren</span><span class="s2">, </span><span class="s1">o: { insert</span><span class="s2">, </span><span class="s1">querySelector</span><span class="s2">, </span><span class="s1">createText</span><span class="s2">, </span><span class="s1">createComment } } = internals</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">disabled = isTeleportDisabled(n2.props)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">dynamicChildren } = n2</span><span class="s2">;</span>
        <span class="s5">// #3302</span>
        <span class="s5">// HMR updated, force full diff</span>
        <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
            <span class="s1">optimized = </span><span class="s2">false;</span>
            <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s5">// insert anchors in the main view</span>
            <span class="s2">const </span><span class="s1">placeholder = (n2.el = createComment(</span><span class="s3">'teleport start'</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">mainAnchor = (n2.anchor = createComment(</span><span class="s3">'teleport end'</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">;</span>
            <span class="s1">insert(placeholder</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s1">insert(mainAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">target = (n2.target = resolveTarget(n2.props</span><span class="s2">, </span><span class="s1">querySelector))</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">targetAnchor = (n2.targetAnchor = createText(</span><span class="s3">''</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(target) {</span>
                <span class="s1">insert(targetAnchor</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
                <span class="s5">// #2652 we could be teleporting from a non-SVG tree into an SVG tree</span>
                <span class="s1">isSVG = isSVG || isTargetSVG(target)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!disabled) {</span>
                <span class="s1">warn(</span><span class="s3">'Invalid Teleport target on mount:'</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">target}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">mount = (container</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
                <span class="s5">// Teleport *always* has Array children. This is enforced in both the</span>
                <span class="s5">// compiler and vnode children normalization.</span>
                <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                    <span class="s1">mountChildren(children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(disabled) {</span>
                <span class="s1">mount(container</span><span class="s2">, </span><span class="s1">mainAnchor)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(target) {</span>
                <span class="s1">mount(target</span><span class="s2">, </span><span class="s1">targetAnchor)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// update content</span>
            <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">mainAnchor = (n2.anchor = n1.anchor)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">target = (n2.target = n1.target)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">targetAnchor = (n2.targetAnchor = n1.targetAnchor)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">wasDisabled = isTeleportDisabled(n1.props)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">currentContainer = wasDisabled ? container : target</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">currentAnchor = wasDisabled ? mainAnchor : targetAnchor</span><span class="s2">;</span>
            <span class="s1">isSVG = isSVG || isTargetSVG(target)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
                <span class="s5">// fast path when the teleport happens to be a block root</span>
                <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">currentContainer</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
                <span class="s5">// even in block tree mode we need to make sure all root-level nodes</span>
                <span class="s5">// in the teleport inherit previous DOM references so that they can</span>
                <span class="s5">// be moved in future patches.</span>
                <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!optimized) {</span>
                <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">currentContainer</span><span class="s2">, </span><span class="s1">currentAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(disabled) {</span>
                <span class="s2">if </span><span class="s1">(!wasDisabled) {</span>
                    <span class="s5">// enabled -&gt; disabled</span>
                    <span class="s5">// move into main container</span>
                    <span class="s1">moveTeleport(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">mainAnchor</span><span class="s2">, </span><span class="s1">internals</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* TeleportMoveTypes.TOGGLE */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// target changed</span>
                <span class="s2">if </span><span class="s1">((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) {</span>
                    <span class="s2">const </span><span class="s1">nextTarget = (n2.target = resolveTarget(n2.props</span><span class="s2">, </span><span class="s1">querySelector))</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(nextTarget) {</span>
                        <span class="s1">moveTeleport(n2</span><span class="s2">, </span><span class="s1">nextTarget</span><span class="s2">, null, </span><span class="s1">internals</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">warn(</span><span class="s3">'Invalid Teleport target on update:'</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">target}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(wasDisabled) {</span>
                    <span class="s5">// disabled -&gt; enabled</span>
                    <span class="s5">// move into teleport target</span>
                    <span class="s1">moveTeleport(n2</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">targetAnchor</span><span class="s2">, </span><span class="s1">internals</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* TeleportMoveTypes.TOGGLE */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">updateCssVars(n2)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">remove(vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ um: unmount</span><span class="s2">, </span><span class="s1">o: { remove: hostRemove } }</span><span class="s2">, </span><span class="s1">doRemove) {</span>
        <span class="s2">const </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">targetAnchor</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">props } = vnode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(target) {</span>
            <span class="s1">hostRemove(targetAnchor)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// an unmounted teleport should always remove its children if not disabled</span>
        <span class="s2">if </span><span class="s1">(doRemove || !isTeleportDisabled(props)) {</span>
            <span class="s1">hostRemove(anchor)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
                    <span class="s1">unmount(child</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true, </span><span class="s1">!!child.dynamicChildren)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">move: moveTeleport</span><span class="s2">,</span>
    <span class="s1">hydrate: hydrateTeleport</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">moveTeleport(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor</span><span class="s2">, </span><span class="s1">{ o: { insert }</span><span class="s2">, </span><span class="s1">m: move }</span><span class="s2">, </span><span class="s1">moveType = </span><span class="s4">2 </span><span class="s5">/* TeleportMoveTypes.REORDER */</span><span class="s1">) {</span>
    <span class="s5">// move target anchor if this is a target change.</span>
    <span class="s2">if </span><span class="s1">(moveType === </span><span class="s4">0 </span><span class="s5">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s1">) {</span>
        <span class="s1">insert(vnode.targetAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">props } = vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isReorder = moveType === </span><span class="s4">2 </span><span class="s5">/* TeleportMoveTypes.REORDER */</span><span class="s2">;</span>
    <span class="s5">// move main view anchor if this is a re-order.</span>
    <span class="s2">if </span><span class="s1">(isReorder) {</span>
        <span class="s1">insert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// if this is a re-order and teleport is enabled (content is in target)</span>
    <span class="s5">// do not move children. So the opposite is: only move children if this</span>
    <span class="s5">// is not a reorder, or the teleport is disabled</span>
    <span class="s2">if </span><span class="s1">(!isReorder || isTeleportDisabled(props)) {</span>
        <span class="s5">// Teleport has either Array children or no children.</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">move(children[i]</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* MoveType.REORDER */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// move main view anchor if this is a re-order.</span>
    <span class="s2">if </span><span class="s1">(isReorder) {</span>
        <span class="s1">insert(anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hydrateTeleport(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ o: { nextSibling</span><span class="s2">, </span><span class="s1">parentNode</span><span class="s2">, </span><span class="s1">querySelector } }</span><span class="s2">, </span><span class="s1">hydrateChildren) {</span>
    <span class="s2">const </span><span class="s1">target = (vnode.target = resolveTarget(vnode.props</span><span class="s2">, </span><span class="s1">querySelector))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(target) {</span>
        <span class="s5">// if multiple teleports rendered to the same target element, we need to</span>
        <span class="s5">// pick up from where the last teleport finished instead of the first node</span>
        <span class="s2">const </span><span class="s1">targetNode = target._lpa || target.firstChild</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(isTeleportDisabled(vnode.props)) {</span>
                <span class="s1">vnode.anchor = hydrateChildren(nextSibling(node)</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentNode(node)</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
                <span class="s1">vnode.targetAnchor = targetNode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">vnode.anchor = nextSibling(node)</span><span class="s2">;</span>
                <span class="s5">// lookahead until we find the target anchor</span>
                <span class="s5">// we cannot rely on return value of hydrateChildren() because there</span>
                <span class="s5">// could be nested teleports</span>
                <span class="s2">let </span><span class="s1">targetAnchor = targetNode</span><span class="s2">;</span>
                <span class="s2">while </span><span class="s1">(targetAnchor) {</span>
                    <span class="s1">targetAnchor = nextSibling(targetAnchor)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(targetAnchor &amp;&amp;</span>
                        <span class="s1">targetAnchor.nodeType === </span><span class="s4">8 </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">targetAnchor.data === </span><span class="s3">'teleport anchor'</span><span class="s1">) {</span>
                        <span class="s1">vnode.targetAnchor = targetAnchor</span><span class="s2">;</span>
                        <span class="s1">target._lpa =</span>
                            <span class="s1">vnode.targetAnchor &amp;&amp; nextSibling(vnode.targetAnchor)</span><span class="s2">;</span>
                        <span class="s2">break;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">hydrateChildren(targetNode</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">updateCssVars(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">vnode.anchor &amp;&amp; nextSibling(vnode.anchor)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// Force-casted public typing for h and TSX props inference</span>
<span class="s2">const </span><span class="s1">Teleport = TeleportImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">updateCssVars(vnode) {</span>
    <span class="s5">// presence of .ut method indicates owner component uses css vars.</span>
    <span class="s5">// code path here can assume browser environment.</span>
    <span class="s2">const </span><span class="s1">ctx = vnode.ctx</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ctx &amp;&amp; ctx.ut) {</span>
        <span class="s2">let </span><span class="s1">node = vnode.children[</span><span class="s4">0</span><span class="s1">].el</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(node !== vnode.targetAnchor) {</span>
            <span class="s2">if </span><span class="s1">(node.nodeType === </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">node.setAttribute(</span><span class="s3">'data-v-owner'</span><span class="s2">, </span><span class="s1">ctx.uid)</span><span class="s2">;</span>
            <span class="s1">node = node.nextSibling</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">ctx.ut()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">Fragment = Symbol(</span><span class="s3">'Fragment' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Text = Symbol(</span><span class="s3">'Text' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Comment = Symbol(</span><span class="s3">'Comment' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">Static = Symbol(</span><span class="s3">'Static' </span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// Since v-if and v-for are the two possible ways node structure can dynamically</span>
<span class="s5">// change, once we consider v-if branches and each v-for fragment a block, we</span>
<span class="s5">// can divide a template into nested blocks, and within each block the node</span>
<span class="s5">// structure would be stable. This allows us to skip most children diffing</span>
<span class="s5">// and only worry about the dynamic nodes (indicated by patch flags).</span>
<span class="s2">const </span><span class="s1">blockStack = []</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">currentBlock = </span><span class="s2">null;</span>
<span class="s0">/**</span>
 <span class="s0">* Open a block.</span>
 <span class="s0">* This must be called before `createBlock`. It cannot be part of `createBlock`</span>
 <span class="s0">* because the children of the block are evaluated before `createBlock` itself</span>
 <span class="s0">* is called. The generated code typically looks like this:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* function render() {</span>
 <span class="s0">*   return (openBlock(),createBlock('div', null, [...]))</span>
 <span class="s0">* }</span>
 <span class="s0">* ```</span>
 <span class="s0">* disableTracking is true when creating a v-for fragment block, since a v-for</span>
 <span class="s0">* fragment always diffs its children.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">openBlock(disableTracking = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">blockStack.push((currentBlock = disableTracking ? </span><span class="s2">null </span><span class="s1">: []))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">closeBlock() {</span>
    <span class="s1">blockStack.pop()</span><span class="s2">;</span>
    <span class="s1">currentBlock = blockStack[blockStack.length - </span><span class="s4">1</span><span class="s1">] || </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s5">// Whether we should be tracking dynamic child nodes inside a block.</span>
<span class="s5">// Only tracks when this value is &gt; 0</span>
<span class="s5">// We are not using a simple boolean because this value may need to be</span>
<span class="s5">// incremented/decremented by nested usage of v-once (see below)</span>
<span class="s2">let </span><span class="s1">isBlockTreeEnabled = </span><span class="s4">1</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Block tracking sometimes needs to be disabled, for example during the</span>
 <span class="s0">* creation of a tree that needs to be cached by v-once. The compiler generates</span>
 <span class="s0">* code like this:</span>
 <span class="s0">*</span>
 <span class="s0">* ``` js</span>
 <span class="s0">* _cache[1] || (</span>
 <span class="s0">*   setBlockTracking(-1),</span>
 <span class="s0">*   _cache[1] = createVNode(...),</span>
 <span class="s0">*   setBlockTracking(1),</span>
 <span class="s0">*   _cache[1]</span>
 <span class="s0">* )</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">setBlockTracking(value) {</span>
    <span class="s1">isBlockTreeEnabled += value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setupBlock(vnode) {</span>
    <span class="s5">// save current block children on the block vnode</span>
    <span class="s1">vnode.dynamicChildren =</span>
        <span class="s1">isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">? currentBlock || EMPTY_ARR : </span><span class="s2">null;</span>
    <span class="s5">// close block</span>
    <span class="s1">closeBlock()</span><span class="s2">;</span>
    <span class="s5">// a block is always going to be patched, so track it as a child of its</span>
    <span class="s5">// parent block</span>
    <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; currentBlock) {</span>
        <span class="s1">currentBlock.push(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createElementBlock(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">shapeFlag) {</span>
    <span class="s2">return </span><span class="s1">setupBlock(createBaseVNode(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, true </span><span class="s5">/* isBlock */</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Create a block root vnode. Takes the same exact arguments as `createVNode`.</span>
 <span class="s0">* A block root keeps track of dynamic nodes within the block in the</span>
 <span class="s0">* `dynamicChildren` array.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createBlock(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps) {</span>
    <span class="s2">return </span><span class="s1">setupBlock(createVNode(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, true </span><span class="s5">/* isBlock: prevent a block from tracking itself */</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVNode(value) {</span>
    <span class="s2">return </span><span class="s1">value ? value.__v_isVNode === </span><span class="s2">true </span><span class="s1">: </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2) {</span>
    <span class="s2">if </span><span class="s1">(n2.shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">hmrDirtyComponents.has(n2.type)) {</span>
        <span class="s5">// #7042, ensure the vnode being unmounted during HMR</span>
        <span class="s5">// bitwise operations to remove keep alive flags</span>
        <span class="s1">n1.shapeFlag &amp;= ~</span><span class="s4">256 </span><span class="s5">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">;</span>
        <span class="s1">n2.shapeFlag &amp;= ~</span><span class="s4">512 </span><span class="s5">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s2">;</span>
        <span class="s5">// HMR only: if the component has been hot-updated, force a reload.</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">n1.type === n2.type &amp;&amp; n1.key === n2.key</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">vnodeArgsTransformer</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Internal API for registering an arguments transform for createVNode</span>
 <span class="s0">* used for creating stubs in the test-utils</span>
 <span class="s0">* It is *internal* but needs to be exposed for test-utils to pick up proper</span>
 <span class="s0">* typings</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">transformVNodeArgs(transformer) {</span>
    <span class="s1">vnodeArgsTransformer = transformer</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createVNodeWithArgsTransform = (...args) =&gt; {</span>
    <span class="s2">return </span><span class="s1">_createVNode(...(vnodeArgsTransformer</span>
        <span class="s1">? vnodeArgsTransformer(args</span><span class="s2">, </span><span class="s1">currentRenderingInstance)</span>
        <span class="s1">: args))</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">InternalObjectKey = </span><span class="s3">`__vInternal`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">normalizeKey = ({ key }) =&gt; key != </span><span class="s2">null </span><span class="s1">? key : </span><span class="s2">null;</span>
<span class="s2">const </span><span class="s1">normalizeRef = ({ ref</span><span class="s2">, </span><span class="s1">ref_key</span><span class="s2">, </span><span class="s1">ref_for }) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(ref != </span><span class="s2">null</span>
        <span class="s1">? isString(ref) || isRef(ref) || isFunction(ref)</span>
            <span class="s1">? { i: currentRenderingInstance</span><span class="s2">, </span><span class="s1">r: ref</span><span class="s2">, </span><span class="s1">k: ref_key</span><span class="s2">, </span><span class="s1">f: !!ref_for }</span>
            <span class="s1">: ref</span>
        <span class="s1">: </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createBaseVNode(type</span><span class="s2">, </span><span class="s1">props = </span><span class="s2">null, </span><span class="s1">children = </span><span class="s2">null, </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamicProps = </span><span class="s2">null, </span><span class="s1">shapeFlag = type === Fragment ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */</span><span class="s2">, </span><span class="s1">isBlockNode = </span><span class="s2">false, </span><span class="s1">needFullChildrenNormalization = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">vnode = {</span>
        <span class="s1">__v_isVNode: </span><span class="s2">true,</span>
        <span class="s1">__v_skip: </span><span class="s2">true,</span>
        <span class="s1">type</span><span class="s2">,</span>
        <span class="s1">props</span><span class="s2">,</span>
        <span class="s1">key: props &amp;&amp; normalizeKey(props)</span><span class="s2">,</span>
        <span class="s1">ref: props &amp;&amp; normalizeRef(props)</span><span class="s2">,</span>
        <span class="s1">scopeId: currentScopeId</span><span class="s2">,</span>
        <span class="s1">slotScopeIds: </span><span class="s2">null,</span>
        <span class="s1">children</span><span class="s2">,</span>
        <span class="s1">component: </span><span class="s2">null,</span>
        <span class="s1">suspense: </span><span class="s2">null,</span>
        <span class="s1">ssContent: </span><span class="s2">null,</span>
        <span class="s1">ssFallback: </span><span class="s2">null,</span>
        <span class="s1">dirs: </span><span class="s2">null,</span>
        <span class="s1">transition: </span><span class="s2">null,</span>
        <span class="s1">el: </span><span class="s2">null,</span>
        <span class="s1">anchor: </span><span class="s2">null,</span>
        <span class="s1">target: </span><span class="s2">null,</span>
        <span class="s1">targetAnchor: </span><span class="s2">null,</span>
        <span class="s1">staticCount: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">shapeFlag</span><span class="s2">,</span>
        <span class="s1">patchFlag</span><span class="s2">,</span>
        <span class="s1">dynamicProps</span><span class="s2">,</span>
        <span class="s1">dynamicChildren: </span><span class="s2">null,</span>
        <span class="s1">appContext: </span><span class="s2">null,</span>
        <span class="s1">ctx: currentRenderingInstance</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needFullChildrenNormalization) {</span>
        <span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s5">// normalize suspense children</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
            <span class="s1">type.normalize(vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(children) {</span>
        <span class="s5">// compiled element vnode - if children is passed, only possible types are</span>
        <span class="s5">// string or Array.</span>
        <span class="s1">vnode.shapeFlag |= isString(children)</span>
            <span class="s1">? </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span>
            <span class="s1">: </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// validate key</span>
    <span class="s2">if </span><span class="s1">(vnode.key !== vnode.key) {</span>
        <span class="s1">warn(</span><span class="s3">`VNode created with invalid key (NaN). VNode type:`</span><span class="s2">, </span><span class="s1">vnode.type)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// track vnode for block tree</span>
    <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s5">// avoid a block node from tracking itself</span>
        <span class="s1">!isBlockNode &amp;&amp;</span>
        <span class="s5">// has current parent block</span>
        <span class="s1">currentBlock &amp;&amp;</span>
        <span class="s5">// presence of a patch flag indicates this node needs patching on updates.</span>
        <span class="s5">// component nodes also should always be patched, because even if the</span>
        <span class="s5">// component doesn't need to update, it needs to persist the instance on to</span>
        <span class="s5">// the next vnode so that it can be properly unmounted later.</span>
        <span class="s1">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">|| shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) &amp;&amp;</span>
        <span class="s5">// the EVENTS flag is only for hydration and if it is the only flag, the</span>
        <span class="s5">// vnode should not be considered dynamic due to handler caching.</span>
        <span class="s1">vnode.patchFlag !== </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">) {</span>
        <span class="s1">currentBlock.push(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createVNode = (createVNodeWithArgsTransform )</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">_createVNode(type</span><span class="s2">, </span><span class="s1">props = </span><span class="s2">null, </span><span class="s1">children = </span><span class="s2">null, </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamicProps = </span><span class="s2">null, </span><span class="s1">isBlockNode = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!type || type === NULL_DYNAMIC_COMPONENT) {</span>
        <span class="s2">if </span><span class="s1">(!type) {</span>
            <span class="s1">warn(</span><span class="s3">`Invalid vnode type when creating vnode: </span><span class="s1">${type}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">type = Comment</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isVNode(type)) {</span>
        <span class="s5">// createVNode receiving an existing vnode. This happens in cases like</span>
        <span class="s5">// &lt;component :is=&quot;vnode&quot;/&gt;</span>
        <span class="s5">// #2078 make sure to merge refs during the clone instead of overwriting it</span>
        <span class="s2">const </span><span class="s1">cloned = cloneVNode(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, true </span><span class="s5">/* mergeRef: true */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(children) {</span>
            <span class="s1">normalizeChildren(cloned</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isBlockNode &amp;&amp; currentBlock) {</span>
            <span class="s2">if </span><span class="s1">(cloned.shapeFlag &amp; </span><span class="s4">6 </span><span class="s5">/* ShapeFlags.COMPONENT */</span><span class="s1">) {</span>
                <span class="s1">currentBlock[currentBlock.indexOf(type)] = cloned</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">currentBlock.push(cloned)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">cloned.patchFlag |= -</span><span class="s4">2 </span><span class="s5">/* PatchFlags.BAIL */</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// class component normalization.</span>
    <span class="s2">if </span><span class="s1">(isClassComponent(type)) {</span>
        <span class="s1">type = type.__vccOpts</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// class &amp; style normalization.</span>
    <span class="s2">if </span><span class="s1">(props) {</span>
        <span class="s5">// for reactive or proxy objects, we need to clone it to enable mutation.</span>
        <span class="s1">props = guardReactiveProps(props)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">{ </span><span class="s2">class</span><span class="s1">: klass</span><span class="s2">, </span><span class="s1">style } = props</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(klass &amp;&amp; !isString(klass)) {</span>
            <span class="s1">props.class = normalizeClass(klass)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isObject(style)) {</span>
            <span class="s5">// reactive state objects need to be cloned since they are likely to be</span>
            <span class="s5">// mutated</span>
            <span class="s2">if </span><span class="s1">(isProxy(style) &amp;&amp; !isArray(style)) {</span>
                <span class="s1">style = extend({}</span><span class="s2">, </span><span class="s1">style)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">props.style = normalizeStyle(style)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// encode the vnode type information into a bitmap</span>
    <span class="s2">const </span><span class="s1">shapeFlag = isString(type)</span>
        <span class="s1">? </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */</span>
        <span class="s1">: isSuspense(type)</span>
            <span class="s1">? </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span>
            <span class="s1">: isTeleport(type)</span>
                <span class="s1">? </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span>
                <span class="s1">: isObject(type)</span>
                    <span class="s1">? </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */</span>
                    <span class="s1">: isFunction(type)</span>
                        <span class="s1">? </span><span class="s4">2 </span><span class="s5">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span>
                        <span class="s1">: </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */ </span><span class="s1">&amp;&amp; isProxy(type)) {</span>
        <span class="s1">type = toRaw(type)</span><span class="s2">;</span>
        <span class="s1">warn(</span><span class="s3">`Vue received a Component which was made a reactive object. This can ` </span><span class="s1">+</span>
            <span class="s3">`lead to unnecessary performance overhead, and should be avoided by ` </span><span class="s1">+</span>
            <span class="s3">`marking the component with </span><span class="s2">\`</span><span class="s3">markRaw</span><span class="s2">\` </span><span class="s3">or using </span><span class="s2">\`</span><span class="s3">shallowRef</span><span class="s2">\` </span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`instead of </span><span class="s2">\`</span><span class="s3">ref</span><span class="s2">\`</span><span class="s3">.`</span><span class="s2">, </span><span class="s3">`</span><span class="s2">\n</span><span class="s3">Component that was made reactive: `</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createBaseVNode(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">isBlockNode</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">guardReactiveProps(props) {</span>
    <span class="s2">if </span><span class="s1">(!props)</span>
        <span class="s2">return null;</span>
    <span class="s2">return </span><span class="s1">isProxy(props) || InternalObjectKey </span><span class="s2">in </span><span class="s1">props</span>
        <span class="s1">? extend({}</span><span class="s2">, </span><span class="s1">props)</span>
        <span class="s1">: props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cloneVNode(vnode</span><span class="s2">, </span><span class="s1">extraProps</span><span class="s2">, </span><span class="s1">mergeRef = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s5">// This is intentionally NOT using spread or extend to avoid the runtime</span>
    <span class="s5">// key enumeration cost.</span>
    <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">children } = vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mergedProps = extraProps ? mergeProps(props || {}</span><span class="s2">, </span><span class="s1">extraProps) : props</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cloned = {</span>
        <span class="s1">__v_isVNode: </span><span class="s2">true,</span>
        <span class="s1">__v_skip: </span><span class="s2">true,</span>
        <span class="s1">type: vnode.type</span><span class="s2">,</span>
        <span class="s1">props: mergedProps</span><span class="s2">,</span>
        <span class="s1">key: mergedProps &amp;&amp; normalizeKey(mergedProps)</span><span class="s2">,</span>
        <span class="s1">ref: extraProps &amp;&amp; extraProps.ref</span>
            <span class="s1">? </span><span class="s5">// #2078 in the case of &lt;component :is=&quot;vnode&quot; ref=&quot;extra&quot;/&gt;</span>
                <span class="s5">// if the vnode itself already has a ref, cloneVNode will need to merge</span>
                <span class="s5">// the refs so the single vnode can be set on multiple refs</span>
                <span class="s1">mergeRef &amp;&amp; ref</span>
                    <span class="s1">? isArray(ref)</span>
                        <span class="s1">? ref.concat(normalizeRef(extraProps))</span>
                        <span class="s1">: [ref</span><span class="s2">, </span><span class="s1">normalizeRef(extraProps)]</span>
                    <span class="s1">: normalizeRef(extraProps)</span>
            <span class="s1">: ref</span><span class="s2">,</span>
        <span class="s1">scopeId: vnode.scopeId</span><span class="s2">,</span>
        <span class="s1">slotScopeIds: vnode.slotScopeIds</span><span class="s2">,</span>
        <span class="s1">children: patchFlag === -</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */ </span><span class="s1">&amp;&amp; isArray(children)</span>
            <span class="s1">? children.map(deepCloneVNode)</span>
            <span class="s1">: children</span><span class="s2">,</span>
        <span class="s1">target: vnode.target</span><span class="s2">,</span>
        <span class="s1">targetAnchor: vnode.targetAnchor</span><span class="s2">,</span>
        <span class="s1">staticCount: vnode.staticCount</span><span class="s2">,</span>
        <span class="s1">shapeFlag: vnode.shapeFlag</span><span class="s2">,</span>
        <span class="s5">// if the vnode is cloned with extra props, we can no longer assume its</span>
        <span class="s5">// existing patch flag to be reliable and need to add the FULL_PROPS flag.</span>
        <span class="s5">// note: preserve flag for fragments since they use the flag for children</span>
        <span class="s5">// fast paths only.</span>
        <span class="s1">patchFlag: extraProps &amp;&amp; vnode.type !== Fragment</span>
            <span class="s1">? patchFlag === -</span><span class="s4">1 </span><span class="s5">// hoisted node</span>
                <span class="s1">? </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span>
                <span class="s1">: patchFlag | </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span>
            <span class="s1">: patchFlag</span><span class="s2">,</span>
        <span class="s1">dynamicProps: vnode.dynamicProps</span><span class="s2">,</span>
        <span class="s1">dynamicChildren: vnode.dynamicChildren</span><span class="s2">,</span>
        <span class="s1">appContext: vnode.appContext</span><span class="s2">,</span>
        <span class="s1">dirs: vnode.dirs</span><span class="s2">,</span>
        <span class="s1">transition: vnode.transition</span><span class="s2">,</span>
        <span class="s5">// These should technically only be non-null on mounted VNodes. However,</span>
        <span class="s5">// they *should* be copied for kept-alive vnodes. So we just always copy</span>
        <span class="s5">// them since them being non-null during a mount doesn't affect the logic as</span>
        <span class="s5">// they will simply be overwritten.</span>
        <span class="s1">component: vnode.component</span><span class="s2">,</span>
        <span class="s1">suspense: vnode.suspense</span><span class="s2">,</span>
        <span class="s1">ssContent: vnode.ssContent &amp;&amp; cloneVNode(vnode.ssContent)</span><span class="s2">,</span>
        <span class="s1">ssFallback: vnode.ssFallback &amp;&amp; cloneVNode(vnode.ssFallback)</span><span class="s2">,</span>
        <span class="s1">el: vnode.el</span><span class="s2">,</span>
        <span class="s1">anchor: vnode.anchor</span><span class="s2">,</span>
        <span class="s1">ctx: vnode.ctx</span><span class="s2">,</span>
        <span class="s1">ce: vnode.ce</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Dev only, for HMR of hoisted vnodes reused in v-for</span>
 <span class="s0">* https://github.com/vitejs/vite/issues/2022</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">deepCloneVNode(vnode) {</span>
    <span class="s2">const </span><span class="s1">cloned = cloneVNode(vnode)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(vnode.children)) {</span>
        <span class="s1">cloned.children = vnode.children.map(deepCloneVNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createTextVNode(text = </span><span class="s3">' '</span><span class="s2">, </span><span class="s1">flag = </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">createVNode(Text</span><span class="s2">, null, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">flag)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createStaticVNode(content</span><span class="s2">, </span><span class="s1">numberOfNodes) {</span>
    <span class="s5">// A static vnode can contain multiple stringified elements, and the number</span>
    <span class="s5">// of elements is necessary for hydration.</span>
    <span class="s2">const </span><span class="s1">vnode = createVNode(Static</span><span class="s2">, null, </span><span class="s1">content)</span><span class="s2">;</span>
    <span class="s1">vnode.staticCount = numberOfNodes</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createCommentVNode(text = </span><span class="s3">''</span><span class="s2">, </span>
<span class="s5">// when used as the v-else branch, the comment node must be created as a</span>
<span class="s5">// block to ensure correct updates.</span>
<span class="s1">asBlock = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">asBlock</span>
        <span class="s1">? (openBlock()</span><span class="s2">, </span><span class="s1">createBlock(Comment</span><span class="s2">, null, </span><span class="s1">text))</span>
        <span class="s1">: createVNode(Comment</span><span class="s2">, null, </span><span class="s1">text)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeVNode(child) {</span>
    <span class="s2">if </span><span class="s1">(child == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">child === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
        <span class="s5">// empty placeholder</span>
        <span class="s2">return </span><span class="s1">createVNode(Comment)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isArray(child)) {</span>
        <span class="s5">// fragment</span>
        <span class="s2">return </span><span class="s1">createVNode(Fragment</span><span class="s2">, null, </span>
        <span class="s5">// #3666, avoid reference pollution when reusing vnode</span>
        <span class="s1">child.slice())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">child === </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s5">// already vnode, this should be the most common since compiled templates</span>
        <span class="s5">// always produce all-vnode children arrays</span>
        <span class="s2">return </span><span class="s1">cloneIfMounted(child)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// strings and numbers</span>
        <span class="s2">return </span><span class="s1">createVNode(Text</span><span class="s2">, null, </span><span class="s1">String(child))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// optimized normalization for template-compiled render fns</span>
<span class="s2">function </span><span class="s1">cloneIfMounted(child) {</span>
    <span class="s2">return </span><span class="s1">(child.el === </span><span class="s2">null </span><span class="s1">&amp;&amp; child.patchFlag !== -</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */</span><span class="s1">) ||</span>
        <span class="s1">child.memo</span>
        <span class="s1">? child</span>
        <span class="s1">: cloneVNode(child)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">children) {</span>
    <span class="s2">let </span><span class="s1">type = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ shapeFlag } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(children == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">children = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isArray(children)) {</span>
        <span class="s1">type = </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">children === </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">| </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">)) {</span>
            <span class="s5">// Normalize slot to plain children for plain element and Teleport</span>
            <span class="s2">const </span><span class="s1">slot = children.default</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(slot) {</span>
                <span class="s5">// _c marker is added by withCtx() indicating this is a compiled slot</span>
                <span class="s1">slot._c &amp;&amp; (slot._d = </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">slot())</span><span class="s2">;</span>
                <span class="s1">slot._c &amp;&amp; (slot._d = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">type = </span><span class="s4">32 </span><span class="s5">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">slotFlag = children._</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!slotFlag &amp;&amp; !(InternalObjectKey </span><span class="s2">in </span><span class="s1">children)) {</span>
                <span class="s1">children._ctx = currentRenderingInstance</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(slotFlag === </span><span class="s4">3 </span><span class="s5">/* SlotFlags.FORWARDED */ </span><span class="s1">&amp;&amp; currentRenderingInstance) {</span>
                <span class="s5">// a child component receives forwarded slots from the parent.</span>
                <span class="s5">// its slot type is determined by its parent's slot type.</span>
                <span class="s2">if </span><span class="s1">(currentRenderingInstance.slots._ === </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s1">) {</span>
                    <span class="s1">children._ = </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">children._ = </span><span class="s4">2 </span><span class="s5">/* SlotFlags.DYNAMIC */</span><span class="s2">;</span>
                    <span class="s1">vnode.patchFlag |= </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isFunction(children)) {</span>
        <span class="s1">children = { </span><span class="s2">default</span><span class="s1">: children</span><span class="s2">, </span><span class="s1">_ctx: currentRenderingInstance }</span><span class="s2">;</span>
        <span class="s1">type = </span><span class="s4">32 </span><span class="s5">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">children = String(children)</span><span class="s2">;</span>
        <span class="s5">// force teleport children to array so it can be moved around</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64 </span><span class="s5">/* ShapeFlags.TELEPORT */</span><span class="s1">) {</span>
            <span class="s1">type = </span><span class="s4">16 </span><span class="s5">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">;</span>
            <span class="s1">children = [createTextVNode(children)]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">type = </span><span class="s4">8 </span><span class="s5">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">vnode.children = children</span><span class="s2">;</span>
    <span class="s1">vnode.shapeFlag |= type</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeProps(...args) {</span>
    <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; args.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">toMerge = args[i]</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">toMerge) {</span>
            <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'class'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(ret.class !== toMerge.class) {</span>
                    <span class="s1">ret.class = normalizeClass([ret.class</span><span class="s2">, </span><span class="s1">toMerge.class])</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">'style'</span><span class="s1">) {</span>
                <span class="s1">ret.style = normalizeStyle([ret.style</span><span class="s2">, </span><span class="s1">toMerge.style])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isOn(key)) {</span>
                <span class="s2">const </span><span class="s1">existing = ret[key]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">incoming = toMerge[key]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(incoming &amp;&amp;</span>
                    <span class="s1">existing !== incoming &amp;&amp;</span>
                    <span class="s1">!(isArray(existing) &amp;&amp; existing.includes(incoming))) {</span>
                    <span class="s1">ret[key] = existing</span>
                        <span class="s1">? [].concat(existing</span><span class="s2">, </span><span class="s1">incoming)</span>
                        <span class="s1">: incoming</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(key !== </span><span class="s3">''</span><span class="s1">) {</span>
                <span class="s1">ret[key] = toMerge[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invokeVNodeHook(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode = </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">7 </span><span class="s5">/* ErrorCodes.VNODE_HOOK */</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">vnode</span><span class="s2">,</span>
        <span class="s1">prevVNode</span>
    <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">emptyAppContext = createAppContext()</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">uid = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createComponentInstance(vnode</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">suspense) {</span>
    <span class="s2">const </span><span class="s1">type = vnode.type</span><span class="s2">;</span>
    <span class="s5">// inherit parent app context - or - if root, adopt from root vnode</span>
    <span class="s2">const </span><span class="s1">appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">instance = {</span>
        <span class="s1">uid: uid++</span><span class="s2">,</span>
        <span class="s1">vnode</span><span class="s2">,</span>
        <span class="s1">type</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">,</span>
        <span class="s1">appContext</span><span class="s2">,</span>
        <span class="s1">root: </span><span class="s2">null,</span>
        <span class="s1">next: </span><span class="s2">null,</span>
        <span class="s1">subTree: </span><span class="s2">null,</span>
        <span class="s1">effect: </span><span class="s2">null,</span>
        <span class="s1">update: </span><span class="s2">null,</span>
        <span class="s1">scope: </span><span class="s2">new </span><span class="s1">EffectScope(</span><span class="s2">true </span><span class="s5">/* detached */</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">render: </span><span class="s2">null,</span>
        <span class="s1">proxy: </span><span class="s2">null,</span>
        <span class="s1">exposed: </span><span class="s2">null,</span>
        <span class="s1">exposeProxy: </span><span class="s2">null,</span>
        <span class="s1">withProxy: </span><span class="s2">null,</span>
        <span class="s1">provides: parent ? parent.provides : Object.create(appContext.provides)</span><span class="s2">,</span>
        <span class="s1">accessCache: </span><span class="s2">null,</span>
        <span class="s1">renderCache: []</span><span class="s2">,</span>
        <span class="s5">// local resolved assets</span>
        <span class="s1">components: </span><span class="s2">null,</span>
        <span class="s1">directives: </span><span class="s2">null,</span>
        <span class="s5">// resolved props and emits options</span>
        <span class="s1">propsOptions: normalizePropsOptions(type</span><span class="s2">, </span><span class="s1">appContext)</span><span class="s2">,</span>
        <span class="s1">emitsOptions: normalizeEmitsOptions(type</span><span class="s2">, </span><span class="s1">appContext)</span><span class="s2">,</span>
        <span class="s5">// emit</span>
        <span class="s1">emit: </span><span class="s2">null,</span>
        <span class="s1">emitted: </span><span class="s2">null,</span>
        <span class="s5">// props default value</span>
        <span class="s1">propsDefaults: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s5">// inheritAttrs</span>
        <span class="s1">inheritAttrs: type.inheritAttrs</span><span class="s2">,</span>
        <span class="s5">// state</span>
        <span class="s1">ctx: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">data: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">props: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">attrs: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">slots: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">refs: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">setupState: EMPTY_OBJ</span><span class="s2">,</span>
        <span class="s1">setupContext: </span><span class="s2">null,</span>
        <span class="s5">// suspense related</span>
        <span class="s1">suspense</span><span class="s2">,</span>
        <span class="s1">suspenseId: suspense ? suspense.pendingId : </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">asyncDep: </span><span class="s2">null,</span>
        <span class="s1">asyncResolved: </span><span class="s2">false,</span>
        <span class="s5">// lifecycle hooks</span>
        <span class="s5">// not using enums here because it results in computed properties</span>
        <span class="s1">isMounted: </span><span class="s2">false,</span>
        <span class="s1">isUnmounted: </span><span class="s2">false,</span>
        <span class="s1">isDeactivated: </span><span class="s2">false,</span>
        <span class="s1">bc: </span><span class="s2">null,</span>
        <span class="s1">c: </span><span class="s2">null,</span>
        <span class="s1">bm: </span><span class="s2">null,</span>
        <span class="s1">m: </span><span class="s2">null,</span>
        <span class="s1">bu: </span><span class="s2">null,</span>
        <span class="s1">u: </span><span class="s2">null,</span>
        <span class="s1">um: </span><span class="s2">null,</span>
        <span class="s1">bum: </span><span class="s2">null,</span>
        <span class="s1">da: </span><span class="s2">null,</span>
        <span class="s1">a: </span><span class="s2">null,</span>
        <span class="s1">rtg: </span><span class="s2">null,</span>
        <span class="s1">rtc: </span><span class="s2">null,</span>
        <span class="s1">ec: </span><span class="s2">null,</span>
        <span class="s1">sp: </span><span class="s2">null</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">instance.ctx = createDevRenderContext(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">instance.root = parent ? parent.root : instance</span><span class="s2">;</span>
    <span class="s1">instance.emit = emit.bind(</span><span class="s2">null, </span><span class="s1">instance)</span><span class="s2">;</span>
    <span class="s5">// apply custom element special handling</span>
    <span class="s2">if </span><span class="s1">(vnode.ce) {</span>
        <span class="s1">vnode.ce(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">instance</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">currentInstance = </span><span class="s2">null;</span>
<span class="s2">const </span><span class="s1">getCurrentInstance = () =&gt; currentInstance || currentRenderingInstance</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">setCurrentInstance = (instance) =&gt; {</span>
    <span class="s1">currentInstance = instance</span><span class="s2">;</span>
    <span class="s1">instance.scope.on()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">unsetCurrentInstance = () =&gt; {</span>
    <span class="s1">currentInstance &amp;&amp; currentInstance.scope.off()</span><span class="s2">;</span>
    <span class="s1">currentInstance = </span><span class="s2">null;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isBuiltInTag = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">'slot,component'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">validateComponentName(name</span><span class="s2">, </span><span class="s1">config) {</span>
    <span class="s2">const </span><span class="s1">appIsNativeTag = config.isNativeTag || NO</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isBuiltInTag(name) || appIsNativeTag(name)) {</span>
        <span class="s1">warn(</span><span class="s3">'Do not use built-in or reserved HTML elements as component id: ' </span><span class="s1">+ name)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isStatefulComponent(instance) {</span>
    <span class="s2">return </span><span class="s1">instance.vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s5">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">isInSSRComponentSetup = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">setupComponent(instance</span><span class="s2">, </span><span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">isInSSRComponentSetup = isSSR</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">children } = instance.vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isStateful = isStatefulComponent(instance)</span><span class="s2">;</span>
    <span class="s1">initProps(instance</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">isStateful</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
    <span class="s1">initSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setupResult = isStateful</span>
        <span class="s1">? setupStatefulComponent(instance</span><span class="s2">, </span><span class="s1">isSSR)</span>
        <span class="s1">: undefined</span><span class="s2">;</span>
    <span class="s1">isInSSRComponentSetup = </span><span class="s2">false;</span>
    <span class="s2">return </span><span class="s1">setupResult</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setupStatefulComponent(instance</span><span class="s2">, </span><span class="s1">isSSR) {</span>
    <span class="s2">var </span><span class="s1">_a</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(Component.name) {</span>
            <span class="s1">validateComponentName(Component.name</span><span class="s2">, </span><span class="s1">instance.appContext.config)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(Component.components) {</span>
            <span class="s2">const </span><span class="s1">names = Object.keys(Component.components)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; names.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">validateComponentName(names[i]</span><span class="s2">, </span><span class="s1">instance.appContext.config)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(Component.directives) {</span>
            <span class="s2">const </span><span class="s1">names = Object.keys(Component.directives)</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; names.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">validateDirectiveName(names[i])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(Component.compilerOptions &amp;&amp; isRuntimeOnly()) {</span>
            <span class="s1">warn(</span><span class="s3">`&quot;compilerOptions&quot; is only supported when using a build of Vue that ` </span><span class="s1">+</span>
                <span class="s3">`includes the runtime compiler. Since you are using a runtime-only ` </span><span class="s1">+</span>
                <span class="s3">`build, the options should be passed via your build tool config instead.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// 0. create render proxy property access cache</span>
    <span class="s1">instance.accessCache = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s5">// 1. create public instance / render proxy</span>
    <span class="s5">// also mark it raw so it's never observed</span>
    <span class="s1">instance.proxy = markRaw(</span><span class="s2">new </span><span class="s1">Proxy(instance.ctx</span><span class="s2">, </span><span class="s1">PublicInstanceProxyHandlers))</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">exposePropsOnRenderContext(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// 2. call setup()</span>
    <span class="s2">const </span><span class="s1">{ setup } = Component</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(setup) {</span>
        <span class="s2">const </span><span class="s1">setupContext = (instance.setupContext =</span>
            <span class="s1">setup.length &gt; </span><span class="s4">1 </span><span class="s1">? createSetupContext(instance) : </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
        <span class="s1">pauseTracking()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">setupResult = callWithErrorHandling(setup</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">, </span><span class="s1">[shallowReadonly(instance.props) </span><span class="s2">, </span><span class="s1">setupContext])</span><span class="s2">;</span>
        <span class="s1">resetTracking()</span><span class="s2">;</span>
        <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPromise(setupResult)) {</span>
            <span class="s1">setupResult.then(unsetCurrentInstance</span><span class="s2">, </span><span class="s1">unsetCurrentInstance)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isSSR) {</span>
                <span class="s5">// return the promise so server-renderer can wait on it</span>
                <span class="s2">return </span><span class="s1">setupResult</span>
                    <span class="s1">.then((resolvedResult) =&gt; {</span>
                    <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">resolvedResult</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
                <span class="s1">})</span>
                    <span class="s1">.catch(e =&gt; {</span>
                    <span class="s1">handleError(e</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// async setup returned Promise.</span>
                <span class="s5">// bail here and wait for re-entry.</span>
                <span class="s1">instance.asyncDep = setupResult</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!instance.suspense) {</span>
                    <span class="s2">const </span><span class="s1">name = (_a = Component.name) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? _a : </span><span class="s3">'Anonymous'</span><span class="s2">;</span>
                    <span class="s1">warn(</span><span class="s3">`Component &lt;</span><span class="s1">${name}</span><span class="s3">&gt;: setup function returned a promise, but no ` </span><span class="s1">+</span>
                        <span class="s3">`&lt;Suspense&gt; boundary was found in the parent component tree. ` </span><span class="s1">+</span>
                        <span class="s3">`A component with async setup() must be nested in a &lt;Suspense&gt; ` </span><span class="s1">+</span>
                        <span class="s3">`in order to be rendered.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">setupResult</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">setupResult</span><span class="s2">, </span><span class="s1">isSSR) {</span>
    <span class="s2">if </span><span class="s1">(isFunction(setupResult)) {</span>
        <span class="s5">// setup returned an inline render function</span>
        <span class="s1">{</span>
            <span class="s1">instance.render = setupResult</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(setupResult)) {</span>
        <span class="s2">if </span><span class="s1">(isVNode(setupResult)) {</span>
            <span class="s1">warn(</span><span class="s3">`setup() should not return VNodes directly - ` </span><span class="s1">+</span>
                <span class="s3">`return a render function instead.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// setup returned bindings.</span>
        <span class="s5">// assuming a render function compiled from template is present.</span>
        <span class="s1">{</span>
            <span class="s1">instance.devtoolsRawSetupState = setupResult</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">instance.setupState = proxyRefs(setupResult)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">exposeSetupStateOnRenderContext(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(setupResult !== undefined) {</span>
        <span class="s1">warn(</span><span class="s3">`setup() should return an object. Received: </span><span class="s1">${setupResult === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'null' </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">setupResult}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">compile$1</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">installWithProxy</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* For runtime-dom to register the compiler.</span>
 <span class="s0">* Note the exported method uses any to avoid d.ts relying on the compiler types.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">registerRuntimeCompiler(_compile) {</span>
    <span class="s1">compile$1 = _compile</span><span class="s2">;</span>
    <span class="s1">installWithProxy = i =&gt; {</span>
        <span class="s2">if </span><span class="s1">(i.render._rc) {</span>
            <span class="s1">i.withProxy = </span><span class="s2">new </span><span class="s1">Proxy(i.ctx</span><span class="s2">, </span><span class="s1">RuntimeCompiledPublicInstanceProxyHandlers)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// dev only</span>
<span class="s2">const </span><span class="s1">isRuntimeOnly = () =&gt; !compile$1</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR</span><span class="s2">, </span><span class="s1">skipOptions) {</span>
    <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
    <span class="s5">// template / render function normalization</span>
    <span class="s5">// could be already set when returned from setup()</span>
    <span class="s2">if </span><span class="s1">(!instance.render) {</span>
        <span class="s5">// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation</span>
        <span class="s5">// is done by server-renderer</span>
        <span class="s2">if </span><span class="s1">(!isSSR &amp;&amp; compile$1 &amp;&amp; !Component.render) {</span>
            <span class="s2">const </span><span class="s1">template = Component.template ||</span>
                <span class="s1">resolveMergedOptions(instance).template</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(template) {</span>
                <span class="s1">{</span>
                    <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`compile`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">{ isCustomElement</span><span class="s2">, </span><span class="s1">compilerOptions } = instance.appContext.config</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">{ delimiters</span><span class="s2">, </span><span class="s1">compilerOptions: componentCompilerOptions } = Component</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">finalCompilerOptions = extend(extend({</span>
                    <span class="s1">isCustomElement</span><span class="s2">,</span>
                    <span class="s1">delimiters</span>
                <span class="s1">}</span><span class="s2">, </span><span class="s1">compilerOptions)</span><span class="s2">, </span><span class="s1">componentCompilerOptions)</span><span class="s2">;</span>
                <span class="s1">Component.render = compile$1(template</span><span class="s2">, </span><span class="s1">finalCompilerOptions)</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`compile`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">instance.render = (Component.render || NOOP)</span><span class="s2">;</span>
        <span class="s5">// for runtime-compiled render functions using `with` blocks, the render</span>
        <span class="s5">// proxy used needs a different `has` handler which is more performant and</span>
        <span class="s5">// also only allows a whitelist of globals to fallthrough.</span>
        <span class="s2">if </span><span class="s1">(installWithProxy) {</span>
            <span class="s1">installWithProxy(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// support for 2.x options</span>
    <span class="s1">{</span>
        <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
        <span class="s1">pauseTracking()</span><span class="s2">;</span>
        <span class="s1">applyOptions(instance)</span><span class="s2">;</span>
        <span class="s1">resetTracking()</span><span class="s2">;</span>
        <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// warn missing template/render</span>
    <span class="s5">// the runtime compilation of template in SSR is done by server-render</span>
    <span class="s2">if </span><span class="s1">(!Component.render &amp;&amp; instance.render === NOOP &amp;&amp; !isSSR) {</span>
        <span class="s5">/* istanbul ignore if */</span>
        <span class="s2">if </span><span class="s1">(!compile$1 &amp;&amp; Component.template) {</span>
            <span class="s1">warn(</span><span class="s3">`Component provided template option but ` </span><span class="s1">+</span>
                <span class="s3">`runtime compilation is not supported in this build of Vue.` </span><span class="s1">+</span>
                <span class="s1">(</span><span class="s3">` Use &quot;vue.esm-browser.js&quot; instead.`</span>
                        <span class="s1">) </span><span class="s5">/* should not happen */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`Component is missing template or render function.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createAttrsProxy(instance) {</span>
    <span class="s2">return new </span><span class="s1">Proxy(instance.attrs</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
                <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
                <span class="s1">track(instance</span><span class="s2">, </span><span class="s3">&quot;get&quot; </span><span class="s5">/* TrackOpTypes.GET */</span><span class="s2">, </span><span class="s3">'$attrs'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">target[key]</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">set() {</span>
                <span class="s1">warn(</span><span class="s3">`setupContext.attrs is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">deleteProperty() {</span>
                <span class="s1">warn(</span><span class="s3">`setupContext.attrs is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return false;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createSetupContext(instance) {</span>
    <span class="s2">const </span><span class="s1">expose = exposed =&gt; {</span>
        <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(instance.exposed) {</span>
                <span class="s1">warn(</span><span class="s3">`expose() should be called only once per setup().`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(exposed != </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">let </span><span class="s1">exposedType = </span><span class="s2">typeof </span><span class="s1">exposed</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(exposedType === </span><span class="s3">'object'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(isArray(exposed)) {</span>
                        <span class="s1">exposedType = </span><span class="s3">'array'</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(isRef(exposed)) {</span>
                        <span class="s1">exposedType = </span><span class="s3">'ref'</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(exposedType !== </span><span class="s3">'object'</span><span class="s1">) {</span>
                    <span class="s1">warn(</span><span class="s3">`expose() should be passed a plain object, received </span><span class="s1">${exposedType}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">instance.exposed = exposed || {}</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">attrs</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s5">// We use getters in dev in case libs like test-utils overwrite instance</span>
        <span class="s5">// properties (overwrites should not be done in prod)</span>
        <span class="s2">return </span><span class="s1">Object.freeze({</span>
            <span class="s1">get attrs() {</span>
                <span class="s2">return </span><span class="s1">attrs || (attrs = createAttrsProxy(instance))</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get slots() {</span>
                <span class="s2">return </span><span class="s1">shallowReadonly(instance.slots)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">get emit() {</span>
                <span class="s2">return </span><span class="s1">(event</span><span class="s2">, </span><span class="s1">...args) =&gt; instance.emit(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">expose</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExposeProxy(instance) {</span>
    <span class="s2">if </span><span class="s1">(instance.exposed) {</span>
        <span class="s2">return </span><span class="s1">(instance.exposeProxy ||</span>
            <span class="s1">(instance.exposeProxy = </span><span class="s2">new </span><span class="s1">Proxy(proxyRefs(markRaw(instance.exposed))</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
                    <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">target) {</span>
                        <span class="s2">return </span><span class="s1">target[key]</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">publicPropertiesMap) {</span>
                        <span class="s2">return </span><span class="s1">publicPropertiesMap[key](instance)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">has(target</span><span class="s2">, </span><span class="s1">key) {</span>
                    <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target || key </span><span class="s2">in </span><span class="s1">publicPropertiesMap</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">classifyRE = </span><span class="s4">/(?:^|[-_])(\w)/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">classify = (str) =&gt; str.replace(classifyRE</span><span class="s2">, </span><span class="s1">c =&gt; c.toUpperCase()).replace(</span><span class="s4">/[-_]/g</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getComponentName(Component</span><span class="s2">, </span><span class="s1">includeInferred = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">isFunction(Component)</span>
        <span class="s1">? Component.displayName || Component.name</span>
        <span class="s1">: Component.name || (includeInferred &amp;&amp; Component.__name)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">/* istanbul ignore next */</span>
<span class="s2">function </span><span class="s1">formatComponentName(instance</span><span class="s2">, </span><span class="s1">Component</span><span class="s2">, </span><span class="s1">isRoot = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">name = getComponentName(Component)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!name &amp;&amp; Component.__file) {</span>
        <span class="s2">const </span><span class="s1">match = Component.__file.match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(match) {</span>
            <span class="s1">name = match[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!name &amp;&amp; instance &amp;&amp; instance.parent) {</span>
        <span class="s5">// try to infer the name based on reverse resolution</span>
        <span class="s2">const </span><span class="s1">inferFromRegistry = (registry) =&gt; {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">registry) {</span>
                <span class="s2">if </span><span class="s1">(registry[key] === Component) {</span>
                    <span class="s2">return </span><span class="s1">key</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">name =</span>
            <span class="s1">inferFromRegistry(instance.components ||</span>
                <span class="s1">instance.parent.type.components) || inferFromRegistry(instance.appContext.components)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">name ? classify(name) : isRoot ? </span><span class="s3">`App` </span><span class="s1">: </span><span class="s3">`Anonymous`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isClassComponent(value) {</span>
    <span class="s2">return </span><span class="s1">isFunction(value) &amp;&amp; </span><span class="s3">'__vccOpts' </span><span class="s2">in </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">computed = ((getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions) =&gt; {</span>
    <span class="s5">// @ts-ignore</span>
    <span class="s2">return </span><span class="s1">computed$1(getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions</span><span class="s2">, </span><span class="s1">isInSSRComponentSetup)</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s5">// dev only</span>
<span class="s2">const </span><span class="s1">warnRuntimeUsage = (method) =&gt; warn(</span><span class="s3">`</span><span class="s1">${method}</span><span class="s3">() is a compiler-hint helper that is only usable inside ` </span><span class="s1">+</span>
    <span class="s3">`&lt;script setup&gt; of a single file component. Its arguments should be ` </span><span class="s1">+</span>
    <span class="s3">`compiled away and passing it at runtime has no effect.`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// implementation</span>
<span class="s2">function </span><span class="s1">defineProps() {</span>
    <span class="s1">{</span>
        <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineProps`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s5">// implementation</span>
<span class="s2">function </span><span class="s1">defineEmits() {</span>
    <span class="s1">{</span>
        <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineEmits`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's exposed</span>
 <span class="s0">* instance properties when it is accessed by a parent component via template</span>
 <span class="s0">* refs.</span>
 <span class="s0">*</span>
 <span class="s0">* `&lt;script setup&gt;` components are closed by default - i.e. variables inside</span>
 <span class="s0">* the `&lt;script setup&gt;` scope is not exposed to parent unless explicitly exposed</span>
 <span class="s0">* via `defineExpose`.</span>
 <span class="s0">*</span>
 <span class="s0">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s0">* output and should **not** be actually called at runtime.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">defineExpose(exposed) {</span>
    <span class="s1">{</span>
        <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineExpose`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Vue `&lt;script setup&gt;` compiler macro for providing props default values when</span>
 <span class="s0">* using type-based `defineProps` declaration.</span>
 <span class="s0">*</span>
 <span class="s0">* Example usage:</span>
 <span class="s0">* ```ts</span>
 <span class="s0">* withDefaults(defineProps&lt;{</span>
 <span class="s0">*   size?: number</span>
 <span class="s0">*   labels?: string[]</span>
 <span class="s0">* }&gt;(), {</span>
 <span class="s0">*   size: 3,</span>
 <span class="s0">*   labels: () =&gt; ['default label']</span>
 <span class="s0">* })</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the output</span>
 <span class="s0">* and should **not** be actually called at runtime.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">withDefaults(props</span><span class="s2">, </span><span class="s1">defaults) {</span>
    <span class="s1">{</span>
        <span class="s1">warnRuntimeUsage(</span><span class="s3">`withDefaults`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useSlots() {</span>
    <span class="s2">return </span><span class="s1">getContext().slots</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useAttrs() {</span>
    <span class="s2">return </span><span class="s1">getContext().attrs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getContext() {</span>
    <span class="s2">const </span><span class="s1">i = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!i) {</span>
        <span class="s1">warn(</span><span class="s3">`useContext() called without active instance.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">i.setupContext || (i.setupContext = createSetupContext(i))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Runtime helper for merging default declarations. Imported by compiled code</span>
 <span class="s0">* only.</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">mergeDefaults(raw</span><span class="s2">, </span><span class="s1">defaults) {</span>
    <span class="s2">const </span><span class="s1">props = isArray(raw)</span>
        <span class="s1">? raw.reduce((normalized</span><span class="s2">, </span><span class="s1">p) =&gt; ((normalized[p] = {})</span><span class="s2">, </span><span class="s1">normalized)</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s1">: raw</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">defaults) {</span>
        <span class="s2">const </span><span class="s1">opt = props[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(opt) {</span>
            <span class="s2">if </span><span class="s1">(isArray(opt) || isFunction(opt)) {</span>
                <span class="s1">props[key] = { type: opt</span><span class="s2">, default</span><span class="s1">: defaults[key] }</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">opt.default = defaults[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(opt === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">props[key] = { </span><span class="s2">default</span><span class="s1">: defaults[key] }</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`props default key &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has no corresponding declaration.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Used to create a proxy for the rest element when destructuring props with</span>
 <span class="s0">* defineProps().</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">createPropsRestProxy(props</span><span class="s2">, </span><span class="s1">excludedKeys) {</span>
    <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s2">if </span><span class="s1">(!excludedKeys.includes(key)) {</span>
            <span class="s1">Object.defineProperty(ret</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">enumerable: </span><span class="s2">true,</span>
                <span class="s1">get: () =&gt; props[key]</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* `&lt;script setup&gt;` helper for persisting the current instance context over</span>
 <span class="s0">* async/await flows.</span>
 <span class="s0">*</span>
 <span class="s0">* `@vue/compiler-sfc` converts the following:</span>
 <span class="s0">*</span>
 <span class="s0">* ```ts</span>
 <span class="s0">* const x = await foo()</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* into:</span>
 <span class="s0">*</span>
 <span class="s0">* ```ts</span>
 <span class="s0">* let __temp, __restore</span>
 <span class="s0">* const x = (([__temp, __restore] = withAsyncContext(() =&gt; foo())),__temp=await __temp,__restore(),__temp)</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">withAsyncContext(getAwaitable) {</span>
    <span class="s2">const </span><span class="s1">ctx = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!ctx) {</span>
        <span class="s1">warn(</span><span class="s3">`withAsyncContext called without active current instance. ` </span><span class="s1">+</span>
            <span class="s3">`This is likely a bug.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">awaitable = getAwaitable()</span><span class="s2">;</span>
    <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isPromise(awaitable)) {</span>
        <span class="s1">awaitable = awaitable.catch(e =&gt; {</span>
            <span class="s1">setCurrentInstance(ctx)</span><span class="s2">;</span>
            <span class="s2">throw </span><span class="s1">e</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[awaitable</span><span class="s2">, </span><span class="s1">() =&gt; setCurrentInstance(ctx)]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// Actual implementation</span>
<span class="s2">function </span><span class="s1">h(type</span><span class="s2">, </span><span class="s1">propsOrChildren</span><span class="s2">, </span><span class="s1">children) {</span>
    <span class="s2">const </span><span class="s1">l = arguments.length</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(l === </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(isObject(propsOrChildren) &amp;&amp; !isArray(propsOrChildren)) {</span>
            <span class="s5">// single vnode without props</span>
            <span class="s2">if </span><span class="s1">(isVNode(propsOrChildren)) {</span>
                <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, null, </span><span class="s1">[propsOrChildren])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// props without children</span>
            <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, </span><span class="s1">propsOrChildren)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// omit props</span>
            <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, null, </span><span class="s1">propsOrChildren)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(l &gt; </span><span class="s4">3</span><span class="s1">) {</span>
            <span class="s1">children = Array.prototype.slice.call(arguments</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(l === </span><span class="s4">3 </span><span class="s1">&amp;&amp; isVNode(children)) {</span>
            <span class="s1">children = [children]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, </span><span class="s1">propsOrChildren</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">ssrContextKey = Symbol(</span><span class="s3">`ssrContext` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">useSSRContext = () =&gt; {</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">ctx = inject(ssrContextKey)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!ctx) {</span>
            <span class="s1">warn(</span><span class="s3">`Server rendering context not provided. Make sure to only call ` </span><span class="s1">+</span>
                    <span class="s3">`useSSRContext() conditionally in the server build.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">ctx</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">initCustomFormatter() {</span>
    <span class="s5">/* eslint-disable no-restricted-globals */</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">vueStyle = { style: </span><span class="s3">'color:#3ba776' </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">numberStyle = { style: </span><span class="s3">'color:#0b1bc9' </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">stringStyle = { style: </span><span class="s3">'color:#b62e24' </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">keywordStyle = { style: </span><span class="s3">'color:#9d288c' </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// custom formatter for Chrome</span>
    <span class="s5">// https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html</span>
    <span class="s2">const </span><span class="s1">formatter = {</span>
        <span class="s1">header(obj) {</span>
            <span class="s5">// TODO also format ComponentPublicInstance &amp; ctx.slots/attrs in setup</span>
            <span class="s2">if </span><span class="s1">(!isObject(obj)) {</span>
                <span class="s2">return null;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(obj.__isVue) {</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s3">'div'</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s3">`VueInstance`</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isRef(obj)) {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s3">'div'</span><span class="s2">,</span>
                    <span class="s1">{}</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">genRefFlag(obj)]</span><span class="s2">,</span>
                    <span class="s3">'&lt;'</span><span class="s2">,</span>
                    <span class="s1">formatValue(obj.value)</span><span class="s2">,</span>
                    <span class="s3">`&gt;`</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isReactive(obj)) {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s3">'div'</span><span class="s2">,</span>
                    <span class="s1">{}</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">isShallow(obj) ? </span><span class="s3">'ShallowReactive' </span><span class="s1">: </span><span class="s3">'Reactive'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'&lt;'</span><span class="s2">,</span>
                    <span class="s1">formatValue(obj)</span><span class="s2">,</span>
                    <span class="s3">`&gt;</span><span class="s1">${isReadonly(obj) ? </span><span class="s3">` (readonly)` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isReadonly(obj)) {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s3">'div'</span><span class="s2">,</span>
                    <span class="s1">{}</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">isShallow(obj) ? </span><span class="s3">'ShallowReadonly' </span><span class="s1">: </span><span class="s3">'Readonly'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'&lt;'</span><span class="s2">,</span>
                    <span class="s1">formatValue(obj)</span><span class="s2">,</span>
                    <span class="s3">'&gt;'</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return null;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">hasBody(obj) {</span>
            <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__isVue</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">body(obj) {</span>
            <span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__isVue) {</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s3">'div'</span><span class="s2">,</span>
                    <span class="s1">{}</span><span class="s2">,</span>
                    <span class="s1">...formatInstance(obj.$)</span>
                <span class="s1">]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">formatInstance(instance) {</span>
        <span class="s2">const </span><span class="s1">blocks = []</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(instance.type.props &amp;&amp; instance.props) {</span>
            <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">'props'</span><span class="s2">, </span><span class="s1">toRaw(instance.props)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(instance.setupState !== EMPTY_OBJ) {</span>
            <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">'setup'</span><span class="s2">, </span><span class="s1">instance.setupState))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(instance.data !== EMPTY_OBJ) {</span>
            <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">'data'</span><span class="s2">, </span><span class="s1">toRaw(instance.data)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">computed = extractKeys(instance</span><span class="s2">, </span><span class="s3">'computed'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(computed) {</span>
            <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">'computed'</span><span class="s2">, </span><span class="s1">computed))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">injected = extractKeys(instance</span><span class="s2">, </span><span class="s3">'inject'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(injected) {</span>
            <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">'injected'</span><span class="s2">, </span><span class="s1">injected))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">blocks.push([</span>
            <span class="s3">'div'</span><span class="s2">,</span>
            <span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">'span'</span><span class="s2">,</span>
                <span class="s1">{</span>
                    <span class="s1">style: keywordStyle.style + </span><span class="s3">';opacity:0.66'</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s3">'$ (internal): '</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">'object'</span><span class="s2">, </span><span class="s1">{ object: instance }]</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">blocks</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">createInstanceBlock(type</span><span class="s2">, </span><span class="s1">target) {</span>
        <span class="s1">target = extend({}</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!Object.keys(target).length) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">{}]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s3">'div'</span><span class="s2">,</span>
            <span class="s1">{ style: </span><span class="s3">'line-height:1.25em;margin-bottom:0.6em' </span><span class="s1">}</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">'div'</span><span class="s2">,</span>
                <span class="s1">{</span>
                    <span class="s1">style: </span><span class="s3">'color:#476582'</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">type</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">'div'</span><span class="s2">,</span>
                <span class="s1">{</span>
                    <span class="s1">style: </span><span class="s3">'padding-left:1.25em'</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">...Object.keys(target).map(key =&gt; {</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s3">'div'</span><span class="s2">,</span>
                        <span class="s1">{}</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">keywordStyle</span><span class="s2">, </span><span class="s1">key + </span><span class="s3">': '</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">formatValue(target[key]</span><span class="s2">, false</span><span class="s1">)</span>
                    <span class="s1">]</span><span class="s2">;</span>
                <span class="s1">})</span>
            <span class="s1">]</span>
        <span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">formatValue(v</span><span class="s2">, </span><span class="s1">asRaw = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">'number'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">numberStyle</span><span class="s2">, </span><span class="s1">v]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">stringStyle</span><span class="s2">, </span><span class="s1">JSON.stringify(v)]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">keywordStyle</span><span class="s2">, </span><span class="s1">v]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isObject(v)) {</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'object'</span><span class="s2">, </span><span class="s1">{ object: asRaw ? toRaw(v) : v }]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s3">'span'</span><span class="s2">, </span><span class="s1">stringStyle</span><span class="s2">, </span><span class="s1">String(v)]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">extractKeys(instance</span><span class="s2">, </span><span class="s1">type) {</span>
        <span class="s2">const </span><span class="s1">Comp = instance.type</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isFunction(Comp)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">extracted = {}</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">instance.ctx) {</span>
            <span class="s2">if </span><span class="s1">(isKeyOfType(Comp</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type)) {</span>
                <span class="s1">extracted[key] = instance.ctx[key]</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">extracted</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">isKeyOfType(Comp</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type) {</span>
        <span class="s2">const </span><span class="s1">opts = Comp[type]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((isArray(opts) &amp;&amp; opts.includes(key)) ||</span>
            <span class="s1">(isObject(opts) &amp;&amp; key </span><span class="s2">in </span><span class="s1">opts)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(Comp.extends &amp;&amp; isKeyOfType(Comp.extends</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(Comp.mixins &amp;&amp; Comp.mixins.some(m =&gt; isKeyOfType(m</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type))) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">genRefFlag(v) {</span>
        <span class="s2">if </span><span class="s1">(isShallow(v)) {</span>
            <span class="s2">return </span><span class="s3">`ShallowRef`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(v.effect) {</span>
            <span class="s2">return </span><span class="s3">`ComputedRef`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s3">`Ref`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(window.devtoolsFormatters) {</span>
        <span class="s1">window.devtoolsFormatters.push(formatter)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">window.devtoolsFormatters = [formatter]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">withMemo(memo</span><span class="s2">, </span><span class="s1">render</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s2">const </span><span class="s1">cached = cache[index]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached &amp;&amp; isMemoSame(cached</span><span class="s2">, </span><span class="s1">memo)) {</span>
        <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">ret = render()</span><span class="s2">;</span>
    <span class="s5">// shallow clone</span>
    <span class="s1">ret.memo = memo.slice()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(cache[index] = ret)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isMemoSame(cached</span><span class="s2">, </span><span class="s1">memo) {</span>
    <span class="s2">const </span><span class="s1">prev = cached.memo</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prev.length != memo.length) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prev.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(hasChanged(prev[i]</span><span class="s2">, </span><span class="s1">memo[i])) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// make sure to let parent block track it when returning cached</span>
    <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; currentBlock) {</span>
        <span class="s1">currentBlock.push(cached)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>

<span class="s5">// Core API ------------------------------------------------------------------</span>
<span class="s2">const </span><span class="s1">version = </span><span class="s3">&quot;3.2.47&quot;</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">ssrUtils = (</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@internal </span><span class="s0">only exposed in compat builds</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">resolveFilter = </span><span class="s2">null;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@internal </span><span class="s0">only exposed in compat builds.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">compatUtils = (</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">svgNS = </span><span class="s3">'http://www.w3.org/2000/svg'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">doc = (</span><span class="s2">typeof </span><span class="s1">document !== </span><span class="s3">'undefined' </span><span class="s1">? document : </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">templateContainer = doc &amp;&amp; </span><span class="s5">/*#__PURE__*/ </span><span class="s1">doc.createElement(</span><span class="s3">'template'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">nodeOps = {</span>
    <span class="s1">insert: (child</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
        <span class="s1">parent.insertBefore(child</span><span class="s2">, </span><span class="s1">anchor || </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">remove: child =&gt; {</span>
        <span class="s2">const </span><span class="s1">parent = child.parentNode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parent) {</span>
            <span class="s1">parent.removeChild(child)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">createElement: (tag</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">is</span><span class="s2">, </span><span class="s1">props) =&gt; {</span>
        <span class="s2">const </span><span class="s1">el = isSVG</span>
            <span class="s1">? doc.createElementNS(svgNS</span><span class="s2">, </span><span class="s1">tag)</span>
            <span class="s1">: doc.createElement(tag</span><span class="s2">, </span><span class="s1">is ? { is } : undefined)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'select' </span><span class="s1">&amp;&amp; props &amp;&amp; props.multiple != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">el.setAttribute(</span><span class="s3">'multiple'</span><span class="s2">, </span><span class="s1">props.multiple)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">el</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">createText: text =&gt; doc.createTextNode(text)</span><span class="s2">,</span>
    <span class="s1">createComment: text =&gt; doc.createComment(text)</span><span class="s2">,</span>
    <span class="s1">setText: (node</span><span class="s2">, </span><span class="s1">text) =&gt; {</span>
        <span class="s1">node.nodeValue = text</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">setElementText: (el</span><span class="s2">, </span><span class="s1">text) =&gt; {</span>
        <span class="s1">el.textContent = text</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">parentNode: node =&gt; node.parentNode</span><span class="s2">,</span>
    <span class="s1">nextSibling: node =&gt; node.nextSibling</span><span class="s2">,</span>
    <span class="s1">querySelector: selector =&gt; doc.querySelector(selector)</span><span class="s2">,</span>
    <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">id) {</span>
        <span class="s1">el.setAttribute(id</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// __UNSAFE__</span>
    <span class="s5">// Reason: innerHTML.</span>
    <span class="s5">// Static content here can only come from compiled templates.</span>
    <span class="s5">// As long as the user only uses trusted templates, this is safe.</span>
    <span class="s1">insertStaticContent(content</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
        <span class="s5">// &lt;parent&gt; before | first ... last | anchor &lt;/parent&gt;</span>
        <span class="s2">const </span><span class="s1">before = anchor ? anchor.previousSibling : parent.lastChild</span><span class="s2">;</span>
        <span class="s5">// #5308 can only take cached path if:</span>
        <span class="s5">// - has a single root node</span>
        <span class="s5">// - nextSibling info is still available</span>
        <span class="s2">if </span><span class="s1">(start &amp;&amp; (start === end || start.nextSibling)) {</span>
            <span class="s5">// cached</span>
            <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
                <span class="s1">parent.insertBefore(start.cloneNode(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(start === end || !(start = start.nextSibling))</span>
                    <span class="s2">break;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// fresh insert</span>
            <span class="s1">templateContainer.innerHTML = isSVG ? </span><span class="s3">`&lt;svg&gt;</span><span class="s1">${content}</span><span class="s3">&lt;/svg&gt;` </span><span class="s1">: content</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">template = templateContainer.content</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isSVG) {</span>
                <span class="s5">// remove outer svg wrapper</span>
                <span class="s2">const </span><span class="s1">wrapper = template.firstChild</span><span class="s2">;</span>
                <span class="s2">while </span><span class="s1">(wrapper.firstChild) {</span>
                    <span class="s1">template.appendChild(wrapper.firstChild)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">template.removeChild(wrapper)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">parent.insertBefore(template</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s5">// first</span>
            <span class="s1">before ? before.nextSibling : parent.firstChild</span><span class="s2">,</span>
            <span class="s5">// last</span>
            <span class="s1">anchor ? anchor.previousSibling : parent.lastChild</span>
        <span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">// compiler should normalize class + :class bindings on the same element</span>
<span class="s5">// into a single binding ['staticClass', dynamic]</span>
<span class="s2">function </span><span class="s1">patchClass(el</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG) {</span>
    <span class="s5">// directly setting className should be faster than setAttribute in theory</span>
    <span class="s5">// if this is an element during a transition, take the temporary transition</span>
    <span class="s5">// classes into account.</span>
    <span class="s2">const </span><span class="s1">transitionClasses = el._vtc</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(transitionClasses) {</span>
        <span class="s1">value = (value ? [value</span><span class="s2">, </span><span class="s1">...transitionClasses] : [...transitionClasses]).join(</span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">el.removeAttribute(</span><span class="s3">'class'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isSVG) {</span>
        <span class="s1">el.setAttribute(</span><span class="s3">'class'</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">el.className = value</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">patchStyle(el</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next) {</span>
    <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isCssString = isString(next)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(next &amp;&amp; !isCssString) {</span>
        <span class="s2">if </span><span class="s1">(prev &amp;&amp; !isString(prev)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">prev) {</span>
                <span class="s2">if </span><span class="s1">(next[key] == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">next) {</span>
            <span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">next[key])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">currentDisplay = style.display</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isCssString) {</span>
            <span class="s2">if </span><span class="s1">(prev !== next) {</span>
                <span class="s1">style.cssText = next</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(prev) {</span>
            <span class="s1">el.removeAttribute(</span><span class="s3">'style'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// indicates that the `display` of the element is controlled by `v-show`,</span>
        <span class="s5">// so we always keep the current `display` value regardless of the `style`</span>
        <span class="s5">// value, thus handing over control to `v-show`.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s3">'_vod' </span><span class="s2">in </span><span class="s1">el) {</span>
            <span class="s1">style.display = currentDisplay</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">semicolonRE = </span><span class="s4">/[^\\];\s*$/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">importantRE = </span><span class="s4">/\s*!important$/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val) {</span>
    <span class="s2">if </span><span class="s1">(isArray(val)) {</span>
        <span class="s1">val.forEach(v =&gt; setStyle(style</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">v))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(val == </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s1">val = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(semicolonRE.test(val)) {</span>
                <span class="s1">warn(</span><span class="s3">`Unexpected semicolon at the end of '</span><span class="s1">${name}</span><span class="s3">' style value: '</span><span class="s1">${val}</span><span class="s3">'`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(name.startsWith(</span><span class="s3">'--'</span><span class="s1">)) {</span>
            <span class="s5">// custom property definition</span>
            <span class="s1">style.setProperty(name</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">prefixed = autoPrefix(style</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(importantRE.test(val)) {</span>
                <span class="s5">// !important</span>
                <span class="s1">style.setProperty(hyphenate(prefixed)</span><span class="s2">, </span><span class="s1">val.replace(importantRE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'important'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">style[prefixed] = val</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">prefixes = [</span><span class="s3">'Webkit'</span><span class="s2">, </span><span class="s3">'Moz'</span><span class="s2">, </span><span class="s3">'ms'</span><span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">prefixCache = {}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">autoPrefix(style</span><span class="s2">, </span><span class="s1">rawName) {</span>
    <span class="s2">const </span><span class="s1">cached = prefixCache[rawName]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached) {</span>
        <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">name = camelize(rawName)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">'filter' </span><span class="s1">&amp;&amp; name </span><span class="s2">in </span><span class="s1">style) {</span>
        <span class="s2">return </span><span class="s1">(prefixCache[rawName] = name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">name = capitalize(name)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prefixes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">prefixed = prefixes[i] + name</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prefixed </span><span class="s2">in </span><span class="s1">style) {</span>
            <span class="s2">return </span><span class="s1">(prefixCache[rawName] = prefixed)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">rawName</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">xlinkNS = </span><span class="s3">'http://www.w3.org/1999/xlink'</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">patchAttr(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">instance) {</span>
    <span class="s2">if </span><span class="s1">(isSVG &amp;&amp; key.startsWith(</span><span class="s3">'xlink:'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">el.removeAttributeNS(xlinkNS</span><span class="s2">, </span><span class="s1">key.slice(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">key.length))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">el.setAttributeNS(xlinkNS</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// note we are only checking boolean attributes that don't have a</span>
        <span class="s5">// corresponding dom prop of the same name here.</span>
        <span class="s2">const </span><span class="s1">isBoolean = isSpecialBooleanAttr(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">|| (isBoolean &amp;&amp; !includeBooleanAttr(value))) {</span>
            <span class="s1">el.removeAttribute(key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">el.setAttribute(key</span><span class="s2">, </span><span class="s1">isBoolean ? </span><span class="s3">'' </span><span class="s1">: value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">// __UNSAFE__</span>
<span class="s5">// functions. The user is responsible for using them with only trusted content.</span>
<span class="s2">function </span><span class="s1">patchDOMProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span>
<span class="s5">// the following args are passed only due to potential innerHTML/textContent</span>
<span class="s5">// overriding existing VNodes, in which case the old tree must be properly</span>
<span class="s5">// unmounted.</span>
<span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren) {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'innerHTML' </span><span class="s1">|| key === </span><span class="s3">'textContent'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(prevChildren) {</span>
            <span class="s1">unmountChildren(prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">el[key] = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: value</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'value' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">el.tagName !== </span><span class="s3">'PROGRESS' </span><span class="s1">&amp;&amp;</span>
        <span class="s5">// custom elements may use _value internally</span>
        <span class="s1">!el.tagName.includes(</span><span class="s3">'-'</span><span class="s1">)) {</span>
        <span class="s5">// store value as _value as well since</span>
        <span class="s5">// non-string values will be stringified.</span>
        <span class="s1">el._value = value</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">newValue = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: value</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(el.value !== newValue ||</span>
            <span class="s5">// #4956: always set for OPTION elements because its value falls back to</span>
            <span class="s5">// textContent if no value attribute is present. And setting .value for</span>
            <span class="s5">// OPTION has no side effect</span>
            <span class="s1">el.tagName === </span><span class="s3">'OPTION'</span><span class="s1">) {</span>
            <span class="s1">el.value = newValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">el.removeAttribute(key)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">needRemove = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'' </span><span class="s1">|| value == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">el[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
            <span class="s5">// e.g. &lt;select multiple&gt; compiles to { multiple: '' }</span>
            <span class="s1">value = includeBooleanAttr(value)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">&amp;&amp; type === </span><span class="s3">'string'</span><span class="s1">) {</span>
            <span class="s5">// e.g. &lt;div :id=&quot;null&quot;&gt;</span>
            <span class="s1">value = </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s1">needRemove = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(type === </span><span class="s3">'number'</span><span class="s1">) {</span>
            <span class="s5">// e.g. &lt;img :width=&quot;null&quot;&gt;</span>
            <span class="s1">value = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">needRemove = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// some properties perform value validation and throw,</span>
    <span class="s5">// some properties has getter, no setter, will error in 'use strict'</span>
    <span class="s5">// eg. &lt;select :type=&quot;null&quot;&gt;&lt;/select&gt; &lt;select :willValidate=&quot;null&quot;&gt;&lt;/select&gt;</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">el[key] = value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s5">// do not warn if value is auto-coerced from nullish values</span>
        <span class="s2">if </span><span class="s1">(!needRemove) {</span>
            <span class="s1">warn(</span><span class="s3">`Failed setting prop &quot;</span><span class="s1">${key}</span><span class="s3">&quot; on &lt;</span><span class="s1">${el.tagName.toLowerCase()}</span><span class="s3">&gt;: ` </span><span class="s1">+</span>
                <span class="s3">`value </span><span class="s1">${value} </span><span class="s3">is invalid.`</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">needRemove &amp;&amp; el.removeAttribute(key)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s1">el.addEventListener(event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeEventListener(el</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s1">el.removeEventListener(event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchEvent(el</span><span class="s2">, </span><span class="s1">rawName</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">instance = </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s5">// vei = vue event invokers</span>
    <span class="s2">const </span><span class="s1">invokers = el._vei || (el._vei = {})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">existingInvoker = invokers[rawName]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextValue &amp;&amp; existingInvoker) {</span>
        <span class="s5">// patch</span>
        <span class="s1">existingInvoker.value = nextValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">options] = parseName(rawName)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(nextValue) {</span>
            <span class="s5">// add</span>
            <span class="s2">const </span><span class="s1">invoker = (invokers[rawName] = createInvoker(nextValue</span><span class="s2">, </span><span class="s1">instance))</span><span class="s2">;</span>
            <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">invoker</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(existingInvoker) {</span>
            <span class="s5">// remove</span>
            <span class="s1">removeEventListener(el</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">existingInvoker</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
            <span class="s1">invokers[rawName] = undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">optionsModifierRE = </span><span class="s4">/(?:Once|Passive|Capture)$/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseName(name) {</span>
    <span class="s2">let </span><span class="s1">options</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(optionsModifierRE.test(name)) {</span>
        <span class="s1">options = {}</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">m</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">((m = name.match(optionsModifierRE))) {</span>
            <span class="s1">name = name.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">name.length - m[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s2">;</span>
            <span class="s1">options[m[</span><span class="s4">0</span><span class="s1">].toLowerCase()] = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">event = name[</span><span class="s4">2</span><span class="s1">] === </span><span class="s3">':' </span><span class="s1">? name.slice(</span><span class="s4">3</span><span class="s1">) : hyphenate(name.slice(</span><span class="s4">2</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[event</span><span class="s2">, </span><span class="s1">options]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// To avoid the overhead of repeatedly calling Date.now(), we cache</span>
<span class="s5">// and use the same timestamp for all event listeners attached in the same tick.</span>
<span class="s2">let </span><span class="s1">cachedNow = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">p = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">Promise.resolve()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">getNow = () =&gt; cachedNow || (p.then(() =&gt; (cachedNow = </span><span class="s4">0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(cachedNow = Date.now()))</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createInvoker(initialValue</span><span class="s2">, </span><span class="s1">instance) {</span>
    <span class="s2">const </span><span class="s1">invoker = (e) =&gt; {</span>
        <span class="s5">// async edge case vuejs/vue#6566</span>
        <span class="s5">// inner click event triggers patch, event handler</span>
        <span class="s5">// attached to outer element during patch, and triggered again. This</span>
        <span class="s5">// happens because browsers fire microtask ticks between event propagation.</span>
        <span class="s5">// this no longer happens for templates in Vue 3, but could still be</span>
        <span class="s5">// theoretically possible for hand-written render functions.</span>
        <span class="s5">// the solution: we save the timestamp when a handler is attached,</span>
        <span class="s5">// and also attach the timestamp to any event that was handled by vue</span>
        <span class="s5">// for the first time (to avoid inconsistent event timestamp implementations</span>
        <span class="s5">// or events fired from iframes, e.g. #2513)</span>
        <span class="s5">// The handler would only fire if the event passed to it was fired</span>
        <span class="s5">// AFTER it was attached.</span>
        <span class="s2">if </span><span class="s1">(!e._vts) {</span>
            <span class="s1">e._vts = Date.now()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(e._vts &lt;= invoker.attached) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">callWithAsyncErrorHandling(patchStopImmediatePropagation(e</span><span class="s2">, </span><span class="s1">invoker.value)</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">5 </span><span class="s5">/* ErrorCodes.NATIVE_EVENT_HANDLER */</span><span class="s2">, </span><span class="s1">[e])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">invoker.value = initialValue</span><span class="s2">;</span>
    <span class="s1">invoker.attached = getNow()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">invoker</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchStopImmediatePropagation(e</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s2">const </span><span class="s1">originalStop = e.stopImmediatePropagation</span><span class="s2">;</span>
        <span class="s1">e.stopImmediatePropagation = () =&gt; {</span>
            <span class="s1">originalStop.call(e)</span><span class="s2">;</span>
            <span class="s1">e._stopped = </span><span class="s2">true;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">value.map(fn =&gt; (e) =&gt; !e._stopped &amp;&amp; fn &amp;&amp; fn(e))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">nativeOnRE = </span><span class="s4">/^on[a-z]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">patchProp = (el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG = </span><span class="s2">false, </span><span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'class'</span><span class="s1">) {</span>
        <span class="s1">patchClass(el</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">'style'</span><span class="s1">) {</span>
        <span class="s1">patchStyle(el</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isOn(key)) {</span>
        <span class="s5">// ignore v-model listeners</span>
        <span class="s2">if </span><span class="s1">(!isModelListener(key)) {</span>
            <span class="s1">patchEvent(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'.'</span>
        <span class="s1">? ((key = key.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">, true</span><span class="s1">)</span>
        <span class="s1">: key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'^'</span>
            <span class="s1">? ((key = key.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">, false</span><span class="s1">)</span>
            <span class="s1">: shouldSetAsProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)) {</span>
        <span class="s1">patchDOMProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// special case for &lt;input v-model type=&quot;checkbox&quot;&gt; with</span>
        <span class="s5">// :true-value &amp; :false-value</span>
        <span class="s5">// store value as dom properties since non-string values will be</span>
        <span class="s5">// stringified.</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'true-value'</span><span class="s1">) {</span>
            <span class="s1">el._trueValue = nextValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(key === </span><span class="s3">'false-value'</span><span class="s1">) {</span>
            <span class="s1">el._falseValue = nextValue</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">patchAttr(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">shouldSetAsProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG) {</span>
    <span class="s2">if </span><span class="s1">(isSVG) {</span>
        <span class="s5">// most keys must be set as attribute on svg elements to work</span>
        <span class="s5">// ...except innerHTML &amp; textContent</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'innerHTML' </span><span class="s1">|| key === </span><span class="s3">'textContent'</span><span class="s1">) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s5">// or native onclick with function values</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">el &amp;&amp; nativeOnRE.test(key) &amp;&amp; isFunction(value)) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s5">// these are enumerated attrs, however their corresponding DOM properties</span>
    <span class="s5">// are actually booleans - this leads to setting it with a string &quot;false&quot;</span>
    <span class="s5">// value leading it to be coerced to `true`, so we need to always treat</span>
    <span class="s5">// them as attributes.</span>
    <span class="s5">// Note that `contentEditable` doesn't have this problem: its DOM</span>
    <span class="s5">// property is also enumerated string values.</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'spellcheck' </span><span class="s1">|| key === </span><span class="s3">'draggable' </span><span class="s1">|| key === </span><span class="s3">'translate'</span><span class="s1">) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s5">// #1787, #2840 form property on form elements is readonly and must be set as</span>
    <span class="s5">// attribute.</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'form'</span><span class="s1">) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s5">// #1526 &lt;input list&gt; must be set as attribute</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'list' </span><span class="s1">&amp;&amp; el.tagName === </span><span class="s3">'INPUT'</span><span class="s1">) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s5">// #2766 &lt;textarea type&gt; must be set as attribute</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'type' </span><span class="s1">&amp;&amp; el.tagName === </span><span class="s3">'TEXTAREA'</span><span class="s1">) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s5">// native onclick with string value, must be set as attribute</span>
    <span class="s2">if </span><span class="s1">(nativeOnRE.test(key) &amp;&amp; isString(value)) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">el</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">defineCustomElement(options</span><span class="s2">, </span><span class="s1">hydrate) {</span>
    <span class="s2">const </span><span class="s1">Comp = defineComponent(options)</span><span class="s2">;</span>
    <span class="s2">class </span><span class="s1">VueCustomElement </span><span class="s2">extends </span><span class="s1">VueElement {</span>
        <span class="s1">constructor(initialProps) {</span>
            <span class="s2">super</span><span class="s1">(Comp</span><span class="s2">, </span><span class="s1">initialProps</span><span class="s2">, </span><span class="s1">hydrate)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">VueCustomElement.def = Comp</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">VueCustomElement</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">defineSSRCustomElement = ((options) =&gt; {</span>
    <span class="s5">// @ts-ignore</span>
    <span class="s2">return </span><span class="s1">defineCustomElement(options</span><span class="s2">, </span><span class="s1">hydrate)</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">BaseClass = (</span><span class="s2">typeof </span><span class="s1">HTMLElement !== </span><span class="s3">'undefined' </span><span class="s1">? HTMLElement : </span><span class="s2">class </span><span class="s1">{</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">class </span><span class="s1">VueElement </span><span class="s2">extends </span><span class="s1">BaseClass {</span>
    <span class="s1">constructor(_def</span><span class="s2">, </span><span class="s1">_props = {}</span><span class="s2">, </span><span class="s1">hydrate) {</span>
        <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._def = _def</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._props = _props</span><span class="s2">;</span>
        <span class="s0">/**</span>
         <span class="s0">* </span><span class="s6">@internal</span>
         <span class="s0">*/</span>
        <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
        <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">._resolved = </span><span class="s2">false;</span>
        <span class="s2">this</span><span class="s1">._numberProps = </span><span class="s2">null;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shadowRoot &amp;&amp; hydrate) {</span>
            <span class="s1">hydrate(</span><span class="s2">this</span><span class="s1">._createVNode()</span><span class="s2">, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shadowRoot) {</span>
                <span class="s1">warn(</span><span class="s3">`Custom element has pre-rendered declarative shadow root but is not ` </span><span class="s1">+</span>
                    <span class="s3">`defined as hydratable. Use </span><span class="s2">\`</span><span class="s3">defineSSRCustomElement</span><span class="s2">\`</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.attachShadow({ mode: </span><span class="s3">'open' </span><span class="s1">})</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._def.__asyncLoader) {</span>
                <span class="s5">// for sync component defs we can immediately resolve props</span>
                <span class="s2">this</span><span class="s1">._resolveProps(</span><span class="s2">this</span><span class="s1">._def)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">connectedCallback() {</span>
        <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._instance) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._resolved) {</span>
                <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">._resolveDef()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">disconnectedCallback() {</span>
        <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">false;</span>
        <span class="s1">nextTick(() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._connected) {</span>
                <span class="s1">render(</span><span class="s2">null, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* resolve inner component definition (handle possible async component)</span>
     <span class="s0">*/</span>
    <span class="s1">_resolveDef() {</span>
        <span class="s2">this</span><span class="s1">._resolved = </span><span class="s2">true;</span>
        <span class="s5">// set initial attrs</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; </span><span class="s2">this</span><span class="s1">.attributes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">this</span><span class="s1">._setAttr(</span><span class="s2">this</span><span class="s1">.attributes[i].name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// watch future attr changes</span>
        <span class="s2">new </span><span class="s1">MutationObserver(mutations =&gt; {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">m of mutations) {</span>
                <span class="s2">this</span><span class="s1">._setAttr(m.attributeName)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}).observe(</span><span class="s2">this, </span><span class="s1">{ attributes: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">resolve = (def</span><span class="s2">, </span><span class="s1">isAsync = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">styles } = def</span><span class="s2">;</span>
            <span class="s5">// cast Number-type props set before resolve</span>
            <span class="s2">let </span><span class="s1">numberProps</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(props &amp;&amp; !isArray(props)) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
                    <span class="s2">const </span><span class="s1">opt = props[key]</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(opt === Number || (opt &amp;&amp; opt.type === Number)) {</span>
                        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in this</span><span class="s1">._props) {</span>
                            <span class="s2">this</span><span class="s1">._props[key] = toNumber(</span><span class="s2">this</span><span class="s1">._props[key])</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s1">(numberProps || (numberProps = Object.create(</span><span class="s2">null</span><span class="s1">)))[camelize(key)] = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">._numberProps = numberProps</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isAsync) {</span>
                <span class="s5">// defining getter/setters on prototype</span>
                <span class="s5">// for sync defs, this already happened in the constructor</span>
                <span class="s2">this</span><span class="s1">._resolveProps(def)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// apply CSS</span>
            <span class="s2">this</span><span class="s1">._applyStyles(styles)</span><span class="s2">;</span>
            <span class="s5">// initial render</span>
            <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">asyncDef = </span><span class="s2">this</span><span class="s1">._def.__asyncLoader</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(asyncDef) {</span>
            <span class="s1">asyncDef().then(def =&gt; resolve(def</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">resolve(</span><span class="s2">this</span><span class="s1">._def)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">_resolveProps(def) {</span>
        <span class="s2">const </span><span class="s1">{ props } = def</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">declaredPropKeys = isArray(props) ? props : Object.keys(props || {})</span><span class="s2">;</span>
        <span class="s5">// check if there are props set pre-upgrade or connect</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(</span><span class="s2">this</span><span class="s1">)) {</span>
            <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">'_' </span><span class="s1">&amp;&amp; declaredPropKeys.includes(key)) {</span>
                <span class="s2">this</span><span class="s1">._setProp(key</span><span class="s2">, this</span><span class="s1">[key]</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// defining getter/setters on prototype</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of declaredPropKeys.map(camelize)) {</span>
            <span class="s1">Object.defineProperty(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                <span class="s1">get() {</span>
                    <span class="s2">return this</span><span class="s1">._getProp(key)</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s1">set(val) {</span>
                    <span class="s2">this</span><span class="s1">._setProp(key</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">_setAttr(key) {</span>
        <span class="s2">let </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.getAttribute(key)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">camelKey = camelize(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._numberProps &amp;&amp; </span><span class="s2">this</span><span class="s1">._numberProps[camelKey]) {</span>
            <span class="s1">value = toNumber(value)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">._setProp(camelKey</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s6">@internal</span>
     <span class="s0">*/</span>
    <span class="s1">_getProp(key) {</span>
        <span class="s2">return this</span><span class="s1">._props[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s6">@internal</span>
     <span class="s0">*/</span>
    <span class="s1">_setProp(key</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">shouldReflect = </span><span class="s2">true, </span><span class="s1">shouldUpdate = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(val !== </span><span class="s2">this</span><span class="s1">._props[key]) {</span>
            <span class="s2">this</span><span class="s1">._props[key] = val</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(shouldUpdate &amp;&amp; </span><span class="s2">this</span><span class="s1">._instance) {</span>
                <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// reflect</span>
            <span class="s2">if </span><span class="s1">(shouldReflect) {</span>
                <span class="s2">if </span><span class="s1">(val === </span><span class="s2">true</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.setAttribute(hyphenate(key)</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'string' </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">'number'</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.setAttribute(hyphenate(key)</span><span class="s2">, </span><span class="s1">val + </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!val) {</span>
                    <span class="s2">this</span><span class="s1">.removeAttribute(hyphenate(key))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">_update() {</span>
        <span class="s1">render(</span><span class="s2">this</span><span class="s1">._createVNode()</span><span class="s2">, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">_createVNode() {</span>
        <span class="s2">const </span><span class="s1">vnode = createVNode(</span><span class="s2">this</span><span class="s1">._def</span><span class="s2">, </span><span class="s1">extend({}</span><span class="s2">, this</span><span class="s1">._props))</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._instance) {</span>
            <span class="s1">vnode.ce = instance =&gt; {</span>
                <span class="s2">this</span><span class="s1">._instance = instance</span><span class="s2">;</span>
                <span class="s1">instance.isCE = </span><span class="s2">true;</span>
                <span class="s5">// HMR</span>
                <span class="s1">{</span>
                    <span class="s1">instance.ceReload = newStyles =&gt; {</span>
                        <span class="s5">// always reset styles</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._styles) {</span>
                            <span class="s2">this</span><span class="s1">._styles.forEach(s =&gt; </span><span class="s2">this</span><span class="s1">.shadowRoot.removeChild(s))</span><span class="s2">;</span>
                            <span class="s2">this</span><span class="s1">._styles.length = </span><span class="s4">0</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">this</span><span class="s1">._applyStyles(newStyles)</span><span class="s2">;</span>
                        <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
                        <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
                    <span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">dispatch = (event</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
                    <span class="s2">this</span><span class="s1">.dispatchEvent(</span><span class="s2">new </span><span class="s1">CustomEvent(event</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">detail: args</span>
                    <span class="s1">}))</span><span class="s2">;</span>
                <span class="s1">}</span><span class="s2">;</span>
                <span class="s5">// intercept emit</span>
                <span class="s1">instance.emit = (event</span><span class="s2">, </span><span class="s1">...args) =&gt; {</span>
                    <span class="s5">// dispatch both the raw and hyphenated versions of an event</span>
                    <span class="s5">// to match Vue behavior</span>
                    <span class="s1">dispatch(event</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(hyphenate(event) !== event) {</span>
                        <span class="s1">dispatch(hyphenate(event)</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span><span class="s2">;</span>
                <span class="s5">// locate nearest Vue custom element parent for provide/inject</span>
                <span class="s2">let </span><span class="s1">parent = </span><span class="s2">this;</span>
                <span class="s2">while </span><span class="s1">((parent =</span>
                    <span class="s1">parent &amp;&amp; (parent.parentNode || parent.host))) {</span>
                    <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">VueElement) {</span>
                        <span class="s1">instance.parent = parent._instance</span><span class="s2">;</span>
                        <span class="s1">instance.provides = parent._instance.provides</span><span class="s2">;</span>
                        <span class="s2">break;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">_applyStyles(styles) {</span>
        <span class="s2">if </span><span class="s1">(styles) {</span>
            <span class="s1">styles.forEach(css =&gt; {</span>
                <span class="s2">const </span><span class="s1">s = document.createElement(</span><span class="s3">'style'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">s.textContent = css</span><span class="s2">;</span>
                <span class="s2">this</span><span class="s1">.shadowRoot.appendChild(s)</span><span class="s2">;</span>
                <span class="s5">// record for HMR</span>
                <span class="s1">{</span>
                    <span class="s1">(</span><span class="s2">this</span><span class="s1">._styles || (</span><span class="s2">this</span><span class="s1">._styles = [])).push(s)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useCssModule(name = </span><span class="s3">'$style'</span><span class="s1">) {</span>
    <span class="s5">/* istanbul ignore else */</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!instance) {</span>
            <span class="s1">warn(</span><span class="s3">`useCssModule must be called inside setup()`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">modules = instance.type.__cssModules</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!modules) {</span>
            <span class="s1">warn(</span><span class="s3">`Current instance does not have CSS modules injected.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">mod = modules[name]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!mod) {</span>
            <span class="s1">warn(</span><span class="s3">`Current instance does not have CSS module named &quot;</span><span class="s1">${name}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">mod</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runtime helper for SFC's CSS variable injection feature.</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">useCssVars(getter) {</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s5">/* istanbul ignore next */</span>
    <span class="s2">if </span><span class="s1">(!instance) {</span>
        <span class="s1">warn(</span><span class="s3">`useCssVars is called without current active component instance.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">updateTeleports = (instance.ut = (vars = getter(instance.proxy)) =&gt; {</span>
        <span class="s1">Array.from(document.querySelectorAll(</span><span class="s3">`[data-v-owner=&quot;</span><span class="s1">${instance.uid}</span><span class="s3">&quot;]`</span><span class="s1">)).forEach(node =&gt; setVarsOnNode(node</span><span class="s2">, </span><span class="s1">vars))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setVars = () =&gt; {</span>
        <span class="s2">const </span><span class="s1">vars = getter(instance.proxy)</span><span class="s2">;</span>
        <span class="s1">setVarsOnVNode(instance.subTree</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
        <span class="s1">updateTeleports(vars)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">watchPostEffect(setVars)</span><span class="s2">;</span>
    <span class="s1">onMounted(() =&gt; {</span>
        <span class="s2">const </span><span class="s1">ob = </span><span class="s2">new </span><span class="s1">MutationObserver(setVars)</span><span class="s2">;</span>
        <span class="s1">ob.observe(instance.subTree.el.parentNode</span><span class="s2">, </span><span class="s1">{ childList: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
        <span class="s1">onUnmounted(() =&gt; ob.disconnect())</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setVarsOnVNode(vnode</span><span class="s2">, </span><span class="s1">vars) {</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s5">/* ShapeFlags.SUSPENSE */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">suspense = vnode.suspense</span><span class="s2">;</span>
        <span class="s1">vnode = suspense.activeBranch</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(suspense.pendingBranch &amp;&amp; !suspense.isHydrating) {</span>
            <span class="s1">suspense.effects.push(() =&gt; {</span>
                <span class="s1">setVarsOnVNode(suspense.activeBranch</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// drill down HOCs until it's a non-component vnode</span>
    <span class="s2">while </span><span class="s1">(vnode.component) {</span>
        <span class="s1">vnode = vnode.component.subTree</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">1 </span><span class="s5">/* ShapeFlags.ELEMENT */ </span><span class="s1">&amp;&amp; vnode.el) {</span>
        <span class="s1">setVarsOnNode(vnode.el</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(vnode.type === Fragment) {</span>
        <span class="s1">vnode.children.forEach(c =&gt; setVarsOnVNode(c</span><span class="s2">, </span><span class="s1">vars))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(vnode.type === Static) {</span>
        <span class="s2">let </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">anchor } = vnode</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(el) {</span>
            <span class="s1">setVarsOnNode(el</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(el === anchor)</span>
                <span class="s2">break;</span>
            <span class="s1">el = el.nextSibling</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setVarsOnNode(el</span><span class="s2">, </span><span class="s1">vars) {</span>
    <span class="s2">if </span><span class="s1">(el.nodeType === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">vars) {</span>
            <span class="s1">style.setProperty(</span><span class="s3">`--</span><span class="s1">${key}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">vars[key])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">TRANSITION$1 = </span><span class="s3">'transition'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">ANIMATION = </span><span class="s3">'animation'</span><span class="s2">;</span>
<span class="s5">// DOM Transition is a higher-order-component based on the platform-agnostic</span>
<span class="s5">// base Transition component, with DOM-specific logic.</span>
<span class="s2">const </span><span class="s1">Transition = (props</span><span class="s2">, </span><span class="s1">{ slots }) =&gt; h(BaseTransition</span><span class="s2">, </span><span class="s1">resolveTransitionProps(props)</span><span class="s2">, </span><span class="s1">slots)</span><span class="s2">;</span>
<span class="s1">Transition.displayName = </span><span class="s3">'Transition'</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">DOMTransitionPropsValidators = {</span>
    <span class="s1">name: String</span><span class="s2">,</span>
    <span class="s1">type: String</span><span class="s2">,</span>
    <span class="s1">css: {</span>
        <span class="s1">type: Boolean</span><span class="s2">,</span>
        <span class="s2">default</span><span class="s1">: </span><span class="s2">true</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">duration: [String</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">, </span><span class="s1">Object]</span><span class="s2">,</span>
    <span class="s1">enterFromClass: String</span><span class="s2">,</span>
    <span class="s1">enterActiveClass: String</span><span class="s2">,</span>
    <span class="s1">enterToClass: String</span><span class="s2">,</span>
    <span class="s1">appearFromClass: String</span><span class="s2">,</span>
    <span class="s1">appearActiveClass: String</span><span class="s2">,</span>
    <span class="s1">appearToClass: String</span><span class="s2">,</span>
    <span class="s1">leaveFromClass: String</span><span class="s2">,</span>
    <span class="s1">leaveActiveClass: String</span><span class="s2">,</span>
    <span class="s1">leaveToClass: String</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TransitionPropsValidators = (Transition.props =</span>
    <span class="s5">/*#__PURE__*/ </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">BaseTransition.props</span><span class="s2">, </span><span class="s1">DOMTransitionPropsValidators))</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* #3227 Incoming hooks may be merged into arrays when wrapping Transition</span>
 <span class="s0">* with custom HOCs.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">callHook = (hook</span><span class="s2">, </span><span class="s1">args = []) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
        <span class="s1">hook.forEach(h =&gt; h(...args))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(hook) {</span>
        <span class="s1">hook(...args)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Check if a hook expects a callback (2nd arg), which means the user</span>
 <span class="s0">* intends to explicitly control the end of the transition.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">hasExplicitCallback = (hook) =&gt; {</span>
    <span class="s2">return </span><span class="s1">hook</span>
        <span class="s1">? isArray(hook)</span>
            <span class="s1">? hook.some(h =&gt; h.length &gt; </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">: hook.length &gt; </span><span class="s4">1</span>
        <span class="s1">: </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveTransitionProps(rawProps) {</span>
    <span class="s2">const </span><span class="s1">baseProps = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawProps) {</span>
        <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">DOMTransitionPropsValidators)) {</span>
            <span class="s1">baseProps[key] = rawProps[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(rawProps.css === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">baseProps</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ name = </span><span class="s3">'v'</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">duration</span><span class="s2">, </span><span class="s1">enterFromClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-from`</span><span class="s2">, </span><span class="s1">enterActiveClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-active`</span><span class="s2">, </span><span class="s1">enterToClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-to`</span><span class="s2">, </span><span class="s1">appearFromClass = enterFromClass</span><span class="s2">, </span><span class="s1">appearActiveClass = enterActiveClass</span><span class="s2">, </span><span class="s1">appearToClass = enterToClass</span><span class="s2">, </span><span class="s1">leaveFromClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-from`</span><span class="s2">, </span><span class="s1">leaveActiveClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-active`</span><span class="s2">, </span><span class="s1">leaveToClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-to` </span><span class="s1">} = rawProps</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">durations = normalizeDuration(duration)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">enterDuration = durations &amp;&amp; durations[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">leaveDuration = durations &amp;&amp; durations[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ onBeforeEnter</span><span class="s2">, </span><span class="s1">onEnter</span><span class="s2">, </span><span class="s1">onEnterCancelled</span><span class="s2">, </span><span class="s1">onLeave</span><span class="s2">, </span><span class="s1">onLeaveCancelled</span><span class="s2">, </span><span class="s1">onBeforeAppear = onBeforeEnter</span><span class="s2">, </span><span class="s1">onAppear = onEnter</span><span class="s2">, </span><span class="s1">onAppearCancelled = onEnterCancelled } = baseProps</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">finishEnter = (el</span><span class="s2">, </span><span class="s1">isAppear</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearToClass : enterToClass)</span><span class="s2">;</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearActiveClass : enterActiveClass)</span><span class="s2">;</span>
        <span class="s1">done &amp;&amp; done()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">finishLeave = (el</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
        <span class="s1">el._isLeaving = </span><span class="s2">false;</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveToClass)</span><span class="s2">;</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveActiveClass)</span><span class="s2">;</span>
        <span class="s1">done &amp;&amp; done()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">makeEnterHook = (isAppear) =&gt; {</span>
        <span class="s2">return </span><span class="s1">(el</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
            <span class="s2">const </span><span class="s1">hook = isAppear ? onAppear : onEnter</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">resolve = () =&gt; finishEnter(el</span><span class="s2">, </span><span class="s1">isAppear</span><span class="s2">, </span><span class="s1">done)</span><span class="s2">;</span>
            <span class="s1">callHook(hook</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">resolve])</span><span class="s2">;</span>
            <span class="s1">nextFrame(() =&gt; {</span>
                <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearFromClass : enterFromClass)</span><span class="s2">;</span>
                <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearToClass : enterToClass)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!hasExplicitCallback(hook)) {</span>
                    <span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">enterDuration</span><span class="s2">, </span><span class="s1">resolve)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">extend(baseProps</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">onBeforeEnter(el) {</span>
            <span class="s1">callHook(onBeforeEnter</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">enterFromClass)</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">enterActiveClass)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onBeforeAppear(el) {</span>
            <span class="s1">callHook(onBeforeAppear</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">appearFromClass)</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">appearActiveClass)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onEnter: makeEnterHook(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">onAppear: makeEnterHook(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">onLeave(el</span><span class="s2">, </span><span class="s1">done) {</span>
            <span class="s1">el._isLeaving = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">resolve = () =&gt; finishLeave(el</span><span class="s2">, </span><span class="s1">done)</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
            <span class="s5">// force reflow so *-leave-from classes immediately take effect (#2593)</span>
            <span class="s1">forceReflow()</span><span class="s2">;</span>
            <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveActiveClass)</span><span class="s2">;</span>
            <span class="s1">nextFrame(() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(!el._isLeaving) {</span>
                    <span class="s5">// cancelled</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
                <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveToClass)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!hasExplicitCallback(onLeave)) {</span>
                    <span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">leaveDuration</span><span class="s2">, </span><span class="s1">resolve)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">callHook(onLeave</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">resolve])</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onEnterCancelled(el) {</span>
            <span class="s1">finishEnter(el</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">callHook(onEnterCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onAppearCancelled(el) {</span>
            <span class="s1">finishEnter(el</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">callHook(onAppearCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onLeaveCancelled(el) {</span>
            <span class="s1">finishLeave(el)</span><span class="s2">;</span>
            <span class="s1">callHook(onLeaveCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeDuration(duration) {</span>
    <span class="s2">if </span><span class="s1">(duration == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return null;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isObject(duration)) {</span>
        <span class="s2">return </span><span class="s1">[NumberOf(duration.enter)</span><span class="s2">, </span><span class="s1">NumberOf(duration.leave)]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">n = NumberOf(duration)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">[n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">NumberOf(val) {</span>
    <span class="s2">const </span><span class="s1">res = toNumber(val)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">assertNumber(res</span><span class="s2">, </span><span class="s3">'&lt;transition&gt; explicit duration'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">cls) {</span>
    <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach(c =&gt; c &amp;&amp; el.classList.add(c))</span><span class="s2">;</span>
    <span class="s1">(el._vtc ||</span>
        <span class="s1">(el._vtc = </span><span class="s2">new </span><span class="s1">Set())).add(cls)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">cls) {</span>
    <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach(c =&gt; c &amp;&amp; el.classList.remove(c))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ _vtc } = el</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(_vtc) {</span>
        <span class="s1">_vtc.delete(cls)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!_vtc.size) {</span>
            <span class="s1">el._vtc = undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">nextFrame(cb) {</span>
    <span class="s1">requestAnimationFrame(() =&gt; {</span>
        <span class="s1">requestAnimationFrame(cb)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">let </span><span class="s1">endId = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">expectedType</span><span class="s2">, </span><span class="s1">explicitTimeout</span><span class="s2">, </span><span class="s1">resolve) {</span>
    <span class="s2">const </span><span class="s1">id = (el._endId = ++endId)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">resolveIfNotStale = () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(id === el._endId) {</span>
            <span class="s1">resolve()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(explicitTimeout) {</span>
        <span class="s2">return </span><span class="s1">setTimeout(resolveIfNotStale</span><span class="s2">, </span><span class="s1">explicitTimeout)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">propCount } = getTransitionInfo(el</span><span class="s2">, </span><span class="s1">expectedType)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!type) {</span>
        <span class="s2">return </span><span class="s1">resolve()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">endEvent = type + </span><span class="s3">'end'</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">ended = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">end = () =&gt; {</span>
        <span class="s1">el.removeEventListener(endEvent</span><span class="s2">, </span><span class="s1">onEnd)</span><span class="s2">;</span>
        <span class="s1">resolveIfNotStale()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">onEnd = (e) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(e.target === el &amp;&amp; ++ended &gt;= propCount) {</span>
            <span class="s1">end()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">setTimeout(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(ended &lt; propCount) {</span>
            <span class="s1">end()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">el.addEventListener(endEvent</span><span class="s2">, </span><span class="s1">onEnd)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTransitionInfo(el</span><span class="s2">, </span><span class="s1">expectedType) {</span>
    <span class="s2">const </span><span class="s1">styles = window.getComputedStyle(el)</span><span class="s2">;</span>
    <span class="s5">// JSDOM may return undefined for transition properties</span>
    <span class="s2">const </span><span class="s1">getStyleProperties = (key) =&gt; (styles[key] || </span><span class="s3">''</span><span class="s1">).split(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">transitionDelays = getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION$1}</span><span class="s3">Delay`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">transitionDurations = getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION$1}</span><span class="s3">Duration`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">transitionTimeout = getTimeout(transitionDelays</span><span class="s2">, </span><span class="s1">transitionDurations)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">animationDelays = getStyleProperties(</span><span class="s3">`</span><span class="s1">${ANIMATION}</span><span class="s3">Delay`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">animationDurations = getStyleProperties(</span><span class="s3">`</span><span class="s1">${ANIMATION}</span><span class="s3">Duration`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">animationTimeout = getTimeout(animationDelays</span><span class="s2">, </span><span class="s1">animationDurations)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">type = </span><span class="s2">null;</span>
    <span class="s2">let </span><span class="s1">timeout = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">propCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s5">/* istanbul ignore if */</span>
    <span class="s2">if </span><span class="s1">(expectedType === TRANSITION$1) {</span>
        <span class="s2">if </span><span class="s1">(transitionTimeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">type = TRANSITION$1</span><span class="s2">;</span>
            <span class="s1">timeout = transitionTimeout</span><span class="s2">;</span>
            <span class="s1">propCount = transitionDurations.length</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(expectedType === ANIMATION) {</span>
        <span class="s2">if </span><span class="s1">(animationTimeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">type = ANIMATION</span><span class="s2">;</span>
            <span class="s1">timeout = animationTimeout</span><span class="s2">;</span>
            <span class="s1">propCount = animationDurations.length</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">timeout = Math.max(transitionTimeout</span><span class="s2">, </span><span class="s1">animationTimeout)</span><span class="s2">;</span>
        <span class="s1">type =</span>
            <span class="s1">timeout &gt; </span><span class="s4">0</span>
                <span class="s1">? transitionTimeout &gt; animationTimeout</span>
                    <span class="s1">? TRANSITION$1</span>
                    <span class="s1">: ANIMATION</span>
                <span class="s1">: </span><span class="s2">null;</span>
        <span class="s1">propCount = type</span>
            <span class="s1">? type === TRANSITION$1</span>
                <span class="s1">? transitionDurations.length</span>
                <span class="s1">: animationDurations.length</span>
            <span class="s1">: </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">hasTransform = type === TRANSITION$1 &amp;&amp;</span>
        <span class="s4">/\b(transform|all)(,|$)/</span><span class="s1">.test(getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION$1}</span><span class="s3">Property`</span><span class="s1">).toString())</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type</span><span class="s2">,</span>
        <span class="s1">timeout</span><span class="s2">,</span>
        <span class="s1">propCount</span><span class="s2">,</span>
        <span class="s1">hasTransform</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTimeout(delays</span><span class="s2">, </span><span class="s1">durations) {</span>
    <span class="s2">while </span><span class="s1">(delays.length &lt; durations.length) {</span>
        <span class="s1">delays = delays.concat(delays)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Math.max(...durations.map((d</span><span class="s2">, </span><span class="s1">i) =&gt; toMs(d) + toMs(delays[i])))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// Old versions of Chromium (below 61.0.3163.100) formats floating pointer</span>
<span class="s5">// numbers in a locale-dependent way, using a comma instead of a dot.</span>
<span class="s5">// If comma is not replaced with a dot, the input will be rounded down</span>
<span class="s5">// (i.e. acting as a floor function) causing unexpected behaviors</span>
<span class="s2">function </span><span class="s1">toMs(s) {</span>
    <span class="s2">return </span><span class="s1">Number(s.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">).replace(</span><span class="s3">','</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">)) * </span><span class="s4">1000</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// synchronously force layout to put elements into a certain state</span>
<span class="s2">function </span><span class="s1">forceReflow() {</span>
    <span class="s2">return </span><span class="s1">document.body.offsetHeight</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">positionMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">newPositionMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TransitionGroupImpl = {</span>
    <span class="s1">name: </span><span class="s3">'TransitionGroup'</span><span class="s2">,</span>
    <span class="s1">props: </span><span class="s5">/*#__PURE__*/ </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">TransitionPropsValidators</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">tag: String</span><span class="s2">,</span>
        <span class="s1">moveClass: String</span>
    <span class="s1">})</span><span class="s2">,</span>
    <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
        <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">state = useTransitionState()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">prevChildren</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">children</span><span class="s2">;</span>
        <span class="s1">onUpdated(() =&gt; {</span>
            <span class="s5">// children is guaranteed to exist after initial render</span>
            <span class="s2">if </span><span class="s1">(!prevChildren.length) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">moveClass = props.moveClass || </span><span class="s3">`</span><span class="s1">${props.name || </span><span class="s3">'v'</span><span class="s1">}</span><span class="s3">-move`</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!hasCSSTransform(prevChildren[</span><span class="s4">0</span><span class="s1">].el</span><span class="s2">, </span><span class="s1">instance.vnode.el</span><span class="s2">, </span><span class="s1">moveClass)) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s5">// we divide the work into three loops to avoid mixing DOM reads and writes</span>
            <span class="s5">// in each iteration - which helps prevent layout thrashing.</span>
            <span class="s1">prevChildren.forEach(callPendingCbs)</span><span class="s2">;</span>
            <span class="s1">prevChildren.forEach(recordPosition)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">movedChildren = prevChildren.filter(applyTranslation)</span><span class="s2">;</span>
            <span class="s5">// force reflow to put everything in position</span>
            <span class="s1">forceReflow()</span><span class="s2">;</span>
            <span class="s1">movedChildren.forEach(c =&gt; {</span>
                <span class="s2">const </span><span class="s1">el = c.el</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
                <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">moveClass)</span><span class="s2">;</span>
                <span class="s1">style.transform = style.webkitTransform = style.transitionDuration = </span><span class="s3">''</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">cb = (el._moveCb = (e) =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(e &amp;&amp; e.target !== el) {</span>
                        <span class="s2">return;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!e || </span><span class="s4">/transform$/</span><span class="s1">.test(e.propertyName)) {</span>
                        <span class="s1">el.removeEventListener(</span><span class="s3">'transitionend'</span><span class="s2">, </span><span class="s1">cb)</span><span class="s2">;</span>
                        <span class="s1">el._moveCb = </span><span class="s2">null;</span>
                        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">moveClass)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">})</span><span class="s2">;</span>
                <span class="s1">el.addEventListener(</span><span class="s3">'transitionend'</span><span class="s2">, </span><span class="s1">cb)</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">rawProps = toRaw(props)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">cssTransitionProps = resolveTransitionProps(rawProps)</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">tag = rawProps.tag || Fragment</span><span class="s2">;</span>
            <span class="s1">prevChildren = children</span><span class="s2">;</span>
            <span class="s1">children = slots.default ? getTransitionRawChildren(slots.default()) : []</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(child.key != </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">setTransitionHooks(child</span><span class="s2">, </span><span class="s1">resolveTransitionHooks(child</span><span class="s2">, </span><span class="s1">cssTransitionProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">warn(</span><span class="s3">`&lt;TransitionGroup&gt; children must be keyed.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(prevChildren) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prevChildren.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">const </span><span class="s1">child = prevChildren[i]</span><span class="s2">;</span>
                    <span class="s1">setTransitionHooks(child</span><span class="s2">, </span><span class="s1">resolveTransitionHooks(child</span><span class="s2">, </span><span class="s1">cssTransitionProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance))</span><span class="s2">;</span>
                    <span class="s1">positionMap.set(child</span><span class="s2">, </span><span class="s1">child.el.getBoundingClientRect())</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">createVNode(tag</span><span class="s2">, null, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* TransitionGroup does not support &quot;mode&quot; so we need to remove it from the</span>
 <span class="s0">* props declarations, but direct delete operation is considered a side effect</span>
 <span class="s0">* and will make the entire transition feature non-tree-shakeable, so we do it</span>
 <span class="s0">* in a function and mark the function's invocation as pure.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">removeMode = (props) =&gt; </span><span class="s2">delete </span><span class="s1">props.mode</span><span class="s2">;</span>
<span class="s5">/*#__PURE__*/ </span><span class="s1">removeMode(TransitionGroupImpl.props)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TransitionGroup = TransitionGroupImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">callPendingCbs(c) {</span>
    <span class="s2">const </span><span class="s1">el = c.el</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(el._moveCb) {</span>
        <span class="s1">el._moveCb()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(el._enterCb) {</span>
        <span class="s1">el._enterCb()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">recordPosition(c) {</span>
    <span class="s1">newPositionMap.set(c</span><span class="s2">, </span><span class="s1">c.el.getBoundingClientRect())</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">applyTranslation(c) {</span>
    <span class="s2">const </span><span class="s1">oldPos = positionMap.get(c)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newPos = newPositionMap.get(c)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dx = oldPos.left - newPos.left</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dy = oldPos.top - newPos.top</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dx || dy) {</span>
        <span class="s2">const </span><span class="s1">s = c.el.style</span><span class="s2">;</span>
        <span class="s1">s.transform = s.webkitTransform = </span><span class="s3">`translate(</span><span class="s1">${dx}</span><span class="s3">px,</span><span class="s1">${dy}</span><span class="s3">px)`</span><span class="s2">;</span>
        <span class="s1">s.transitionDuration = </span><span class="s3">'0s'</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">c</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasCSSTransform(el</span><span class="s2">, </span><span class="s1">root</span><span class="s2">, </span><span class="s1">moveClass) {</span>
    <span class="s5">// Detect whether an element with the move class applied has</span>
    <span class="s5">// CSS transitions. Since the element may be inside an entering</span>
    <span class="s5">// transition at this very moment, we make a clone of it and remove</span>
    <span class="s5">// all other transition classes applied to ensure only the move class</span>
    <span class="s5">// is applied.</span>
    <span class="s2">const </span><span class="s1">clone = el.cloneNode()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(el._vtc) {</span>
        <span class="s1">el._vtc.forEach(cls =&gt; {</span>
            <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach(c =&gt; c &amp;&amp; clone.classList.remove(c))</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">moveClass.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach(c =&gt; c &amp;&amp; clone.classList.add(c))</span><span class="s2">;</span>
    <span class="s1">clone.style.display = </span><span class="s3">'none'</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">container = (root.nodeType === </span><span class="s4">1 </span><span class="s1">? root : root.parentNode)</span><span class="s2">;</span>
    <span class="s1">container.appendChild(clone)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ hasTransform } = getTransitionInfo(clone)</span><span class="s2">;</span>
    <span class="s1">container.removeChild(clone)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">hasTransform</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">getModelAssigner = (vnode) =&gt; {</span>
    <span class="s2">const </span><span class="s1">fn = vnode.props[</span><span class="s3">'onUpdate:modelValue'</span><span class="s1">] ||</span>
        <span class="s1">(</span><span class="s2">false </span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">isArray(fn) ? value =&gt; invokeArrayFns(fn</span><span class="s2">, </span><span class="s1">value) : fn</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">onCompositionStart(e) {</span>
    <span class="s1">e.target.composing = </span><span class="s2">true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onCompositionEnd(e) {</span>
    <span class="s2">const </span><span class="s1">target = e.target</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(target.composing) {</span>
        <span class="s1">target.composing = </span><span class="s2">false;</span>
        <span class="s1">target.dispatchEvent(</span><span class="s2">new </span><span class="s1">Event(</span><span class="s3">'input'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// We are exporting the v-model runtime directly as vnode hooks so that it can</span>
<span class="s5">// be tree-shaken in case v-model is never used.</span>
<span class="s2">const </span><span class="s1">vModelText = {</span>
    <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ modifiers: { lazy</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">, </span><span class="s1">number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">castToNumber = number || (vnode.props &amp;&amp; vnode.props.type === </span><span class="s3">'number'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">lazy ? </span><span class="s3">'change' </span><span class="s1">: </span><span class="s3">'input'</span><span class="s2">, </span><span class="s1">e =&gt; {</span>
            <span class="s2">if </span><span class="s1">(e.target.composing)</span>
                <span class="s2">return;</span>
            <span class="s2">let </span><span class="s1">domValue = el.value</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(trim) {</span>
                <span class="s1">domValue = domValue.trim()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(castToNumber) {</span>
                <span class="s1">domValue = looseToNumber(domValue)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">el._assign(domValue)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(trim) {</span>
            <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
                <span class="s1">el.value = el.value.trim()</span><span class="s2">;</span>
            <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!lazy) {</span>
            <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'compositionstart'</span><span class="s2">, </span><span class="s1">onCompositionStart)</span><span class="s2">;</span>
            <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'compositionend'</span><span class="s2">, </span><span class="s1">onCompositionEnd)</span><span class="s2">;</span>
            <span class="s5">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span>
            <span class="s5">// switching focus before confirming composition choice</span>
            <span class="s5">// this also fixes the issue where some browsers e.g. iOS Chrome</span>
            <span class="s5">// fires &quot;change&quot; instead of &quot;input&quot; on autocomplete.</span>
            <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">onCompositionEnd)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// set value on mounted so it's after min/max for type=&quot;range&quot;</span>
    <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
        <span class="s1">el.value = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: value</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">modifiers: { lazy</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">, </span><span class="s1">number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s5">// avoid clearing unresolved text. #2302</span>
        <span class="s2">if </span><span class="s1">(el.composing)</span>
            <span class="s2">return;</span>
        <span class="s2">if </span><span class="s1">(document.activeElement === el &amp;&amp; el.type !== </span><span class="s3">'range'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(lazy) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(trim &amp;&amp; el.value.trim() === value) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((number || el.type === </span><span class="s3">'number'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">looseToNumber(el.value) === value) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">newValue = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: value</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(el.value !== newValue) {</span>
            <span class="s1">el.value = newValue</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">vModelCheckbox = {</span>
    <span class="s5">// #4096 array checkboxes need to be deep traversed</span>
    <span class="s1">deep: </span><span class="s2">true,</span>
    <span class="s1">created(el</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">modelValue = el._modelValue</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">elementValue = getValue(el)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">checked = el.checked</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">assign = el._assign</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isArray(modelValue)) {</span>
                <span class="s2">const </span><span class="s1">index = looseIndexOf(modelValue</span><span class="s2">, </span><span class="s1">elementValue)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">found = index !== -</span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(checked &amp;&amp; !found) {</span>
                    <span class="s1">assign(modelValue.concat(elementValue))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!checked &amp;&amp; found) {</span>
                    <span class="s2">const </span><span class="s1">filtered = [...modelValue]</span><span class="s2">;</span>
                    <span class="s1">filtered.splice(index</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">assign(filtered)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isSet(modelValue)) {</span>
                <span class="s2">const </span><span class="s1">cloned = </span><span class="s2">new </span><span class="s1">Set(modelValue)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(checked) {</span>
                    <span class="s1">cloned.add(elementValue)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">cloned.delete(elementValue)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">assign(cloned)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">assign(getCheckboxValue(el</span><span class="s2">, </span><span class="s1">checked))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// set initial checked on mount to wait for true-value/false-value</span>
    <span class="s1">mounted: setChecked</span><span class="s2">,</span>
    <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s1">setChecked(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setChecked(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._modelValue = value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s1">el.checked = looseIndexOf(value</span><span class="s2">, </span><span class="s1">vnode.props.value) &gt; -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isSet(value)) {</span>
        <span class="s1">el.checked = value.has(vnode.props.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(value !== oldValue) {</span>
        <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">getCheckboxValue(el</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">vModelRadio = {</span>
    <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">vnode.props.value)</span><span class="s2">;</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s1">el._assign(getValue(el))</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(value !== oldValue) {</span>
            <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">vnode.props.value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">vModelSelect = {</span>
    <span class="s5">// &lt;select multiple&gt; value need to be deep traversed</span>
    <span class="s1">deep: </span><span class="s2">true,</span>
    <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">modifiers: { number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s2">const </span><span class="s1">isSetModel = isSet(value)</span><span class="s2">;</span>
        <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">'change'</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">selectedVal = Array.prototype.filter</span>
                <span class="s1">.call(el.options</span><span class="s2">, </span><span class="s1">(o) =&gt; o.selected)</span>
                <span class="s1">.map((o) =&gt; number ? looseToNumber(getValue(o)) : getValue(o))</span><span class="s2">;</span>
            <span class="s1">el._assign(el.multiple</span>
                <span class="s1">? isSetModel</span>
                    <span class="s1">? </span><span class="s2">new </span><span class="s1">Set(selectedVal)</span>
                    <span class="s1">: selectedVal</span>
                <span class="s1">: selectedVal[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// set value in mounted &amp; updated because &lt;select&gt; relies on its children</span>
    <span class="s5">// &lt;option&gt;s.</span>
    <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
        <span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">_binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
        <span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">const </span><span class="s1">isMultiple = el.multiple</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isMultiple &amp;&amp; !isArray(value) &amp;&amp; !isSet(value)) {</span>
        <span class="s1">warn(</span><span class="s3">`&lt;select multiple v-model&gt; expects an Array or Set value for its binding, ` </span><span class="s1">+</span>
                <span class="s3">`but got </span><span class="s1">${Object.prototype.toString.call(value).slice(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = el.options.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">option = el.options[i]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">optionValue = getValue(option)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isMultiple) {</span>
            <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
                <span class="s1">option.selected = looseIndexOf(value</span><span class="s2">, </span><span class="s1">optionValue) &gt; -</span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">option.selected = value.has(optionValue)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(looseEqual(getValue(option)</span><span class="s2">, </span><span class="s1">value)) {</span>
                <span class="s2">if </span><span class="s1">(el.selectedIndex !== i)</span>
                    <span class="s1">el.selectedIndex = i</span><span class="s2">;</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isMultiple &amp;&amp; el.selectedIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">el.selectedIndex = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// retrieve raw value set via :value bindings</span>
<span class="s2">function </span><span class="s1">getValue(el) {</span>
    <span class="s2">return </span><span class="s3">'_value' </span><span class="s2">in </span><span class="s1">el ? el._value : el.value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings</span>
<span class="s2">function </span><span class="s1">getCheckboxValue(el</span><span class="s2">, </span><span class="s1">checked) {</span>
    <span class="s2">const </span><span class="s1">key = checked ? </span><span class="s3">'_trueValue' </span><span class="s1">: </span><span class="s3">'_falseValue'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">el ? el[key] : checked</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">vModelDynamic = {</span>
    <span class="s1">created(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, </span><span class="s3">'created'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
        <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, </span><span class="s3">'mounted'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode) {</span>
        <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s3">'beforeUpdate'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode) {</span>
        <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s3">'updated'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveDynamicModel(tagName</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">switch </span><span class="s1">(tagName) {</span>
        <span class="s2">case </span><span class="s3">'SELECT'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">vModelSelect</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s3">'TEXTAREA'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">vModelText</span><span class="s2">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">switch </span><span class="s1">(type) {</span>
                <span class="s2">case </span><span class="s3">'checkbox'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">vModelCheckbox</span><span class="s2">;</span>
                <span class="s2">case </span><span class="s3">'radio'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">vModelRadio</span><span class="s2">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">vModelText</span><span class="s2">;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s1">hook) {</span>
    <span class="s2">const </span><span class="s1">modelToUse = resolveDynamicModel(el.tagName</span><span class="s2">, </span><span class="s1">vnode.props &amp;&amp; vnode.props.type)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">fn = modelToUse[hook]</span><span class="s2">;</span>
    <span class="s1">fn &amp;&amp; fn(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">systemModifiers = [</span><span class="s3">'ctrl'</span><span class="s2">, </span><span class="s3">'shift'</span><span class="s2">, </span><span class="s3">'alt'</span><span class="s2">, </span><span class="s3">'meta'</span><span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">modifierGuards = {</span>
    <span class="s1">stop: e =&gt; e.stopPropagation()</span><span class="s2">,</span>
    <span class="s1">prevent: e =&gt; e.preventDefault()</span><span class="s2">,</span>
    <span class="s1">self: e =&gt; e.target !== e.currentTarget</span><span class="s2">,</span>
    <span class="s1">ctrl: e =&gt; !e.ctrlKey</span><span class="s2">,</span>
    <span class="s1">shift: e =&gt; !e.shiftKey</span><span class="s2">,</span>
    <span class="s1">alt: e =&gt; !e.altKey</span><span class="s2">,</span>
    <span class="s1">meta: e =&gt; !e.metaKey</span><span class="s2">,</span>
    <span class="s1">left: e =&gt; </span><span class="s3">'button' </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">middle: e =&gt; </span><span class="s3">'button' </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">right: e =&gt; </span><span class="s3">'button' </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">2</span><span class="s2">,</span>
    <span class="s1">exact: (e</span><span class="s2">, </span><span class="s1">modifiers) =&gt; systemModifiers.some(m =&gt; e[</span><span class="s3">`</span><span class="s1">${m}</span><span class="s3">Key`</span><span class="s1">] &amp;&amp; !modifiers.includes(m))</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">withModifiers = (fn</span><span class="s2">, </span><span class="s1">modifiers) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(event</span><span class="s2">, </span><span class="s1">...args) =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; modifiers.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">guard = modifierGuards[modifiers[i]]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(guard &amp;&amp; guard(event</span><span class="s2">, </span><span class="s1">modifiers))</span>
                <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">fn(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s5">// Kept for 2.x compat.</span>
<span class="s5">// Note: IE11 compat for `spacebar` and `del` is removed for now.</span>
<span class="s2">const </span><span class="s1">keyNames = {</span>
    <span class="s1">esc: </span><span class="s3">'escape'</span><span class="s2">,</span>
    <span class="s1">space: </span><span class="s3">' '</span><span class="s2">,</span>
    <span class="s1">up: </span><span class="s3">'arrow-up'</span><span class="s2">,</span>
    <span class="s1">left: </span><span class="s3">'arrow-left'</span><span class="s2">,</span>
    <span class="s1">right: </span><span class="s3">'arrow-right'</span><span class="s2">,</span>
    <span class="s1">down: </span><span class="s3">'arrow-down'</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: </span><span class="s3">'backspace'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@private</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">withKeys = (fn</span><span class="s2">, </span><span class="s1">modifiers) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(event) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s3">'key' </span><span class="s2">in </span><span class="s1">event)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">eventKey = hyphenate(event.key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(modifiers.some(k =&gt; k === eventKey || keyNames[k] === eventKey)) {</span>
            <span class="s2">return </span><span class="s1">fn(event)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">vShow = {</span>
    <span class="s1">beforeMount(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
        <span class="s1">el._vod = el.style.display === </span><span class="s3">'none' </span><span class="s1">? </span><span class="s3">'' </span><span class="s1">: el.style.display</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(transition &amp;&amp; value) {</span>
            <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
        <span class="s2">if </span><span class="s1">(transition &amp;&amp; value) {</span>
            <span class="s1">transition.enter(el)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
        <span class="s2">if </span><span class="s1">(!value === !oldValue)</span>
            <span class="s2">return;</span>
        <span class="s2">if </span><span class="s1">(transition) {</span>
            <span class="s2">if </span><span class="s1">(value) {</span>
                <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
                <span class="s1">setDisplay(el</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">transition.enter(el)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">transition.leave(el</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
                    <span class="s1">setDisplay(el</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">beforeUnmount(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
        <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s1">el.style.display = value ? el._vod : </span><span class="s3">'none'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">rendererOptions = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">extend({ patchProp }</span><span class="s2">, </span><span class="s1">nodeOps)</span><span class="s2">;</span>
<span class="s5">// lazy create the renderer - this makes core renderer logic tree-shakable</span>
<span class="s5">// in case the user only imports reactivity utilities from Vue.</span>
<span class="s2">let </span><span class="s1">renderer</span><span class="s2">;</span>
<span class="s2">let </span><span class="s1">enabledHydration = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">ensureRenderer() {</span>
    <span class="s2">return </span><span class="s1">(renderer ||</span>
        <span class="s1">(renderer = createRenderer(rendererOptions)))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ensureHydrationRenderer() {</span>
    <span class="s1">renderer = enabledHydration</span>
        <span class="s1">? renderer</span>
        <span class="s1">: createHydrationRenderer(rendererOptions)</span><span class="s2">;</span>
    <span class="s1">enabledHydration = </span><span class="s2">true;</span>
    <span class="s2">return </span><span class="s1">renderer</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// use explicit type casts here to avoid import() calls in rolled-up d.ts</span>
<span class="s2">const </span><span class="s1">render = ((...args) =&gt; {</span>
    <span class="s1">ensureRenderer().render(...args)</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">hydrate = ((...args) =&gt; {</span>
    <span class="s1">ensureHydrationRenderer().hydrate(...args)</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">createApp = ((...args) =&gt; {</span>
    <span class="s2">const </span><span class="s1">app = ensureRenderer().createApp(...args)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">injectNativeTagCheck(app)</span><span class="s2">;</span>
        <span class="s1">injectCompilerOptionsCheck(app)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ mount } = app</span><span class="s2">;</span>
    <span class="s1">app.mount = (containerOrSelector) =&gt; {</span>
        <span class="s2">const </span><span class="s1">container = normalizeContainer(containerOrSelector)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!container)</span>
            <span class="s2">return;</span>
        <span class="s2">const </span><span class="s1">component = app._component</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) {</span>
            <span class="s5">// __UNSAFE__</span>
            <span class="s5">// Reason: potential execution of JS expressions in in-DOM template.</span>
            <span class="s5">// The user must make sure the in-DOM template is trusted. If it's</span>
            <span class="s5">// rendered by the server, the template should not contain any user data.</span>
            <span class="s1">component.template = container.innerHTML</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// clear content before mounting</span>
        <span class="s1">container.innerHTML = </span><span class="s3">''</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">proxy = mount(container</span><span class="s2">, false, </span><span class="s1">container </span><span class="s2">instanceof </span><span class="s1">SVGElement)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(container </span><span class="s2">instanceof </span><span class="s1">Element) {</span>
            <span class="s1">container.removeAttribute(</span><span class="s3">'v-cloak'</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">container.setAttribute(</span><span class="s3">'data-v-app'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">proxy</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">createSSRApp = ((...args) =&gt; {</span>
    <span class="s2">const </span><span class="s1">app = ensureHydrationRenderer().createApp(...args)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">injectNativeTagCheck(app)</span><span class="s2">;</span>
        <span class="s1">injectCompilerOptionsCheck(app)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ mount } = app</span><span class="s2">;</span>
    <span class="s1">app.mount = (containerOrSelector) =&gt; {</span>
        <span class="s2">const </span><span class="s1">container = normalizeContainer(containerOrSelector)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(container) {</span>
            <span class="s2">return </span><span class="s1">mount(container</span><span class="s2">, true, </span><span class="s1">container </span><span class="s2">instanceof </span><span class="s1">SVGElement)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">injectNativeTagCheck(app) {</span>
    <span class="s5">// Inject `isNativeTag`</span>
    <span class="s5">// this is used for component name validation (dev only)</span>
    <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">'isNativeTag'</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">value: (tag) =&gt; isHTMLTag(tag) || isSVGTag(tag)</span><span class="s2">,</span>
        <span class="s1">writable: </span><span class="s2">false</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// dev only</span>
<span class="s2">function </span><span class="s1">injectCompilerOptionsCheck(app) {</span>
    <span class="s2">if </span><span class="s1">(isRuntimeOnly()) {</span>
        <span class="s2">const </span><span class="s1">isCustomElement = app.config.isCustomElement</span><span class="s2">;</span>
        <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">'isCustomElement'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">get() {</span>
                <span class="s2">return </span><span class="s1">isCustomElement</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">set() {</span>
                <span class="s1">warn(</span><span class="s3">`The </span><span class="s2">\`</span><span class="s3">isCustomElement</span><span class="s2">\` </span><span class="s3">config option is deprecated. Use ` </span><span class="s1">+</span>
                    <span class="s3">`</span><span class="s2">\`</span><span class="s3">compilerOptions.isCustomElement</span><span class="s2">\` </span><span class="s3">instead.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">compilerOptions = app.config.compilerOptions</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">msg = </span><span class="s3">`The </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">config option is only respected when using ` </span><span class="s1">+</span>
            <span class="s3">`a build of Vue.js that includes the runtime compiler (aka &quot;full build&quot;). ` </span><span class="s1">+</span>
            <span class="s3">`Since you are using the runtime-only build, </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`must be passed to </span><span class="s2">\`</span><span class="s3">@vue/compiler-dom</span><span class="s2">\` </span><span class="s3">in the build setup instead.</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`- For vue-loader: pass it via vue-loader's </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">loader option.</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
            <span class="s3">`- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`</span><span class="s2">;</span>
        <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">'compilerOptions'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">get() {</span>
                <span class="s1">warn(msg)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">compilerOptions</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">set() {</span>
                <span class="s1">warn(msg)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeContainer(container) {</span>
    <span class="s2">if </span><span class="s1">(isString(container)) {</span>
        <span class="s2">const </span><span class="s1">res = document.querySelector(container)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!res) {</span>
            <span class="s1">warn(</span><span class="s3">`Failed to mount app: mount target selector &quot;</span><span class="s1">${container}</span><span class="s3">&quot; returned null.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(window.ShadowRoot &amp;&amp;</span>
        <span class="s1">container </span><span class="s2">instanceof </span><span class="s1">window.ShadowRoot &amp;&amp;</span>
        <span class="s1">container.mode === </span><span class="s3">'closed'</span><span class="s1">) {</span>
        <span class="s1">warn(</span><span class="s3">`mounting on a ShadowRoot with </span><span class="s2">\`</span><span class="s3">{mode: &quot;closed&quot;}</span><span class="s2">\` </span><span class="s3">may lead to unpredictable bugs`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">container</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s6">@internal</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">initDirectivesForSSR = NOOP</span><span class="s2">;</span>

<span class="s2">var </span><span class="s1">runtimeDom = </span><span class="s5">/*#__PURE__*/</span><span class="s1">Object.freeze({</span>
  <span class="s1">__proto__: </span><span class="s2">null,</span>
  <span class="s1">BaseTransition: BaseTransition</span><span class="s2">,</span>
  <span class="s1">Comment: Comment</span><span class="s2">,</span>
  <span class="s1">EffectScope: EffectScope</span><span class="s2">,</span>
  <span class="s1">Fragment: Fragment</span><span class="s2">,</span>
  <span class="s1">KeepAlive: KeepAlive</span><span class="s2">,</span>
  <span class="s1">ReactiveEffect: ReactiveEffect</span><span class="s2">,</span>
  <span class="s1">Static: Static</span><span class="s2">,</span>
  <span class="s1">Suspense: Suspense</span><span class="s2">,</span>
  <span class="s1">Teleport: Teleport</span><span class="s2">,</span>
  <span class="s1">Text: Text</span><span class="s2">,</span>
  <span class="s1">Transition: Transition</span><span class="s2">,</span>
  <span class="s1">TransitionGroup: TransitionGroup</span><span class="s2">,</span>
  <span class="s1">VueElement: VueElement</span><span class="s2">,</span>
  <span class="s1">assertNumber: assertNumber</span><span class="s2">,</span>
  <span class="s1">callWithAsyncErrorHandling: callWithAsyncErrorHandling</span><span class="s2">,</span>
  <span class="s1">callWithErrorHandling: callWithErrorHandling</span><span class="s2">,</span>
  <span class="s1">camelize: camelize</span><span class="s2">,</span>
  <span class="s1">capitalize: capitalize</span><span class="s2">,</span>
  <span class="s1">cloneVNode: cloneVNode</span><span class="s2">,</span>
  <span class="s1">compatUtils: compatUtils</span><span class="s2">,</span>
  <span class="s1">computed: computed</span><span class="s2">,</span>
  <span class="s1">createApp: createApp</span><span class="s2">,</span>
  <span class="s1">createBlock: createBlock</span><span class="s2">,</span>
  <span class="s1">createCommentVNode: createCommentVNode</span><span class="s2">,</span>
  <span class="s1">createElementBlock: createElementBlock</span><span class="s2">,</span>
  <span class="s1">createElementVNode: createBaseVNode</span><span class="s2">,</span>
  <span class="s1">createHydrationRenderer: createHydrationRenderer</span><span class="s2">,</span>
  <span class="s1">createPropsRestProxy: createPropsRestProxy</span><span class="s2">,</span>
  <span class="s1">createRenderer: createRenderer</span><span class="s2">,</span>
  <span class="s1">createSSRApp: createSSRApp</span><span class="s2">,</span>
  <span class="s1">createSlots: createSlots</span><span class="s2">,</span>
  <span class="s1">createStaticVNode: createStaticVNode</span><span class="s2">,</span>
  <span class="s1">createTextVNode: createTextVNode</span><span class="s2">,</span>
  <span class="s1">createVNode: createVNode</span><span class="s2">,</span>
  <span class="s1">customRef: customRef</span><span class="s2">,</span>
  <span class="s1">defineAsyncComponent: defineAsyncComponent</span><span class="s2">,</span>
  <span class="s1">defineComponent: defineComponent</span><span class="s2">,</span>
  <span class="s1">defineCustomElement: defineCustomElement</span><span class="s2">,</span>
  <span class="s1">defineEmits: defineEmits</span><span class="s2">,</span>
  <span class="s1">defineExpose: defineExpose</span><span class="s2">,</span>
  <span class="s1">defineProps: defineProps</span><span class="s2">,</span>
  <span class="s1">defineSSRCustomElement: defineSSRCustomElement</span><span class="s2">,</span>
  <span class="s1">get devtools () { </span><span class="s2">return </span><span class="s1">devtools</span><span class="s2">; </span><span class="s1">}</span><span class="s2">,</span>
  <span class="s1">effect: effect</span><span class="s2">,</span>
  <span class="s1">effectScope: effectScope</span><span class="s2">,</span>
  <span class="s1">getCurrentInstance: getCurrentInstance</span><span class="s2">,</span>
  <span class="s1">getCurrentScope: getCurrentScope</span><span class="s2">,</span>
  <span class="s1">getTransitionRawChildren: getTransitionRawChildren</span><span class="s2">,</span>
  <span class="s1">guardReactiveProps: guardReactiveProps</span><span class="s2">,</span>
  <span class="s1">h: h</span><span class="s2">,</span>
  <span class="s1">handleError: handleError</span><span class="s2">,</span>
  <span class="s1">hydrate: hydrate</span><span class="s2">,</span>
  <span class="s1">initCustomFormatter: initCustomFormatter</span><span class="s2">,</span>
  <span class="s1">initDirectivesForSSR: initDirectivesForSSR</span><span class="s2">,</span>
  <span class="s1">inject: inject</span><span class="s2">,</span>
  <span class="s1">isMemoSame: isMemoSame</span><span class="s2">,</span>
  <span class="s1">isProxy: isProxy</span><span class="s2">,</span>
  <span class="s1">isReactive: isReactive</span><span class="s2">,</span>
  <span class="s1">isReadonly: isReadonly</span><span class="s2">,</span>
  <span class="s1">isRef: isRef</span><span class="s2">,</span>
  <span class="s1">isRuntimeOnly: isRuntimeOnly</span><span class="s2">,</span>
  <span class="s1">isShallow: isShallow</span><span class="s2">,</span>
  <span class="s1">isVNode: isVNode</span><span class="s2">,</span>
  <span class="s1">markRaw: markRaw</span><span class="s2">,</span>
  <span class="s1">mergeDefaults: mergeDefaults</span><span class="s2">,</span>
  <span class="s1">mergeProps: mergeProps</span><span class="s2">,</span>
  <span class="s1">nextTick: nextTick</span><span class="s2">,</span>
  <span class="s1">normalizeClass: normalizeClass</span><span class="s2">,</span>
  <span class="s1">normalizeProps: normalizeProps</span><span class="s2">,</span>
  <span class="s1">normalizeStyle: normalizeStyle</span><span class="s2">,</span>
  <span class="s1">onActivated: onActivated</span><span class="s2">,</span>
  <span class="s1">onBeforeMount: onBeforeMount</span><span class="s2">,</span>
  <span class="s1">onBeforeUnmount: onBeforeUnmount</span><span class="s2">,</span>
  <span class="s1">onBeforeUpdate: onBeforeUpdate</span><span class="s2">,</span>
  <span class="s1">onDeactivated: onDeactivated</span><span class="s2">,</span>
  <span class="s1">onErrorCaptured: onErrorCaptured</span><span class="s2">,</span>
  <span class="s1">onMounted: onMounted</span><span class="s2">,</span>
  <span class="s1">onRenderTracked: onRenderTracked</span><span class="s2">,</span>
  <span class="s1">onRenderTriggered: onRenderTriggered</span><span class="s2">,</span>
  <span class="s1">onScopeDispose: onScopeDispose</span><span class="s2">,</span>
  <span class="s1">onServerPrefetch: onServerPrefetch</span><span class="s2">,</span>
  <span class="s1">onUnmounted: onUnmounted</span><span class="s2">,</span>
  <span class="s1">onUpdated: onUpdated</span><span class="s2">,</span>
  <span class="s1">openBlock: openBlock</span><span class="s2">,</span>
  <span class="s1">popScopeId: popScopeId</span><span class="s2">,</span>
  <span class="s1">provide: provide</span><span class="s2">,</span>
  <span class="s1">proxyRefs: proxyRefs</span><span class="s2">,</span>
  <span class="s1">pushScopeId: pushScopeId</span><span class="s2">,</span>
  <span class="s1">queuePostFlushCb: queuePostFlushCb</span><span class="s2">,</span>
  <span class="s1">reactive: reactive</span><span class="s2">,</span>
  <span class="s1">readonly: readonly</span><span class="s2">,</span>
  <span class="s1">ref: ref</span><span class="s2">,</span>
  <span class="s1">registerRuntimeCompiler: registerRuntimeCompiler</span><span class="s2">,</span>
  <span class="s1">render: render</span><span class="s2">,</span>
  <span class="s1">renderList: renderList</span><span class="s2">,</span>
  <span class="s1">renderSlot: renderSlot</span><span class="s2">,</span>
  <span class="s1">resolveComponent: resolveComponent</span><span class="s2">,</span>
  <span class="s1">resolveDirective: resolveDirective</span><span class="s2">,</span>
  <span class="s1">resolveDynamicComponent: resolveDynamicComponent</span><span class="s2">,</span>
  <span class="s1">resolveFilter: resolveFilter</span><span class="s2">,</span>
  <span class="s1">resolveTransitionHooks: resolveTransitionHooks</span><span class="s2">,</span>
  <span class="s1">setBlockTracking: setBlockTracking</span><span class="s2">,</span>
  <span class="s1">setDevtoolsHook: setDevtoolsHook</span><span class="s2">,</span>
  <span class="s1">setTransitionHooks: setTransitionHooks</span><span class="s2">,</span>
  <span class="s1">shallowReactive: shallowReactive</span><span class="s2">,</span>
  <span class="s1">shallowReadonly: shallowReadonly</span><span class="s2">,</span>
  <span class="s1">shallowRef: shallowRef</span><span class="s2">,</span>
  <span class="s1">ssrContextKey: ssrContextKey</span><span class="s2">,</span>
  <span class="s1">ssrUtils: ssrUtils</span><span class="s2">,</span>
  <span class="s1">stop: stop</span><span class="s2">,</span>
  <span class="s1">toDisplayString: toDisplayString</span><span class="s2">,</span>
  <span class="s1">toHandlerKey: toHandlerKey</span><span class="s2">,</span>
  <span class="s1">toHandlers: toHandlers</span><span class="s2">,</span>
  <span class="s1">toRaw: toRaw</span><span class="s2">,</span>
  <span class="s1">toRef: toRef</span><span class="s2">,</span>
  <span class="s1">toRefs: toRefs</span><span class="s2">,</span>
  <span class="s1">transformVNodeArgs: transformVNodeArgs</span><span class="s2">,</span>
  <span class="s1">triggerRef: triggerRef</span><span class="s2">,</span>
  <span class="s1">unref: unref</span><span class="s2">,</span>
  <span class="s1">useAttrs: useAttrs</span><span class="s2">,</span>
  <span class="s1">useCssModule: useCssModule</span><span class="s2">,</span>
  <span class="s1">useCssVars: useCssVars</span><span class="s2">,</span>
  <span class="s1">useSSRContext: useSSRContext</span><span class="s2">,</span>
  <span class="s1">useSlots: useSlots</span><span class="s2">,</span>
  <span class="s1">useTransitionState: useTransitionState</span><span class="s2">,</span>
  <span class="s1">vModelCheckbox: vModelCheckbox</span><span class="s2">,</span>
  <span class="s1">vModelDynamic: vModelDynamic</span><span class="s2">,</span>
  <span class="s1">vModelRadio: vModelRadio</span><span class="s2">,</span>
  <span class="s1">vModelSelect: vModelSelect</span><span class="s2">,</span>
  <span class="s1">vModelText: vModelText</span><span class="s2">,</span>
  <span class="s1">vShow: vShow</span><span class="s2">,</span>
  <span class="s1">version: version</span><span class="s2">,</span>
  <span class="s1">warn: warn</span><span class="s2">,</span>
  <span class="s1">watch: watch</span><span class="s2">,</span>
  <span class="s1">watchEffect: watchEffect</span><span class="s2">,</span>
  <span class="s1">watchPostEffect: watchPostEffect</span><span class="s2">,</span>
  <span class="s1">watchSyncEffect: watchSyncEffect</span><span class="s2">,</span>
  <span class="s1">withAsyncContext: withAsyncContext</span><span class="s2">,</span>
  <span class="s1">withCtx: withCtx</span><span class="s2">,</span>
  <span class="s1">withDefaults: withDefaults</span><span class="s2">,</span>
  <span class="s1">withDirectives: withDirectives</span><span class="s2">,</span>
  <span class="s1">withKeys: withKeys</span><span class="s2">,</span>
  <span class="s1">withMemo: withMemo</span><span class="s2">,</span>
  <span class="s1">withModifiers: withModifiers</span><span class="s2">,</span>
  <span class="s1">withScopeId: withScopeId</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">initDev() {</span>
    <span class="s1">{</span>
        <span class="s5">/* istanbul ignore if */</span>
        <span class="s1">{</span>
            <span class="s1">console.info(</span><span class="s3">`You are running a development build of Vue.</span><span class="s2">\n</span><span class="s3">` </span><span class="s1">+</span>
                <span class="s3">`Make sure to use the production build (*.prod.js) when deploying for production.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">initCustomFormatter()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">defaultOnError(error) {</span>
    <span class="s2">throw </span><span class="s1">error</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defaultOnWarn(msg) {</span>
    <span class="s1">console.warn(</span><span class="s3">`[Vue warn] </span><span class="s1">${msg.message}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCompilerError(code</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">messages</span><span class="s2">, </span><span class="s1">additionalMessage) {</span>
    <span class="s2">const </span><span class="s1">msg = (messages || errorMessages)[code] + (additionalMessage || </span><span class="s3">``</span><span class="s1">)</span>
        <span class="s2">;</span>
    <span class="s2">const </span><span class="s1">error = </span><span class="s2">new </span><span class="s1">SyntaxError(String(msg))</span><span class="s2">;</span>
    <span class="s1">error.code = code</span><span class="s2">;</span>
    <span class="s1">error.loc = loc</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">error</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">errorMessages = {</span>
    <span class="s5">// parse errors</span>
    <span class="s1">[</span><span class="s4">0 </span><span class="s5">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">]: </span><span class="s3">'Illegal comment.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">1 </span><span class="s5">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">]: </span><span class="s3">'CDATA section is allowed only in XML context.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">2 </span><span class="s5">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">]: </span><span class="s3">'Duplicate attribute.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">3 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">]: </span><span class="s3">'End tag cannot have attributes.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">4 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">]: </span><span class="s3">&quot;Illegal '/' in tags.&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s1">]: </span><span class="s3">'Unexpected EOF in tag.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">6 </span><span class="s5">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">]: </span><span class="s3">'Unexpected EOF in CDATA section.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">7 </span><span class="s5">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">]: </span><span class="s3">'Unexpected EOF in comment.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">8 </span><span class="s5">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">]: </span><span class="s3">'Unexpected EOF in script.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">9 </span><span class="s5">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">]: </span><span class="s3">'Unexpected EOF in tag.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">10 </span><span class="s5">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">]: </span><span class="s3">'Incorrectly closed comment.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">11 </span><span class="s5">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">]: </span><span class="s3">'Incorrectly opened comment.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s3">&quot;Illegal tag name. Use '&amp;lt;' to print '&lt;'.&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">13 </span><span class="s5">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s3">'Attribute value was expected.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">14 </span><span class="s5">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s1">]: </span><span class="s3">'End tag name was expected.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">15 </span><span class="s5">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">]: </span><span class="s3">'Whitespace was expected.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">16 </span><span class="s5">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">]: </span><span class="s3">&quot;Unexpected '&lt;!--' in comment.&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">17 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s3">'Attribute name cannot contain U+0022 (&quot;), U+0027 (</span><span class="s2">\'</span><span class="s3">), and U+003C (&lt;).'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">18 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s1">]: </span><span class="s3">'Unquoted attribute value cannot contain U+0022 (&quot;), U+0027 (</span><span class="s2">\'</span><span class="s3">), U+003C (&lt;), U+003D (=), and U+0060 (`).'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">19 </span><span class="s5">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">]: </span><span class="s3">&quot;Attribute name cannot start with '='.&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">21 </span><span class="s5">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s1">]: </span><span class="s3">&quot;'&lt;?' is allowed only in XML context.&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">20 </span><span class="s5">/* ErrorCodes.UNEXPECTED_NULL_CHARACTER */</span><span class="s1">]: </span><span class="s3">`Unexpected null character.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">22 </span><span class="s5">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">]: </span><span class="s3">&quot;Illegal '/' in tags.&quot;</span><span class="s2">,</span>
    <span class="s5">// Vue-specific parse errors</span>
    <span class="s1">[</span><span class="s4">23 </span><span class="s5">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">]: </span><span class="s3">'Invalid end tag.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">24 </span><span class="s5">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s1">]: </span><span class="s3">'Element is missing end tag.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">25 </span><span class="s5">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">]: </span><span class="s3">'Interpolation end sign was not found.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">27 </span><span class="s5">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">]: </span><span class="s3">'End bracket for dynamic directive argument was not found. ' </span><span class="s1">+</span>
        <span class="s3">'Note that dynamic directive argument cannot contain spaces.'</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">26 </span><span class="s5">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">]: </span><span class="s3">'Legal directive name was expected.'</span><span class="s2">,</span>
    <span class="s5">// transform errors</span>
    <span class="s1">[</span><span class="s4">28 </span><span class="s5">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-if/v-else-if is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">29 </span><span class="s5">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s1">]: </span><span class="s3">`v-if/else branches must use unique keys.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s1">]: </span><span class="s3">`v-else/v-else-if has no adjacent v-if or v-else-if.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">31 </span><span class="s5">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-for is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-for has invalid expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">33 </span><span class="s5">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s1">]: </span><span class="s3">`&lt;template v-for&gt; key should be placed on the &lt;template&gt; tag.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-bind is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-on is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">36 </span><span class="s5">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s1">]: </span><span class="s3">`Unexpected custom directive on &lt;slot&gt; outlet.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">37 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s1">]: </span><span class="s3">`Mixed v-slot usage on both the component and nested &lt;template&gt;. ` </span><span class="s1">+</span>
        <span class="s3">`When there are multiple named slots, all slots should use &lt;template&gt; ` </span><span class="s1">+</span>
        <span class="s3">`syntax to avoid scope ambiguity.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">38 </span><span class="s5">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s1">]: </span><span class="s3">`Duplicate slot names found. `</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">39 </span><span class="s5">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s1">]: </span><span class="s3">`Extraneous children found when component already has explicitly named ` </span><span class="s1">+</span>
        <span class="s3">`default slot. These children will be ignored.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">40 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s1">]: </span><span class="s3">`v-slot can only be used on components or &lt;template&gt; tags.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">41 </span><span class="s5">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-model is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">42 </span><span class="s5">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-model value must be a valid JavaScript member expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">43 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */</span><span class="s1">]: </span><span class="s3">`v-model cannot be used on v-for or v-slot scope variables because they are not writable.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">44 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s1">]: </span><span class="s3">`v-model cannot be used on a prop, because local prop bindings are not writable.</span><span class="s2">\n</span><span class="s3">Use a v-bind binding combined with a v-on listener that emits update:x event instead.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">45 </span><span class="s5">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`Error parsing JavaScript expression: `</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">46 </span><span class="s5">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s1">]: </span><span class="s3">`&lt;KeepAlive&gt; expects exactly one child component.`</span><span class="s2">,</span>
    <span class="s5">// generic errors</span>
    <span class="s1">[</span><span class="s4">47 </span><span class="s5">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s3">`&quot;prefixIdentifiers&quot; option is not supported in this build of compiler.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">48 </span><span class="s5">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s3">`ES module mode is not supported in this build of compiler.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">49 </span><span class="s5">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s3">`&quot;cacheHandlers&quot; option is only supported when the &quot;prefixIdentifiers&quot; option is enabled.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">50 </span><span class="s5">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">]: </span><span class="s3">`&quot;scopeId&quot; option is only supported in module mode.`</span><span class="s2">,</span>
    <span class="s5">// just to fulfill types</span>
    <span class="s1">[</span><span class="s4">51 </span><span class="s5">/* ErrorCodes.__EXTEND_POINT__ */</span><span class="s1">]: </span><span class="s3">``</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">FRAGMENT = Symbol(</span><span class="s3">`Fragment` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TELEPORT = Symbol(</span><span class="s3">`Teleport` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SUSPENSE = Symbol(</span><span class="s3">`Suspense` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">KEEP_ALIVE = Symbol(</span><span class="s3">`KeepAlive` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">BASE_TRANSITION = Symbol(</span><span class="s3">`BaseTransition` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">OPEN_BLOCK = Symbol(</span><span class="s3">`openBlock` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_BLOCK = Symbol(</span><span class="s3">`createBlock` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_ELEMENT_BLOCK = Symbol(</span><span class="s3">`createElementBlock` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_VNODE = Symbol(</span><span class="s3">`createVNode` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_ELEMENT_VNODE = Symbol(</span><span class="s3">`createElementVNode` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_COMMENT = Symbol(</span><span class="s3">`createCommentVNode` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_TEXT = Symbol(</span><span class="s3">`createTextVNode` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_STATIC = Symbol(</span><span class="s3">`createStaticVNode` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RESOLVE_COMPONENT = Symbol(</span><span class="s3">`resolveComponent` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RESOLVE_DYNAMIC_COMPONENT = Symbol(</span><span class="s3">`resolveDynamicComponent` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RESOLVE_DIRECTIVE = Symbol(</span><span class="s3">`resolveDirective` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RESOLVE_FILTER = Symbol(</span><span class="s3">`resolveFilter` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">WITH_DIRECTIVES = Symbol(</span><span class="s3">`withDirectives` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RENDER_LIST = Symbol(</span><span class="s3">`renderList` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">RENDER_SLOT = Symbol(</span><span class="s3">`renderSlot` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CREATE_SLOTS = Symbol(</span><span class="s3">`createSlots` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TO_DISPLAY_STRING = Symbol(</span><span class="s3">`toDisplayString` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">MERGE_PROPS = Symbol(</span><span class="s3">`mergeProps` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NORMALIZE_CLASS = Symbol(</span><span class="s3">`normalizeClass` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NORMALIZE_STYLE = Symbol(</span><span class="s3">`normalizeStyle` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">NORMALIZE_PROPS = Symbol(</span><span class="s3">`normalizeProps` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">GUARD_REACTIVE_PROPS = Symbol(</span><span class="s3">`guardReactiveProps` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TO_HANDLERS = Symbol(</span><span class="s3">`toHandlers` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CAMELIZE = Symbol(</span><span class="s3">`camelize` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">CAPITALIZE = Symbol(</span><span class="s3">`capitalize` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TO_HANDLER_KEY = Symbol(</span><span class="s3">`toHandlerKey` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">SET_BLOCK_TRACKING = Symbol(</span><span class="s3">`setBlockTracking` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">PUSH_SCOPE_ID = Symbol(</span><span class="s3">`pushScopeId` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">POP_SCOPE_ID = Symbol(</span><span class="s3">`popScopeId` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">WITH_CTX = Symbol(</span><span class="s3">`withCtx` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">UNREF = Symbol(</span><span class="s3">`unref` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">IS_REF = Symbol(</span><span class="s3">`isRef` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">WITH_MEMO = Symbol(</span><span class="s3">`withMemo` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">IS_MEMO_SAME = Symbol(</span><span class="s3">`isMemoSame` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// Name mapping for runtime helpers that need to be imported from 'vue' in</span>
<span class="s5">// generated code. Make sure these are correctly exported in the runtime!</span>
<span class="s2">const </span><span class="s1">helperNameMap = {</span>
    <span class="s1">[FRAGMENT]: </span><span class="s3">`Fragment`</span><span class="s2">,</span>
    <span class="s1">[TELEPORT]: </span><span class="s3">`Teleport`</span><span class="s2">,</span>
    <span class="s1">[SUSPENSE]: </span><span class="s3">`Suspense`</span><span class="s2">,</span>
    <span class="s1">[KEEP_ALIVE]: </span><span class="s3">`KeepAlive`</span><span class="s2">,</span>
    <span class="s1">[BASE_TRANSITION]: </span><span class="s3">`BaseTransition`</span><span class="s2">,</span>
    <span class="s1">[OPEN_BLOCK]: </span><span class="s3">`openBlock`</span><span class="s2">,</span>
    <span class="s1">[CREATE_BLOCK]: </span><span class="s3">`createBlock`</span><span class="s2">,</span>
    <span class="s1">[CREATE_ELEMENT_BLOCK]: </span><span class="s3">`createElementBlock`</span><span class="s2">,</span>
    <span class="s1">[CREATE_VNODE]: </span><span class="s3">`createVNode`</span><span class="s2">,</span>
    <span class="s1">[CREATE_ELEMENT_VNODE]: </span><span class="s3">`createElementVNode`</span><span class="s2">,</span>
    <span class="s1">[CREATE_COMMENT]: </span><span class="s3">`createCommentVNode`</span><span class="s2">,</span>
    <span class="s1">[CREATE_TEXT]: </span><span class="s3">`createTextVNode`</span><span class="s2">,</span>
    <span class="s1">[CREATE_STATIC]: </span><span class="s3">`createStaticVNode`</span><span class="s2">,</span>
    <span class="s1">[RESOLVE_COMPONENT]: </span><span class="s3">`resolveComponent`</span><span class="s2">,</span>
    <span class="s1">[RESOLVE_DYNAMIC_COMPONENT]: </span><span class="s3">`resolveDynamicComponent`</span><span class="s2">,</span>
    <span class="s1">[RESOLVE_DIRECTIVE]: </span><span class="s3">`resolveDirective`</span><span class="s2">,</span>
    <span class="s1">[RESOLVE_FILTER]: </span><span class="s3">`resolveFilter`</span><span class="s2">,</span>
    <span class="s1">[WITH_DIRECTIVES]: </span><span class="s3">`withDirectives`</span><span class="s2">,</span>
    <span class="s1">[RENDER_LIST]: </span><span class="s3">`renderList`</span><span class="s2">,</span>
    <span class="s1">[RENDER_SLOT]: </span><span class="s3">`renderSlot`</span><span class="s2">,</span>
    <span class="s1">[CREATE_SLOTS]: </span><span class="s3">`createSlots`</span><span class="s2">,</span>
    <span class="s1">[TO_DISPLAY_STRING]: </span><span class="s3">`toDisplayString`</span><span class="s2">,</span>
    <span class="s1">[MERGE_PROPS]: </span><span class="s3">`mergeProps`</span><span class="s2">,</span>
    <span class="s1">[NORMALIZE_CLASS]: </span><span class="s3">`normalizeClass`</span><span class="s2">,</span>
    <span class="s1">[NORMALIZE_STYLE]: </span><span class="s3">`normalizeStyle`</span><span class="s2">,</span>
    <span class="s1">[NORMALIZE_PROPS]: </span><span class="s3">`normalizeProps`</span><span class="s2">,</span>
    <span class="s1">[GUARD_REACTIVE_PROPS]: </span><span class="s3">`guardReactiveProps`</span><span class="s2">,</span>
    <span class="s1">[TO_HANDLERS]: </span><span class="s3">`toHandlers`</span><span class="s2">,</span>
    <span class="s1">[CAMELIZE]: </span><span class="s3">`camelize`</span><span class="s2">,</span>
    <span class="s1">[CAPITALIZE]: </span><span class="s3">`capitalize`</span><span class="s2">,</span>
    <span class="s1">[TO_HANDLER_KEY]: </span><span class="s3">`toHandlerKey`</span><span class="s2">,</span>
    <span class="s1">[SET_BLOCK_TRACKING]: </span><span class="s3">`setBlockTracking`</span><span class="s2">,</span>
    <span class="s1">[PUSH_SCOPE_ID]: </span><span class="s3">`pushScopeId`</span><span class="s2">,</span>
    <span class="s1">[POP_SCOPE_ID]: </span><span class="s3">`popScopeId`</span><span class="s2">,</span>
    <span class="s1">[WITH_CTX]: </span><span class="s3">`withCtx`</span><span class="s2">,</span>
    <span class="s1">[UNREF]: </span><span class="s3">`unref`</span><span class="s2">,</span>
    <span class="s1">[IS_REF]: </span><span class="s3">`isRef`</span><span class="s2">,</span>
    <span class="s1">[WITH_MEMO]: </span><span class="s3">`withMemo`</span><span class="s2">,</span>
    <span class="s1">[IS_MEMO_SAME]: </span><span class="s3">`isMemoSame`</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">registerRuntimeHelpers(helpers) {</span>
    <span class="s1">Object.getOwnPropertySymbols(helpers).forEach(s =&gt; {</span>
        <span class="s1">helperNameMap[s] = helpers[s]</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// AST Utilities ---------------------------------------------------------------</span>
<span class="s5">// Some expressions, e.g. sequence and conditional expressions, are never</span>
<span class="s5">// associated with template nodes, so their source locations are just a stub.</span>
<span class="s5">// Container types like CompoundExpression also don't need a real location.</span>
<span class="s2">const </span><span class="s1">locStub = {</span>
    <span class="s1">source: </span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">start: { line: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">end: { line: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">column: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">offset: </span><span class="s4">0 </span><span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createRoot(children</span><span class="s2">, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */</span><span class="s2">,</span>
        <span class="s1">children</span><span class="s2">,</span>
        <span class="s1">helpers: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
        <span class="s1">components: []</span><span class="s2">,</span>
        <span class="s1">directives: []</span><span class="s2">,</span>
        <span class="s1">hoists: []</span><span class="s2">,</span>
        <span class="s1">imports: []</span><span class="s2">,</span>
        <span class="s1">cached: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">temps: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">codegenNode: undefined</span><span class="s2">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createVNodeCall(context</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">directives</span><span class="s2">, </span><span class="s1">isBlock = </span><span class="s2">false, </span><span class="s1">disableTracking = </span><span class="s2">false, </span><span class="s1">isComponent = </span><span class="s2">false, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">if </span><span class="s1">(context) {</span>
        <span class="s2">if </span><span class="s1">(isBlock) {</span>
            <span class="s1">context.helper(OPEN_BLOCK)</span><span class="s2">;</span>
            <span class="s1">context.helper(getVNodeBlockHelper(context.inSSR</span><span class="s2">, </span><span class="s1">isComponent))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s2">, </span><span class="s1">isComponent))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(directives) {</span>
            <span class="s1">context.helper(WITH_DIRECTIVES)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s2">,</span>
        <span class="s1">tag</span><span class="s2">,</span>
        <span class="s1">props</span><span class="s2">,</span>
        <span class="s1">children</span><span class="s2">,</span>
        <span class="s1">patchFlag</span><span class="s2">,</span>
        <span class="s1">dynamicProps</span><span class="s2">,</span>
        <span class="s1">directives</span><span class="s2">,</span>
        <span class="s1">isBlock</span><span class="s2">,</span>
        <span class="s1">disableTracking</span><span class="s2">,</span>
        <span class="s1">isComponent</span><span class="s2">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createArrayExpression(elements</span><span class="s2">, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">,</span>
        <span class="s1">elements</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createObjectExpression(properties</span><span class="s2">, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">,</span>
        <span class="s1">properties</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createObjectProperty(key</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">16 </span><span class="s5">/* NodeTypes.JS_PROPERTY */</span><span class="s2">,</span>
        <span class="s1">loc: locStub</span><span class="s2">,</span>
        <span class="s1">key: isString(key) ? createSimpleExpression(key</span><span class="s2">, true</span><span class="s1">) : key</span><span class="s2">,</span>
        <span class="s1">value</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createSimpleExpression(content</span><span class="s2">, </span><span class="s1">isStatic = </span><span class="s2">false, </span><span class="s1">loc = locStub</span><span class="s2">, </span><span class="s1">constType = </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">,</span>
        <span class="s1">content</span><span class="s2">,</span>
        <span class="s1">isStatic</span><span class="s2">,</span>
        <span class="s1">constType: isStatic ? </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */ </span><span class="s1">: constType</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCompoundExpression(children</span><span class="s2">, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">,</span>
        <span class="s1">children</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCallExpression(callee</span><span class="s2">, </span><span class="s1">args = []</span><span class="s2">, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">,</span>
        <span class="s1">callee</span><span class="s2">,</span>
        <span class="s1">arguments: args</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createFunctionExpression(params</span><span class="s2">, </span><span class="s1">returns = undefined</span><span class="s2">, </span><span class="s1">newline = </span><span class="s2">false, </span><span class="s1">isSlot = </span><span class="s2">false, </span><span class="s1">loc = locStub) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">18 </span><span class="s5">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">params</span><span class="s2">,</span>
        <span class="s1">returns</span><span class="s2">,</span>
        <span class="s1">newline</span><span class="s2">,</span>
        <span class="s1">isSlot</span><span class="s2">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createConditionalExpression(test</span><span class="s2">, </span><span class="s1">consequent</span><span class="s2">, </span><span class="s1">alternate</span><span class="s2">, </span><span class="s1">newline = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">test</span><span class="s2">,</span>
        <span class="s1">consequent</span><span class="s2">,</span>
        <span class="s1">alternate</span><span class="s2">,</span>
        <span class="s1">newline</span><span class="s2">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCacheExpression(index</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isVNode = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s2">,</span>
        <span class="s1">index</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">isVNode</span><span class="s2">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createBlockStatement(body) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">21 </span><span class="s5">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s2">,</span>
        <span class="s1">body</span><span class="s2">,</span>
        <span class="s1">loc: locStub</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isStaticExp = (p) =&gt; p.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; p.isStatic</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isBuiltInType = (tag</span><span class="s2">, </span><span class="s1">expected) =&gt; tag === expected || tag === hyphenate(expected)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isCoreComponent(tag) {</span>
    <span class="s2">if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">'Teleport'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">TELEPORT</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">'Suspense'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">SUSPENSE</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">'KeepAlive'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">KEEP_ALIVE</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">'BaseTransition'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">BASE_TRANSITION</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">nonIdentifierRE = </span><span class="s4">/^\d|[^\$\w]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isSimpleIdentifier = (name) =&gt; !nonIdentifierRE.test(name)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">validFirstIdentCharRE = </span><span class="s4">/[A-Za-z_$\xA0-\uFFFF]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">validIdentCharRE = </span><span class="s4">/[\.\?\w$\xA0-\uFFFF]/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">whitespaceRE = </span><span class="s4">/\s+[.[]\s*|\s*[.[]\s+/g</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Simple lexer to check if an expression is a member expression. This is</span>
 <span class="s0">* lax and only checks validity at the root level (i.e. does not validate exps</span>
 <span class="s0">* inside square brackets), but it's ok since these are only used on template</span>
 <span class="s0">* expressions and false positives are invalid expressions in the first place.</span>
 <span class="s0">*/</span>
<span class="s2">const </span><span class="s1">isMemberExpressionBrowser = (path) =&gt; {</span>
    <span class="s5">// remove whitespaces around . or [ first</span>
    <span class="s1">path = path.trim().replace(whitespaceRE</span><span class="s2">, </span><span class="s1">s =&gt; s.trim())</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">state = </span><span class="s4">0 </span><span class="s5">/* MemberExpLexState.inMemberExp */</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">stateStack = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">currentOpenBracketCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">currentOpenParensCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">currentStringType = </span><span class="s2">null;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; path.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">char = path.charAt(i)</span><span class="s2">;</span>
        <span class="s2">switch </span><span class="s1">(state) {</span>
            <span class="s2">case </span><span class="s4">0 </span><span class="s5">/* MemberExpLexState.inMemberExp */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(char === </span><span class="s3">'['</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s2">;</span>
                    <span class="s1">state = </span><span class="s4">1 </span><span class="s5">/* MemberExpLexState.inBrackets */</span><span class="s2">;</span>
                    <span class="s1">currentOpenBracketCount++</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(char === </span><span class="s3">'('</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s2">;</span>
                    <span class="s1">state = </span><span class="s4">2 </span><span class="s5">/* MemberExpLexState.inParens */</span><span class="s2">;</span>
                    <span class="s1">currentOpenParensCount++</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!(i === </span><span class="s4">0 </span><span class="s1">? validFirstIdentCharRE : validIdentCharRE).test(char)) {</span>
                    <span class="s2">return false;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* MemberExpLexState.inBrackets */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(char === </span><span class="s3">`'` </span><span class="s1">|| char === </span><span class="s3">`&quot;` </span><span class="s1">|| char === </span><span class="s3">'`'</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s2">;</span>
                    <span class="s1">state = </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s2">;</span>
                    <span class="s1">currentStringType = char</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(char === </span><span class="s3">`[`</span><span class="s1">) {</span>
                    <span class="s1">currentOpenBracketCount++</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(char === </span><span class="s3">`]`</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!--currentOpenBracketCount) {</span>
                        <span class="s1">state = stateStack.pop()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">2 </span><span class="s5">/* MemberExpLexState.inParens */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(char === </span><span class="s3">`'` </span><span class="s1">|| char === </span><span class="s3">`&quot;` </span><span class="s1">|| char === </span><span class="s3">'`'</span><span class="s1">) {</span>
                    <span class="s1">stateStack.push(state)</span><span class="s2">;</span>
                    <span class="s1">state = </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s2">;</span>
                    <span class="s1">currentStringType = char</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(char === </span><span class="s3">`(`</span><span class="s1">) {</span>
                    <span class="s1">currentOpenParensCount++</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(char === </span><span class="s3">`)`</span><span class="s1">) {</span>
                    <span class="s5">// if the exp ends as a call then it should not be considered valid</span>
                    <span class="s2">if </span><span class="s1">(i === path.length - </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s2">return false;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!--currentOpenParensCount) {</span>
                        <span class="s1">state = stateStack.pop()</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* MemberExpLexState.inString */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(char === currentStringType) {</span>
                    <span class="s1">state = stateStack.pop()</span><span class="s2">;</span>
                    <span class="s1">currentStringType = </span><span class="s2">null;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">!currentOpenBracketCount &amp;&amp; !currentOpenParensCount</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isMemberExpression = isMemberExpressionBrowser</span>
    <span class="s2">;</span>
<span class="s2">function </span><span class="s1">getInnerRange(loc</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">length) {</span>
    <span class="s2">const </span><span class="s1">source = loc.source.slice(offset</span><span class="s2">, </span><span class="s1">offset + length)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newLoc = {</span>
        <span class="s1">source</span><span class="s2">,</span>
        <span class="s1">start: advancePositionWithClone(loc.start</span><span class="s2">, </span><span class="s1">loc.source</span><span class="s2">, </span><span class="s1">offset)</span><span class="s2">,</span>
        <span class="s1">end: loc.end</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(length != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">newLoc.end = advancePositionWithClone(loc.start</span><span class="s2">, </span><span class="s1">loc.source</span><span class="s2">, </span><span class="s1">offset + length)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newLoc</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">advancePositionWithClone(pos</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">numberOfCharacters = source.length) {</span>
    <span class="s2">return </span><span class="s1">advancePositionWithMutation(extend({}</span><span class="s2">, </span><span class="s1">pos)</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">numberOfCharacters)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// advance by mutation without cloning (for performance reasons), since this</span>
<span class="s5">// gets called a lot in the parser</span>
<span class="s2">function </span><span class="s1">advancePositionWithMutation(pos</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">numberOfCharacters = source.length) {</span>
    <span class="s2">let </span><span class="s1">linesCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">lastNewLinePos = -</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; numberOfCharacters</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">if </span><span class="s1">(source.charCodeAt(i) === </span><span class="s4">10 </span><span class="s5">/* newline char code */</span><span class="s1">) {</span>
            <span class="s1">linesCount++</span><span class="s2">;</span>
            <span class="s1">lastNewLinePos = i</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">pos.offset += numberOfCharacters</span><span class="s2">;</span>
    <span class="s1">pos.line += linesCount</span><span class="s2">;</span>
    <span class="s1">pos.column =</span>
        <span class="s1">lastNewLinePos === -</span><span class="s4">1</span>
            <span class="s1">? pos.column + numberOfCharacters</span>
            <span class="s1">: numberOfCharacters - lastNewLinePos</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">pos</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assert(condition</span><span class="s2">, </span><span class="s1">msg) {</span>
    <span class="s5">/* istanbul ignore if */</span>
    <span class="s2">if </span><span class="s1">(!condition) {</span>
        <span class="s2">throw new </span><span class="s1">Error(msg || </span><span class="s3">`unexpected compiler condition`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">findDir(node</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">allowEmpty = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">p = node.props[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(allowEmpty || p.exp) &amp;&amp;</span>
            <span class="s1">(isString(name) ? p.name === name : name.test(p.name))) {</span>
            <span class="s2">return </span><span class="s1">p</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">findProp(node</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">dynamicOnly = </span><span class="s2">false, </span><span class="s1">allowEmpty = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">p = node.props[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(dynamicOnly)</span>
                <span class="s2">continue;</span>
            <span class="s2">if </span><span class="s1">(p.name === name &amp;&amp; (p.value || allowEmpty)) {</span>
                <span class="s2">return </span><span class="s1">p</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(p.exp || allowEmpty) &amp;&amp;</span>
            <span class="s1">isStaticArgOf(p.arg</span><span class="s2">, </span><span class="s1">name)) {</span>
            <span class="s2">return </span><span class="s1">p</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isStaticArgOf(arg</span><span class="s2">, </span><span class="s1">name) {</span>
    <span class="s2">return </span><span class="s1">!!(arg &amp;&amp; isStaticExp(arg) &amp;&amp; arg.content === name)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasDynamicKeyVBind(node) {</span>
    <span class="s2">return </span><span class="s1">node.props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(!p.arg || </span><span class="s5">// v-bind=&quot;obj&quot;</span>
            <span class="s1">p.arg.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">|| </span><span class="s5">// v-bind:[_ctx.foo]</span>
            <span class="s1">!p.arg.isStatic) </span><span class="s5">// v-bind:[foo]</span>
    <span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isText$1(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">|| node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVSlot(p) {</span>
    <span class="s2">return </span><span class="s1">p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s3">'slot'</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isTemplateNode(node) {</span>
    <span class="s2">return </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSlotOutlet(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; node.tagType === </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getVNodeHelper(ssr</span><span class="s2">, </span><span class="s1">isComponent) {</span>
    <span class="s2">return </span><span class="s1">ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getVNodeBlockHelper(ssr</span><span class="s2">, </span><span class="s1">isComponent) {</span>
    <span class="s2">return </span><span class="s1">ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">propsHelperSet = </span><span class="s2">new </span><span class="s1">Set([NORMALIZE_PROPS</span><span class="s2">, </span><span class="s1">GUARD_REACTIVE_PROPS])</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getUnnormalizedProps(props</span><span class="s2">, </span><span class="s1">callPath = []) {</span>
    <span class="s2">if </span><span class="s1">(props &amp;&amp;</span>
        <span class="s1">!isString(props) &amp;&amp;</span>
        <span class="s1">props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">callee = props.callee</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isString(callee) &amp;&amp; propsHelperSet.has(callee)) {</span>
            <span class="s2">return </span><span class="s1">getUnnormalizedProps(props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">callPath.concat(props))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[props</span><span class="s2">, </span><span class="s1">callPath]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">injectProp(node</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">let </span><span class="s1">propsWithInjection</span><span class="s2">;</span>
    <span class="s0">/**</span>
     <span class="s0">* 1. mergeProps(...)</span>
     <span class="s0">* 2. toHandlers(...)</span>
     <span class="s0">* 3. normalizeProps(...)</span>
     <span class="s0">* 4. normalizeProps(guardReactiveProps(...))</span>
     <span class="s0">*</span>
     <span class="s0">* we need to get the real props before normalization</span>
     <span class="s0">*/</span>
    <span class="s2">let </span><span class="s1">props = node.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */ </span><span class="s1">? node.props : node.arguments[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">callPath = []</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">parentCall</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(props &amp;&amp;</span>
        <span class="s1">!isString(props) &amp;&amp;</span>
        <span class="s1">props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">ret = getUnnormalizedProps(props)</span><span class="s2">;</span>
        <span class="s1">props = ret[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">callPath = ret[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(props == </span><span class="s2">null </span><span class="s1">|| isString(props)) {</span>
        <span class="s1">propsWithInjection = createObjectExpression([prop])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(props.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s5">// merged props... add ours</span>
        <span class="s5">// only inject key to object literal if it's the first argument so that</span>
        <span class="s5">// if doesn't override user provided keys</span>
        <span class="s2">const </span><span class="s1">first = props.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isString(first) &amp;&amp; first.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s5">// #6631</span>
            <span class="s2">if </span><span class="s1">(!hasProp(prop</span><span class="s2">, </span><span class="s1">first)) {</span>
                <span class="s1">first.properties.unshift(prop)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(props.callee === TO_HANDLERS) {</span>
                <span class="s5">// #2366</span>
                <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">createObjectExpression([prop])</span><span class="s2">,</span>
                    <span class="s1">props</span>
                <span class="s1">])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">props.arguments.unshift(createObjectExpression([prop]))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">!propsWithInjection &amp;&amp; (propsWithInjection = props)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(props.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!hasProp(prop</span><span class="s2">, </span><span class="s1">props)) {</span>
            <span class="s1">props.properties.unshift(prop)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">propsWithInjection = props</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// single v-bind with expression, return a merged replacement</span>
        <span class="s1">propsWithInjection = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">createObjectExpression([prop])</span><span class="s2">,</span>
            <span class="s1">props</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s5">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,</span>
        <span class="s5">// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,</span>
        <span class="s5">// the `guardReactiveProps` will no longer be needed</span>
        <span class="s2">if </span><span class="s1">(parentCall &amp;&amp; parentCall.callee === GUARD_REACTIVE_PROPS) {</span>
            <span class="s1">parentCall = callPath[callPath.length - </span><span class="s4">2</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(parentCall) {</span>
            <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node.props = propsWithInjection</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(parentCall) {</span>
            <span class="s1">parentCall.arguments[</span><span class="s4">0</span><span class="s1">] = propsWithInjection</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node.arguments[</span><span class="s4">2</span><span class="s1">] = propsWithInjection</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">// check existing key to avoid overriding user provided keys</span>
<span class="s2">function </span><span class="s1">hasProp(prop</span><span class="s2">, </span><span class="s1">props) {</span>
    <span class="s2">let </span><span class="s1">result = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(prop.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">propKeyName = prop.key.content</span><span class="s2">;</span>
        <span class="s1">result = props.properties.some(p =&gt; p.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">p.key.content === propKeyName)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toValidAssetId(name</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s5">// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character</span>
    <span class="s2">return </span><span class="s3">`_</span><span class="s1">${type}</span><span class="s3">_</span><span class="s1">${name.replace(</span><span class="s4">/[^\w]/g</span><span class="s2">, </span><span class="s1">(searchValue</span><span class="s2">, </span><span class="s1">replaceValue) =&gt; {</span>
        <span class="s2">return </span><span class="s1">searchValue === </span><span class="s3">'-' </span><span class="s1">? </span><span class="s3">'_' </span><span class="s1">: name.charCodeAt(replaceValue).toString()</span><span class="s2">;</span>
    <span class="s1">})}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getMemoedVNodeCall(node) {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp; node.callee === WITH_MEMO) {</span>
        <span class="s2">return </span><span class="s1">node.arguments[</span><span class="s4">1</span><span class="s1">].returns</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeBlock(node</span><span class="s2">, </span><span class="s1">{ helper</span><span class="s2">, </span><span class="s1">removeHelper</span><span class="s2">, </span><span class="s1">inSSR }) {</span>
    <span class="s2">if </span><span class="s1">(!node.isBlock) {</span>
        <span class="s1">node.isBlock = </span><span class="s2">true;</span>
        <span class="s1">removeHelper(getVNodeHelper(inSSR</span><span class="s2">, </span><span class="s1">node.isComponent))</span><span class="s2">;</span>
        <span class="s1">helper(OPEN_BLOCK)</span><span class="s2">;</span>
        <span class="s1">helper(getVNodeBlockHelper(inSSR</span><span class="s2">, </span><span class="s1">node.isComponent))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">deprecationData = {</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`Platform-native elements with &quot;is&quot; prop will no longer be ` </span><span class="s1">+</span>
            <span class="s3">`treated as components in Vue 3 unless the &quot;is&quot; value is explicitly ` </span><span class="s1">+</span>
            <span class="s3">`prefixed with &quot;vue:&quot;.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_V_BIND_SYNC&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */</span><span class="s1">]: {</span>
        <span class="s1">message: key =&gt; </span><span class="s3">`.sync modifier for v-bind has been removed. Use v-model with ` </span><span class="s1">+</span>
            <span class="s3">`argument instead. </span><span class="s2">\`</span><span class="s3">v-bind:</span><span class="s1">${key}</span><span class="s3">.sync</span><span class="s2">\` </span><span class="s3">should be changed to ` </span><span class="s1">+</span>
            <span class="s3">`</span><span class="s2">\`</span><span class="s3">v-model:</span><span class="s1">${key}</span><span class="s2">\`</span><span class="s3">.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/v-model.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_V_BIND_PROP&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`.prop modifier for v-bind has been removed and no longer necessary. ` </span><span class="s1">+</span>
            <span class="s3">`Vue 3 will automatically set a binding as DOM property when appropriate.`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_V_BIND_OBJECT_ORDER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`v-bind=&quot;obj&quot; usage is now order sensitive and behaves like JavaScript ` </span><span class="s1">+</span>
            <span class="s3">`object spread: it will now overwrite an existing non-mergeable attribute ` </span><span class="s1">+</span>
            <span class="s3">`that appears before v-bind in the case of conflict. ` </span><span class="s1">+</span>
            <span class="s3">`To retain 2.x behavior, move v-bind to make it the first attribute. ` </span><span class="s1">+</span>
            <span class="s3">`You can also suppress this warning if the usage is intended.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/v-bind.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_V_ON_NATIVE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`.native modifier for v-on has been removed as is no longer necessary.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_V_IF_V_FOR_PRECEDENCE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`v-if / v-for precedence when used on the same element has changed ` </span><span class="s1">+</span>
            <span class="s3">`in Vue 3: v-if now takes higher precedence and will no longer have ` </span><span class="s1">+</span>
            <span class="s3">`access to v-for scope variables. It is best to avoid the ambiguity ` </span><span class="s1">+</span>
            <span class="s3">`with &lt;template&gt; tags or use a computed property that filters v-for ` </span><span class="s1">+</span>
            <span class="s3">`data source.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_NATIVE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`&lt;template&gt; with no special directives will render as a native template ` </span><span class="s1">+</span>
            <span class="s3">`element instead of its inner content in Vue 3.`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_INLINE_TEMPLATE&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`&quot;inline-template&quot; has been removed in Vue 3.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;COMPILER_FILTER&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_FILTERS */</span><span class="s1">]: {</span>
        <span class="s1">message: </span><span class="s3">`filters have been removed in Vue 3. ` </span><span class="s1">+</span>
            <span class="s3">`The &quot;|&quot; symbol will be treated as native JavaScript bitwise OR operator. ` </span><span class="s1">+</span>
            <span class="s3">`Use method calls or computed properties instead.`</span><span class="s2">,</span>
        <span class="s1">link: </span><span class="s3">`https://v3-migration.vuejs.org/breaking-changes/filters.html`</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getCompatValue(key</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">config = context.options</span>
        <span class="s1">? context.options.compatConfig</span>
        <span class="s1">: context.compatConfig</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">value = config &amp;&amp; config[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">'MODE'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">value || </span><span class="s4">3</span><span class="s2">; </span><span class="s5">// compiler defaults to v3 behavior</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isCompatEnabled(key</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">mode = getCompatValue(</span><span class="s3">'MODE'</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">value = getCompatValue(key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s5">// in v3 mode, only enable if explicitly set to true</span>
    <span class="s5">// otherwise enable for any non-false value</span>
    <span class="s2">return </span><span class="s1">mode === </span><span class="s4">3 </span><span class="s1">? value === </span><span class="s2">true </span><span class="s1">: value !== </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkCompatEnabled(key</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">...args) {</span>
    <span class="s2">const </span><span class="s1">enabled = isCompatEnabled(key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(enabled) {</span>
        <span class="s1">warnDeprecation(key</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">enabled</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">warnDeprecation(key</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">...args) {</span>
    <span class="s2">const </span><span class="s1">val = getCompatValue(key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(val === </span><span class="s3">'suppress-warning'</span><span class="s1">) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ message</span><span class="s2">, </span><span class="s1">link } = deprecationData[key]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">msg = </span><span class="s3">`(deprecation </span><span class="s1">${key}</span><span class="s3">) </span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">message === </span><span class="s3">'function' </span><span class="s1">? message(...args) : message}${link ? </span><span class="s3">`</span><span class="s2">\n  </span><span class="s3">Details: </span><span class="s1">${link}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">SyntaxError(msg)</span><span class="s2">;</span>
    <span class="s1">err.code = key</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(loc)</span>
        <span class="s1">err.loc = loc</span><span class="s2">;</span>
    <span class="s1">context.onWarn(err)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// The default decoder only provides escapes for characters reserved as part of</span>
<span class="s5">// the template syntax, and is only used if the custom renderer did not provide</span>
<span class="s5">// a platform-specific decoder.</span>
<span class="s2">const </span><span class="s1">decodeRE = </span><span class="s4">/&amp;(gt|lt|amp|apos|quot);/g</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">decodeMap = {</span>
    <span class="s1">gt: </span><span class="s3">'&gt;'</span><span class="s2">,</span>
    <span class="s1">lt: </span><span class="s3">'&lt;'</span><span class="s2">,</span>
    <span class="s1">amp: </span><span class="s3">'&amp;'</span><span class="s2">,</span>
    <span class="s1">apos: </span><span class="s3">&quot;'&quot;</span><span class="s2">,</span>
    <span class="s1">quot: </span><span class="s3">'&quot;'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">defaultParserOptions = {</span>
    <span class="s1">delimiters: [</span><span class="s3">`{{`</span><span class="s2">, </span><span class="s3">`}}`</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">getNamespace: () =&gt; </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s2">,</span>
    <span class="s1">getTextMode: () =&gt; </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s2">,</span>
    <span class="s1">isVoidTag: NO</span><span class="s2">,</span>
    <span class="s1">isPreTag: NO</span><span class="s2">,</span>
    <span class="s1">isCustomElement: NO</span><span class="s2">,</span>
    <span class="s1">decodeEntities: (rawText) =&gt; rawText.replace(decodeRE</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">p1) =&gt; decodeMap[p1])</span><span class="s2">,</span>
    <span class="s1">onError: defaultOnError</span><span class="s2">,</span>
    <span class="s1">onWarn: defaultOnWarn</span><span class="s2">,</span>
    <span class="s1">comments: </span><span class="s2">true</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">baseParse(content</span><span class="s2">, </span><span class="s1">options = {}) {</span>
    <span class="s2">const </span><span class="s1">context = createParserContext(content</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">createRoot(parseChildren(context</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">, </span><span class="s1">getSelection(context</span><span class="s2">, </span><span class="s1">start))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createParserContext(content</span><span class="s2">, </span><span class="s1">rawOptions) {</span>
    <span class="s2">const </span><span class="s1">options = extend({}</span><span class="s2">, </span><span class="s1">defaultParserOptions)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">key</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">rawOptions) {</span>
        <span class="s5">// @ts-ignore</span>
        <span class="s1">options[key] =</span>
            <span class="s1">rawOptions[key] === undefined</span>
                <span class="s1">? defaultParserOptions[key]</span>
                <span class="s1">: rawOptions[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">options</span><span class="s2">,</span>
        <span class="s1">column: </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">line: </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">offset: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">originalSource: content</span><span class="s2">,</span>
        <span class="s1">source: content</span><span class="s2">,</span>
        <span class="s1">inPre: </span><span class="s2">false,</span>
        <span class="s1">inVPre: </span><span class="s2">false,</span>
        <span class="s1">onWarn: options.onWarn</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseChildren(context</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">ancestors) {</span>
    <span class="s2">const </span><span class="s1">parent = last(ancestors)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nodes = []</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(!isEnd(context</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">ancestors)) {</span>
        <span class="s2">const </span><span class="s1">s = context.source</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">node = undefined</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */ </span><span class="s1">|| mode === </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(s</span><span class="s2">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">])) {</span>
                <span class="s5">// '{{'</span>
                <span class="s1">node = parseInterpolation(context</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(mode === </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */ </span><span class="s1">&amp;&amp; s[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'&lt;'</span><span class="s1">) {</span>
                <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state</span>
                <span class="s2">if </span><span class="s1">(s.length === </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'!'</span><span class="s1">) {</span>
                    <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state</span>
                    <span class="s2">if </span><span class="s1">(startsWith(s</span><span class="s2">, </span><span class="s3">'&lt;!--'</span><span class="s1">)) {</span>
                        <span class="s1">node = parseComment(context)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(startsWith(s</span><span class="s2">, </span><span class="s3">'&lt;!DOCTYPE'</span><span class="s1">)) {</span>
                        <span class="s5">// Ignore DOCTYPE by a limitation.</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(startsWith(s</span><span class="s2">, </span><span class="s3">'&lt;![CDATA['</span><span class="s1">)) {</span>
                        <span class="s2">if </span><span class="s1">(ns !== </span><span class="s4">0 </span><span class="s5">/* Namespaces.HTML */</span><span class="s1">) {</span>
                            <span class="s1">node = parseCDATA(context</span><span class="s2">, </span><span class="s1">ancestors)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* ErrorCodes.CDATA_IN_HTML_CONTENT */</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s1">node = parseBogusComment(context)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">11 </span><span class="s5">/* ErrorCodes.INCORRECTLY_OPENED_COMMENT */</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
                    <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state</span>
                    <span class="s2">if </span><span class="s1">(s.length === </span><span class="s4">2</span><span class="s1">) {</span>
                        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">5 </span><span class="s5">/* ErrorCodes.EOF_BEFORE_TAG_NAME */</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(s[</span><span class="s4">2</span><span class="s1">] === </span><span class="s3">'&gt;'</span><span class="s1">) {</span>
                        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">14 </span><span class="s5">/* ErrorCodes.MISSING_END_TAG_NAME */</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s2">continue;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">2</span><span class="s1">])) {</span>
                        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">23 </span><span class="s5">/* ErrorCodes.X_INVALID_END_TAG */</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">parseTag(context</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s2">, </span><span class="s1">parent)</span><span class="s2">;</span>
                        <span class="s2">continue;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s1">node = parseBogusComment(context)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(</span><span class="s4">/[a-z]/i</span><span class="s1">.test(s[</span><span class="s4">1</span><span class="s1">])) {</span>
                    <span class="s1">node = parseElement(context</span><span class="s2">, </span><span class="s1">ancestors)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(s[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'?'</span><span class="s1">) {</span>
                    <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">21 </span><span class="s5">/* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">node = parseBogusComment(context)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">12 </span><span class="s5">/* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!node) {</span>
            <span class="s1">node = parseText(context</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isArray(node)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">pushNode(nodes</span><span class="s2">, </span><span class="s1">node[i])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">pushNode(nodes</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// Whitespace handling strategy like v2</span>
    <span class="s2">let </span><span class="s1">removedWhitespace = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(mode !== </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */ </span><span class="s1">&amp;&amp; mode !== </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">shouldCondense = context.options.whitespace !== </span><span class="s3">'preserve'</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; nodes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">node = nodes[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!context.inPre) {</span>
                    <span class="s2">if </span><span class="s1">(!</span><span class="s4">/[^\t\r\n\f ]/</span><span class="s1">.test(node.content)) {</span>
                        <span class="s2">const </span><span class="s1">prev = nodes[i - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
                        <span class="s2">const </span><span class="s1">next = nodes[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
                        <span class="s5">// Remove if:</span>
                        <span class="s5">// - the whitespace is the first or last node, or:</span>
                        <span class="s5">// - (condense mode) the whitespace is between twos comments, or:</span>
                        <span class="s5">// - (condense mode) the whitespace is between comment and element, or:</span>
                        <span class="s5">// - (condense mode) the whitespace is between two elements AND contains newline</span>
                        <span class="s2">if </span><span class="s1">(!prev ||</span>
                            <span class="s1">!next ||</span>
                            <span class="s1">(shouldCondense &amp;&amp;</span>
                                <span class="s1">((prev.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                    <span class="s1">next.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) ||</span>
                                    <span class="s1">(prev.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s1">next.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                                        <span class="s4">/[\r\n]/</span><span class="s1">.test(node.content))))) {</span>
                            <span class="s1">removedWhitespace = </span><span class="s2">true;</span>
                            <span class="s1">nodes[i] = </span><span class="s2">null;</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s5">// Otherwise, the whitespace is condensed into a single space</span>
                            <span class="s1">node.content = </span><span class="s3">' '</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(shouldCondense) {</span>
                        <span class="s5">// in condense mode, consecutive whitespaces in text are condensed</span>
                        <span class="s5">// down to a single space.</span>
                        <span class="s1">node.content = node.content.replace(</span><span class="s4">/[\t\r\n\f ]+/g</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s5">// #6410 normalize windows newlines in &lt;pre&gt;:</span>
                    <span class="s5">// in SSR, browsers normalize server-rendered \r\n into a single \n</span>
                    <span class="s5">// in the DOM</span>
                    <span class="s1">node.content = node.content.replace(</span><span class="s4">/\r\n/g</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// Remove comment nodes if desired by configuration.</span>
            <span class="s2">else if </span><span class="s1">(node.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp; !context.options.comments) {</span>
                <span class="s1">removedWhitespace = </span><span class="s2">true;</span>
                <span class="s1">nodes[i] = </span><span class="s2">null;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(context.inPre &amp;&amp; parent &amp;&amp; context.options.isPreTag(parent.tag)) {</span>
            <span class="s5">// remove leading newline per html spec</span>
            <span class="s5">// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element</span>
            <span class="s2">const </span><span class="s1">first = nodes[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(first &amp;&amp; first.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                <span class="s1">first.content = first.content.replace(</span><span class="s4">/^\r?\n/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">removedWhitespace ? nodes.filter(Boolean) : nodes</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">pushNode(nodes</span><span class="s2">, </span><span class="s1">node) {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">prev = last(nodes)</span><span class="s2">;</span>
        <span class="s5">// Merge if both this and the previous node are text and those are</span>
        <span class="s5">// consecutive. This happens for cases like &quot;a &lt; b&quot;.</span>
        <span class="s2">if </span><span class="s1">(prev &amp;&amp;</span>
            <span class="s1">prev.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">prev.loc.end.offset === node.loc.start.offset) {</span>
            <span class="s1">prev.content += node.content</span><span class="s2">;</span>
            <span class="s1">prev.loc.end = node.loc.end</span><span class="s2">;</span>
            <span class="s1">prev.loc.source += node.loc.source</span><span class="s2">;</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">nodes.push(node)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseCDATA(context</span><span class="s2">, </span><span class="s1">ancestors) {</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">9</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nodes = parseChildren(context</span><span class="s2">, </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */</span><span class="s2">, </span><span class="s1">ancestors)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">6 </span><span class="s5">/* ErrorCodes.EOF_IN_CDATA */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">nodes</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseComment(context) {</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">content</span><span class="s2">;</span>
    <span class="s5">// Regular comment.</span>
    <span class="s2">const </span><span class="s1">match = </span><span class="s4">/--(\!)?&gt;/</span><span class="s1">.exec(context.source)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!match) {</span>
        <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">context.source.length)</span><span class="s2">;</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">7 </span><span class="s5">/* ErrorCodes.EOF_IN_COMMENT */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(match.index &lt;= </span><span class="s4">3</span><span class="s1">) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(match[</span><span class="s4">1</span><span class="s1">]) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">10 </span><span class="s5">/* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">content = context.source.slice(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">match.index)</span><span class="s2">;</span>
        <span class="s5">// Advancing with reporting nested comments.</span>
        <span class="s2">const </span><span class="s1">s = context.source.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">match.index)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">prevIndex = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">nestedIndex = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">((nestedIndex = s.indexOf(</span><span class="s3">'&lt;!--'</span><span class="s2">, </span><span class="s1">prevIndex)) !== -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">nestedIndex - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(nestedIndex + </span><span class="s4">4 </span><span class="s1">&lt; s.length) {</span>
                <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">16 </span><span class="s5">/* ErrorCodes.NESTED_COMMENT */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">prevIndex = nestedIndex + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">match.index + match[</span><span class="s4">0</span><span class="s1">].length - prevIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s2">,</span>
        <span class="s1">content</span><span class="s2">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseBogusComment(context) {</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">contentStart = context.source[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'?' </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">content</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">closeIndex = context.source.indexOf(</span><span class="s3">'&gt;'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">content = context.source.slice(contentStart)</span><span class="s2">;</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">context.source.length)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">content = context.source.slice(contentStart</span><span class="s2">, </span><span class="s1">closeIndex)</span><span class="s2">;</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">closeIndex + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s2">,</span>
        <span class="s1">content</span><span class="s2">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseElement(context</span><span class="s2">, </span><span class="s1">ancestors) {</span>
    <span class="s5">// Start tag.</span>
    <span class="s2">const </span><span class="s1">wasInPre = context.inPre</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wasInVPre = context.inVPre</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">parent = last(ancestors)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">element = parseTag(context</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* TagType.Start */</span><span class="s2">, </span><span class="s1">parent)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isPreBoundary = context.inPre &amp;&amp; !wasInPre</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isVPreBoundary = context.inVPre &amp;&amp; !wasInVPre</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(element.isSelfClosing || context.options.isVoidTag(element.tag)) {</span>
        <span class="s5">// #4030 self-closing &lt;pre&gt; tag</span>
        <span class="s2">if </span><span class="s1">(isPreBoundary) {</span>
            <span class="s1">context.inPre = </span><span class="s2">false;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isVPreBoundary) {</span>
            <span class="s1">context.inVPre = </span><span class="s2">false;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">element</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// Children.</span>
    <span class="s1">ancestors.push(element)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mode = context.options.getTextMode(element</span><span class="s2">, </span><span class="s1">parent)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">children = parseChildren(context</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">ancestors)</span><span class="s2">;</span>
    <span class="s1">ancestors.pop()</span><span class="s2">;</span>
    <span class="s1">element.children = children</span><span class="s2">;</span>
    <span class="s5">// End tag.</span>
    <span class="s2">if </span><span class="s1">(startsWithEndTagOpen(context.source</span><span class="s2">, </span><span class="s1">element.tag)) {</span>
        <span class="s1">parseTag(context</span><span class="s2">, </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s2">, </span><span class="s1">parent)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">24 </span><span class="s5">/* ErrorCodes.X_MISSING_END_TAG */</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">element.loc.start)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(context.source.length === </span><span class="s4">0 </span><span class="s1">&amp;&amp; element.tag.toLowerCase() === </span><span class="s3">'script'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">first = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(first &amp;&amp; startsWith(first.loc.source</span><span class="s2">, </span><span class="s3">'&lt;!--'</span><span class="s1">)) {</span>
                <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">8 </span><span class="s5">/* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">element.loc = getSelection(context</span><span class="s2">, </span><span class="s1">element.loc.start)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isPreBoundary) {</span>
        <span class="s1">context.inPre = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isVPreBoundary) {</span>
        <span class="s1">context.inVPre = </span><span class="s2">false;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">element</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">isSpecialTemplateDirective = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">`if,else,else-if,for,slot`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseTag(context</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">parent) {</span>
    <span class="s5">// Tag open.</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^&lt;\/?([a-z][^\t\r\n\f /&gt;]*)/i</span><span class="s1">.exec(context.source)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">tag = match[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">ns = context.options.getNamespace(tag</span><span class="s2">, </span><span class="s1">parent)</span><span class="s2">;</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s2">;</span>
    <span class="s1">advanceSpaces(context)</span><span class="s2">;</span>
    <span class="s5">// save current state in case we need to re-parse attributes with v-pre</span>
    <span class="s2">const </span><span class="s1">cursor = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">currentSource = context.source</span><span class="s2">;</span>
    <span class="s5">// check &lt;pre&gt; tag</span>
    <span class="s2">if </span><span class="s1">(context.options.isPreTag(tag)) {</span>
        <span class="s1">context.inPre = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s5">// Attributes.</span>
    <span class="s2">let </span><span class="s1">props = parseAttributes(context</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
    <span class="s5">// check v-pre</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s5">/* TagType.Start */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!context.inVPre &amp;&amp;</span>
        <span class="s1">props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s3">'pre'</span><span class="s1">)) {</span>
        <span class="s1">context.inVPre = </span><span class="s2">true;</span>
        <span class="s5">// reset context</span>
        <span class="s1">extend(context</span><span class="s2">, </span><span class="s1">cursor)</span><span class="s2">;</span>
        <span class="s1">context.source = currentSource</span><span class="s2">;</span>
        <span class="s5">// re-parse attrs and filter out v-pre itself</span>
        <span class="s1">props = parseAttributes(context</span><span class="s2">, </span><span class="s1">type).filter(p =&gt; p.name !== </span><span class="s3">'v-pre'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// Tag close.</span>
    <span class="s2">let </span><span class="s1">isSelfClosing = </span><span class="s2">false;</span>
    <span class="s2">if </span><span class="s1">(context.source.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">9 </span><span class="s5">/* ErrorCodes.EOF_IN_TAG */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">isSelfClosing = startsWith(context.source</span><span class="s2">, </span><span class="s3">'/&gt;'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */ </span><span class="s1">&amp;&amp; isSelfClosing) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">4 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">isSelfClosing ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s1">) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">tagType = </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!context.inVPre) {</span>
        <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'slot'</span><span class="s1">) {</span>
            <span class="s1">tagType = </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(tag === </span><span class="s3">'template'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(props.some(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; isSpecialTemplateDirective(p.name))) {</span>
                <span class="s1">tagType = </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isComponent(tag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">context)) {</span>
            <span class="s1">tagType = </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s2">,</span>
        <span class="s1">ns</span><span class="s2">,</span>
        <span class="s1">tag</span><span class="s2">,</span>
        <span class="s1">tagType</span><span class="s2">,</span>
        <span class="s1">props</span><span class="s2">,</span>
        <span class="s1">isSelfClosing</span><span class="s2">,</span>
        <span class="s1">children: []</span><span class="s2">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">,</span>
        <span class="s1">codegenNode: undefined </span><span class="s5">// to be created during transform phase</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isComponent(tag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">options = context.options</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.isCustomElement(tag)) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'component' </span><span class="s1">||</span>
        <span class="s4">/^[A-Z]/</span><span class="s1">.test(tag) ||</span>
        <span class="s1">isCoreComponent(tag) ||</span>
        <span class="s1">(options.isBuiltInComponent &amp;&amp; options.isBuiltInComponent(tag)) ||</span>
        <span class="s1">(options.isNativeTag &amp;&amp; !options.isNativeTag(tag))) {</span>
        <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s5">// at this point the tag should be a native tag, but check for potential &quot;is&quot;</span>
    <span class="s5">// casting</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">p = props[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(p.name === </span><span class="s3">'is' </span><span class="s1">&amp;&amp; p.value) {</span>
                <span class="s2">if </span><span class="s1">(p.value.content.startsWith(</span><span class="s3">'vue:'</span><span class="s1">)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// directive</span>
            <span class="s5">// v-is (TODO Deprecate)</span>
            <span class="s2">if </span><span class="s1">(p.name === </span><span class="s3">'is'</span><span class="s1">) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span>
            <span class="s5">// :is on plain element - only treat as component in compat mode</span>
            <span class="s1">p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isStaticArgOf(p.arg</span><span class="s2">, </span><span class="s3">'is'</span><span class="s1">) &amp;&amp;</span>
                <span class="s2">false </span><span class="s1">&amp;&amp;</span>
                <span class="s1">checkCompatEnabled(</span><span class="s3">&quot;COMPILER_IS_ON_ELEMENT&quot; </span><span class="s5">/* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">p.loc)) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseAttributes(context</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">const </span><span class="s1">props = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">attributeNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(context.source.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!startsWith(context.source</span><span class="s2">, </span><span class="s3">'&gt;'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">!startsWith(context.source</span><span class="s2">, </span><span class="s3">'/&gt;'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(startsWith(context.source</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">22 </span><span class="s5">/* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">advanceSpaces(context)</span><span class="s2">;</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s4">1 </span><span class="s5">/* TagType.End */</span><span class="s1">) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">3 </span><span class="s5">/* ErrorCodes.END_TAG_WITH_ATTRIBUTES */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">attr = parseAttribute(context</span><span class="s2">, </span><span class="s1">attributeNames)</span><span class="s2">;</span>
        <span class="s5">// Trim whitespace between class</span>
        <span class="s5">// https://github.com/vuejs/core/issues/4251</span>
        <span class="s2">if </span><span class="s1">(attr.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">attr.value &amp;&amp;</span>
            <span class="s1">attr.name === </span><span class="s3">'class'</span><span class="s1">) {</span>
            <span class="s1">attr.value.content = attr.value.content.replace(</span><span class="s4">/\s+/g</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">).trim()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s5">/* TagType.Start */</span><span class="s1">) {</span>
            <span class="s1">props.push(attr)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">/^[^\t\r\n\f /&gt;]/</span><span class="s1">.test(context.source)) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">15 </span><span class="s5">/* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">advanceSpaces(context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseAttribute(context</span><span class="s2">, </span><span class="s1">nameSet) {</span>
    <span class="s5">// Name.</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span><span class="s1">.exec(context.source)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">name = match[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nameSet.has(name)) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ErrorCodes.DUPLICATE_ATTRIBUTE */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">nameSet.add(name)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(name[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'='</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">19 </span><span class="s5">/* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
        <span class="s2">const </span><span class="s1">pattern = </span><span class="s4">/[&quot;'&lt;]/g</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">m</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">((m = pattern.exec(name))) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">17 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */</span><span class="s2">, </span><span class="s1">m.index)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">name.length)</span><span class="s2">;</span>
    <span class="s5">// Value</span>
    <span class="s2">let </span><span class="s1">value = undefined</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">/^[\t\r\n\f ]*=/</span><span class="s1">.test(context.source)) {</span>
        <span class="s1">advanceSpaces(context)</span><span class="s2">;</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">advanceSpaces(context)</span><span class="s2">;</span>
        <span class="s1">value = parseAttributeValue(context)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!value) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">13 </span><span class="s5">/* ErrorCodes.MISSING_ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">loc = getSelection(context</span><span class="s2">, </span><span class="s1">start)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!context.inVPre &amp;&amp; </span><span class="s4">/^(v-[A-Za-z0-9-]|:|\.|@|#)/</span><span class="s1">.test(name)) {</span>
        <span class="s2">const </span><span class="s1">match = </span><span class="s4">/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i</span><span class="s1">.exec(name)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">isPropShorthand = startsWith(name</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">dirName = match[</span><span class="s4">1</span><span class="s1">] ||</span>
            <span class="s1">(isPropShorthand || startsWith(name</span><span class="s2">, </span><span class="s3">':'</span><span class="s1">)</span>
                <span class="s1">? </span><span class="s3">'bind'</span>
                <span class="s1">: startsWith(name</span><span class="s2">, </span><span class="s3">'@'</span><span class="s1">)</span>
                    <span class="s1">? </span><span class="s3">'on'</span>
                    <span class="s1">: </span><span class="s3">'slot'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">arg</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(match[</span><span class="s4">2</span><span class="s1">]) {</span>
            <span class="s2">const </span><span class="s1">isSlot = dirName === </span><span class="s3">'slot'</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">startOffset = name.lastIndexOf(match[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">loc = getSelection(context</span><span class="s2">, </span><span class="s1">getNewPosition(context</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">startOffset)</span><span class="s2">, </span><span class="s1">getNewPosition(context</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">startOffset + match[</span><span class="s4">2</span><span class="s1">].length + ((isSlot &amp;&amp; match[</span><span class="s4">3</span><span class="s1">]) || </span><span class="s3">''</span><span class="s1">).length))</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">content = match[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">isStatic = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(content.startsWith(</span><span class="s3">'['</span><span class="s1">)) {</span>
                <span class="s1">isStatic = </span><span class="s2">false;</span>
                <span class="s2">if </span><span class="s1">(!content.endsWith(</span><span class="s3">']'</span><span class="s1">)) {</span>
                    <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">27 </span><span class="s5">/* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">content = content.slice(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">content.length - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isSlot) {</span>
                <span class="s5">// #1241 special case for v-slot: vuetify relies extensively on slot</span>
                <span class="s5">// names containing dots. v-slot doesn't have any modifiers and Vue 2.x</span>
                <span class="s5">// supports such usage so we are keeping it consistent with 2.x.</span>
                <span class="s1">content += match[</span><span class="s4">3</span><span class="s1">] || </span><span class="s3">''</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">arg = {</span>
                <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">,</span>
                <span class="s1">content</span><span class="s2">,</span>
                <span class="s1">isStatic</span><span class="s2">,</span>
                <span class="s1">constType: isStatic</span>
                    <span class="s1">? </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span>
                    <span class="s1">: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">,</span>
                <span class="s1">loc</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(value &amp;&amp; value.isQuoted) {</span>
            <span class="s2">const </span><span class="s1">valueLoc = value.loc</span><span class="s2">;</span>
            <span class="s1">valueLoc.start.offset++</span><span class="s2">;</span>
            <span class="s1">valueLoc.start.column++</span><span class="s2">;</span>
            <span class="s1">valueLoc.end = advancePositionWithClone(valueLoc.start</span><span class="s2">, </span><span class="s1">value.content)</span><span class="s2">;</span>
            <span class="s1">valueLoc.source = valueLoc.source.slice(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">modifiers = match[</span><span class="s4">3</span><span class="s1">] ? match[</span><span class="s4">3</span><span class="s1">].slice(</span><span class="s4">1</span><span class="s1">).split(</span><span class="s3">'.'</span><span class="s1">) : []</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isPropShorthand)</span>
            <span class="s1">modifiers.push(</span><span class="s3">'prop'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s2">,</span>
            <span class="s1">name: dirName</span><span class="s2">,</span>
            <span class="s1">exp: value &amp;&amp; {</span>
                <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">,</span>
                <span class="s1">content: value.content</span><span class="s2">,</span>
                <span class="s1">isStatic: </span><span class="s2">false,</span>
                <span class="s5">// Treat as non-constant by default. This can be potentially set to</span>
                <span class="s5">// other values by `transformExpression` to make it eligible for hoisting.</span>
                <span class="s1">constType: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">,</span>
                <span class="s1">loc: value.loc</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">arg</span><span class="s2">,</span>
            <span class="s1">modifiers</span><span class="s2">,</span>
            <span class="s1">loc</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// missing directive name or illegal directive name</span>
    <span class="s2">if </span><span class="s1">(!context.inVPre &amp;&amp; startsWith(name</span><span class="s2">, </span><span class="s3">'v-'</span><span class="s1">)) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">26 </span><span class="s5">/* ErrorCodes.X_MISSING_DIRECTIVE_NAME */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">,</span>
        <span class="s1">value: value &amp;&amp; {</span>
            <span class="s1">type: </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s2">,</span>
            <span class="s1">content: value.content</span><span class="s2">,</span>
            <span class="s1">loc: value.loc</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">loc</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseAttributeValue(context) {</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">content</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">quote = context.source[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isQuoted = quote === </span><span class="s3">`&quot;` </span><span class="s1">|| quote === </span><span class="s3">`'`</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isQuoted) {</span>
        <span class="s5">// Quoted value.</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">endIndex = context.source.indexOf(quote)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(endIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">content = parseTextData(context</span><span class="s2">, </span><span class="s1">context.source.length</span><span class="s2">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">content = parseTextData(context</span><span class="s2">, </span><span class="s1">endIndex</span><span class="s2">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// Unquoted</span>
        <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^[^\t\r\n\f &gt;]+/</span><span class="s1">.exec(context.source)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!match) {</span>
            <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">unexpectedChars = </span><span class="s4">/[&quot;'&lt;=`]/g</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">m</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">((m = unexpectedChars.exec(match[</span><span class="s4">0</span><span class="s1">]))) {</span>
            <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">18 </span><span class="s5">/* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */</span><span class="s2">, </span><span class="s1">m.index)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">content = parseTextData(context</span><span class="s2">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s2">, </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ content</span><span class="s2">, </span><span class="s1">isQuoted</span><span class="s2">, </span><span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start) }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseInterpolation(context</span><span class="s2">, </span><span class="s1">mode) {</span>
    <span class="s2">const </span><span class="s1">[open</span><span class="s2">, </span><span class="s1">close] = context.options.delimiters</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">closeIndex = context.source.indexOf(close</span><span class="s2">, </span><span class="s1">open.length)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(closeIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">emitError(context</span><span class="s2">, </span><span class="s4">25 </span><span class="s5">/* ErrorCodes.X_MISSING_INTERPOLATION_END */</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">open.length)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">innerStart = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">innerEnd = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawContentLength = closeIndex - open.length</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawContent = context.source.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rawContentLength)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">preTrimContent = parseTextData(context</span><span class="s2">, </span><span class="s1">rawContentLength</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">content = preTrimContent.trim()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">startOffset = preTrimContent.indexOf(content)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(startOffset &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">advancePositionWithMutation(innerStart</span><span class="s2">, </span><span class="s1">rawContent</span><span class="s2">, </span><span class="s1">startOffset)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</span><span class="s2">;</span>
    <span class="s1">advancePositionWithMutation(innerEnd</span><span class="s2">, </span><span class="s1">rawContent</span><span class="s2">, </span><span class="s1">endOffset)</span><span class="s2">;</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">close.length)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s2">,</span>
        <span class="s1">content: {</span>
            <span class="s1">type: </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s2">,</span>
            <span class="s1">isStatic: </span><span class="s2">false,</span>
            <span class="s5">// Set `isConstant` to false by default and will decide in transformExpression</span>
            <span class="s1">constType: </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">,</span>
            <span class="s1">content</span><span class="s2">,</span>
            <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">innerStart</span><span class="s2">, </span><span class="s1">innerEnd)</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseText(context</span><span class="s2">, </span><span class="s1">mode) {</span>
    <span class="s2">const </span><span class="s1">endTokens = mode === </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */ </span><span class="s1">? [</span><span class="s3">']]&gt;'</span><span class="s1">] : [</span><span class="s3">'&lt;'</span><span class="s2">, </span><span class="s1">context.options.delimiters[</span><span class="s4">0</span><span class="s1">]]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">endIndex = context.source.length</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; endTokens.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">index = context.source.indexOf(endTokens[i]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; endIndex &gt; index) {</span>
            <span class="s1">endIndex = index</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">start = getCursor(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">content = parseTextData(context</span><span class="s2">, </span><span class="s1">endIndex</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s2">,</span>
        <span class="s1">content</span><span class="s2">,</span>
        <span class="s1">loc: getSelection(context</span><span class="s2">, </span><span class="s1">start)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Get text data with a given length from the current location.</span>
 <span class="s0">* This translates HTML entities in the text data.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">parseTextData(context</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">mode) {</span>
    <span class="s2">const </span><span class="s1">rawText = context.source.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">length)</span><span class="s2">;</span>
    <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">length)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(mode === </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */ </span><span class="s1">||</span>
        <span class="s1">mode === </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */ </span><span class="s1">||</span>
        <span class="s1">!rawText.includes(</span><span class="s3">'&amp;'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">rawText</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.</span>
        <span class="s2">return </span><span class="s1">context.options.decodeEntities(rawText</span><span class="s2">, </span><span class="s1">mode === </span><span class="s4">4 </span><span class="s5">/* TextModes.ATTRIBUTE_VALUE */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCursor(context) {</span>
    <span class="s2">const </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">offset } = context</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{ column</span><span class="s2">, </span><span class="s1">line</span><span class="s2">, </span><span class="s1">offset }</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSelection(context</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
    <span class="s1">end = end || getCursor(context)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">start</span><span class="s2">,</span>
        <span class="s1">end</span><span class="s2">,</span>
        <span class="s1">source: context.originalSource.slice(start.offset</span><span class="s2">, </span><span class="s1">end.offset)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">last(xs) {</span>
    <span class="s2">return </span><span class="s1">xs[xs.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">startsWith(source</span><span class="s2">, </span><span class="s1">searchString) {</span>
    <span class="s2">return </span><span class="s1">source.startsWith(searchString)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">numberOfCharacters) {</span>
    <span class="s2">const </span><span class="s1">{ source } = context</span><span class="s2">;</span>
    <span class="s1">advancePositionWithMutation(context</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">numberOfCharacters)</span><span class="s2">;</span>
    <span class="s1">context.source = source.slice(numberOfCharacters)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">advanceSpaces(context) {</span>
    <span class="s2">const </span><span class="s1">match = </span><span class="s4">/^[\t\r\n\f ]+/</span><span class="s1">.exec(context.source)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(match) {</span>
        <span class="s1">advanceBy(context</span><span class="s2">, </span><span class="s1">match[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNewPosition(context</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">numberOfCharacters) {</span>
    <span class="s2">return </span><span class="s1">advancePositionWithClone(start</span><span class="s2">, </span><span class="s1">context.originalSource.slice(start.offset</span><span class="s2">, </span><span class="s1">numberOfCharacters)</span><span class="s2">, </span><span class="s1">numberOfCharacters)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emitError(context</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">loc = getCursor(context)) {</span>
    <span class="s2">if </span><span class="s1">(offset) {</span>
        <span class="s1">loc.offset += offset</span><span class="s2">;</span>
        <span class="s1">loc.column += offset</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">context.options.onError(createCompilerError(code</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">start: loc</span><span class="s2">,</span>
        <span class="s1">end: loc</span><span class="s2">,</span>
        <span class="s1">source: </span><span class="s3">''</span>
    <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isEnd(context</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">ancestors) {</span>
    <span class="s2">const </span><span class="s1">s = context.source</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(mode) {</span>
        <span class="s2">case </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(startsWith(s</span><span class="s2">, </span><span class="s3">'&lt;/'</span><span class="s1">)) {</span>
                <span class="s5">// TODO: probably bad performance</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = ancestors.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">--i) {</span>
                    <span class="s2">if </span><span class="s1">(startsWithEndTagOpen(s</span><span class="s2">, </span><span class="s1">ancestors[i].tag)) {</span>
                        <span class="s2">return true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */</span><span class="s1">: {</span>
            <span class="s2">const </span><span class="s1">parent = last(ancestors)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(parent &amp;&amp; startsWithEndTagOpen(s</span><span class="s2">, </span><span class="s1">parent.tag)) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* TextModes.CDATA */</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(startsWith(s</span><span class="s2">, </span><span class="s3">']]&gt;'</span><span class="s1">)) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">!s</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">startsWithEndTagOpen(source</span><span class="s2">, </span><span class="s1">tag) {</span>
    <span class="s2">return </span><span class="s1">(startsWith(source</span><span class="s2">, </span><span class="s3">'&lt;/'</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">source.slice(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ tag.length).toLowerCase() === tag.toLowerCase() &amp;&amp;</span>
        <span class="s4">/[\t\r\n\f /&gt;]/</span><span class="s1">.test(source[</span><span class="s4">2 </span><span class="s1">+ tag.length] || </span><span class="s3">'&gt;'</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">hoistStatic(root</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s1">walk(root</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span>
    <span class="s5">// Root node is unfortunately non-hoistable due to potential parent</span>
    <span class="s5">// fallthrough attributes.</span>
    <span class="s1">isSingleElementRoot(root</span><span class="s2">, </span><span class="s1">root.children[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSingleElementRoot(root</span><span class="s2">, </span><span class="s1">child) {</span>
    <span class="s2">const </span><span class="s1">{ children } = root</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
        <span class="s1">child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isSlotOutlet(child))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">walk(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">doNotHoistNode = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ children } = node</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">originalCount = children.length</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hoistedCount = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
        <span class="s5">// only plain elements &amp; text calls are eligible for hoisting.</span>
        <span class="s2">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">child.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">constantType = doNotHoistNode</span>
                <span class="s1">? </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span>
                <span class="s1">: getConstantType(child</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(constantType &gt; </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(constantType &gt;= </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                    <span class="s1">child.codegenNode.patchFlag =</span>
                        <span class="s1">-</span><span class="s4">1 </span><span class="s5">/* PatchFlags.HOISTED */ </span><span class="s1">+ (</span><span class="s3">` /* HOISTED */` </span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">child.codegenNode = context.hoist(child.codegenNode)</span><span class="s2">;</span>
                    <span class="s1">hoistedCount++</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// node may contain dynamic children, but its props may be eligible for</span>
                <span class="s5">// hoisting.</span>
                <span class="s2">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">((!flag ||</span>
                        <span class="s1">flag === </span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */ </span><span class="s1">||</span>
                        <span class="s1">flag === </span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">) &amp;&amp;</span>
                        <span class="s1">getGeneratedPropsConstantType(child</span><span class="s2">, </span><span class="s1">context) &gt;=</span>
                            <span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">) {</span>
                        <span class="s2">const </span><span class="s1">props = getNodeProps(child)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(props) {</span>
                            <span class="s1">codegenNode.props = context.hoist(props)</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(codegenNode.dynamicProps) {</span>
                        <span class="s1">codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// walk further</span>
        <span class="s2">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">isComponent = child.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isComponent) {</span>
                <span class="s1">context.scopes.vSlot++</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">walk(child</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isComponent) {</span>
                <span class="s1">context.scopes.vSlot--</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(child.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">) {</span>
            <span class="s5">// Do not hoist v-for single child because it has to be a block</span>
            <span class="s1">walk(child</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">child.children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(child.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; child.branches.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s5">// Do not hoist v-if single child because it has to be a block</span>
                <span class="s1">walk(child.branches[i]</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">child.branches[i].children.length === </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(hoistedCount &amp;&amp; context.transformHoist) {</span>
        <span class="s1">context.transformHoist(children</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// all children were hoisted - the entire children array is hoistable.</span>
    <span class="s2">if </span><span class="s1">(hoistedCount &amp;&amp;</span>
        <span class="s1">hoistedCount === originalCount &amp;&amp;</span>
        <span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.codegenNode &amp;&amp;</span>
        <span class="s1">node.codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">isArray(node.codegenNode.children)) {</span>
        <span class="s1">node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getConstantType(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ constantCache } = context</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(node.tagType !== </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">cached = constantCache.get(node)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(cached !== undefined) {</span>
                <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(codegenNode.type !== </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(codegenNode.isBlock &amp;&amp;</span>
                <span class="s1">node.tag !== </span><span class="s3">'svg' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">node.tag !== </span><span class="s3">'foreignObject'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">flag = getPatchFlag(codegenNode)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(!flag) {</span>
                <span class="s2">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s2">;</span>
                <span class="s5">// Element itself has no patch flag. However we still need to check:</span>
                <span class="s5">// 1. Even for a node with no patch flag, it is possible for it to contain</span>
                <span class="s5">// non-hoistable expressions that refers to scope variables, e.g. compiler</span>
                <span class="s5">// injected keys or cached event handlers. Therefore we need to always</span>
                <span class="s5">// check the codegenNode's props to be sure.</span>
                <span class="s2">const </span><span class="s1">generatedPropsType = getGeneratedPropsConstantType(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(generatedPropsType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(generatedPropsType &lt; returnType) {</span>
                    <span class="s1">returnType = generatedPropsType</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// 2. its children.</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">const </span><span class="s1">childType = getConstantType(node.children[i]</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                        <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(childType &lt; returnType) {</span>
                        <span class="s1">returnType = childType</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s5">// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0</span>
                <span class="s5">// type, check if any of the props can cause the type to be lowered</span>
                <span class="s5">// we can skip can_patch because it's guaranteed by the absence of a</span>
                <span class="s5">// patchFlag.</span>
                <span class="s2">if </span><span class="s1">(returnType &gt; </span><span class="s4">1 </span><span class="s5">/* ConstantTypes.CAN_SKIP_PATCH */</span><span class="s1">) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                        <span class="s2">const </span><span class="s1">p = node.props[i]</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp; p.exp) {</span>
                            <span class="s2">const </span><span class="s1">expType = getConstantType(p.exp</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                            <span class="s2">if </span><span class="s1">(expType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                                <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s2">;</span>
                                <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(expType &lt; returnType) {</span>
                                <span class="s1">returnType = expType</span><span class="s2">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s5">// only svg/foreignObject could be block here, however if they are</span>
                <span class="s5">// static then they don't need to be blocks since there will be no</span>
                <span class="s5">// nested updates.</span>
                <span class="s2">if </span><span class="s1">(codegenNode.isBlock) {</span>
                    <span class="s5">// except set custom directives.</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                        <span class="s2">const </span><span class="s1">p = node.props[i]</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                            <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">context.removeHelper(OPEN_BLOCK)</span><span class="s2">;</span>
                    <span class="s1">context.removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s2">, </span><span class="s1">codegenNode.isComponent))</span><span class="s2">;</span>
                    <span class="s1">codegenNode.isBlock = </span><span class="s2">false;</span>
                    <span class="s1">context.helper(getVNodeHelper(context.inSSR</span><span class="s2">, </span><span class="s1">codegenNode.isComponent))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s1">returnType)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">returnType</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">constantCache.set(node</span><span class="s2">, </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">getConstantType(node.content</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">node.constType</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
            <span class="s2">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">child = node.children[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isString(child) || isSymbol(child)) {</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">childType = getConstantType(child</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(childType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(childType &lt; returnType) {</span>
                    <span class="s1">returnType = childType</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">returnType</span><span class="s2">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">allowHoistedHelperSet = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">NORMALIZE_CLASS</span><span class="s2">,</span>
    <span class="s1">NORMALIZE_STYLE</span><span class="s2">,</span>
    <span class="s1">NORMALIZE_PROPS</span><span class="s2">,</span>
    <span class="s1">GUARD_REACTIVE_PROPS</span>
<span class="s1">])</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getConstantTypeOfHelperCall(value</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isString(value.callee) &amp;&amp;</span>
        <span class="s1">allowHoistedHelperSet.has(value.callee)) {</span>
        <span class="s2">const </span><span class="s1">arg = value.arguments[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">getConstantType(arg</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(arg.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s5">// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`</span>
            <span class="s2">return </span><span class="s1">getConstantTypeOfHelperCall(arg</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getGeneratedPropsConstantType(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">let </span><span class="s1">returnType = </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">props = getNodeProps(node)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(props &amp;&amp; props.type === </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ properties } = props</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; properties.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">{ key</span><span class="s2">, </span><span class="s1">value } = properties[i]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">keyType = getConstantType(key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(keyType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">keyType</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(keyType &lt; returnType) {</span>
                <span class="s1">returnType = keyType</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">valueType</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">valueType = getConstantType(value</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(value.type === </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s5">// some helper calls can be hoisted,</span>
                <span class="s5">// such as the `normalizeProps` generated by the compiler for pre-normalize class,</span>
                <span class="s5">// in this case we need to respect the ConstantType of the helper's arguments</span>
                <span class="s1">valueType = getConstantTypeOfHelperCall(value</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">valueType = </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(valueType === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">valueType</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(valueType &lt; returnType) {</span>
                <span class="s1">returnType = valueType</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">returnType</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getNodeProps(node) {</span>
    <span class="s2">const </span><span class="s1">codegenNode = node.codegenNode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">codegenNode.props</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPatchFlag(node) {</span>
    <span class="s2">const </span><span class="s1">flag = node.patchFlag</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">flag ? parseInt(flag</span><span class="s2">, </span><span class="s4">10</span><span class="s1">) : undefined</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">createTransformContext(root</span><span class="s2">, </span><span class="s1">{ filename = </span><span class="s3">''</span><span class="s2">, </span><span class="s1">prefixIdentifiers = </span><span class="s2">false, </span><span class="s1">hoistStatic = </span><span class="s2">false, </span><span class="s1">cacheHandlers = </span><span class="s2">false, </span><span class="s1">nodeTransforms = []</span><span class="s2">, </span><span class="s1">directiveTransforms = {}</span><span class="s2">, </span><span class="s1">transformHoist = </span><span class="s2">null, </span><span class="s1">isBuiltInComponent = NOOP</span><span class="s2">, </span><span class="s1">isCustomElement = NOOP</span><span class="s2">, </span><span class="s1">expressionPlugins = []</span><span class="s2">, </span><span class="s1">scopeId = </span><span class="s2">null, </span><span class="s1">slotted = </span><span class="s2">true, </span><span class="s1">ssr = </span><span class="s2">false, </span><span class="s1">inSSR = </span><span class="s2">false, </span><span class="s1">ssrCssVars = </span><span class="s3">``</span><span class="s2">, </span><span class="s1">bindingMetadata = EMPTY_OBJ</span><span class="s2">, </span><span class="s1">inline = </span><span class="s2">false, </span><span class="s1">isTS = </span><span class="s2">false, </span><span class="s1">onError = defaultOnError</span><span class="s2">, </span><span class="s1">onWarn = defaultOnWarn</span><span class="s2">, </span><span class="s1">compatConfig }) {</span>
    <span class="s2">const </span><span class="s1">nameMatch = filename.replace(</span><span class="s4">/\?.*$/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">context = {</span>
        <span class="s5">// options</span>
        <span class="s1">selfName: nameMatch &amp;&amp; capitalize(camelize(nameMatch[</span><span class="s4">1</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">prefixIdentifiers</span><span class="s2">,</span>
        <span class="s1">hoistStatic</span><span class="s2">,</span>
        <span class="s1">cacheHandlers</span><span class="s2">,</span>
        <span class="s1">nodeTransforms</span><span class="s2">,</span>
        <span class="s1">directiveTransforms</span><span class="s2">,</span>
        <span class="s1">transformHoist</span><span class="s2">,</span>
        <span class="s1">isBuiltInComponent</span><span class="s2">,</span>
        <span class="s1">isCustomElement</span><span class="s2">,</span>
        <span class="s1">expressionPlugins</span><span class="s2">,</span>
        <span class="s1">scopeId</span><span class="s2">,</span>
        <span class="s1">slotted</span><span class="s2">,</span>
        <span class="s1">ssr</span><span class="s2">,</span>
        <span class="s1">inSSR</span><span class="s2">,</span>
        <span class="s1">ssrCssVars</span><span class="s2">,</span>
        <span class="s1">bindingMetadata</span><span class="s2">,</span>
        <span class="s1">inline</span><span class="s2">,</span>
        <span class="s1">isTS</span><span class="s2">,</span>
        <span class="s1">onError</span><span class="s2">,</span>
        <span class="s1">onWarn</span><span class="s2">,</span>
        <span class="s1">compatConfig</span><span class="s2">,</span>
        <span class="s5">// state</span>
        <span class="s1">root</span><span class="s2">,</span>
        <span class="s1">helpers: </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">,</span>
        <span class="s1">components: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
        <span class="s1">directives: </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">,</span>
        <span class="s1">hoists: []</span><span class="s2">,</span>
        <span class="s1">imports: []</span><span class="s2">,</span>
        <span class="s1">constantCache: </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">,</span>
        <span class="s1">temps: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">cached: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">identifiers: Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">scopes: {</span>
            <span class="s1">vFor: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">vSlot: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">vPre: </span><span class="s4">0</span><span class="s2">,</span>
            <span class="s1">vOnce: </span><span class="s4">0</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">parent: </span><span class="s2">null,</span>
        <span class="s1">currentNode: root</span><span class="s2">,</span>
        <span class="s1">childIndex: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">inVOnce: </span><span class="s2">false,</span>
        <span class="s5">// methods</span>
        <span class="s1">helper(name) {</span>
            <span class="s2">const </span><span class="s1">count = context.helpers.get(name) || </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">context.helpers.set(name</span><span class="s2">, </span><span class="s1">count + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">name</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">removeHelper(name) {</span>
            <span class="s2">const </span><span class="s1">count = context.helpers.get(name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(count) {</span>
                <span class="s2">const </span><span class="s1">currentCount = count - </span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(!currentCount) {</span>
                    <span class="s1">context.helpers.delete(name)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">context.helpers.set(name</span><span class="s2">, </span><span class="s1">currentCount)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">helperString(name) {</span>
            <span class="s2">return </span><span class="s3">`_</span><span class="s1">${helperNameMap[context.helper(name)]}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">replaceNode(node) {</span>
            <span class="s5">/* istanbul ignore if */</span>
            <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(!context.currentNode) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Node being replaced is already removed.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!context.parent) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Cannot replace root node.`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">context.parent.children[context.childIndex] = context.currentNode = node</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">removeNode(node) {</span>
            <span class="s2">if </span><span class="s1">(!context.parent) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Cannot remove root node.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">list = context.parent.children</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">removalIndex = node</span>
                <span class="s1">? list.indexOf(node)</span>
                <span class="s1">: context.currentNode</span>
                    <span class="s1">? context.childIndex</span>
                    <span class="s1">: -</span><span class="s4">1</span><span class="s2">;</span>
            <span class="s5">/* istanbul ignore if */</span>
            <span class="s2">if </span><span class="s1">(removalIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`node being removed is not a child of current parent`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!node || node === context.currentNode) {</span>
                <span class="s5">// current node removed</span>
                <span class="s1">context.currentNode = </span><span class="s2">null;</span>
                <span class="s1">context.onNodeRemoved()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// sibling node removed</span>
                <span class="s2">if </span><span class="s1">(context.childIndex &gt; removalIndex) {</span>
                    <span class="s1">context.childIndex--</span><span class="s2">;</span>
                    <span class="s1">context.onNodeRemoved()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">context.parent.children.splice(removalIndex</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">onNodeRemoved: () =&gt; { }</span><span class="s2">,</span>
        <span class="s1">addIdentifiers(exp) {</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">removeIdentifiers(exp) {</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">hoist(exp) {</span>
            <span class="s2">if </span><span class="s1">(isString(exp))</span>
                <span class="s1">exp = createSimpleExpression(exp)</span><span class="s2">;</span>
            <span class="s1">context.hoists.push(exp)</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">identifier = createSimpleExpression(</span><span class="s3">`_hoisted_</span><span class="s1">${context.hoists.length}</span><span class="s3">`</span><span class="s2">, false, </span><span class="s1">exp.loc</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">identifier.hoisted = exp</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">identifier</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">cache(exp</span><span class="s2">, </span><span class="s1">isVNode = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">createCacheExpression(context.cached++</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">isVNode)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">transform(root</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">const </span><span class="s1">context = createTransformContext(root</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">traverseNode(root</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.hoistStatic) {</span>
        <span class="s1">hoistStatic(root</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!options.ssr) {</span>
        <span class="s1">createRootCodegen(root</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// finalize meta information</span>
    <span class="s1">root.helpers = </span><span class="s2">new </span><span class="s1">Set([...context.helpers.keys()])</span><span class="s2">;</span>
    <span class="s1">root.components = [...context.components]</span><span class="s2">;</span>
    <span class="s1">root.directives = [...context.directives]</span><span class="s2">;</span>
    <span class="s1">root.imports = context.imports</span><span class="s2">;</span>
    <span class="s1">root.hoists = context.hoists</span><span class="s2">;</span>
    <span class="s1">root.temps = context.temps</span><span class="s2">;</span>
    <span class="s1">root.cached = context.cached</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRootCodegen(root</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ helper } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ children } = root</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(children.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s5">// if the single child is an element, turn it into a block.</span>
        <span class="s2">if </span><span class="s1">(isSingleElementRoot(root</span><span class="s2">, </span><span class="s1">child) &amp;&amp; child.codegenNode) {</span>
            <span class="s5">// single element root is never hoisted so codegenNode will never be</span>
            <span class="s5">// SimpleExpressionNode</span>
            <span class="s2">const </span><span class="s1">codegenNode = child.codegenNode</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s1">makeBlock(codegenNode</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">root.codegenNode = codegenNode</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// - single &lt;slot/&gt;, IfNode, ForNode: already blocks.</span>
            <span class="s5">// - single text node: always patched.</span>
            <span class="s5">// root codegen falls through via genNode()</span>
            <span class="s1">root.codegenNode = child</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s5">// root has multiple nodes - return a fragment block.</span>
        <span class="s2">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s5">// check if the fragment actually contains a single valid child with</span>
        <span class="s5">// the rest being comments</span>
        <span class="s2">if </span><span class="s1">(children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">;</span>
            <span class="s1">patchFlagText += </span><span class="s3">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">root.codegenNode = createVNodeCall(context</span><span class="s2">, </span><span class="s1">helper(FRAGMENT)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">root.children</span><span class="s2">, </span><span class="s1">patchFlag + (</span><span class="s3">` /* </span><span class="s1">${patchFlagText} </span><span class="s3">*/` </span><span class="s1">)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true, </span><span class="s1">undefined</span><span class="s2">, false </span><span class="s5">/* isComponent */</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else ;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traverseChildren(parent</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nodeRemoved = () =&gt; {</span>
        <span class="s1">i--</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">; </span><span class="s1">i &lt; parent.children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = parent.children[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isString(child))</span>
            <span class="s2">continue;</span>
        <span class="s1">context.parent = parent</span><span class="s2">;</span>
        <span class="s1">context.childIndex = i</span><span class="s2">;</span>
        <span class="s1">context.onNodeRemoved = nodeRemoved</span><span class="s2">;</span>
        <span class="s1">traverseNode(child</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traverseNode(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s1">context.currentNode = node</span><span class="s2">;</span>
    <span class="s5">// apply transform plugins</span>
    <span class="s2">const </span><span class="s1">{ nodeTransforms } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exitFns = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; nodeTransforms.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">onExit = nodeTransforms[i](node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(onExit) {</span>
            <span class="s2">if </span><span class="s1">(isArray(onExit)) {</span>
                <span class="s1">exitFns.push(...onExit)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">exitFns.push(onExit)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!context.currentNode) {</span>
            <span class="s5">// node was removed</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// node may have been replaced</span>
            <span class="s1">node = context.currentNode</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(!context.ssr) {</span>
                <span class="s5">// inject import for the Comment symbol, which is needed for creating</span>
                <span class="s5">// comment nodes with `createVNode`</span>
                <span class="s1">context.helper(CREATE_COMMENT)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
            <span class="s5">// no need to traverse, but we need to inject toString helper</span>
            <span class="s2">if </span><span class="s1">(!context.ssr) {</span>
                <span class="s1">context.helper(TO_DISPLAY_STRING)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s5">// for container types, further traverse downwards</span>
        <span class="s2">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.branches.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s1">traverseNode(node.branches[i]</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */</span><span class="s1">:</span>
            <span class="s1">traverseChildren(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
    <span class="s1">}</span>
    <span class="s5">// exit transforms</span>
    <span class="s1">context.currentNode = node</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">i = exitFns.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(i--) {</span>
        <span class="s1">exitFns[i]()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStructuralDirectiveTransform(name</span><span class="s2">, </span><span class="s1">fn) {</span>
    <span class="s2">const </span><span class="s1">matches = isString(name)</span>
        <span class="s1">? (n) =&gt; n === name</span>
        <span class="s1">: (n) =&gt; name.test(n)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ props } = node</span><span class="s2">;</span>
            <span class="s5">// structural directive transforms are not concerned with slots</span>
            <span class="s5">// as they are handled separately in vSlot.ts</span>
            <span class="s2">if </span><span class="s1">(node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */ </span><span class="s1">&amp;&amp; props.some(isVSlot)) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">exitFns = []</span><span class="s2">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">prop = props[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(prop.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; matches(prop.name)) {</span>
                    <span class="s5">// structural directives are removed to avoid infinite recursion</span>
                    <span class="s5">// also we remove them *before* applying so that it can further</span>
                    <span class="s5">// traverse itself in case it moves the node around</span>
                    <span class="s1">props.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">i--</span><span class="s2">;</span>
                    <span class="s2">const </span><span class="s1">onExit = fn(node</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(onExit)</span>
                        <span class="s1">exitFns.push(onExit)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">exitFns</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">PURE_ANNOTATION = </span><span class="s3">`/*#__PURE__*/`</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">aliasHelper = (s) =&gt; </span><span class="s3">`</span><span class="s1">${helperNameMap[s]}</span><span class="s3">: _</span><span class="s1">${helperNameMap[s]}</span><span class="s3">`</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createCodegenContext(ast</span><span class="s2">, </span><span class="s1">{ mode = </span><span class="s3">'function'</span><span class="s2">, </span><span class="s1">prefixIdentifiers = mode === </span><span class="s3">'module'</span><span class="s2">, </span><span class="s1">sourceMap = </span><span class="s2">false, </span><span class="s1">filename = </span><span class="s3">`template.vue.html`</span><span class="s2">, </span><span class="s1">scopeId = </span><span class="s2">null, </span><span class="s1">optimizeImports = </span><span class="s2">false, </span><span class="s1">runtimeGlobalName = </span><span class="s3">`Vue`</span><span class="s2">, </span><span class="s1">runtimeModuleName = </span><span class="s3">`vue`</span><span class="s2">, </span><span class="s1">ssrRuntimeModuleName = </span><span class="s3">'vue/server-renderer'</span><span class="s2">, </span><span class="s1">ssr = </span><span class="s2">false, </span><span class="s1">isTS = </span><span class="s2">false, </span><span class="s1">inSSR = </span><span class="s2">false </span><span class="s1">}) {</span>
    <span class="s2">const </span><span class="s1">context = {</span>
        <span class="s1">mode</span><span class="s2">,</span>
        <span class="s1">prefixIdentifiers</span><span class="s2">,</span>
        <span class="s1">sourceMap</span><span class="s2">,</span>
        <span class="s1">filename</span><span class="s2">,</span>
        <span class="s1">scopeId</span><span class="s2">,</span>
        <span class="s1">optimizeImports</span><span class="s2">,</span>
        <span class="s1">runtimeGlobalName</span><span class="s2">,</span>
        <span class="s1">runtimeModuleName</span><span class="s2">,</span>
        <span class="s1">ssrRuntimeModuleName</span><span class="s2">,</span>
        <span class="s1">ssr</span><span class="s2">,</span>
        <span class="s1">isTS</span><span class="s2">,</span>
        <span class="s1">inSSR</span><span class="s2">,</span>
        <span class="s1">source: ast.loc.source</span><span class="s2">,</span>
        <span class="s1">code: </span><span class="s3">``</span><span class="s2">,</span>
        <span class="s1">column: </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">line: </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">offset: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">indentLevel: </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">pure: </span><span class="s2">false,</span>
        <span class="s1">map: undefined</span><span class="s2">,</span>
        <span class="s1">helper(key) {</span>
            <span class="s2">return </span><span class="s3">`_</span><span class="s1">${helperNameMap[key]}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">push(code</span><span class="s2">, </span><span class="s1">node) {</span>
            <span class="s1">context.code += code</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">indent() {</span>
            <span class="s1">newline(++context.indentLevel)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">deindent(withoutNewLine = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(withoutNewLine) {</span>
                <span class="s1">--context.indentLevel</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newline(--context.indentLevel)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">newline() {</span>
            <span class="s1">newline(context.indentLevel)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">newline(n) {</span>
        <span class="s1">context.push(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">`  `</span><span class="s1">.repeat(n))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">context</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generate(ast</span><span class="s2">, </span><span class="s1">options = {}) {</span>
    <span class="s2">const </span><span class="s1">context = createCodegenContext(ast</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.onContextCreated)</span>
        <span class="s1">options.onContextCreated(context)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ mode</span><span class="s2">, </span><span class="s1">push</span><span class="s2">, </span><span class="s1">prefixIdentifiers</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">deindent</span><span class="s2">, </span><span class="s1">newline</span><span class="s2">, </span><span class="s1">scopeId</span><span class="s2">, </span><span class="s1">ssr } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hasHelpers = helpers.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">useWithBlock = !prefixIdentifiers &amp;&amp; mode !== </span><span class="s3">'module'</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isSetupInlined = !</span><span class="s2">true ;</span>
    <span class="s5">// preambles</span>
    <span class="s5">// in setup() inline mode, the preamble is generated in a sub context</span>
    <span class="s5">// and returned separately.</span>
    <span class="s2">const </span><span class="s1">preambleContext = isSetupInlined</span>
        <span class="s1">? createCodegenContext(ast</span><span class="s2">, </span><span class="s1">options)</span>
        <span class="s1">: context</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">genFunctionPreamble(ast</span><span class="s2">, </span><span class="s1">preambleContext)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// enter render function</span>
    <span class="s2">const </span><span class="s1">functionName = ssr ? </span><span class="s3">`ssrRender` </span><span class="s1">: </span><span class="s3">`render`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">args = ssr ? [</span><span class="s3">'_ctx'</span><span class="s2">, </span><span class="s3">'_push'</span><span class="s2">, </span><span class="s3">'_parent'</span><span class="s2">, </span><span class="s3">'_attrs'</span><span class="s1">] : [</span><span class="s3">'_ctx'</span><span class="s2">, </span><span class="s3">'_cache'</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">signature = args.join(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">push(</span><span class="s3">`function </span><span class="s1">${functionName}</span><span class="s3">(</span><span class="s1">${signature}</span><span class="s3">) {`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">indent()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(useWithBlock) {</span>
        <span class="s1">push(</span><span class="s3">`with (_ctx) {`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">indent()</span><span class="s2">;</span>
        <span class="s5">// function mode const declarations should be inside with block</span>
        <span class="s5">// also they should be renamed to avoid collision with user properties</span>
        <span class="s2">if </span><span class="s1">(hasHelpers) {</span>
            <span class="s1">push(</span><span class="s3">`const { </span><span class="s1">${helpers.map(aliasHelper).join(</span><span class="s3">', '</span><span class="s1">)} </span><span class="s3">} = _Vue`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">push(</span><span class="s3">`</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// generate asset resolution statements</span>
    <span class="s2">if </span><span class="s1">(ast.components.length) {</span>
        <span class="s1">genAssets(ast.components</span><span class="s2">, </span><span class="s3">'component'</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(ast.directives.length || ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ast.directives.length) {</span>
        <span class="s1">genAssets(ast.directives</span><span class="s2">, </span><span class="s3">'directive'</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ast.temps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">push(</span><span class="s3">`let `</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; ast.temps</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s1">push(</span><span class="s3">`</span><span class="s1">${i &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`, ` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">_temp</span><span class="s1">${i}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ast.components.length || ast.directives.length || ast.temps) {</span>
        <span class="s1">push(</span><span class="s3">`</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">newline()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// generate the VNode tree expression</span>
    <span class="s2">if </span><span class="s1">(!ssr) {</span>
        <span class="s1">push(</span><span class="s3">`return `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ast.codegenNode) {</span>
        <span class="s1">genNode(ast.codegenNode</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s3">`null`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(useWithBlock) {</span>
        <span class="s1">deindent()</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`}`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deindent()</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`}`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">ast</span><span class="s2">,</span>
        <span class="s1">code: context.code</span><span class="s2">,</span>
        <span class="s1">preamble: isSetupInlined ? preambleContext.code : </span><span class="s3">``</span><span class="s2">,</span>
        <span class="s5">// SourceMapGenerator does have toJSON() method but it's not in the types</span>
        <span class="s1">map: context.map ? context.map.toJSON() : undefined</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genFunctionPreamble(ast</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ ssr</span><span class="s2">, </span><span class="s1">prefixIdentifiers</span><span class="s2">, </span><span class="s1">push</span><span class="s2">, </span><span class="s1">newline</span><span class="s2">, </span><span class="s1">runtimeModuleName</span><span class="s2">, </span><span class="s1">runtimeGlobalName</span><span class="s2">, </span><span class="s1">ssrRuntimeModuleName } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">VueBinding = runtimeGlobalName</span><span class="s2">;</span>
    <span class="s5">// Generate const declaration for helpers</span>
    <span class="s5">// In prefix mode, we place the const declaration at top so it's done</span>
    <span class="s5">// only once; But if we not prefixing, we place the declaration inside the</span>
    <span class="s5">// with block so it doesn't incur the `in` check cost for every helper access.</span>
    <span class="s2">const </span><span class="s1">helpers = Array.from(ast.helpers)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(helpers.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">{</span>
            <span class="s5">// &quot;with&quot; mode.</span>
            <span class="s5">// save Vue in a separate variable to avoid collision</span>
            <span class="s1">push(</span><span class="s3">`const _Vue = </span><span class="s1">${VueBinding}</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s5">// in &quot;with&quot; mode, helpers are declared inside the with block to avoid</span>
            <span class="s5">// has check cost, but hoists are lifted out of the function - we need</span>
            <span class="s5">// to provide the helper here.</span>
            <span class="s2">if </span><span class="s1">(ast.hoists.length) {</span>
                <span class="s2">const </span><span class="s1">staticHelpers = [</span>
                    <span class="s1">CREATE_VNODE</span><span class="s2">,</span>
                    <span class="s1">CREATE_ELEMENT_VNODE</span><span class="s2">,</span>
                    <span class="s1">CREATE_COMMENT</span><span class="s2">,</span>
                    <span class="s1">CREATE_TEXT</span><span class="s2">,</span>
                    <span class="s1">CREATE_STATIC</span>
                <span class="s1">]</span>
                    <span class="s1">.filter(helper =&gt; helpers.includes(helper))</span>
                    <span class="s1">.map(aliasHelper)</span>
                    <span class="s1">.join(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">push(</span><span class="s3">`const { </span><span class="s1">${staticHelpers} </span><span class="s3">} = _Vue</span><span class="s2">\n</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">genHoists(ast.hoists</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">newline()</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`return `</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genAssets(assets</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">{ helper</span><span class="s2">, </span><span class="s1">push</span><span class="s2">, </span><span class="s1">newline</span><span class="s2">, </span><span class="s1">isTS }) {</span>
    <span class="s2">const </span><span class="s1">resolver = helper(type === </span><span class="s3">'component'</span>
            <span class="s1">? RESOLVE_COMPONENT</span>
            <span class="s1">: RESOLVE_DIRECTIVE)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; assets.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">let </span><span class="s1">id = assets[i]</span><span class="s2">;</span>
        <span class="s5">// potential component implicit self-reference inferred from SFC filename</span>
        <span class="s2">const </span><span class="s1">maybeSelfReference = id.endsWith(</span><span class="s3">'__self'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(maybeSelfReference) {</span>
            <span class="s1">id = id.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">push(</span><span class="s3">`const </span><span class="s1">${toValidAssetId(id</span><span class="s2">, </span><span class="s1">type)} </span><span class="s3">= </span><span class="s1">${resolver}</span><span class="s3">(</span><span class="s1">${JSON.stringify(id)}${maybeSelfReference ? </span><span class="s3">`, true` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">)</span><span class="s1">${isTS ? </span><span class="s3">`!` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(i &lt; assets.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genHoists(hoists</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">if </span><span class="s1">(!hoists.length) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">context.pure = </span><span class="s2">true;</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">newline</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">scopeId</span><span class="s2">, </span><span class="s1">mode } = context</span><span class="s2">;</span>
    <span class="s1">newline()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; hoists.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">exp = hoists[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exp) {</span>
            <span class="s1">push(</span><span class="s3">`const _hoisted_</span><span class="s1">${i + </span><span class="s4">1</span><span class="s1">} </span><span class="s3">= </span><span class="s1">${</span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">genNode(exp</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">context.pure = </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isText(n) {</span>
    <span class="s2">return </span><span class="s1">(isString(n) ||</span>
        <span class="s1">n.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
        <span class="s1">n.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genNodeListAsArray(nodes</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">multilines = nodes.length &gt; </span><span class="s4">3 </span><span class="s1">||</span>
        <span class="s1">(nodes.some(n =&gt; isArray(n) || !isText(n)))</span><span class="s2">;</span>
    <span class="s1">context.push(</span><span class="s3">`[`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">multilines &amp;&amp; context.indent()</span><span class="s2">;</span>
    <span class="s1">genNodeList(nodes</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">multilines)</span><span class="s2">;</span>
    <span class="s1">multilines &amp;&amp; context.deindent()</span><span class="s2">;</span>
    <span class="s1">context.push(</span><span class="s3">`]`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genNodeList(nodes</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">multilines = </span><span class="s2">false, </span><span class="s1">comma = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">newline } = context</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; nodes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">node = nodes[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isString(node)) {</span>
            <span class="s1">push(node)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isArray(node)) {</span>
            <span class="s1">genNodeListAsArray(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">genNode(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(i &lt; nodes.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(multilines) {</span>
                <span class="s1">comma &amp;&amp; push(</span><span class="s3">','</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">newline()</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">comma &amp;&amp; push(</span><span class="s3">', '</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genNode(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">if </span><span class="s1">(isString(node)) {</span>
        <span class="s1">context.push(node)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isSymbol(node)) {</span>
        <span class="s1">context.push(context.helper(node))</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
            <span class="s1">assert(node.codegenNode != </span><span class="s2">null, </span><span class="s3">`Codegen node is missing for element/if/for node. ` </span><span class="s1">+</span>
                    <span class="s3">`Apply appropriate transforms first.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">genNode(node.codegenNode</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">:</span>
            <span class="s1">genText(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">:</span>
            <span class="s1">genInterpolation(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">:</span>
            <span class="s1">genNode(node.codegenNode</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCompoundExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">:</span>
            <span class="s1">genComment(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">:</span>
            <span class="s1">genVNodeCall(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCallExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genObjectExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genArrayExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">18 </span><span class="s5">/* NodeTypes.JS_FUNCTION_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genFunctionExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genConditionalExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s1">genCacheExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">21 </span><span class="s5">/* NodeTypes.JS_BLOCK_STATEMENT */</span><span class="s1">:</span>
            <span class="s1">genNodeList(node.body</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s5">// SSR only types</span>
        <span class="s2">case </span><span class="s4">22 </span><span class="s5">/* NodeTypes.JS_TEMPLATE_LITERAL */</span><span class="s1">:</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">23 </span><span class="s5">/* NodeTypes.JS_IF_STATEMENT */</span><span class="s1">:</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">24 </span><span class="s5">/* NodeTypes.JS_ASSIGNMENT_EXPRESSION */</span><span class="s1">:</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">25 </span><span class="s5">/* NodeTypes.JS_SEQUENCE_EXPRESSION */</span><span class="s1">:</span>
            <span class="s2">break;</span>
        <span class="s2">case </span><span class="s4">26 </span><span class="s5">/* NodeTypes.JS_RETURN_STATEMENT */</span><span class="s1">:</span>
            <span class="s2">break;</span>
        <span class="s5">/* istanbul ignore next */</span>
        <span class="s2">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s5">// noop</span>
            <span class="s2">break;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s1">assert(</span><span class="s2">false, </span><span class="s3">`unhandled codegen node type: </span><span class="s1">${node.type}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s5">// make sure we exhaust all possible types</span>
                <span class="s2">const </span><span class="s1">exhaustiveCheck = node</span><span class="s2">;</span>
                <span class="s2">return </span><span class="s1">exhaustiveCheck</span><span class="s2">;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genText(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s1">context.push(JSON.stringify(node.content)</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ content</span><span class="s2">, </span><span class="s1">isStatic } = node</span><span class="s2">;</span>
    <span class="s1">context.push(isStatic ? JSON.stringify(content) : content</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genInterpolation(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">pure } = context</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pure)</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`</span><span class="s1">${helper(TO_DISPLAY_STRING)}</span><span class="s3">(`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">genNode(node.content</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genCompoundExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = node.children[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isString(child)) {</span>
            <span class="s1">context.push(child)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">genNode(child</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genExpressionAsPropertyKey(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push } = context</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">push(</span><span class="s3">`[`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">genCompoundExpression(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`]`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(node.isStatic) {</span>
        <span class="s5">// only quote keys if necessary</span>
        <span class="s2">const </span><span class="s1">text = isSimpleIdentifier(node.content)</span>
            <span class="s1">? node.content</span>
            <span class="s1">: JSON.stringify(node.content)</span><span class="s2">;</span>
        <span class="s1">push(text</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s3">`[</span><span class="s1">${node.content}</span><span class="s3">]`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genComment(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">pure } = context</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s3">`</span><span class="s1">${helper(CREATE_COMMENT)}</span><span class="s3">(</span><span class="s1">${JSON.stringify(node.content)}</span><span class="s3">)`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genVNodeCall(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">pure } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ tag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">directives</span><span class="s2">, </span><span class="s1">isBlock</span><span class="s2">, </span><span class="s1">disableTracking</span><span class="s2">, </span><span class="s1">isComponent } = node</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(directives) {</span>
        <span class="s1">push(helper(WITH_DIRECTIVES) + </span><span class="s3">`(`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBlock) {</span>
        <span class="s1">push(</span><span class="s3">`(</span><span class="s1">${helper(OPEN_BLOCK)}</span><span class="s3">(</span><span class="s1">${disableTracking ? </span><span class="s3">`true` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">), `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">callHelper = isBlock</span>
        <span class="s1">? getVNodeBlockHelper(context.inSSR</span><span class="s2">, </span><span class="s1">isComponent)</span>
        <span class="s1">: getVNodeHelper(context.inSSR</span><span class="s2">, </span><span class="s1">isComponent)</span><span class="s2">;</span>
    <span class="s1">push(helper(callHelper) + </span><span class="s3">`(`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s1">genNodeList(genNullableArgs([tag</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps])</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isBlock) {</span>
        <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(directives) {</span>
        <span class="s1">push(</span><span class="s3">`, `</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">genNode(directives</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genNullableArgs(args) {</span>
    <span class="s2">let </span><span class="s1">i = args.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(i--) {</span>
        <span class="s2">if </span><span class="s1">(args[i] != </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">break;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">args.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">).map(arg =&gt; arg || </span><span class="s3">`null`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// JavaScript</span>
<span class="s2">function </span><span class="s1">genCallExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">pure } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">callee = isString(node.callee) ? node.callee : helper(node.callee)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(pure) {</span>
        <span class="s1">push(PURE_ANNOTATION)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(callee + </span><span class="s3">`(`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s1">genNodeList(node.arguments</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genObjectExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">deindent</span><span class="s2">, </span><span class="s1">newline } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ properties } = node</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!properties.length) {</span>
        <span class="s1">push(</span><span class="s3">`{}`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">multilines = properties.length &gt; </span><span class="s4">1 </span><span class="s1">||</span>
        <span class="s1">(properties.some(p =&gt; p.value.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">push(multilines ? </span><span class="s3">`{` </span><span class="s1">: </span><span class="s3">`{ `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">multilines &amp;&amp; indent()</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; properties.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">{ key</span><span class="s2">, </span><span class="s1">value } = properties[i]</span><span class="s2">;</span>
        <span class="s5">// key</span>
        <span class="s1">genExpressionAsPropertyKey(key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`: `</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s5">// value</span>
        <span class="s1">genNode(value</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(i &lt; properties.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s5">// will only reach this if it's multilines</span>
            <span class="s1">push(</span><span class="s3">`,`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">multilines &amp;&amp; deindent()</span><span class="s2">;</span>
    <span class="s1">push(multilines ? </span><span class="s3">`}` </span><span class="s1">: </span><span class="s3">` }`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genArrayExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s1">genNodeListAsArray(node.elements</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genFunctionExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">deindent } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ params</span><span class="s2">, </span><span class="s1">returns</span><span class="s2">, </span><span class="s1">body</span><span class="s2">, </span><span class="s1">newline</span><span class="s2">, </span><span class="s1">isSlot } = node</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isSlot) {</span>
        <span class="s5">// wrap slot functions with owner context</span>
        <span class="s1">push(</span><span class="s3">`_</span><span class="s1">${helperNameMap[WITH_CTX]}</span><span class="s3">(`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s3">`(`</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(params)) {</span>
        <span class="s1">genNodeList(params</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(params) {</span>
        <span class="s1">genNode(params</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s3">`) =&gt; `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(newline || body) {</span>
        <span class="s1">push(</span><span class="s3">`{`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">indent()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(returns) {</span>
        <span class="s2">if </span><span class="s1">(newline) {</span>
            <span class="s1">push(</span><span class="s3">`return `</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isArray(returns)) {</span>
            <span class="s1">genNodeListAsArray(returns</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">genNode(returns</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(body) {</span>
        <span class="s1">genNode(body</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(newline || body) {</span>
        <span class="s1">deindent()</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`}`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isSlot) {</span>
        <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genConditionalExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ test</span><span class="s2">, </span><span class="s1">consequent</span><span class="s2">, </span><span class="s1">alternate</span><span class="s2">, </span><span class="s1">newline: needNewline } = node</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">deindent</span><span class="s2">, </span><span class="s1">newline } = context</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(test.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">needsParens = !isSimpleIdentifier(test.content)</span><span class="s2">;</span>
        <span class="s1">needsParens &amp;&amp; push(</span><span class="s3">`(`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">genExpression(test</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">needsParens &amp;&amp; push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">push(</span><span class="s3">`(`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">genNode(test</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">needNewline &amp;&amp; indent()</span><span class="s2">;</span>
    <span class="s1">context.indentLevel++</span><span class="s2">;</span>
    <span class="s1">needNewline || push(</span><span class="s3">` `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`? `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">genNode(consequent</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">context.indentLevel--</span><span class="s2">;</span>
    <span class="s1">needNewline &amp;&amp; newline()</span><span class="s2">;</span>
    <span class="s1">needNewline || push(</span><span class="s3">` `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`: `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isNested = alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isNested) {</span>
        <span class="s1">context.indentLevel++</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">genNode(alternate</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isNested) {</span>
        <span class="s1">context.indentLevel--</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">needNewline &amp;&amp; deindent(</span><span class="s2">true </span><span class="s5">/* without newline */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">genCacheExpression(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ push</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">deindent</span><span class="s2">, </span><span class="s1">newline } = context</span><span class="s2">;</span>
    <span class="s1">push(</span><span class="s3">`_cache[</span><span class="s1">${node.index}</span><span class="s3">] || (`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.isVNode) {</span>
        <span class="s1">indent()</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s3">(-1),`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">newline()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s3">`_cache[</span><span class="s1">${node.index}</span><span class="s3">] = `</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">genNode(node.value</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(node.isVNode) {</span>
        <span class="s1">push(</span><span class="s3">`,`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`</span><span class="s1">${helper(SET_BLOCK_TRACKING)}</span><span class="s3">(1),`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">newline()</span><span class="s2">;</span>
        <span class="s1">push(</span><span class="s3">`_cache[</span><span class="s1">${node.index}</span><span class="s3">]`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">deindent()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// these keywords should not appear inside expressions, but operators like</span>
<span class="s5">// 'typeof', 'instanceof', and 'in' are allowed</span>
<span class="s2">const </span><span class="s1">prohibitedKeywordRE = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">b' </span><span class="s1">+</span>
    <span class="s1">(</span><span class="s3">'arguments,await,break,case,catch,class,const,continue,debugger,default,' </span><span class="s1">+</span>
        <span class="s3">'delete,do,else,export,extends,finally,for,function,if,import,let,new,' </span><span class="s1">+</span>
        <span class="s3">'return,super,switch,throw,try,var,void,while,with,yield'</span><span class="s1">)</span>
        <span class="s1">.split(</span><span class="s3">','</span><span class="s1">)</span>
        <span class="s1">.join(</span><span class="s3">'</span><span class="s2">\\</span><span class="s3">b|</span><span class="s2">\\</span><span class="s3">b'</span><span class="s1">) +</span>
    <span class="s3">'</span><span class="s2">\\</span><span class="s3">b'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// strip strings in expressions</span>
<span class="s2">const </span><span class="s1">stripStringRE = </span><span class="s4">/'(?:[^'\\]|\\.)*'|&quot;(?:[^&quot;\\]|\\.)*&quot;|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g</span><span class="s2">;</span>
<span class="s0">/**</span>
 <span class="s0">* Validate a non-prefixed expression.</span>
 <span class="s0">* This is only called when using the in-browser runtime compiler since it</span>
 <span class="s0">* doesn't prefix expressions.</span>
 <span class="s0">*/</span>
<span class="s2">function </span><span class="s1">validateBrowserExpression(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">asParams = </span><span class="s2">false, </span><span class="s1">asRawStatements = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">exp = node.content</span><span class="s2">;</span>
    <span class="s5">// empty expressions are validated per-directive since some directives</span>
    <span class="s5">// do allow empty expressions.</span>
    <span class="s2">if </span><span class="s1">(!exp.trim()) {</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">new </span><span class="s1">Function(asRawStatements</span>
            <span class="s1">? </span><span class="s3">` </span><span class="s1">${exp} </span><span class="s3">`</span>
            <span class="s1">: </span><span class="s3">`return </span><span class="s1">${asParams ? </span><span class="s3">`(</span><span class="s1">${exp}</span><span class="s3">) =&gt; {}` </span><span class="s1">: </span><span class="s3">`(</span><span class="s1">${exp}</span><span class="s3">)`</span><span class="s1">}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">let </span><span class="s1">message = e.message</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keywordMatch = exp</span>
            <span class="s1">.replace(stripStringRE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">.match(prohibitedKeywordRE)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(keywordMatch) {</span>
            <span class="s1">message = </span><span class="s3">`avoid using JavaScript keyword as property name: &quot;</span><span class="s1">${keywordMatch[</span><span class="s4">0</span><span class="s1">]}</span><span class="s3">&quot;`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">45 </span><span class="s5">/* ErrorCodes.X_INVALID_EXPRESSION */</span><span class="s2">, </span><span class="s1">node.loc</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">message))</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">transformExpression = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */</span><span class="s1">) {</span>
        <span class="s1">node.content = processExpression(node.content</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s5">// handle directives on element</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">dir = node.props[i]</span><span class="s2">;</span>
            <span class="s5">// do not process for v-on &amp; v-for since they are special handled</span>
            <span class="s2">if </span><span class="s1">(dir.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; dir.name !== </span><span class="s3">'for'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">exp = dir.exp</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">arg = dir.arg</span><span class="s2">;</span>
                <span class="s5">// do not process exp if this is v-on:arg - we need special handling</span>
                <span class="s5">// for wrapping inline statements.</span>
                <span class="s2">if </span><span class="s1">(exp &amp;&amp;</span>
                    <span class="s1">exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!(dir.name === </span><span class="s3">'on' </span><span class="s1">&amp;&amp; arg)) {</span>
                    <span class="s1">dir.exp = processExpression(exp</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span>
                    <span class="s5">// slot args must be processed as function params</span>
                    <span class="s1">dir.name === </span><span class="s3">'slot'</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(arg &amp;&amp; arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !arg.isStatic) {</span>
                    <span class="s1">dir.arg = processExpression(arg</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s5">// Important: since this function uses Node.js only dependencies, it should</span>
<span class="s5">// always be used with a leading !true check so that it can be</span>
<span class="s5">// tree-shaken from the browser build.</span>
<span class="s2">function </span><span class="s1">processExpression(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span>
<span class="s5">// some expressions like v-slot props &amp; v-for aliases should be parsed as</span>
<span class="s5">// function params</span>
<span class="s1">asParams = </span><span class="s2">false, </span>
<span class="s5">// v-on handler values may contain multiple statements</span>
<span class="s1">asRawStatements = </span><span class="s2">false, </span><span class="s1">localVars = Object.create(context.identifiers)) {</span>
    <span class="s1">{</span>
        <span class="s1">{</span>
            <span class="s5">// simple in-browser validation (same logic in 2.x)</span>
            <span class="s1">validateBrowserExpression(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">asParams</span><span class="s2">, </span><span class="s1">asRawStatements)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">transformIf = createStructuralDirectiveTransform(</span><span class="s4">/^(if|else|else-if)$/</span><span class="s2">, </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">return </span><span class="s1">processIf(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">(ifNode</span><span class="s2">, </span><span class="s1">branch</span><span class="s2">, </span><span class="s1">isRoot) =&gt; {</span>
        <span class="s5">// #1587: We need to dynamically increment the key based on the current</span>
        <span class="s5">// node's sibling nodes, since chained v-if/else branches are</span>
        <span class="s5">// rendered at the same depth</span>
        <span class="s2">const </span><span class="s1">siblings = context.parent.children</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">i = siblings.indexOf(ifNode)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">key = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(i-- &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">sibling = siblings[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
                <span class="s1">key += sibling.branches.length</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// Exit callback. Complete the codegenNode when all children have been</span>
        <span class="s5">// transformed.</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(isRoot) {</span>
                <span class="s1">ifNode.codegenNode = createCodegenNodeForBranch(branch</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// attach this branch's codegen node to the v-if root.</span>
                <span class="s2">const </span><span class="s1">parentCondition = getParentCondition(ifNode.codegenNode)</span><span class="s2">;</span>
                <span class="s1">parentCondition.alternate = createCodegenNodeForBranch(branch</span><span class="s2">, </span><span class="s1">key + ifNode.branches.length - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s5">// target-agnostic transform used for both Client and SSR</span>
<span class="s2">function </span><span class="s1">processIf(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">processCodegen) {</span>
    <span class="s2">if </span><span class="s1">(dir.name !== </span><span class="s3">'else' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(!dir.exp || !dir.exp.content.trim())) {</span>
        <span class="s2">const </span><span class="s1">loc = dir.exp ? dir.exp.loc : node.loc</span><span class="s2">;</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">28 </span><span class="s5">/* ErrorCodes.X_V_IF_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
        <span class="s1">dir.exp = createSimpleExpression(</span><span class="s3">`true`</span><span class="s2">, false, </span><span class="s1">loc)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dir.exp) {</span>
        <span class="s1">validateBrowserExpression(dir.exp</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dir.name === </span><span class="s3">'if'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">branch = createIfBranch(node</span><span class="s2">, </span><span class="s1">dir)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">ifNode = {</span>
            <span class="s1">type: </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s2">,</span>
            <span class="s1">loc: node.loc</span><span class="s2">,</span>
            <span class="s1">branches: [branch]</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">context.replaceNode(ifNode)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(processCodegen) {</span>
            <span class="s2">return </span><span class="s1">processCodegen(ifNode</span><span class="s2">, </span><span class="s1">branch</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// locate the adjacent v-if</span>
        <span class="s2">const </span><span class="s1">siblings = context.parent.children</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">comments = []</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">i = siblings.indexOf(node)</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(i-- &gt;= -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">sibling = siblings[i]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                <span class="s1">context.removeNode(sibling)</span><span class="s2">;</span>
                <span class="s1">comments.unshift(sibling)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(sibling &amp;&amp;</span>
                <span class="s1">sibling.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!sibling.content.trim().length) {</span>
                <span class="s1">context.removeNode(sibling)</span><span class="s2">;</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(sibling &amp;&amp; sibling.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">) {</span>
                <span class="s5">// Check if v-else was followed by v-else-if</span>
                <span class="s2">if </span><span class="s1">(dir.name === </span><span class="s3">'else-if' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">sibling.branches[sibling.branches.length - </span><span class="s4">1</span><span class="s1">].condition === undefined) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s2">, </span><span class="s1">node.loc))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// move the node to the if node's branches</span>
                <span class="s1">context.removeNode()</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">branch = createIfBranch(node</span><span class="s2">, </span><span class="s1">dir)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(comments.length &amp;&amp;</span>
                    <span class="s5">// #3619 ignore comments if the v-if is direct child of &lt;transition&gt;</span>
                    <span class="s1">!(context.parent &amp;&amp;</span>
                        <span class="s1">context.parent.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">isBuiltInType(context.parent.tag</span><span class="s2">, </span><span class="s3">'transition'</span><span class="s1">))) {</span>
                    <span class="s1">branch.children = [...comments</span><span class="s2">, </span><span class="s1">...branch.children]</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// check if user is forcing same key on different branches</span>
                <span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">key = branch.userKey</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(key) {</span>
                        <span class="s1">sibling.branches.forEach(({ userKey }) =&gt; {</span>
                            <span class="s2">if </span><span class="s1">(isSameKey(userKey</span><span class="s2">, </span><span class="s1">key)) {</span>
                                <span class="s1">context.onError(createCompilerError(</span><span class="s4">29 </span><span class="s5">/* ErrorCodes.X_V_IF_SAME_KEY */</span><span class="s2">, </span><span class="s1">branch.userKey.loc))</span><span class="s2">;</span>
                            <span class="s1">}</span>
                        <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">sibling.branches.push(branch)</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(sibling</span><span class="s2">, </span><span class="s1">branch</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s5">// since the branch was removed, it will not be traversed.</span>
                <span class="s5">// make sure to traverse here.</span>
                <span class="s1">traverseNode(branch</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s5">// call on exit</span>
                <span class="s2">if </span><span class="s1">(onExit)</span>
                    <span class="s1">onExit()</span><span class="s2">;</span>
                <span class="s5">// make sure to reset currentNode after traversal to indicate this</span>
                <span class="s5">// node has been removed.</span>
                <span class="s1">context.currentNode = </span><span class="s2">null;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s2">, </span><span class="s1">node.loc))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createIfBranch(node</span><span class="s2">, </span><span class="s1">dir) {</span>
    <span class="s2">const </span><span class="s1">isTemplateIf = node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">type: </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s2">,</span>
        <span class="s1">loc: node.loc</span><span class="s2">,</span>
        <span class="s1">condition: dir.name === </span><span class="s3">'else' </span><span class="s1">? undefined : dir.exp</span><span class="s2">,</span>
        <span class="s1">children: isTemplateIf &amp;&amp; !findDir(node</span><span class="s2">, </span><span class="s3">'for'</span><span class="s1">) ? node.children : [node]</span><span class="s2">,</span>
        <span class="s1">userKey: findProp(node</span><span class="s2">, </span><span class="s3">`key`</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">isTemplateIf</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCodegenNodeForBranch(branch</span><span class="s2">, </span><span class="s1">keyIndex</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">if </span><span class="s1">(branch.condition) {</span>
        <span class="s2">return </span><span class="s1">createConditionalExpression(branch.condition</span><span class="s2">, </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s2">, </span><span class="s1">keyIndex</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">, </span>
        <span class="s5">// make sure to pass in asBlock: true so that the comment node call</span>
        <span class="s5">// closes the current block.</span>
        <span class="s1">createCallExpression(context.helper(CREATE_COMMENT)</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s3">'&quot;v-if&quot;' </span><span class="s2">,</span>
            <span class="s3">'true'</span>
        <span class="s1">]))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s2">, </span><span class="s1">keyIndex</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createChildrenCodegenNode(branch</span><span class="s2">, </span><span class="s1">keyIndex</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">{ helper } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">keyProperty = createObjectProperty(</span><span class="s3">`key`</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">`</span><span class="s1">${keyIndex}</span><span class="s3">`</span><span class="s2">, false, </span><span class="s1">locStub</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ children } = branch</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">firstChild = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| firstChild.type !== </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needFragmentWrapper) {</span>
        <span class="s2">if </span><span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; firstChild.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">) {</span>
            <span class="s5">// optimize away nested fragments when child is a ForNode</span>
            <span class="s2">const </span><span class="s1">vnodeCall = firstChild.codegenNode</span><span class="s2">;</span>
            <span class="s1">injectProp(vnodeCall</span><span class="s2">, </span><span class="s1">keyProperty</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">vnodeCall</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">let </span><span class="s1">patchFlag = </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">patchFlagText = PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s5">// check if the fragment actually contains a single valid child with</span>
            <span class="s5">// the rest being comments</span>
            <span class="s2">if </span><span class="s1">(!branch.isTemplateIf &amp;&amp;</span>
                <span class="s1">children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">).length === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">patchFlag |= </span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s2">;</span>
                <span class="s1">patchFlagText += </span><span class="s3">`, </span><span class="s1">${PatchFlagNames[</span><span class="s4">2048 </span><span class="s5">/* PatchFlags.DEV_ROOT_FRAGMENT */</span><span class="s1">]}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">createVNodeCall(context</span><span class="s2">, </span><span class="s1">helper(FRAGMENT)</span><span class="s2">, </span><span class="s1">createObjectExpression([keyProperty])</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag + (</span><span class="s3">` /* </span><span class="s1">${patchFlagText} </span><span class="s3">*/` </span><span class="s1">)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true, false, false </span><span class="s5">/* isComponent */</span><span class="s2">, </span><span class="s1">branch.loc)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">ret = firstChild.codegenNode</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">vnodeCall = getMemoedVNodeCall(ret)</span><span class="s2">;</span>
        <span class="s5">// Change createVNode to createBlock.</span>
        <span class="s2">if </span><span class="s1">(vnodeCall.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
            <span class="s1">makeBlock(vnodeCall</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// inject branch key</span>
        <span class="s1">injectProp(vnodeCall</span><span class="s2">, </span><span class="s1">keyProperty</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSameKey(a</span><span class="s2">, </span><span class="s1">b) {</span>
    <span class="s2">if </span><span class="s1">(!a || a.type !== b.type) {</span>
        <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(a.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(a.value.content !== b.value.content) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// directive</span>
        <span class="s2">const </span><span class="s1">exp = a.exp</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">branchExp = b.exp</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exp.type !== branchExp.type) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(exp.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
            <span class="s1">exp.isStatic !== branchExp.isStatic ||</span>
            <span class="s1">exp.content !== branchExp.content) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getParentCondition(node) {</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(node.alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                <span class="s1">node = node.alternate</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.type === </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s1">node = node.value</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">transformFor = createStructuralDirectiveTransform(</span><span class="s3">'for'</span><span class="s2">, </span><span class="s1">(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ helper</span><span class="s2">, </span><span class="s1">removeHelper } = context</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">processFor(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">forNode =&gt; {</span>
        <span class="s5">// create the loop render function expression now, and add the</span>
        <span class="s5">// iterator on exit after all children have been traversed</span>
        <span class="s2">const </span><span class="s1">renderExp = createCallExpression(helper(RENDER_LIST)</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">forNode.source</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isTemplate = isTemplateNode(node)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">memo = findDir(node</span><span class="s2">, </span><span class="s3">'memo'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keyProp = findProp(node</span><span class="s2">, </span><span class="s3">`key`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keyExp = keyProp &amp;&amp;</span>
            <span class="s1">(keyProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s1">? createSimpleExpression(keyProp.value.content</span><span class="s2">, true</span><span class="s1">)</span>
                <span class="s1">: keyProp.exp)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keyProperty = keyProp ? createObjectProperty(</span><span class="s3">`key`</span><span class="s2">, </span><span class="s1">keyExp) : </span><span class="s2">null;</span>
        <span class="s2">const </span><span class="s1">isStableFragment = forNode.source.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">forNode.source.constType &gt; </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">fragmentFlag = isStableFragment</span>
            <span class="s1">? </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span>
            <span class="s1">: keyProp</span>
                <span class="s1">? </span><span class="s4">128 </span><span class="s5">/* PatchFlags.KEYED_FRAGMENT */</span>
                <span class="s1">: </span><span class="s4">256 </span><span class="s5">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s2">;</span>
        <span class="s1">forNode.codegenNode = createVNodeCall(context</span><span class="s2">, </span><span class="s1">helper(FRAGMENT)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">renderExp</span><span class="s2">, </span><span class="s1">fragmentFlag +</span>
            <span class="s1">(</span><span class="s3">` /* </span><span class="s1">${PatchFlagNames[fragmentFlag]} </span><span class="s3">*/` </span><span class="s1">)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true </span><span class="s5">/* isBlock */</span><span class="s2">, </span><span class="s1">!isStableFragment </span><span class="s5">/* disableTracking */</span><span class="s2">, false </span><span class="s5">/* isComponent */</span><span class="s2">, </span><span class="s1">node.loc)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s5">// finish the codegen now that all children have been traversed</span>
            <span class="s2">let </span><span class="s1">childBlock</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">{ children } = forNode</span><span class="s2">;</span>
            <span class="s5">// check &lt;template v-for&gt; key placement</span>
            <span class="s2">if </span><span class="s1">(isTemplate) {</span>
                <span class="s1">node.children.some(c =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(c.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
                        <span class="s2">const </span><span class="s1">key = findProp(c</span><span class="s2">, </span><span class="s3">'key'</span><span class="s1">)</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(key) {</span>
                            <span class="s1">context.onError(createCompilerError(</span><span class="s4">33 </span><span class="s5">/* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */</span><span class="s2">, </span><span class="s1">key.loc))</span><span class="s2">;</span>
                            <span class="s2">return true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">})</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">needFragmentWrapper = children.length !== </span><span class="s4">1 </span><span class="s1">|| children[</span><span class="s4">0</span><span class="s1">].type !== </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">slotOutlet = isSlotOutlet(node)</span>
                <span class="s1">? node</span>
                <span class="s1">: isTemplate &amp;&amp;</span>
                    <span class="s1">node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isSlotOutlet(node.children[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">? node.children[</span><span class="s4">0</span><span class="s1">] </span><span class="s5">// api-extractor somehow fails to infer this</span>
                    <span class="s1">: </span><span class="s2">null;</span>
            <span class="s2">if </span><span class="s1">(slotOutlet) {</span>
                <span class="s5">// &lt;slot v-for=&quot;...&quot;&gt; or &lt;template v-for=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                <span class="s1">childBlock = slotOutlet.codegenNode</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s5">// &lt;template v-for=&quot;...&quot; :key=&quot;...&quot;&gt;&lt;slot/&gt;&lt;/template&gt;</span>
                    <span class="s5">// we need to inject the key to the renderSlot() call.</span>
                    <span class="s5">// the props for renderSlot is passed as the 3rd argument.</span>
                    <span class="s1">injectProp(childBlock</span><span class="s2">, </span><span class="s1">keyProperty</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(needFragmentWrapper) {</span>
                <span class="s5">// &lt;template v-for=&quot;...&quot;&gt; with text or multi-elements</span>
                <span class="s5">// should generate a fragment block for each loop</span>
                <span class="s1">childBlock = createVNodeCall(context</span><span class="s2">, </span><span class="s1">helper(FRAGMENT)</span><span class="s2">, </span><span class="s1">keyProperty ? createObjectExpression([keyProperty]) : undefined</span><span class="s2">, </span><span class="s1">node.children</span><span class="s2">, </span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s1">+</span>
                    <span class="s1">(</span><span class="s3">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">64 </span><span class="s5">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s1">]} </span><span class="s3">*/`</span>
                        <span class="s1">)</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, true, </span><span class="s1">undefined</span><span class="s2">, false </span><span class="s5">/* isComponent */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// Normal element v-for. Directly use the child's codegenNode</span>
                <span class="s5">// but mark it as a block.</span>
                <span class="s1">childBlock = children[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">.codegenNode</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isTemplate &amp;&amp; keyProperty) {</span>
                    <span class="s1">injectProp(childBlock</span><span class="s2">, </span><span class="s1">keyProperty</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(childBlock.isBlock !== !isStableFragment) {</span>
                    <span class="s2">if </span><span class="s1">(childBlock.isBlock) {</span>
                        <span class="s5">// switch from block to vnode</span>
                        <span class="s1">removeHelper(OPEN_BLOCK)</span><span class="s2">;</span>
                        <span class="s1">removeHelper(getVNodeBlockHelper(context.inSSR</span><span class="s2">, </span><span class="s1">childBlock.isComponent))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s5">// switch from vnode to block</span>
                        <span class="s1">removeHelper(getVNodeHelper(context.inSSR</span><span class="s2">, </span><span class="s1">childBlock.isComponent))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">childBlock.isBlock = !isStableFragment</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(childBlock.isBlock) {</span>
                    <span class="s1">helper(OPEN_BLOCK)</span><span class="s2">;</span>
                    <span class="s1">helper(getVNodeBlockHelper(context.inSSR</span><span class="s2">, </span><span class="s1">childBlock.isComponent))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">helper(getVNodeHelper(context.inSSR</span><span class="s2">, </span><span class="s1">childBlock.isComponent))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(memo) {</span>
                <span class="s2">const </span><span class="s1">loop = createFunctionExpression(createForLoopParams(forNode.parseResult</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">createSimpleExpression(</span><span class="s3">`_cached`</span><span class="s1">)</span>
                <span class="s1">]))</span><span class="s2">;</span>
                <span class="s1">loop.body = createBlockStatement([</span>
                    <span class="s1">createCompoundExpression([</span><span class="s3">`const _memo = (`</span><span class="s2">, </span><span class="s1">memo.exp</span><span class="s2">, </span><span class="s3">`)`</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">createCompoundExpression([</span>
                        <span class="s3">`if (_cached`</span><span class="s2">,</span>
                        <span class="s1">...(keyExp ? [</span><span class="s3">` &amp;&amp; _cached.key === `</span><span class="s2">, </span><span class="s1">keyExp] : [])</span><span class="s2">,</span>
                        <span class="s3">` &amp;&amp; </span><span class="s1">${context.helperString(IS_MEMO_SAME)}</span><span class="s3">(_cached, _memo)) return _cached`</span>
                    <span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">createCompoundExpression([</span><span class="s3">`const _item = `</span><span class="s2">, </span><span class="s1">childBlock])</span><span class="s2">,</span>
                    <span class="s1">createSimpleExpression(</span><span class="s3">`_item.memo = _memo`</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">createSimpleExpression(</span><span class="s3">`return _item`</span><span class="s1">)</span>
                <span class="s1">])</span><span class="s2">;</span>
                <span class="s1">renderExp.arguments.push(loop</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">`_cache`</span><span class="s1">)</span><span class="s2">, </span><span class="s1">createSimpleExpression(String(context.cached++)))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult)</span><span class="s2">, </span><span class="s1">childBlock</span><span class="s2">, true </span><span class="s5">/* force newline */</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s5">// target-agnostic transform used for both Client and SSR</span>
<span class="s2">function </span><span class="s1">processFor(node</span><span class="s2">, </span><span class="s1">dir</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">processCodegen) {</span>
    <span class="s2">if </span><span class="s1">(!dir.exp) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">31 </span><span class="s5">/* ErrorCodes.X_V_FOR_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parseResult = parseForExpression(</span>
    <span class="s5">// can only be simple expression because vFor transform is applied</span>
    <span class="s5">// before expression transform.</span>
    <span class="s1">dir.exp</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!parseResult) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ addIdentifiers</span><span class="s2">, </span><span class="s1">removeIdentifiers</span><span class="s2">, </span><span class="s1">scopes } = context</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ source</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">index } = parseResult</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">forNode = {</span>
        <span class="s1">type: </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s2">,</span>
        <span class="s1">loc: dir.loc</span><span class="s2">,</span>
        <span class="s1">source</span><span class="s2">,</span>
        <span class="s1">valueAlias: value</span><span class="s2">,</span>
        <span class="s1">keyAlias: key</span><span class="s2">,</span>
        <span class="s1">objectIndexAlias: index</span><span class="s2">,</span>
        <span class="s1">parseResult</span><span class="s2">,</span>
        <span class="s1">children: isTemplateNode(node) ? node.children : [node]</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">context.replaceNode(forNode)</span><span class="s2">;</span>
    <span class="s5">// bookkeeping</span>
    <span class="s1">scopes.vFor++</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">onExit = processCodegen &amp;&amp; processCodegen(forNode)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
        <span class="s1">scopes.vFor--</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(onExit)</span>
            <span class="s1">onExit()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">forAliasRE = </span><span class="s4">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span><span class="s2">;</span>
<span class="s5">// This regex doesn't cover the case if key or index aliases have destructuring,</span>
<span class="s5">// but those do not make sense in the first place, so this works in practice.</span>
<span class="s2">const </span><span class="s1">forIteratorRE = </span><span class="s4">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">stripParensRE = </span><span class="s4">/^\(|\)$/g</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseForExpression(input</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">loc = input.loc</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exp = input.content</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">inMatch = exp.match(forAliasRE)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!inMatch)</span>
        <span class="s2">return;</span>
    <span class="s2">const </span><span class="s1">[</span><span class="s2">, </span><span class="s1">LHS</span><span class="s2">, </span><span class="s1">RHS] = inMatch</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = {</span>
        <span class="s1">source: createAliasExpression(loc</span><span class="s2">, </span><span class="s1">RHS.trim()</span><span class="s2">, </span><span class="s1">exp.indexOf(RHS</span><span class="s2">, </span><span class="s1">LHS.length))</span><span class="s2">,</span>
        <span class="s1">value: undefined</span><span class="s2">,</span>
        <span class="s1">key: undefined</span><span class="s2">,</span>
        <span class="s1">index: undefined</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">validateBrowserExpression(result.source</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">valueContent = LHS.trim().replace(stripParensRE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).trim()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">trimmedOffset = LHS.indexOf(valueContent)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">iteratorMatch = valueContent.match(forIteratorRE)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(iteratorMatch) {</span>
        <span class="s1">valueContent = valueContent.replace(forIteratorRE</span><span class="s2">, </span><span class="s3">''</span><span class="s1">).trim()</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">keyContent = iteratorMatch[</span><span class="s4">1</span><span class="s1">].trim()</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">keyOffset</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(keyContent) {</span>
            <span class="s1">keyOffset = exp.indexOf(keyContent</span><span class="s2">, </span><span class="s1">trimmedOffset + valueContent.length)</span><span class="s2">;</span>
            <span class="s1">result.key = createAliasExpression(loc</span><span class="s2">, </span><span class="s1">keyContent</span><span class="s2">, </span><span class="s1">keyOffset)</span><span class="s2">;</span>
            <span class="s1">{</span>
                <span class="s1">validateBrowserExpression(result.key</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(iteratorMatch[</span><span class="s4">2</span><span class="s1">]) {</span>
            <span class="s2">const </span><span class="s1">indexContent = iteratorMatch[</span><span class="s4">2</span><span class="s1">].trim()</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(indexContent) {</span>
                <span class="s1">result.index = createAliasExpression(loc</span><span class="s2">, </span><span class="s1">indexContent</span><span class="s2">, </span><span class="s1">exp.indexOf(indexContent</span><span class="s2">, </span><span class="s1">result.key</span>
                    <span class="s1">? keyOffset + keyContent.length</span>
                    <span class="s1">: trimmedOffset + valueContent.length))</span><span class="s2">;</span>
                <span class="s1">{</span>
                    <span class="s1">validateBrowserExpression(result.index</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(valueContent) {</span>
        <span class="s1">result.value = createAliasExpression(loc</span><span class="s2">, </span><span class="s1">valueContent</span><span class="s2">, </span><span class="s1">trimmedOffset)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">validateBrowserExpression(result.value</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createAliasExpression(range</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">offset) {</span>
    <span class="s2">return </span><span class="s1">createSimpleExpression(content</span><span class="s2">, false, </span><span class="s1">getInnerRange(range</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">content.length))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createForLoopParams({ value</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">index }</span><span class="s2">, </span><span class="s1">memoArgs = []) {</span>
    <span class="s2">return </span><span class="s1">createParamsList([value</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">...memoArgs])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createParamsList(args) {</span>
    <span class="s2">let </span><span class="s1">i = args.length</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(i--) {</span>
        <span class="s2">if </span><span class="s1">(args[i])</span>
            <span class="s2">break;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">args</span>
        <span class="s1">.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">.map((arg</span><span class="s2">, </span><span class="s1">i) =&gt; arg || createSimpleExpression(</span><span class="s3">`_`</span><span class="s1">.repeat(i + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, false</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">defaultFallback = createSimpleExpression(</span><span class="s3">`undefined`</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// A NodeTransform that:</span>
<span class="s5">// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed</span>
<span class="s5">//    by transformExpression. This is only applied in non-browser builds with</span>
<span class="s5">//    { prefixIdentifiers: true }.</span>
<span class="s5">// 2. Track v-slot depths so that we know a slot is inside another slot.</span>
<span class="s5">//    Note the exit callback is executed before buildSlots() on the same node,</span>
<span class="s5">//    so only nested slots see positive numbers.</span>
<span class="s2">const </span><span class="s1">trackSlotScopes = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */ </span><span class="s1">||</span>
            <span class="s1">node.tagType === </span><span class="s4">3 </span><span class="s5">/* ElementTypes.TEMPLATE */</span><span class="s1">)) {</span>
        <span class="s5">// We are only checking non-empty v-slot here</span>
        <span class="s5">// since we only care about slots that introduce scope variables.</span>
        <span class="s2">const </span><span class="s1">vSlot = findDir(node</span><span class="s2">, </span><span class="s3">'slot'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vSlot) {</span>
            <span class="s1">vSlot.exp</span><span class="s2">;</span>
            <span class="s1">context.scopes.vSlot++</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">() =&gt; {</span>
                <span class="s1">context.scopes.vSlot--</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">buildClientSlotFn = (props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">loc) =&gt; createFunctionExpression(props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, false </span><span class="s5">/* newline */</span><span class="s2">, true </span><span class="s5">/* isSlot */</span><span class="s2">, </span><span class="s1">children.length ? children[</span><span class="s4">0</span><span class="s1">].loc : loc)</span><span class="s2">;</span>
<span class="s5">// Instead of being a DirectiveTransform, v-slot processing is called during</span>
<span class="s5">// transformElement to build the slots object for a component.</span>
<span class="s2">function </span><span class="s1">buildSlots(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">buildSlotFn = buildClientSlotFn) {</span>
    <span class="s1">context.helper(WITH_CTX)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ children</span><span class="s2">, </span><span class="s1">loc } = node</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">slotsProperties = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">dynamicSlots = []</span><span class="s2">;</span>
    <span class="s5">// If the slot is inside a v-for or another v-slot, force it to be dynamic</span>
    <span class="s5">// since it likely uses a scope variable.</span>
    <span class="s2">let </span><span class="s1">hasDynamicSlots = context.scopes.vSlot &gt; </span><span class="s4">0 </span><span class="s1">|| context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s5">// 1. Check for slot with slotProps on component itself.</span>
    <span class="s5">//    &lt;Comp v-slot=&quot;{ prop }&quot;/&gt;</span>
    <span class="s2">const </span><span class="s1">onComponentSlot = findDir(node</span><span class="s2">, </span><span class="s3">'slot'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(onComponentSlot) {</span>
        <span class="s2">const </span><span class="s1">{ arg</span><span class="s2">, </span><span class="s1">exp } = onComponentSlot</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(arg &amp;&amp; !isStaticExp(arg)) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">slotsProperties.push(createObjectProperty(arg || createSimpleExpression(</span><span class="s3">'default'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">buildSlotFn(exp</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">loc)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// 2. Iterate through children and check for template slots</span>
    <span class="s5">//    &lt;template v-slot:foo=&quot;{ prop }&quot;&gt;</span>
    <span class="s2">let </span><span class="s1">hasTemplateSlots = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasNamedDefaultSlot = </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">implicitDefaultChildren = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">seenSlotNames = </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">conditionalBranchIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">slotElement = children[i]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">slotDir</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!isTemplateNode(slotElement) ||</span>
            <span class="s1">!(slotDir = findDir(slotElement</span><span class="s2">, </span><span class="s3">'slot'</span><span class="s2">, true</span><span class="s1">))) {</span>
            <span class="s5">// not a &lt;template v-slot&gt;, skip.</span>
            <span class="s2">if </span><span class="s1">(slotElement.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                <span class="s1">implicitDefaultChildren.push(slotElement)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(onComponentSlot) {</span>
            <span class="s5">// already has on-component slot - this is incorrect usage.</span>
            <span class="s1">context.onError(createCompilerError(</span><span class="s4">37 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */</span><span class="s2">, </span><span class="s1">slotDir.loc))</span><span class="s2">;</span>
            <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">hasTemplateSlots = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ children: slotChildren</span><span class="s2">, </span><span class="s1">loc: slotLoc } = slotElement</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ arg: slotName = createSimpleExpression(</span><span class="s3">`default`</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exp: slotProps</span><span class="s2">, </span><span class="s1">loc: dirLoc } = slotDir</span><span class="s2">;</span>
        <span class="s5">// check if name is dynamic.</span>
        <span class="s2">let </span><span class="s1">staticSlotName</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isStaticExp(slotName)) {</span>
            <span class="s1">staticSlotName = slotName ? slotName.content : </span><span class="s3">`default`</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hasDynamicSlots = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">slotFunction = buildSlotFn(slotProps</span><span class="s2">, </span><span class="s1">slotChildren</span><span class="s2">, </span><span class="s1">slotLoc)</span><span class="s2">;</span>
        <span class="s5">// check if this slot is conditional (v-if/v-for)</span>
        <span class="s2">let </span><span class="s1">vIf</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vElse</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vFor</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">((vIf = findDir(slotElement</span><span class="s2">, </span><span class="s3">'if'</span><span class="s1">))) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s2">true;</span>
            <span class="s1">dynamicSlots.push(createConditionalExpression(vIf.exp</span><span class="s2">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s2">, </span><span class="s1">slotFunction</span><span class="s2">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s2">, </span><span class="s1">defaultFallback))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">((vElse = findDir(slotElement</span><span class="s2">, </span><span class="s4">/^else(-if)?$/</span><span class="s2">, true </span><span class="s5">/* allowEmpty */</span><span class="s1">))) {</span>
            <span class="s5">// find adjacent v-if</span>
            <span class="s2">let </span><span class="s1">j = i</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">prev</span><span class="s2">;</span>
            <span class="s2">while </span><span class="s1">(j--) {</span>
                <span class="s1">prev = children[j]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(prev.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */</span><span class="s1">) {</span>
                    <span class="s2">break;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(prev &amp;&amp; isTemplateNode(prev) &amp;&amp; findDir(prev</span><span class="s2">, </span><span class="s3">'if'</span><span class="s1">)) {</span>
                <span class="s5">// remove node</span>
                <span class="s1">children.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">i--</span><span class="s2">;</span>
                <span class="s5">// attach this slot to previous conditional</span>
                <span class="s2">let </span><span class="s1">conditional = dynamicSlots[dynamicSlots.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s2">while </span><span class="s1">(conditional.alternate.type === </span><span class="s4">19 </span><span class="s5">/* NodeTypes.JS_CONDITIONAL_EXPRESSION */</span><span class="s1">) {</span>
                    <span class="s1">conditional = conditional.alternate</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">conditional.alternate = vElse.exp</span>
                    <span class="s1">? createConditionalExpression(vElse.exp</span><span class="s2">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s2">, </span><span class="s1">slotFunction</span><span class="s2">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s2">, </span><span class="s1">defaultFallback)</span>
                    <span class="s1">: buildDynamicSlot(slotName</span><span class="s2">, </span><span class="s1">slotFunction</span><span class="s2">, </span><span class="s1">conditionalBranchIndex++)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">30 </span><span class="s5">/* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */</span><span class="s2">, </span><span class="s1">vElse.loc))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">((vFor = findDir(slotElement</span><span class="s2">, </span><span class="s3">'for'</span><span class="s1">))) {</span>
            <span class="s1">hasDynamicSlots = </span><span class="s2">true;</span>
            <span class="s2">const </span><span class="s1">parseResult = vFor.parseResult ||</span>
                <span class="s1">parseForExpression(vFor.exp</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(parseResult) {</span>
                <span class="s5">// Render the dynamic slots as an array and add it to the createSlot()</span>
                <span class="s5">// args. The runtime knows how to handle it appropriately.</span>
                <span class="s1">dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST)</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">parseResult.source</span><span class="s2">,</span>
                    <span class="s1">createFunctionExpression(createForLoopParams(parseResult)</span><span class="s2">, </span><span class="s1">buildDynamicSlot(slotName</span><span class="s2">, </span><span class="s1">slotFunction)</span><span class="s2">, true </span><span class="s5">/* force newline */</span><span class="s1">)</span>
                <span class="s1">]))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">32 </span><span class="s5">/* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */</span><span class="s2">, </span><span class="s1">vFor.loc))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// check duplicate static names</span>
            <span class="s2">if </span><span class="s1">(staticSlotName) {</span>
                <span class="s2">if </span><span class="s1">(seenSlotNames.has(staticSlotName)) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">38 </span><span class="s5">/* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */</span><span class="s2">, </span><span class="s1">dirLoc))</span><span class="s2">;</span>
                    <span class="s2">continue;</span>
                <span class="s1">}</span>
                <span class="s1">seenSlotNames.add(staticSlotName)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(staticSlotName === </span><span class="s3">'default'</span><span class="s1">) {</span>
                    <span class="s1">hasNamedDefaultSlot = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">slotsProperties.push(createObjectProperty(slotName</span><span class="s2">, </span><span class="s1">slotFunction))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!onComponentSlot) {</span>
        <span class="s2">const </span><span class="s1">buildDefaultSlotProperty = (props</span><span class="s2">, </span><span class="s1">children) =&gt; {</span>
            <span class="s2">const </span><span class="s1">fn = buildSlotFn(props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">loc)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">createObjectProperty(</span><span class="s3">`default`</span><span class="s2">, </span><span class="s1">fn)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!hasTemplateSlots) {</span>
            <span class="s5">// implicit default slot (on component)</span>
            <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s2">, </span><span class="s1">children))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(implicitDefaultChildren.length &amp;&amp;</span>
            <span class="s5">// #3766</span>
            <span class="s5">// with whitespace: 'preserve', whitespaces between slots will end up in</span>
            <span class="s5">// implicitDefaultChildren. Ignore if all implicit children are whitespaces.</span>
            <span class="s1">implicitDefaultChildren.some(node =&gt; isNonWhitespaceContent(node))) {</span>
            <span class="s5">// implicit default slot (mixed with named slots)</span>
            <span class="s2">if </span><span class="s1">(hasNamedDefaultSlot) {</span>
                <span class="s1">context.onError(createCompilerError(</span><span class="s4">39 </span><span class="s5">/* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */</span><span class="s2">, </span><span class="s1">implicitDefaultChildren[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">slotsProperties.push(buildDefaultSlotProperty(undefined</span><span class="s2">, </span><span class="s1">implicitDefaultChildren))</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">slotFlag = hasDynamicSlots</span>
        <span class="s1">? </span><span class="s4">2 </span><span class="s5">/* SlotFlags.DYNAMIC */</span>
        <span class="s1">: hasForwardedSlots(node.children)</span>
            <span class="s1">? </span><span class="s4">3 </span><span class="s5">/* SlotFlags.FORWARDED */</span>
            <span class="s1">: </span><span class="s4">1 </span><span class="s5">/* SlotFlags.STABLE */</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">slots = createObjectExpression(slotsProperties.concat(createObjectProperty(</span><span class="s3">`_`</span><span class="s2">, </span>
    <span class="s5">// 2 = compiled but dynamic = can skip normalization, but must run diff</span>
    <span class="s5">// 1 = compiled and static = can skip normalization AND diff as optimized</span>
    <span class="s1">createSimpleExpression(slotFlag + (</span><span class="s3">` /* </span><span class="s1">${slotFlagsText[slotFlag]} </span><span class="s3">*/` </span><span class="s1">)</span><span class="s2">, false</span><span class="s1">)))</span><span class="s2">, </span><span class="s1">loc)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dynamicSlots.length) {</span>
        <span class="s1">slots = createCallExpression(context.helper(CREATE_SLOTS)</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">slots</span><span class="s2">,</span>
            <span class="s1">createArrayExpression(dynamicSlots)</span>
        <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">slots</span><span class="s2">,</span>
        <span class="s1">hasDynamicSlots</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildDynamicSlot(name</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">index) {</span>
    <span class="s2">const </span><span class="s1">props = [</span>
        <span class="s1">createObjectProperty(</span><span class="s3">`name`</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span>
        <span class="s1">createObjectProperty(</span><span class="s3">`fn`</span><span class="s2">, </span><span class="s1">fn)</span>
    <span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(index != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">props.push(createObjectProperty(</span><span class="s3">`key`</span><span class="s2">, </span><span class="s1">createSimpleExpression(String(index)</span><span class="s2">, true</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createObjectExpression(props)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasForwardedSlots(children) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
        <span class="s2">switch </span><span class="s1">(child.type) {</span>
            <span class="s2">case </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(child.tagType === </span><span class="s4">2 </span><span class="s5">/* ElementTypes.SLOT */ </span><span class="s1">||</span>
                    <span class="s1">hasForwardedSlots(child.children)) {</span>
                    <span class="s2">return true;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(hasForwardedSlots(child.branches))</span>
                    <span class="s2">return true;</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(hasForwardedSlots(child.children))</span>
                    <span class="s2">return true;</span>
                <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNonWhitespaceContent(node) {</span>
    <span class="s2">if </span><span class="s1">(node.type !== </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp; node.type !== </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s1">)</span>
        <span class="s2">return true;</span>
    <span class="s2">return </span><span class="s1">node.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span>
        <span class="s1">? !!node.content.trim()</span>
        <span class="s1">: isNonWhitespaceContent(node.content)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// some directive transforms (e.g. v-model) may return a symbol for runtime</span>
<span class="s5">// import, which should be used instead of a resolveDirective call.</span>
<span class="s2">const </span><span class="s1">directiveImportMap = </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s5">// generate a JavaScript AST for this element's codegen</span>
<span class="s2">const </span><span class="s1">transformElement = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s5">// perform the work on exit, after all child expressions have been</span>
    <span class="s5">// processed and merged.</span>
    <span class="s2">return function </span><span class="s1">postTransformElement() {</span>
        <span class="s1">node = context.currentNode</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                <span class="s1">node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">))) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ tag</span><span class="s2">, </span><span class="s1">props } = node</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isComponent = node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s2">;</span>
        <span class="s5">// The goal of the transform is to create a codegenNode implementing the</span>
        <span class="s5">// VNodeCall interface.</span>
        <span class="s2">let </span><span class="s1">vnodeTag = isComponent</span>
            <span class="s1">? resolveComponentType(node</span><span class="s2">, </span><span class="s1">context)</span>
            <span class="s1">: </span><span class="s3">`&quot;</span><span class="s1">${tag}</span><span class="s3">&quot;`</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isDynamicComponent = isObject(vnodeTag) &amp;&amp; vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeProps</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeChildren</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodePatchFlag</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeDynamicProps</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">dynamicPropNames</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeDirectives</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">shouldUseBlock = </span>
        <span class="s5">// dynamic component may resolve to plain elements</span>
        <span class="s1">isDynamicComponent ||</span>
            <span class="s1">vnodeTag === TELEPORT ||</span>
            <span class="s1">vnodeTag === SUSPENSE ||</span>
            <span class="s1">(!isComponent &amp;&amp;</span>
                <span class="s5">// &lt;svg&gt; and &lt;foreignObject&gt; must be forced into blocks so that block</span>
                <span class="s5">// updates inside get proper isSVG flag at runtime. (#639, #643)</span>
                <span class="s5">// This is technically web-specific, but splitting the logic out of core</span>
                <span class="s5">// leads to too much unnecessary complexity.</span>
                <span class="s1">(tag === </span><span class="s3">'svg' </span><span class="s1">|| tag === </span><span class="s3">'foreignObject'</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s5">// props</span>
        <span class="s2">if </span><span class="s1">(props.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">propsBuildResult = buildProps(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isComponent</span><span class="s2">, </span><span class="s1">isDynamicComponent)</span><span class="s2">;</span>
            <span class="s1">vnodeProps = propsBuildResult.props</span><span class="s2">;</span>
            <span class="s1">patchFlag = propsBuildResult.patchFlag</span><span class="s2">;</span>
            <span class="s1">dynamicPropNames = propsBuildResult.dynamicPropNames</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">directives = propsBuildResult.directives</span><span class="s2">;</span>
            <span class="s1">vnodeDirectives =</span>
                <span class="s1">directives &amp;&amp; directives.length</span>
                    <span class="s1">? createArrayExpression(directives.map(dir =&gt; buildDirectiveArgs(dir</span><span class="s2">, </span><span class="s1">context)))</span>
                    <span class="s1">: undefined</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(propsBuildResult.shouldUseBlock) {</span>
                <span class="s1">shouldUseBlock = </span><span class="s2">true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// children</span>
        <span class="s2">if </span><span class="s1">(node.children.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(vnodeTag === KEEP_ALIVE) {</span>
                <span class="s5">// Although a built-in component, we compile KeepAlive with raw children</span>
                <span class="s5">// instead of slot functions so that it can be used inside Transition</span>
                <span class="s5">// or other Transition-wrapping HOCs.</span>
                <span class="s5">// To ensure correct updates with block optimizations, we need to:</span>
                <span class="s5">// 1. Force keep-alive into a block. This avoids its children being</span>
                <span class="s5">//    collected by a parent block.</span>
                <span class="s1">shouldUseBlock = </span><span class="s2">true;</span>
                <span class="s5">// 2. Force keep-alive to always be updated, since it uses raw children.</span>
                <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(node.children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">46 </span><span class="s5">/* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">start: node.children[</span><span class="s4">0</span><span class="s1">].loc.start</span><span class="s2">,</span>
                        <span class="s1">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s1">].loc.end</span><span class="s2">,</span>
                        <span class="s1">source: </span><span class="s3">''</span>
                    <span class="s1">}))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">shouldBuildAsSlots = isComponent &amp;&amp;</span>
                <span class="s5">// Teleport is not a real component and has dedicated runtime handling</span>
                <span class="s1">vnodeTag !== TELEPORT &amp;&amp;</span>
                <span class="s5">// explained above.</span>
                <span class="s1">vnodeTag !== KEEP_ALIVE</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(shouldBuildAsSlots) {</span>
                <span class="s2">const </span><span class="s1">{ slots</span><span class="s2">, </span><span class="s1">hasDynamicSlots } = buildSlots(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">vnodeChildren = slots</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hasDynamicSlots) {</span>
                    <span class="s1">patchFlag |= </span><span class="s4">1024 </span><span class="s5">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; vnodeTag !== TELEPORT) {</span>
                <span class="s2">const </span><span class="s1">child = node.children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">type = child.type</span><span class="s2">;</span>
                <span class="s5">// check for dynamic text children</span>
                <span class="s2">const </span><span class="s1">hasDynamicTextChild = type === </span><span class="s4">5 </span><span class="s5">/* NodeTypes.INTERPOLATION */ </span><span class="s1">||</span>
                    <span class="s1">type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hasDynamicTextChild &amp;&amp;</span>
                    <span class="s1">getConstantType(child</span><span class="s2">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                    <span class="s1">patchFlag |= </span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// pass directly if the only child is a text node</span>
                <span class="s5">// (plain / interpolation / expression)</span>
                <span class="s2">if </span><span class="s1">(hasDynamicTextChild || type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */</span><span class="s1">) {</span>
                    <span class="s1">vnodeChildren = child</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">vnodeChildren = node.children</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">vnodeChildren = node.children</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s5">// patchFlag &amp; dynamicPropNames</span>
        <span class="s2">if </span><span class="s1">(patchFlag !== </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(patchFlag &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s5">// special flags (negative and mutually exclusive)</span>
                    <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s3">` /* </span><span class="s1">${PatchFlagNames[patchFlag]} </span><span class="s3">*/`</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s5">// bitwise flags</span>
                    <span class="s2">const </span><span class="s1">flagNames = Object.keys(PatchFlagNames)</span>
                        <span class="s1">.map(Number)</span>
                        <span class="s1">.filter(n =&gt; n &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; n)</span>
                        <span class="s1">.map(n =&gt; PatchFlagNames[n])</span>
                        <span class="s1">.join(</span><span class="s3">`, `</span><span class="s1">)</span><span class="s2">;</span>
                    <span class="s1">vnodePatchFlag = patchFlag + </span><span class="s3">` /* </span><span class="s1">${flagNames} </span><span class="s3">*/`</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(dynamicPropNames &amp;&amp; dynamicPropNames.length) {</span>
                <span class="s1">vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">node.codegenNode = createVNodeCall(context</span><span class="s2">, </span><span class="s1">vnodeTag</span><span class="s2">, </span><span class="s1">vnodeProps</span><span class="s2">, </span><span class="s1">vnodeChildren</span><span class="s2">, </span><span class="s1">vnodePatchFlag</span><span class="s2">, </span><span class="s1">vnodeDynamicProps</span><span class="s2">, </span><span class="s1">vnodeDirectives</span><span class="s2">, </span><span class="s1">!!shouldUseBlock</span><span class="s2">, false </span><span class="s5">/* disableTracking */</span><span class="s2">, </span><span class="s1">isComponent</span><span class="s2">, </span><span class="s1">node.loc)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveComponentType(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">ssr = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">{ tag } = node</span><span class="s2">;</span>
    <span class="s5">// 1. dynamic component</span>
    <span class="s2">const </span><span class="s1">isExplicitDynamic = isComponentTag(tag)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isProp = findProp(node</span><span class="s2">, </span><span class="s3">'is'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isProp) {</span>
        <span class="s2">if </span><span class="s1">(isExplicitDynamic ||</span>
            <span class="s1">(</span><span class="s2">false </span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">exp = isProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span>
                <span class="s1">? isProp.value &amp;&amp; createSimpleExpression(isProp.value.content</span><span class="s2">, true</span><span class="s1">)</span>
                <span class="s1">: isProp.exp</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(exp) {</span>
                <span class="s2">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">exp</span>
                <span class="s1">])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isProp.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
            <span class="s1">isProp.value.content.startsWith(</span><span class="s3">'vue:'</span><span class="s1">)) {</span>
            <span class="s5">// &lt;button is=&quot;vue:xxx&quot;&gt;</span>
            <span class="s5">// if not &lt;component&gt;, only is value that starts with &quot;vue:&quot; will be</span>
            <span class="s5">// treated as component by the parse phase and reach here, unless it's</span>
            <span class="s5">// compat mode where all is values are considered components</span>
            <span class="s1">tag = isProp.value.content.slice(</span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// 1.5 v-is (TODO: Deprecate)</span>
    <span class="s2">const </span><span class="s1">isDir = !isExplicitDynamic &amp;&amp; findDir(node</span><span class="s2">, </span><span class="s3">'is'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isDir &amp;&amp; isDir.exp) {</span>
        <span class="s2">return </span><span class="s1">createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT)</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">isDir.exp</span>
        <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)</span>
    <span class="s2">const </span><span class="s1">builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(builtIn) {</span>
        <span class="s5">// built-ins are simply fallthroughs / have special handling during ssr</span>
        <span class="s5">// so we don't need to import their runtime equivalents</span>
        <span class="s2">if </span><span class="s1">(!ssr)</span>
            <span class="s1">context.helper(builtIn)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">builtIn</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// 5. user component (resolve)</span>
    <span class="s1">context.helper(RESOLVE_COMPONENT)</span><span class="s2">;</span>
    <span class="s1">context.components.add(tag)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">toValidAssetId(tag</span><span class="s2">, </span><span class="s3">`component`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildProps(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">props = node.props</span><span class="s2">, </span><span class="s1">isComponent</span><span class="s2">, </span><span class="s1">isDynamicComponent</span><span class="s2">, </span><span class="s1">ssr = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ tag</span><span class="s2">, </span><span class="s1">loc: elementLoc</span><span class="s2">, </span><span class="s1">children } = node</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">properties = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">mergeArgs = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">runtimeDirectives = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">hasChildren = children.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">shouldUseBlock = </span><span class="s2">false;</span>
    <span class="s5">// patchFlag analysis</span>
    <span class="s2">let </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hasRef = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasClassBinding = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasStyleBinding = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasHydrationEventBinding = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasDynamicKeys = </span><span class="s2">false;</span>
    <span class="s2">let </span><span class="s1">hasVnodeHook = </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">dynamicPropNames = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">pushMergeArg = (arg) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(properties.length) {</span>
            <span class="s1">mergeArgs.push(createObjectExpression(dedupeProperties(properties)</span><span class="s2">, </span><span class="s1">elementLoc))</span><span class="s2">;</span>
            <span class="s1">properties = []</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(arg)</span>
            <span class="s1">mergeArgs.push(arg)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">analyzePatchFlag = ({ key</span><span class="s2">, </span><span class="s1">value }) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(isStaticExp(key)) {</span>
            <span class="s2">const </span><span class="s1">name = key.content</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">isEventHandler = isOn(name)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isEventHandler &amp;&amp;</span>
                <span class="s1">(!isComponent || isDynamicComponent) &amp;&amp;</span>
                <span class="s5">// omit the flag for click handlers because hydration gives click</span>
                <span class="s5">// dedicated fast path.</span>
                <span class="s1">name.toLowerCase() !== </span><span class="s3">'onclick' </span><span class="s1">&amp;&amp;</span>
                <span class="s5">// omit v-model handlers</span>
                <span class="s1">name !== </span><span class="s3">'onUpdate:modelValue' </span><span class="s1">&amp;&amp;</span>
                <span class="s5">// omit onVnodeXXX hooks</span>
                <span class="s1">!isReservedProp(name)) {</span>
                <span class="s1">hasHydrationEventBinding = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isEventHandler &amp;&amp; isReservedProp(name)) {</span>
                <span class="s1">hasVnodeHook = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(value.type === </span><span class="s4">20 </span><span class="s5">/* NodeTypes.JS_CACHE_EXPRESSION */ </span><span class="s1">||</span>
                <span class="s1">((value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">||</span>
                    <span class="s1">value.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">getConstantType(value</span><span class="s2">, </span><span class="s1">context) &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
                <span class="s5">// skip if the prop is a cached handler or has constant value</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'ref'</span><span class="s1">) {</span>
                <span class="s1">hasRef = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(name === </span><span class="s3">'class'</span><span class="s1">) {</span>
                <span class="s1">hasClassBinding = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(name === </span><span class="s3">'style'</span><span class="s1">) {</span>
                <span class="s1">hasStyleBinding = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(name !== </span><span class="s3">'key' </span><span class="s1">&amp;&amp; !dynamicPropNames.includes(name)) {</span>
                <span class="s1">dynamicPropNames.push(name)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// treat the dynamic class and style binding of the component as dynamic props</span>
            <span class="s2">if </span><span class="s1">(isComponent &amp;&amp;</span>
                <span class="s1">(name === </span><span class="s3">'class' </span><span class="s1">|| name === </span><span class="s3">'style'</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">!dynamicPropNames.includes(name)) {</span>
                <span class="s1">dynamicPropNames.push(name)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hasDynamicKeys = </span><span class="s2">true;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s5">// static attribute</span>
        <span class="s2">const </span><span class="s1">prop = props[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prop.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ loc</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value } = prop</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">isStatic = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'ref'</span><span class="s1">) {</span>
                <span class="s1">hasRef = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s3">'ref_for'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">'true'</span><span class="s1">)))</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s5">// skip is on &lt;component&gt;, or is=&quot;vue:xxx&quot;</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'is' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(isComponentTag(tag) ||</span>
                    <span class="s1">(value &amp;&amp; value.content.startsWith(</span><span class="s3">'vue:'</span><span class="s1">)) ||</span>
                    <span class="s1">(</span><span class="s2">false </span><span class="s1">))) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s1">properties.push(createObjectProperty(createSimpleExpression(name</span><span class="s2">, true, </span><span class="s1">getInnerRange(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">name.length))</span><span class="s2">, </span><span class="s1">createSimpleExpression(value ? value.content : </span><span class="s3">''</span><span class="s2">, </span><span class="s1">isStatic</span><span class="s2">, </span><span class="s1">value ? value.loc : loc)))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// directives</span>
            <span class="s2">const </span><span class="s1">{ name</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">loc } = prop</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">isVBind = name === </span><span class="s3">'bind'</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">isVOn = name === </span><span class="s3">'on'</span><span class="s2">;</span>
            <span class="s5">// skip v-slot - it is handled by its dedicated transform.</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'slot'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!isComponent) {</span>
                    <span class="s1">context.onError(createCompilerError(</span><span class="s4">40 </span><span class="s5">/* ErrorCodes.X_V_SLOT_MISPLACED */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s5">// skip v-once/v-memo - they are handled by dedicated transforms.</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'once' </span><span class="s1">|| name === </span><span class="s3">'memo'</span><span class="s1">) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s5">// skip v-is and :is on &lt;component&gt;</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'is' </span><span class="s1">||</span>
                <span class="s1">(isVBind &amp;&amp;</span>
                    <span class="s1">isStaticArgOf(arg</span><span class="s2">, </span><span class="s3">'is'</span><span class="s1">) &amp;&amp;</span>
                    <span class="s1">(isComponentTag(tag) ||</span>
                        <span class="s1">(</span><span class="s2">false </span><span class="s1">)))) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s5">// skip v-on in SSR compilation</span>
            <span class="s2">if </span><span class="s1">(isVOn &amp;&amp; ssr) {</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span>
            <span class="s5">// #938: elements with dynamic keys should be forced into blocks</span>
            <span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s2">, </span><span class="s3">'key'</span><span class="s1">)) ||</span>
                <span class="s5">// inline before-update hooks need to force block so that it is invoked</span>
                <span class="s5">// before children</span>
                <span class="s1">(isVOn &amp;&amp; hasChildren &amp;&amp; isStaticArgOf(arg</span><span class="s2">, </span><span class="s3">'vue:before-update'</span><span class="s1">))) {</span>
                <span class="s1">shouldUseBlock = </span><span class="s2">true;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isVBind &amp;&amp; isStaticArgOf(arg</span><span class="s2">, </span><span class="s3">'ref'</span><span class="s1">) &amp;&amp; context.scopes.vFor &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">properties.push(createObjectProperty(createSimpleExpression(</span><span class="s3">'ref_for'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">'true'</span><span class="s1">)))</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// special case for v-bind and v-on with no argument</span>
            <span class="s2">if </span><span class="s1">(!arg &amp;&amp; (isVBind || isVOn)) {</span>
                <span class="s1">hasDynamicKeys = </span><span class="s2">true;</span>
                <span class="s2">if </span><span class="s1">(exp) {</span>
                    <span class="s2">if </span><span class="s1">(isVBind) {</span>
                        <span class="s5">// have to merge early for compat build check</span>
                        <span class="s1">pushMergeArg()</span><span class="s2">;</span>
                        <span class="s1">mergeArgs.push(exp)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s5">// v-on=&quot;obj&quot; -&gt; toHandlers(obj)</span>
                        <span class="s1">pushMergeArg({</span>
                            <span class="s1">type: </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s2">,</span>
                            <span class="s1">loc</span><span class="s2">,</span>
                            <span class="s1">callee: context.helper(TO_HANDLERS)</span><span class="s2">,</span>
                            <span class="s1">arguments: isComponent ? [exp] : [exp</span><span class="s2">, </span><span class="s3">`true`</span><span class="s1">]</span>
                        <span class="s1">})</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">context.onError(createCompilerError(isVBind</span>
                        <span class="s1">? </span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span>
                        <span class="s1">: </span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">continue;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">directiveTransform = context.directiveTransforms[name]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(directiveTransform) {</span>
                <span class="s5">// has built-in directive transform.</span>
                <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">needRuntime } = directiveTransform(prop</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">!ssr &amp;&amp; props.forEach(analyzePatchFlag)</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isVOn &amp;&amp; arg &amp;&amp; !isStaticExp(arg)) {</span>
                    <span class="s1">pushMergeArg(createObjectExpression(props</span><span class="s2">, </span><span class="s1">elementLoc))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">properties.push(...props)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(needRuntime) {</span>
                    <span class="s1">runtimeDirectives.push(prop)</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isSymbol(needRuntime)) {</span>
                        <span class="s1">directiveImportMap.set(prop</span><span class="s2">, </span><span class="s1">needRuntime)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!isBuiltInDirective(name)) {</span>
                <span class="s5">// no built-in transform, this is a user custom directive.</span>
                <span class="s1">runtimeDirectives.push(prop)</span><span class="s2">;</span>
                <span class="s5">// custom dirs may use beforeUpdate so they need to force blocks</span>
                <span class="s5">// to ensure before-update gets called before children update</span>
                <span class="s2">if </span><span class="s1">(hasChildren) {</span>
                    <span class="s1">shouldUseBlock = </span><span class="s2">true;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">propsExpression = undefined</span><span class="s2">;</span>
    <span class="s5">// has v-bind=&quot;object&quot; or v-on=&quot;object&quot;, wrap with mergeProps</span>
    <span class="s2">if </span><span class="s1">(mergeArgs.length) {</span>
        <span class="s5">// close up any not-yet-merged props</span>
        <span class="s1">pushMergeArg()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mergeArgs.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">propsExpression = createCallExpression(context.helper(MERGE_PROPS)</span><span class="s2">, </span><span class="s1">mergeArgs</span><span class="s2">, </span><span class="s1">elementLoc)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// single v-bind with nothing else - no need for a mergeProps call</span>
            <span class="s1">propsExpression = mergeArgs[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(properties.length) {</span>
        <span class="s1">propsExpression = createObjectExpression(dedupeProperties(properties)</span><span class="s2">, </span><span class="s1">elementLoc)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// patchFlag analysis</span>
    <span class="s2">if </span><span class="s1">(hasDynamicKeys) {</span>
        <span class="s1">patchFlag |= </span><span class="s4">16 </span><span class="s5">/* PatchFlags.FULL_PROPS */</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(hasClassBinding &amp;&amp; !isComponent) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">2 </span><span class="s5">/* PatchFlags.CLASS */</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hasStyleBinding &amp;&amp; !isComponent) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">4 </span><span class="s5">/* PatchFlags.STYLE */</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(dynamicPropNames.length) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">8 </span><span class="s5">/* PatchFlags.PROPS */</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hasHydrationEventBinding) {</span>
            <span class="s1">patchFlag |= </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!shouldUseBlock &amp;&amp;</span>
        <span class="s1">(patchFlag === </span><span class="s4">0 </span><span class="s1">|| patchFlag === </span><span class="s4">32 </span><span class="s5">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(hasRef || hasVnodeHook || runtimeDirectives.length &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">patchFlag |= </span><span class="s4">512 </span><span class="s5">/* PatchFlags.NEED_PATCH */</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// pre-normalize props, SSR is skipped for now</span>
    <span class="s2">if </span><span class="s1">(!context.inSSR &amp;&amp; propsExpression) {</span>
        <span class="s2">switch </span><span class="s1">(propsExpression.type) {</span>
            <span class="s2">case </span><span class="s4">15 </span><span class="s5">/* NodeTypes.JS_OBJECT_EXPRESSION */</span><span class="s1">:</span>
                <span class="s5">// means that there is no v-bind,</span>
                <span class="s5">// but still need to deal with dynamic key binding</span>
                <span class="s2">let </span><span class="s1">classKeyIndex = -</span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">styleKeyIndex = -</span><span class="s4">1</span><span class="s2">;</span>
                <span class="s2">let </span><span class="s1">hasDynamicKey = </span><span class="s2">false;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; propsExpression.properties.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                    <span class="s2">const </span><span class="s1">key = propsExpression.properties[i].key</span><span class="s2">;</span>
                    <span class="s2">if </span><span class="s1">(isStaticExp(key)) {</span>
                        <span class="s2">if </span><span class="s1">(key.content === </span><span class="s3">'class'</span><span class="s1">) {</span>
                            <span class="s1">classKeyIndex = i</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">else if </span><span class="s1">(key.content === </span><span class="s3">'style'</span><span class="s1">) {</span>
                            <span class="s1">styleKeyIndex = i</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(!key.isHandlerKey) {</span>
                        <span class="s1">hasDynamicKey = </span><span class="s2">true;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">classProp = propsExpression.properties[classKeyIndex]</span><span class="s2">;</span>
                <span class="s2">const </span><span class="s1">styleProp = propsExpression.properties[styleKeyIndex]</span><span class="s2">;</span>
                <span class="s5">// no dynamic key</span>
                <span class="s2">if </span><span class="s1">(!hasDynamicKey) {</span>
                    <span class="s2">if </span><span class="s1">(classProp &amp;&amp; !isStaticExp(classProp.value)) {</span>
                        <span class="s1">classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS)</span><span class="s2">, </span><span class="s1">[classProp.value])</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(styleProp &amp;&amp;</span>
                        <span class="s5">// the static style is compiled into an object,</span>
                        <span class="s5">// so use `hasStyleBinding` to ensure that it is a dynamic style binding</span>
                        <span class="s1">(hasStyleBinding ||</span>
                            <span class="s1">(styleProp.value.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">styleProp.value.content.trim()[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">`[`</span><span class="s1">) ||</span>
                            <span class="s5">// v-bind:style and style both exist,</span>
                            <span class="s5">// v-bind:style with static literal object</span>
                            <span class="s1">styleProp.value.type === </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">)) {</span>
                        <span class="s1">styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE)</span><span class="s2">, </span><span class="s1">[styleProp.value])</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s5">// dynamic key binding, wrap with `normalizeProps`</span>
                    <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s2">, </span><span class="s1">[propsExpression])</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">break;</span>
            <span class="s2">case </span><span class="s4">14 </span><span class="s5">/* NodeTypes.JS_CALL_EXPRESSION */</span><span class="s1">:</span>
                <span class="s5">// mergeProps call, do nothing</span>
                <span class="s2">break;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s5">// single v-bind</span>
                <span class="s1">propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS)</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">createCallExpression(context.helper(GUARD_REACTIVE_PROPS)</span><span class="s2">, </span><span class="s1">[</span>
                        <span class="s1">propsExpression</span>
                    <span class="s1">])</span>
                <span class="s1">])</span><span class="s2">;</span>
                <span class="s2">break;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">props: propsExpression</span><span class="s2">,</span>
        <span class="s1">directives: runtimeDirectives</span><span class="s2">,</span>
        <span class="s1">patchFlag</span><span class="s2">,</span>
        <span class="s1">dynamicPropNames</span><span class="s2">,</span>
        <span class="s1">shouldUseBlock</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// Dedupe props in an object literal.</span>
<span class="s5">// Literal duplicated attributes would have been warned during the parse phase,</span>
<span class="s5">// however, it's possible to encounter duplicated `onXXX` handlers with different</span>
<span class="s5">// modifiers. We also need to merge static and dynamic class / style attributes.</span>
<span class="s5">// - onXXX handlers / style: merge into array</span>
<span class="s5">// - class: merge into single expression with concatenation</span>
<span class="s2">function </span><span class="s1">dedupeProperties(properties) {</span>
    <span class="s2">const </span><span class="s1">knownProps = </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">deduped = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; properties.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">prop = properties[i]</span><span class="s2">;</span>
        <span class="s5">// dynamic keys are always allowed</span>
        <span class="s2">if </span><span class="s1">(prop.key.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */ </span><span class="s1">|| !prop.key.isStatic) {</span>
            <span class="s1">deduped.push(prop)</span><span class="s2">;</span>
            <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">name = prop.key.content</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">existing = knownProps.get(name)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(existing) {</span>
            <span class="s2">if </span><span class="s1">(name === </span><span class="s3">'style' </span><span class="s1">|| name === </span><span class="s3">'class' </span><span class="s1">|| isOn(name)) {</span>
                <span class="s1">mergeAsArray(existing</span><span class="s2">, </span><span class="s1">prop)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s5">// unexpected duplicate, should have emitted error during parse</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">knownProps.set(name</span><span class="s2">, </span><span class="s1">prop)</span><span class="s2">;</span>
            <span class="s1">deduped.push(prop)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">deduped</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeAsArray(existing</span><span class="s2">, </span><span class="s1">incoming) {</span>
    <span class="s2">if </span><span class="s1">(existing.value.type === </span><span class="s4">17 </span><span class="s5">/* NodeTypes.JS_ARRAY_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">existing.value.elements.push(incoming.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">existing.value = createArrayExpression([existing.value</span><span class="s2">, </span><span class="s1">incoming.value]</span><span class="s2">, </span><span class="s1">existing.loc)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">buildDirectiveArgs(dir</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">const </span><span class="s1">dirArgs = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">runtime = directiveImportMap.get(dir)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(runtime) {</span>
        <span class="s5">// built-in directive with runtime</span>
        <span class="s1">dirArgs.push(context.helperString(runtime))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">{</span>
            <span class="s5">// inject statement for resolving directive</span>
            <span class="s1">context.helper(RESOLVE_DIRECTIVE)</span><span class="s2">;</span>
            <span class="s1">context.directives.add(dir.name)</span><span class="s2">;</span>
            <span class="s1">dirArgs.push(toValidAssetId(dir.name</span><span class="s2">, </span><span class="s3">`directive`</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ loc } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dir.exp)</span>
        <span class="s1">dirArgs.push(dir.exp)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dir.arg) {</span>
        <span class="s2">if </span><span class="s1">(!dir.exp) {</span>
            <span class="s1">dirArgs.push(</span><span class="s3">`void 0`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">dirArgs.push(dir.arg)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Object.keys(dir.modifiers).length) {</span>
        <span class="s2">if </span><span class="s1">(!dir.arg) {</span>
            <span class="s2">if </span><span class="s1">(!dir.exp) {</span>
                <span class="s1">dirArgs.push(</span><span class="s3">`void 0`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">dirArgs.push(</span><span class="s3">`void 0`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">trueExpression = createSimpleExpression(</span><span class="s3">`true`</span><span class="s2">, false, </span><span class="s1">loc)</span><span class="s2">;</span>
        <span class="s1">dirArgs.push(createObjectExpression(dir.modifiers.map(modifier =&gt; createObjectProperty(modifier</span><span class="s2">, </span><span class="s1">trueExpression))</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createArrayExpression(dirArgs</span><span class="s2">, </span><span class="s1">dir.loc)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">stringifyDynamicPropNames(props) {</span>
    <span class="s2">let </span><span class="s1">propsNamesString = </span><span class="s3">`[`</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = props.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">propsNamesString += JSON.stringify(props[i])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(i &lt; l - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">propsNamesString += </span><span class="s3">', '</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">propsNamesString + </span><span class="s3">`]`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isComponentTag(tag) {</span>
    <span class="s2">return </span><span class="s1">tag === </span><span class="s3">'component' </span><span class="s1">|| tag === </span><span class="s3">'Component'</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">transformSlotOutlet = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(isSlotOutlet(node)) {</span>
        <span class="s2">const </span><span class="s1">{ children</span><span class="s2">, </span><span class="s1">loc } = node</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ slotName</span><span class="s2">, </span><span class="s1">slotProps } = processSlotOutlet(node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">slotArgs = [</span>
            <span class="s1">context.prefixIdentifiers ? </span><span class="s3">`_ctx.$slots` </span><span class="s1">: </span><span class="s3">`$slots`</span><span class="s2">,</span>
            <span class="s1">slotName</span><span class="s2">,</span>
            <span class="s3">'{}'</span><span class="s2">,</span>
            <span class="s3">'undefined'</span><span class="s2">,</span>
            <span class="s3">'true'</span>
        <span class="s1">]</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">expectedLen = </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(slotProps) {</span>
            <span class="s1">slotArgs[</span><span class="s4">2</span><span class="s1">] = slotProps</span><span class="s2">;</span>
            <span class="s1">expectedLen = </span><span class="s4">3</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(children.length) {</span>
            <span class="s1">slotArgs[</span><span class="s4">3</span><span class="s1">] = createFunctionExpression([]</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, false, false, </span><span class="s1">loc)</span><span class="s2">;</span>
            <span class="s1">expectedLen = </span><span class="s4">4</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(context.scopeId &amp;&amp; !context.slotted) {</span>
            <span class="s1">expectedLen = </span><span class="s4">5</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">slotArgs.splice(expectedLen)</span><span class="s2">; </span><span class="s5">// remove unused arguments</span>
        <span class="s1">node.codegenNode = createCallExpression(context.helper(RENDER_SLOT)</span><span class="s2">, </span><span class="s1">slotArgs</span><span class="s2">, </span><span class="s1">loc)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">processSlotOutlet(node</span><span class="s2">, </span><span class="s1">context) {</span>
    <span class="s2">let </span><span class="s1">slotName = </span><span class="s3">`&quot;default&quot;`</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">slotProps = undefined</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nonNameProps = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; node.props.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">p = node.props[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(p.value) {</span>
                <span class="s2">if </span><span class="s1">(p.name === </span><span class="s3">'name'</span><span class="s1">) {</span>
                    <span class="s1">slotName = JSON.stringify(p.value.content)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">p.name = camelize(p.name)</span><span class="s2">;</span>
                    <span class="s1">nonNameProps.push(p)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp; isStaticArgOf(p.arg</span><span class="s2">, </span><span class="s3">'name'</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(p.exp)</span>
                    <span class="s1">slotName = p.exp</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(p.name === </span><span class="s3">'bind' </span><span class="s1">&amp;&amp; p.arg &amp;&amp; isStaticExp(p.arg)) {</span>
                    <span class="s1">p.arg.content = camelize(p.arg.content)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">nonNameProps.push(p)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nonNameProps.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">directives } = buildProps(node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">nonNameProps</span><span class="s2">, false, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">slotProps = props</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(directives.length) {</span>
            <span class="s1">context.onError(createCompilerError(</span><span class="s4">36 </span><span class="s5">/* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */</span><span class="s2">, </span><span class="s1">directives[</span><span class="s4">0</span><span class="s1">].loc))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">slotName</span><span class="s2">,</span>
        <span class="s1">slotProps</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">fnExpRE = </span><span class="s4">/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=&gt;|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">transformOn$1 = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">augmentor) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ loc</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">, </span><span class="s1">arg } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!dir.exp &amp;&amp; !modifiers.length) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">35 </span><span class="s5">/* ErrorCodes.X_V_ON_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">eventName</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(arg.isStatic) {</span>
            <span class="s2">let </span><span class="s1">rawName = arg.content</span><span class="s2">;</span>
            <span class="s5">// TODO deprecate @vnodeXXX usage</span>
            <span class="s2">if </span><span class="s1">(rawName.startsWith(</span><span class="s3">'vue:'</span><span class="s1">)) {</span>
                <span class="s1">rawName = </span><span class="s3">`vnode-</span><span class="s1">${rawName.slice(</span><span class="s4">4</span><span class="s1">)}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">eventString = node.tagType !== </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">||</span>
                <span class="s1">rawName.startsWith(</span><span class="s3">'vnode'</span><span class="s1">) ||</span>
                <span class="s1">!</span><span class="s4">/[A-Z]/</span><span class="s1">.test(rawName)</span>
                <span class="s1">? </span><span class="s5">// for non-element and vnode lifecycle event listeners, auto convert</span>
                    <span class="s5">// it to camelCase. See issue #2249</span>
                    <span class="s1">toHandlerKey(camelize(rawName))</span>
                <span class="s1">: </span><span class="s5">// preserve case for plain element listeners that have uppercase</span>
                    <span class="s5">// letters, as these may be custom elements' custom events</span>
                    <span class="s3">`on:</span><span class="s1">${rawName}</span><span class="s3">`</span><span class="s2">;</span>
            <span class="s1">eventName = createSimpleExpression(eventString</span><span class="s2">, true, </span><span class="s1">arg.loc)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// #2388</span>
            <span class="s1">eventName = createCompoundExpression([</span>
                <span class="s3">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s3">(`</span><span class="s2">,</span>
                <span class="s1">arg</span><span class="s2">,</span>
                <span class="s3">`)`</span>
            <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s5">// already a compound expression.</span>
        <span class="s1">eventName = arg</span><span class="s2">;</span>
        <span class="s1">eventName.children.unshift(</span><span class="s3">`</span><span class="s1">${context.helperString(TO_HANDLER_KEY)}</span><span class="s3">(`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">eventName.children.push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// handler processing</span>
    <span class="s2">let </span><span class="s1">exp = dir.exp</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(exp &amp;&amp; !exp.content.trim()) {</span>
        <span class="s1">exp = undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">shouldCache = context.cacheHandlers &amp;&amp; !exp &amp;&amp; !context.inVOnce</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(exp) {</span>
        <span class="s2">const </span><span class="s1">isMemberExp = isMemberExpression(exp.content)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">hasMultipleStatements = exp.content.includes(</span><span class="s3">`;`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">{</span>
            <span class="s1">validateBrowserExpression(exp</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, false, </span><span class="s1">hasMultipleStatements)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isInlineStatement || (shouldCache &amp;&amp; isMemberExp)) {</span>
            <span class="s5">// wrap inline statement in a function expression</span>
            <span class="s1">exp = createCompoundExpression([</span>
                <span class="s3">`</span><span class="s1">${isInlineStatement</span>
                    <span class="s1">? </span><span class="s3">`$event`</span>
                    <span class="s1">: </span><span class="s3">`</span><span class="s1">${</span><span class="s3">``</span><span class="s1">}</span><span class="s3">(...args)`</span><span class="s1">} </span><span class="s3">=&gt; </span><span class="s1">${hasMultipleStatements ? </span><span class="s3">`{` </span><span class="s1">: </span><span class="s3">`(`</span><span class="s1">}</span><span class="s3">`</span><span class="s2">,</span>
                <span class="s1">exp</span><span class="s2">,</span>
                <span class="s1">hasMultipleStatements ? </span><span class="s3">`}` </span><span class="s1">: </span><span class="s3">`)`</span>
            <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">ret = {</span>
        <span class="s1">props: [</span>
            <span class="s1">createObjectProperty(eventName</span><span class="s2">, </span><span class="s1">exp || createSimpleExpression(</span><span class="s3">`() =&gt; {}`</span><span class="s2">, false, </span><span class="s1">loc))</span>
        <span class="s1">]</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s5">// apply extended compiler augmentor</span>
    <span class="s2">if </span><span class="s1">(augmentor) {</span>
        <span class="s1">ret = augmentor(ret)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shouldCache) {</span>
        <span class="s5">// cache handlers so that it's always the same handler being passed down.</span>
        <span class="s5">// this avoids unnecessary re-renders when users use inline handlers on</span>
        <span class="s5">// components.</span>
        <span class="s1">ret.props[</span><span class="s4">0</span><span class="s1">].value = context.cache(ret.props[</span><span class="s4">0</span><span class="s1">].value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// mark the key as handler for props normalization check</span>
    <span class="s1">ret.props.forEach(p =&gt; (p.key.isHandlerKey = </span><span class="s2">true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">// v-bind without arg is handled directly in ./transformElements.ts due to it affecting</span>
<span class="s5">// codegen for the entire props object. This transform here is only for v-bind</span>
<span class="s5">// *with* args.</span>
<span class="s2">const </span><span class="s1">transformBind = (dir</span><span class="s2">, </span><span class="s1">_node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ exp</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">, </span><span class="s1">loc } = dir</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">arg = dir.arg</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(arg.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s1">arg.children.unshift(</span><span class="s3">`(`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">arg.children.push(</span><span class="s3">`) || &quot;&quot;`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!arg.isStatic) {</span>
        <span class="s1">arg.content = </span><span class="s3">`</span><span class="s1">${arg.content} </span><span class="s3">|| &quot;&quot;`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// .sync is replaced by v-model:arg</span>
    <span class="s2">if </span><span class="s1">(modifiers.includes(</span><span class="s3">'camel'</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(arg.isStatic) {</span>
                <span class="s1">arg.content = camelize(arg.content)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">arg.content = </span><span class="s3">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s3">(</span><span class="s1">${arg.content}</span><span class="s3">)`</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">arg.children.unshift(</span><span class="s3">`</span><span class="s1">${context.helperString(CAMELIZE)}</span><span class="s3">(`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">arg.children.push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!context.inSSR) {</span>
        <span class="s2">if </span><span class="s1">(modifiers.includes(</span><span class="s3">'prop'</span><span class="s1">)) {</span>
            <span class="s1">injectPrefix(arg</span><span class="s2">, </span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(modifiers.includes(</span><span class="s3">'attr'</span><span class="s1">)) {</span>
            <span class="s1">injectPrefix(arg</span><span class="s2">, </span><span class="s3">'^'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!exp ||</span>
        <span class="s1">(exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp; !exp.content.trim())) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">34 </span><span class="s5">/* ErrorCodes.X_V_BIND_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">props: [createObjectProperty(arg</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">''</span><span class="s2">, true, </span><span class="s1">loc))]</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">props: [createObjectProperty(arg</span><span class="s2">, </span><span class="s1">exp)]</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">injectPrefix = (arg</span><span class="s2">, </span><span class="s1">prefix) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(arg.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(arg.isStatic) {</span>
            <span class="s1">arg.content = prefix + arg.content</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">arg.content = </span><span class="s3">`</span><span class="s2">\`</span><span class="s1">${prefix}</span><span class="s2">\$</span><span class="s3">{</span><span class="s1">${arg.content}</span><span class="s3">}</span><span class="s2">\`</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">arg.children.unshift(</span><span class="s3">`'</span><span class="s1">${prefix}</span><span class="s3">' + (`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">arg.children.push(</span><span class="s3">`)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">// Merge adjacent text nodes and expressions into a single expression</span>
<span class="s5">// e.g. &lt;div&gt;abc {{ d }} {{ e }}&lt;/div&gt; should have a single expression node as child.</span>
<span class="s2">const </span><span class="s1">transformText = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */ </span><span class="s1">||</span>
        <span class="s1">node.type === </span><span class="s4">10 </span><span class="s5">/* NodeTypes.IF_BRANCH */</span><span class="s1">) {</span>
        <span class="s5">// perform the transform on node exit so that all expressions have already</span>
        <span class="s5">// been processed.</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">children = node.children</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">currentContainer = undefined</span><span class="s2">;</span>
            <span class="s2">let </span><span class="s1">hasText = </span><span class="s2">false;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isText$1(child)) {</span>
                    <span class="s1">hasText = </span><span class="s2">true;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s2">; </span><span class="s1">j &lt; children.length</span><span class="s2">; </span><span class="s1">j++) {</span>
                        <span class="s2">const </span><span class="s1">next = children[j]</span><span class="s2">;</span>
                        <span class="s2">if </span><span class="s1">(isText$1(next)) {</span>
                            <span class="s2">if </span><span class="s1">(!currentContainer) {</span>
                                <span class="s1">currentContainer = children[i] = createCompoundExpression([child]</span><span class="s2">, </span><span class="s1">child.loc)</span><span class="s2">;</span>
                            <span class="s1">}</span>
                            <span class="s5">// merge adjacent text node into current</span>
                            <span class="s1">currentContainer.children.push(</span><span class="s3">` + `</span><span class="s2">, </span><span class="s1">next)</span><span class="s2">;</span>
                            <span class="s1">children.splice(j</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
                            <span class="s1">j--</span><span class="s2">;</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s1">currentContainer = undefined</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!hasText ||</span>
                <span class="s5">// if this is a plain element with a single text child, leave it</span>
                <span class="s5">// as-is since the runtime has dedicated fast path for this by directly</span>
                <span class="s5">// setting textContent of the element.</span>
                <span class="s5">// for component root it's always normalized anyway.</span>
                <span class="s1">(children.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">(node.type === </span><span class="s4">0 </span><span class="s5">/* NodeTypes.ROOT */ </span><span class="s1">||</span>
                        <span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
                            <span class="s5">// #3756</span>
                            <span class="s5">// custom directives can potentially add DOM elements arbitrarily,</span>
                            <span class="s5">// we need to avoid setting textContent of the element at runtime</span>
                            <span class="s5">// to avoid accidentally overwriting the DOM elements added</span>
                            <span class="s5">// by the user through custom directives.</span>
                            <span class="s1">!node.props.find(p =&gt; p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">!context.directiveTransforms[p.name]) &amp;&amp;</span>
                            <span class="s5">// in compat mode, &lt;template&gt; tags with no special directives</span>
                            <span class="s5">// will be rendered as a fragment so its children must be</span>
                            <span class="s5">// converted into vnodes.</span>
                            <span class="s1">!(</span><span class="s2">false </span><span class="s1">))))) {</span>
                <span class="s2">return;</span>
            <span class="s1">}</span>
            <span class="s5">// pre-convert text nodes into createTextVNode(text) calls to avoid</span>
            <span class="s5">// runtime normalization.</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(isText$1(child) || child.type === </span><span class="s4">8 </span><span class="s5">/* NodeTypes.COMPOUND_EXPRESSION */</span><span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">callArgs = []</span><span class="s2">;</span>
                    <span class="s5">// createTextVNode defaults to single whitespace, so if it is a</span>
                    <span class="s5">// single space the code could be an empty call to save bytes.</span>
                    <span class="s2">if </span><span class="s1">(child.type !== </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">|| child.content !== </span><span class="s3">' '</span><span class="s1">) {</span>
                        <span class="s1">callArgs.push(child)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s5">// mark dynamic text with flag so it gets patched inside a block</span>
                    <span class="s2">if </span><span class="s1">(!context.ssr &amp;&amp;</span>
                        <span class="s1">getConstantType(child</span><span class="s2">, </span><span class="s1">context) === </span><span class="s4">0 </span><span class="s5">/* ConstantTypes.NOT_CONSTANT */</span><span class="s1">) {</span>
                        <span class="s1">callArgs.push(</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */ </span><span class="s1">+</span>
                            <span class="s1">(</span><span class="s3">` /* </span><span class="s1">${PatchFlagNames[</span><span class="s4">1 </span><span class="s5">/* PatchFlags.TEXT */</span><span class="s1">]} </span><span class="s3">*/` </span><span class="s1">))</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s1">children[i] = {</span>
                        <span class="s1">type: </span><span class="s4">12 </span><span class="s5">/* NodeTypes.TEXT_CALL */</span><span class="s2">,</span>
                        <span class="s1">content: child</span><span class="s2">,</span>
                        <span class="s1">loc: child.loc</span><span class="s2">,</span>
                        <span class="s1">codegenNode: createCallExpression(context.helper(CREATE_TEXT)</span><span class="s2">, </span><span class="s1">callArgs)</span>
                    <span class="s1">}</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">seen$1 = </span><span class="s2">new </span><span class="s1">WeakSet()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">transformOnce = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp; findDir(node</span><span class="s2">, </span><span class="s3">'once'</span><span class="s2">, true</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(seen$1.has(node) || context.inVOnce) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">seen$1.add(node)</span><span class="s2">;</span>
        <span class="s1">context.inVOnce = </span><span class="s2">true;</span>
        <span class="s1">context.helper(SET_BLOCK_TRACKING)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s1">context.inVOnce = </span><span class="s2">false;</span>
            <span class="s2">const </span><span class="s1">cur = context.currentNode</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(cur.codegenNode) {</span>
                <span class="s1">cur.codegenNode = context.cache(cur.codegenNode</span><span class="s2">, true </span><span class="s5">/* isVNode */</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformModel$1 = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ exp</span><span class="s2">, </span><span class="s1">arg } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!exp) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">41 </span><span class="s5">/* ErrorCodes.X_V_MODEL_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">createTransformProps()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">rawExp = exp.loc.source</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">expString = exp.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">? exp.content : rawExp</span><span class="s2">;</span>
    <span class="s5">// im SFC &lt;script setup&gt; inline mode, the exp may have been transformed into</span>
    <span class="s5">// _unref(exp)</span>
    <span class="s2">const </span><span class="s1">bindingType = context.bindingMetadata[rawExp]</span><span class="s2">;</span>
    <span class="s5">// check props</span>
    <span class="s2">if </span><span class="s1">(bindingType === </span><span class="s3">&quot;props&quot; </span><span class="s5">/* BindingTypes.PROPS */ </span><span class="s1">||</span>
        <span class="s1">bindingType === </span><span class="s3">&quot;props-aliased&quot; </span><span class="s5">/* BindingTypes.PROPS_ALIASED */</span><span class="s1">) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">44 </span><span class="s5">/* ErrorCodes.X_V_MODEL_ON_PROPS */</span><span class="s2">, </span><span class="s1">exp.loc))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">createTransformProps()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">maybeRef = !</span><span class="s2">true  ;</span>
    <span class="s2">if </span><span class="s1">(!expString.trim() ||</span>
        <span class="s1">(!isMemberExpression(expString) &amp;&amp; !maybeRef)) {</span>
        <span class="s1">context.onError(createCompilerError(</span><span class="s4">42 </span><span class="s5">/* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */</span><span class="s2">, </span><span class="s1">exp.loc))</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">createTransformProps()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">propName = arg ? arg : createSimpleExpression(</span><span class="s3">'modelValue'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">eventName = arg</span>
        <span class="s1">? isStaticExp(arg)</span>
            <span class="s1">? </span><span class="s3">`onUpdate:</span><span class="s1">${camelize(arg.content)}</span><span class="s3">`</span>
            <span class="s1">: createCompoundExpression([</span><span class="s3">'&quot;onUpdate:&quot; + '</span><span class="s2">, </span><span class="s1">arg])</span>
        <span class="s1">: </span><span class="s3">`onUpdate:modelValue`</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">assignmentExp</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">eventArg = context.isTS ? </span><span class="s3">`($event: any)` </span><span class="s1">: </span><span class="s3">`$event`</span><span class="s2">;</span>
    <span class="s1">{</span>
        <span class="s1">assignmentExp = createCompoundExpression([</span>
            <span class="s3">`</span><span class="s1">${eventArg} </span><span class="s3">=&gt; ((`</span><span class="s2">,</span>
            <span class="s1">exp</span><span class="s2">,</span>
            <span class="s3">`) = $event)`</span>
        <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">props = [</span>
        <span class="s5">// modelValue: foo</span>
        <span class="s1">createObjectProperty(propName</span><span class="s2">, </span><span class="s1">dir.exp)</span><span class="s2">,</span>
        <span class="s5">// &quot;onUpdate:modelValue&quot;: $event =&gt; (foo = $event)</span>
        <span class="s1">createObjectProperty(eventName</span><span class="s2">, </span><span class="s1">assignmentExp)</span>
    <span class="s1">]</span><span class="s2">;</span>
    <span class="s5">// modelModifiers: { foo: true, &quot;bar-baz&quot;: true }</span>
    <span class="s2">if </span><span class="s1">(dir.modifiers.length &amp;&amp; node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">modifiers = dir.modifiers</span>
            <span class="s1">.map(m =&gt; (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + </span><span class="s3">`: true`</span><span class="s1">)</span>
            <span class="s1">.join(</span><span class="s3">`, `</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">modifiersKey = arg</span>
            <span class="s1">? isStaticExp(arg)</span>
                <span class="s1">? </span><span class="s3">`</span><span class="s1">${arg.content}</span><span class="s3">Modifiers`</span>
                <span class="s1">: createCompoundExpression([arg</span><span class="s2">, </span><span class="s3">' + &quot;Modifiers&quot;'</span><span class="s1">])</span>
            <span class="s1">: </span><span class="s3">`modelModifiers`</span><span class="s2">;</span>
        <span class="s1">props.push(createObjectProperty(modifiersKey</span><span class="s2">, </span><span class="s1">createSimpleExpression(</span><span class="s3">`{ </span><span class="s1">${modifiers} </span><span class="s3">}`</span><span class="s2">, false, </span><span class="s1">dir.loc</span><span class="s2">, </span><span class="s4">2 </span><span class="s5">/* ConstantTypes.CAN_HOIST */</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createTransformProps(props)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createTransformProps(props = []) {</span>
    <span class="s2">return </span><span class="s1">{ props }</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">seen = </span><span class="s2">new </span><span class="s1">WeakSet()</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">transformMemo = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">dir = findDir(node</span><span class="s2">, </span><span class="s3">'memo'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!dir || seen.has(node)) {</span>
            <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">seen.add(node)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s2">const </span><span class="s1">codegenNode = node.codegenNode ||</span>
                <span class="s1">context.currentNode.codegenNode</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(codegenNode &amp;&amp; codegenNode.type === </span><span class="s4">13 </span><span class="s5">/* NodeTypes.VNODE_CALL */</span><span class="s1">) {</span>
                <span class="s5">// non-component sub tree should be turned into a block</span>
                <span class="s2">if </span><span class="s1">(node.tagType !== </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
                    <span class="s1">makeBlock(codegenNode</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s1">node.codegenNode = createCallExpression(context.helper(WITH_MEMO)</span><span class="s2">, </span><span class="s1">[</span>
                    <span class="s1">dir.exp</span><span class="s2">,</span>
                    <span class="s1">createFunctionExpression(undefined</span><span class="s2">, </span><span class="s1">codegenNode)</span><span class="s2">,</span>
                    <span class="s3">`_cache`</span><span class="s2">,</span>
                    <span class="s1">String(context.cached++)</span>
                <span class="s1">])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">getBaseTransformPreset(prefixIdentifiers) {</span>
    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">[</span>
            <span class="s1">transformOnce</span><span class="s2">,</span>
            <span class="s1">transformIf</span><span class="s2">,</span>
            <span class="s1">transformMemo</span><span class="s2">,</span>
            <span class="s1">transformFor</span><span class="s2">,</span>
            <span class="s1">...([])</span><span class="s2">,</span>
            <span class="s1">...([transformExpression]</span>
                    <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">transformSlotOutlet</span><span class="s2">,</span>
            <span class="s1">transformElement</span><span class="s2">,</span>
            <span class="s1">trackSlotScopes</span><span class="s2">,</span>
            <span class="s1">transformText</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">{</span>
            <span class="s1">on: transformOn$1</span><span class="s2">,</span>
            <span class="s1">bind: transformBind</span><span class="s2">,</span>
            <span class="s1">model: transformModel$1</span>
        <span class="s1">}</span>
    <span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s5">// we name it `baseCompile` so that higher order compilers like</span>
<span class="s5">// @vue/compiler-dom can export `compile` while re-exporting everything else.</span>
<span class="s2">function </span><span class="s1">baseCompile(template</span><span class="s2">, </span><span class="s1">options = {}) {</span>
    <span class="s2">const </span><span class="s1">onError = options.onError || defaultOnError</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isModuleMode = options.mode === </span><span class="s3">'module'</span><span class="s2">;</span>
    <span class="s5">/* istanbul ignore if */</span>
    <span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(options.prefixIdentifiers === </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">onError(createCompilerError(</span><span class="s4">47 </span><span class="s5">/* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isModuleMode) {</span>
            <span class="s1">onError(createCompilerError(</span><span class="s4">48 </span><span class="s5">/* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">prefixIdentifiers = !</span><span class="s2">true ;</span>
    <span class="s2">if </span><span class="s1">(options.cacheHandlers) {</span>
        <span class="s1">onError(createCompilerError(</span><span class="s4">49 </span><span class="s5">/* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(options.scopeId &amp;&amp; !isModuleMode) {</span>
        <span class="s1">onError(createCompilerError(</span><span class="s4">50 </span><span class="s5">/* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">ast = isString(template) ? baseParse(template</span><span class="s2">, </span><span class="s1">options) : template</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">[nodeTransforms</span><span class="s2">, </span><span class="s1">directiveTransforms] = getBaseTransformPreset()</span><span class="s2">;</span>
    <span class="s1">transform(ast</span><span class="s2">, </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">prefixIdentifiers</span><span class="s2">,</span>
        <span class="s1">nodeTransforms: [</span>
            <span class="s1">...nodeTransforms</span><span class="s2">,</span>
            <span class="s1">...(options.nodeTransforms || []) </span><span class="s5">// user transforms</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">directiveTransforms: extend({}</span><span class="s2">, </span><span class="s1">directiveTransforms</span><span class="s2">, </span><span class="s1">options.directiveTransforms || {} </span><span class="s5">// user transforms</span>
        <span class="s1">)</span>
    <span class="s1">}))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">generate(ast</span><span class="s2">, </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">prefixIdentifiers</span>
    <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">noopDirectiveTransform = () =&gt; ({ props: [] })</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">V_MODEL_RADIO = Symbol(</span><span class="s3">`vModelRadio` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_MODEL_CHECKBOX = Symbol(</span><span class="s3">`vModelCheckbox` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_MODEL_TEXT = Symbol(</span><span class="s3">`vModelText` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_MODEL_SELECT = Symbol(</span><span class="s3">`vModelSelect` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_MODEL_DYNAMIC = Symbol(</span><span class="s3">`vModelDynamic` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_ON_WITH_MODIFIERS = Symbol(</span><span class="s3">`vOnModifiersGuard` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_ON_WITH_KEYS = Symbol(</span><span class="s3">`vOnKeysGuard` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">V_SHOW = Symbol(</span><span class="s3">`vShow` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TRANSITION = Symbol(</span><span class="s3">`Transition` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">TRANSITION_GROUP = Symbol(</span><span class="s3">`TransitionGroup` </span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">registerRuntimeHelpers({</span>
    <span class="s1">[V_MODEL_RADIO]: </span><span class="s3">`vModelRadio`</span><span class="s2">,</span>
    <span class="s1">[V_MODEL_CHECKBOX]: </span><span class="s3">`vModelCheckbox`</span><span class="s2">,</span>
    <span class="s1">[V_MODEL_TEXT]: </span><span class="s3">`vModelText`</span><span class="s2">,</span>
    <span class="s1">[V_MODEL_SELECT]: </span><span class="s3">`vModelSelect`</span><span class="s2">,</span>
    <span class="s1">[V_MODEL_DYNAMIC]: </span><span class="s3">`vModelDynamic`</span><span class="s2">,</span>
    <span class="s1">[V_ON_WITH_MODIFIERS]: </span><span class="s3">`withModifiers`</span><span class="s2">,</span>
    <span class="s1">[V_ON_WITH_KEYS]: </span><span class="s3">`withKeys`</span><span class="s2">,</span>
    <span class="s1">[V_SHOW]: </span><span class="s3">`vShow`</span><span class="s2">,</span>
    <span class="s1">[TRANSITION]: </span><span class="s3">`Transition`</span><span class="s2">,</span>
    <span class="s1">[TRANSITION_GROUP]: </span><span class="s3">`TransitionGroup`</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s5">/* eslint-disable no-restricted-globals */</span>
<span class="s2">let </span><span class="s1">decoder</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">decodeHtmlBrowser(raw</span><span class="s2">, </span><span class="s1">asAttr = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!decoder) {</span>
        <span class="s1">decoder = document.createElement(</span><span class="s3">'div'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(asAttr) {</span>
        <span class="s1">decoder.innerHTML = </span><span class="s3">`&lt;div foo=&quot;</span><span class="s1">${raw.replace(</span><span class="s4">/&quot;/g</span><span class="s2">, </span><span class="s3">'&amp;quot;'</span><span class="s1">)}</span><span class="s3">&quot;&gt;`</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">decoder.children[</span><span class="s4">0</span><span class="s1">].getAttribute(</span><span class="s3">'foo'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">decoder.innerHTML = raw</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">decoder.textContent</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isRawTextContainer = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">'style,iframe,script,noscript'</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">parserOptions = {</span>
    <span class="s1">isVoidTag</span><span class="s2">,</span>
    <span class="s1">isNativeTag: tag =&gt; isHTMLTag(tag) || isSVGTag(tag)</span><span class="s2">,</span>
    <span class="s1">isPreTag: tag =&gt; tag === </span><span class="s3">'pre'</span><span class="s2">,</span>
    <span class="s1">decodeEntities: decodeHtmlBrowser </span><span class="s2">,</span>
    <span class="s1">isBuiltInComponent: (tag) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">`Transition`</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">TRANSITION</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(isBuiltInType(tag</span><span class="s2">, </span><span class="s3">`TransitionGroup`</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">TRANSITION_GROUP</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher</span>
    <span class="s1">getNamespace(tag</span><span class="s2">, </span><span class="s1">parent) {</span>
        <span class="s2">let </span><span class="s1">ns = parent ? parent.ns : </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parent &amp;&amp; ns === </span><span class="s4">2 </span><span class="s5">/* DOMNamespaces.MATH_ML */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(parent.tag === </span><span class="s3">'annotation-xml'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'svg'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(parent.props.some(a =&gt; a.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">a.name === </span><span class="s3">'encoding' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">a.value != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">(a.value.content === </span><span class="s3">'text/html' </span><span class="s1">||</span>
                        <span class="s1">a.value.content === </span><span class="s3">'application/xhtml+xml'</span><span class="s1">))) {</span>
                    <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span><span class="s4">/^m(?:[ions]|text)$/</span><span class="s1">.test(parent.tag) &amp;&amp;</span>
                <span class="s1">tag !== </span><span class="s3">'mglyph' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">tag !== </span><span class="s3">'malignmark'</span><span class="s1">) {</span>
                <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(parent &amp;&amp; ns === </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(parent.tag === </span><span class="s3">'foreignObject' </span><span class="s1">||</span>
                <span class="s1">parent.tag === </span><span class="s3">'desc' </span><span class="s1">||</span>
                <span class="s1">parent.tag === </span><span class="s3">'title'</span><span class="s1">) {</span>
                <span class="s1">ns = </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(ns === </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'svg'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">1 </span><span class="s5">/* DOMNamespaces.SVG */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'math'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">2 </span><span class="s5">/* DOMNamespaces.MATH_ML */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">ns</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s5">// https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments</span>
    <span class="s1">getTextMode({ tag</span><span class="s2">, </span><span class="s1">ns }) {</span>
        <span class="s2">if </span><span class="s1">(ns === </span><span class="s4">0 </span><span class="s5">/* DOMNamespaces.HTML */</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'textarea' </span><span class="s1">|| tag === </span><span class="s3">'title'</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s4">1 </span><span class="s5">/* TextModes.RCDATA */</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isRawTextContainer(tag)) {</span>
                <span class="s2">return </span><span class="s4">2 </span><span class="s5">/* TextModes.RAWTEXT */</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s4">0 </span><span class="s5">/* TextModes.DATA */</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s5">// Parse inline CSS strings for static style attributes into an object.</span>
<span class="s5">// This is a NodeTransform since it works on the static `style` attribute and</span>
<span class="s5">// converts it into a dynamic equivalent:</span>
<span class="s5">// style=&quot;color: red&quot; -&gt; :style='{ &quot;color&quot;: &quot;red&quot; }'</span>
<span class="s5">// It is then processed by `transformElement` and included in the generated</span>
<span class="s5">// props.</span>
<span class="s2">const </span><span class="s1">transformStyle = node =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
        <span class="s1">node.props.forEach((p</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s3">'style' </span><span class="s1">&amp;&amp; p.value) {</span>
                <span class="s5">// replace p with an expression node</span>
                <span class="s1">node.props[i] = {</span>
                    <span class="s1">type: </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s2">,</span>
                    <span class="s1">name: </span><span class="s3">`bind`</span><span class="s2">,</span>
                    <span class="s1">arg: createSimpleExpression(</span><span class="s3">`style`</span><span class="s2">, true, </span><span class="s1">p.loc)</span><span class="s2">,</span>
                    <span class="s1">exp: parseInlineCSS(p.value.content</span><span class="s2">, </span><span class="s1">p.loc)</span><span class="s2">,</span>
                    <span class="s1">modifiers: []</span><span class="s2">,</span>
                    <span class="s1">loc: p.loc</span>
                <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">parseInlineCSS = (cssText</span><span class="s2">, </span><span class="s1">loc) =&gt; {</span>
    <span class="s2">const </span><span class="s1">normalized = parseStringStyle(cssText)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">createSimpleExpression(JSON.stringify(normalized)</span><span class="s2">, false, </span><span class="s1">loc</span><span class="s2">, </span><span class="s4">3 </span><span class="s5">/* ConstantTypes.CAN_STRINGIFY */</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">function </span><span class="s1">createDOMCompilerError(code</span><span class="s2">, </span><span class="s1">loc) {</span>
    <span class="s2">return </span><span class="s1">createCompilerError(code</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">DOMErrorMessages )</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">DOMErrorMessages = {</span>
    <span class="s1">[</span><span class="s4">51 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-html is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">52 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */</span><span class="s1">]: </span><span class="s3">`v-html will override element children.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">53 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-text is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">54 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */</span><span class="s1">]: </span><span class="s3">`v-text will override element children.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">55 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */</span><span class="s1">]: </span><span class="s3">`v-model can only be used on &lt;input&gt;, &lt;textarea&gt; and &lt;select&gt; elements.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">56 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */</span><span class="s1">]: </span><span class="s3">`v-model argument is not supported on plain elements.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">57 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */</span><span class="s1">]: </span><span class="s3">`v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">58 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */</span><span class="s1">]: </span><span class="s3">`Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">59 </span><span class="s5">/* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */</span><span class="s1">]: </span><span class="s3">`v-show is missing expression.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">60 </span><span class="s5">/* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */</span><span class="s1">]: </span><span class="s3">`&lt;Transition&gt; expects exactly one child element or component.`</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">61 </span><span class="s5">/* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */</span><span class="s1">]: </span><span class="s3">`Tags with side effect (&lt;script&gt; and &lt;style&gt;) are ignored in client component templates.`</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformVHtml = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ exp</span><span class="s2">, </span><span class="s1">loc } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!exp) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">51 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.children.length) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">52 </span><span class="s5">/* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
        <span class="s1">node.children.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">props: [</span>
            <span class="s1">createObjectProperty(createSimpleExpression(</span><span class="s3">`innerHTML`</span><span class="s2">, true, </span><span class="s1">loc)</span><span class="s2">, </span><span class="s1">exp || createSimpleExpression(</span><span class="s3">''</span><span class="s2">, true</span><span class="s1">))</span>
        <span class="s1">]</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformVText = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ exp</span><span class="s2">, </span><span class="s1">loc } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!exp) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">53 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.children.length) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">54 </span><span class="s5">/* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
        <span class="s1">node.children.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">props: [</span>
            <span class="s1">createObjectProperty(createSimpleExpression(</span><span class="s3">`textContent`</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exp</span>
                <span class="s1">? getConstantType(exp</span><span class="s2">, </span><span class="s1">context) &gt; </span><span class="s4">0</span>
                    <span class="s1">? exp</span>
                    <span class="s1">: createCallExpression(context.helperString(TO_DISPLAY_STRING)</span><span class="s2">, </span><span class="s1">[exp]</span><span class="s2">, </span><span class="s1">loc)</span>
                <span class="s1">: createSimpleExpression(</span><span class="s3">''</span><span class="s2">, true</span><span class="s1">))</span>
        <span class="s1">]</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformModel = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">baseResult = transformModel$1(dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context)</span><span class="s2">;</span>
    <span class="s5">// base transform has errors OR component v-model (only need props)</span>
    <span class="s2">if </span><span class="s1">(!baseResult.props.length || node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">baseResult</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dir.arg) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">56 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */</span><span class="s2">, </span><span class="s1">dir.arg.loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">checkDuplicatedValue() {</span>
        <span class="s2">const </span><span class="s1">value = findProp(node</span><span class="s2">, </span><span class="s3">'value'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(value) {</span>
            <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">58 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */</span><span class="s2">, </span><span class="s1">value.loc))</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ tag } = node</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isCustomElement = context.isCustomElement(tag)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'input' </span><span class="s1">||</span>
        <span class="s1">tag === </span><span class="s3">'textarea' </span><span class="s1">||</span>
        <span class="s1">tag === </span><span class="s3">'select' </span><span class="s1">||</span>
        <span class="s1">isCustomElement) {</span>
        <span class="s2">let </span><span class="s1">directiveToUse = V_MODEL_TEXT</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">isInvalidType = </span><span class="s2">false;</span>
        <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">'input' </span><span class="s1">|| isCustomElement) {</span>
            <span class="s2">const </span><span class="s1">type = findProp(node</span><span class="s2">, </span><span class="s3">`type`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(type) {</span>
                <span class="s2">if </span><span class="s1">(type.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */</span><span class="s1">) {</span>
                    <span class="s5">// :type=&quot;foo&quot;</span>
                    <span class="s1">directiveToUse = V_MODEL_DYNAMIC</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(type.value) {</span>
                    <span class="s2">switch </span><span class="s1">(type.value.content) {</span>
                        <span class="s2">case </span><span class="s3">'radio'</span><span class="s1">:</span>
                            <span class="s1">directiveToUse = V_MODEL_RADIO</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s2">case </span><span class="s3">'checkbox'</span><span class="s1">:</span>
                            <span class="s1">directiveToUse = V_MODEL_CHECKBOX</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s2">case </span><span class="s3">'file'</span><span class="s1">:</span>
                            <span class="s1">isInvalidType = </span><span class="s2">true;</span>
                            <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">57 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s5">// text type</span>
                            <span class="s1">checkDuplicatedValue()</span><span class="s2">;</span>
                            <span class="s2">break;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(hasDynamicKeyVBind(node)) {</span>
                <span class="s5">// element has bindings with dynamic keys, which can possibly contain</span>
                <span class="s5">// &quot;type&quot;.</span>
                <span class="s1">directiveToUse = V_MODEL_DYNAMIC</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s5">// text type</span>
                <span class="s1">checkDuplicatedValue()</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(tag === </span><span class="s3">'select'</span><span class="s1">) {</span>
            <span class="s1">directiveToUse = V_MODEL_SELECT</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// textarea</span>
            <span class="s1">checkDuplicatedValue()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// inject runtime directive</span>
        <span class="s5">// by returning the helper symbol via needRuntime</span>
        <span class="s5">// the import will replaced a resolveDirective call.</span>
        <span class="s2">if </span><span class="s1">(!isInvalidType) {</span>
            <span class="s1">baseResult.needRuntime = context.helper(directiveToUse)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">55 </span><span class="s5">/* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */</span><span class="s2">, </span><span class="s1">dir.loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// native vmodel doesn't need the `modelValue` props since they are also</span>
    <span class="s5">// passed to the runtime as `binding.value`. removing it reduces code size.</span>
    <span class="s1">baseResult.props = baseResult.props.filter(p =&gt; !(p.key.type === </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">p.key.content === </span><span class="s3">'modelValue'</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">baseResult</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">isEventOptionModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">`passive,once,capture`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isNonKeyModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span>
<span class="s5">// event propagation management</span>
<span class="s3">`stop,prevent,self,` </span><span class="s1">+</span>
    <span class="s5">// system modifiers + exact</span>
    <span class="s3">`ctrl,shift,alt,meta,exact,` </span><span class="s1">+</span>
    <span class="s5">// mouse</span>
    <span class="s3">`middle`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s5">// left &amp; right could be mouse or key modifiers based on event type</span>
<span class="s2">const </span><span class="s1">maybeKeyModifier = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">'left,right'</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">isKeyboardEvent = </span><span class="s5">/*#__PURE__*/ </span><span class="s1">makeMap(</span><span class="s3">`onkeyup,onkeydown,onkeypress`</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">resolveModifiers = (key</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">loc) =&gt; {</span>
    <span class="s2">const </span><span class="s1">keyModifiers = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">nonKeyModifiers = []</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">eventOptionModifiers = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; modifiers.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">modifier = modifiers[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isEventOptionModifier(modifier)) {</span>
            <span class="s5">// eventOptionModifiers: modifiers for addEventListener() options,</span>
            <span class="s5">// e.g. .passive &amp; .capture</span>
            <span class="s1">eventOptionModifiers.push(modifier)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s5">// runtimeModifiers: modifiers that needs runtime guards</span>
            <span class="s2">if </span><span class="s1">(maybeKeyModifier(modifier)) {</span>
                <span class="s2">if </span><span class="s1">(isStaticExp(key)) {</span>
                    <span class="s2">if </span><span class="s1">(isKeyboardEvent(key.content)) {</span>
                        <span class="s1">keyModifiers.push(modifier)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">keyModifiers.push(modifier)</span><span class="s2">;</span>
                    <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(isNonKeyModifier(modifier)) {</span>
                    <span class="s1">nonKeyModifiers.push(modifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">keyModifiers.push(modifier)</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">keyModifiers</span><span class="s2">,</span>
        <span class="s1">nonKeyModifiers</span><span class="s2">,</span>
        <span class="s1">eventOptionModifiers</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">transformClick = (key</span><span class="s2">, </span><span class="s1">event) =&gt; {</span>
    <span class="s2">const </span><span class="s1">isStaticClick = isStaticExp(key) &amp;&amp; key.content.toLowerCase() === </span><span class="s3">'onclick'</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">isStaticClick</span>
        <span class="s1">? createSimpleExpression(event</span><span class="s2">, true</span><span class="s1">)</span>
        <span class="s1">: key.type !== </span><span class="s4">4 </span><span class="s5">/* NodeTypes.SIMPLE_EXPRESSION */</span>
            <span class="s1">? createCompoundExpression([</span>
                <span class="s3">`(`</span><span class="s2">,</span>
                <span class="s1">key</span><span class="s2">,</span>
                <span class="s3">`) === &quot;onClick&quot; ? &quot;</span><span class="s1">${event}</span><span class="s3">&quot; : (`</span><span class="s2">,</span>
                <span class="s1">key</span><span class="s2">,</span>
                <span class="s3">`)`</span>
            <span class="s1">])</span>
            <span class="s1">: key</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">transformOn = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">return </span><span class="s1">transformOn$1(dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">baseResult =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ modifiers } = dir</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!modifiers.length)</span>
            <span class="s2">return </span><span class="s1">baseResult</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">{ key</span><span class="s2">, </span><span class="s1">value: handlerExp } = baseResult.props[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ keyModifiers</span><span class="s2">, </span><span class="s1">nonKeyModifiers</span><span class="s2">, </span><span class="s1">eventOptionModifiers } = resolveModifiers(key</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">dir.loc)</span><span class="s2">;</span>
        <span class="s5">// normalize click.right and click.middle since they don't actually fire</span>
        <span class="s2">if </span><span class="s1">(nonKeyModifiers.includes(</span><span class="s3">'right'</span><span class="s1">)) {</span>
            <span class="s1">key = transformClick(key</span><span class="s2">, </span><span class="s3">`onContextmenu`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(nonKeyModifiers.includes(</span><span class="s3">'middle'</span><span class="s1">)) {</span>
            <span class="s1">key = transformClick(key</span><span class="s2">, </span><span class="s3">`onMouseup`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(nonKeyModifiers.length) {</span>
            <span class="s1">handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS)</span><span class="s2">, </span><span class="s1">[</span>
                <span class="s1">handlerExp</span><span class="s2">,</span>
                <span class="s1">JSON.stringify(nonKeyModifiers)</span>
            <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(keyModifiers.length &amp;&amp;</span>
            <span class="s5">// if event name is dynamic, always wrap with keys guard</span>
            <span class="s1">(!isStaticExp(key) || isKeyboardEvent(key.content))) {</span>
            <span class="s1">handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS)</span><span class="s2">, </span><span class="s1">[</span>
                <span class="s1">handlerExp</span><span class="s2">,</span>
                <span class="s1">JSON.stringify(keyModifiers)</span>
            <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(eventOptionModifiers.length) {</span>
            <span class="s2">const </span><span class="s1">modifierPostfix = eventOptionModifiers.map(capitalize).join(</span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">key = isStaticExp(key)</span>
                <span class="s1">? createSimpleExpression(</span><span class="s3">`</span><span class="s1">${key.content}${modifierPostfix}</span><span class="s3">`</span><span class="s2">, true</span><span class="s1">)</span>
                <span class="s1">: createCompoundExpression([</span><span class="s3">`(`</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s3">`) + &quot;</span><span class="s1">${modifierPostfix}</span><span class="s3">&quot;`</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">props: [createObjectProperty(key</span><span class="s2">, </span><span class="s1">handlerExp)]</span>
        <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformShow = (dir</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ exp</span><span class="s2">, </span><span class="s1">loc } = dir</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!exp) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">59 </span><span class="s5">/* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */</span><span class="s2">, </span><span class="s1">loc))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">props: []</span><span class="s2">,</span>
        <span class="s1">needRuntime: context.helper(V_SHOW)</span>
    <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">transformTransition = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.tagType === </span><span class="s4">1 </span><span class="s5">/* ElementTypes.COMPONENT */</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">component = context.isBuiltInComponent(node.tag)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(component === TRANSITION) {</span>
            <span class="s2">return </span><span class="s1">() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(!node.children.length) {</span>
                    <span class="s2">return;</span>
                <span class="s1">}</span>
                <span class="s5">// warn multiple transition children</span>
                <span class="s2">if </span><span class="s1">(hasMultipleChildren(node)) {</span>
                    <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">60 </span><span class="s5">/* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */</span><span class="s2">, </span><span class="s1">{</span>
                        <span class="s1">start: node.children[</span><span class="s4">0</span><span class="s1">].loc.start</span><span class="s2">,</span>
                        <span class="s1">end: node.children[node.children.length - </span><span class="s4">1</span><span class="s1">].loc.end</span><span class="s2">,</span>
                        <span class="s1">source: </span><span class="s3">''</span>
                    <span class="s1">}))</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s5">// check if it's s single child w/ v-show</span>
                <span class="s5">// if yes, inject &quot;persisted: true&quot; to the transition props</span>
                <span class="s2">const </span><span class="s1">child = node.children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(child.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */</span><span class="s1">) {</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">p of child.props) {</span>
                        <span class="s2">if </span><span class="s1">(p.type === </span><span class="s4">7 </span><span class="s5">/* NodeTypes.DIRECTIVE */ </span><span class="s1">&amp;&amp; p.name === </span><span class="s3">'show'</span><span class="s1">) {</span>
                            <span class="s1">node.props.push({</span>
                                <span class="s1">type: </span><span class="s4">6 </span><span class="s5">/* NodeTypes.ATTRIBUTE */</span><span class="s2">,</span>
                                <span class="s1">name: </span><span class="s3">'persisted'</span><span class="s2">,</span>
                                <span class="s1">value: undefined</span><span class="s2">,</span>
                                <span class="s1">loc: node.loc</span>
                            <span class="s1">})</span><span class="s2">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">hasMultipleChildren(node) {</span>
    <span class="s5">// #1352 filter out potential comment nodes.</span>
    <span class="s2">const </span><span class="s1">children = (node.children = node.children.filter(c =&gt; c.type !== </span><span class="s4">3 </span><span class="s5">/* NodeTypes.COMMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!(c.type === </span><span class="s4">2 </span><span class="s5">/* NodeTypes.TEXT */ </span><span class="s1">&amp;&amp; !c.content.trim())))</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(children.length !== </span><span class="s4">1 </span><span class="s1">||</span>
        <span class="s1">child.type === </span><span class="s4">11 </span><span class="s5">/* NodeTypes.FOR */ </span><span class="s1">||</span>
        <span class="s1">(child.type === </span><span class="s4">9 </span><span class="s5">/* NodeTypes.IF */ </span><span class="s1">&amp;&amp; child.branches.some(hasMultipleChildren)))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">ignoreSideEffectTags = (node</span><span class="s2">, </span><span class="s1">context) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(node.type === </span><span class="s4">1 </span><span class="s5">/* NodeTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">node.tagType === </span><span class="s4">0 </span><span class="s5">/* ElementTypes.ELEMENT */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">(node.tag === </span><span class="s3">'script' </span><span class="s1">|| node.tag === </span><span class="s3">'style'</span><span class="s1">)) {</span>
        <span class="s1">context.onError(createDOMCompilerError(</span><span class="s4">61 </span><span class="s5">/* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */</span><span class="s2">, </span><span class="s1">node.loc))</span><span class="s2">;</span>
        <span class="s1">context.removeNode()</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s2">const </span><span class="s1">DOMNodeTransforms = [</span>
    <span class="s1">transformStyle</span><span class="s2">,</span>
    <span class="s1">...([transformTransition] )</span>
<span class="s1">]</span><span class="s2">;</span>
<span class="s2">const </span><span class="s1">DOMDirectiveTransforms = {</span>
    <span class="s1">cloak: noopDirectiveTransform</span><span class="s2">,</span>
    <span class="s1">html: transformVHtml</span><span class="s2">,</span>
    <span class="s1">text: transformVText</span><span class="s2">,</span>
    <span class="s1">model: transformModel</span><span class="s2">,</span>
    <span class="s1">on: transformOn</span><span class="s2">,</span>
    <span class="s1">show: transformShow</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">compile(template</span><span class="s2">, </span><span class="s1">options = {}) {</span>
    <span class="s2">return </span><span class="s1">baseCompile(template</span><span class="s2">, </span><span class="s1">extend({}</span><span class="s2">, </span><span class="s1">parserOptions</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">nodeTransforms: [</span>
            <span class="s5">// ignore &lt;script&gt; and &lt;tag&gt;</span>
            <span class="s5">// this is not put inside DOMNodeTransforms because that list is used</span>
            <span class="s5">// by compiler-ssr to generate vnode fallback branches</span>
            <span class="s1">ignoreSideEffectTags</span><span class="s2">,</span>
            <span class="s1">...DOMNodeTransforms</span><span class="s2">,</span>
            <span class="s1">...(options.nodeTransforms || [])</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">directiveTransforms: extend({}</span><span class="s2">, </span><span class="s1">DOMDirectiveTransforms</span><span class="s2">, </span><span class="s1">options.directiveTransforms || {})</span><span class="s2">,</span>
        <span class="s1">transformHoist: </span><span class="s2">null </span>
    <span class="s1">}))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s5">// This entry is the &quot;full-build&quot; that includes both the runtime</span>
<span class="s1">{</span>
    <span class="s1">initDev()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">compileCache = Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">compileToFunction(template</span><span class="s2">, </span><span class="s1">options) {</span>
    <span class="s2">if </span><span class="s1">(!isString(template)) {</span>
        <span class="s2">if </span><span class="s1">(template.nodeType) {</span>
            <span class="s1">template = template.innerHTML</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">warn(</span><span class="s3">`invalid template option: `</span><span class="s2">, </span><span class="s1">template)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">NOOP</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">key = template</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">cached = compileCache[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cached) {</span>
        <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(template[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'#'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">el = document.querySelector(template)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!el) {</span>
            <span class="s1">warn(</span><span class="s3">`Template element not found or is empty: </span><span class="s1">${template}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s5">// __UNSAFE__</span>
        <span class="s5">// Reason: potential execution of JS expressions in in-DOM template.</span>
        <span class="s5">// The user must make sure the in-DOM template is trusted. If it's rendered</span>
        <span class="s5">// by the server, the template should not contain any user data.</span>
        <span class="s1">template = el ? el.innerHTML : </span><span class="s3">``</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">opts = extend({</span>
        <span class="s1">hoistStatic: </span><span class="s2">true,</span>
        <span class="s1">onError: onError </span><span class="s2">,</span>
        <span class="s1">onWarn: e =&gt; onError(e</span><span class="s2">, true</span><span class="s1">) </span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!opts.isCustomElement &amp;&amp; </span><span class="s2">typeof </span><span class="s1">customElements !== </span><span class="s3">'undefined'</span><span class="s1">) {</span>
        <span class="s1">opts.isCustomElement = tag =&gt; !!customElements.get(tag)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ code } = compile(template</span><span class="s2">, </span><span class="s1">opts)</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">onError(err</span><span class="s2">, </span><span class="s1">asWarning = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">message = asWarning</span>
            <span class="s1">? err.message</span>
            <span class="s1">: </span><span class="s3">`Template compilation error: </span><span class="s1">${err.message}</span><span class="s3">`</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">codeFrame = err.loc &amp;&amp;</span>
            <span class="s1">generateCodeFrame(template</span><span class="s2">, </span><span class="s1">err.loc.start.offset</span><span class="s2">, </span><span class="s1">err.loc.end.offset)</span><span class="s2">;</span>
        <span class="s1">warn(codeFrame ? </span><span class="s3">`</span><span class="s1">${message}</span><span class="s2">\n</span><span class="s1">${codeFrame}</span><span class="s3">` </span><span class="s1">: message)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s5">// The wildcard import results in a huge object with every export</span>
    <span class="s5">// with keys that cannot be mangled, and can be quite heavy size-wise.</span>
    <span class="s5">// In the global build we know `Vue` is available globally so we can avoid</span>
    <span class="s5">// the wildcard object.</span>
    <span class="s2">const </span><span class="s1">render = (</span><span class="s2">new </span><span class="s1">Function(</span><span class="s3">'Vue'</span><span class="s2">, </span><span class="s1">code)(runtimeDom))</span><span class="s2">;</span>
    <span class="s1">render._rc = </span><span class="s2">true;</span>
    <span class="s2">return </span><span class="s1">(compileCache[key] = render)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s1">registerRuntimeCompiler(compileToFunction)</span><span class="s2">;</span>

<span class="s2">export </span><span class="s1">{ BaseTransition</span><span class="s2">, </span><span class="s1">Comment</span><span class="s2">, </span><span class="s1">EffectScope</span><span class="s2">, </span><span class="s1">Fragment</span><span class="s2">, </span><span class="s1">KeepAlive</span><span class="s2">, </span><span class="s1">ReactiveEffect</span><span class="s2">, </span><span class="s1">Static</span><span class="s2">, </span><span class="s1">Suspense</span><span class="s2">, </span><span class="s1">Teleport</span><span class="s2">, </span><span class="s1">Text</span><span class="s2">, </span><span class="s1">Transition</span><span class="s2">, </span><span class="s1">TransitionGroup</span><span class="s2">, </span><span class="s1">VueElement</span><span class="s2">, </span><span class="s1">assertNumber</span><span class="s2">, </span><span class="s1">callWithAsyncErrorHandling</span><span class="s2">, </span><span class="s1">callWithErrorHandling</span><span class="s2">, </span><span class="s1">camelize</span><span class="s2">, </span><span class="s1">capitalize</span><span class="s2">, </span><span class="s1">cloneVNode</span><span class="s2">, </span><span class="s1">compatUtils</span><span class="s2">, </span><span class="s1">compileToFunction as compile</span><span class="s2">, </span><span class="s1">computed</span><span class="s2">, </span><span class="s1">createApp</span><span class="s2">, </span><span class="s1">createBlock</span><span class="s2">, </span><span class="s1">createCommentVNode</span><span class="s2">, </span><span class="s1">createElementBlock</span><span class="s2">, </span><span class="s1">createBaseVNode as createElementVNode</span><span class="s2">, </span><span class="s1">createHydrationRenderer</span><span class="s2">, </span><span class="s1">createPropsRestProxy</span><span class="s2">, </span><span class="s1">createRenderer</span><span class="s2">, </span><span class="s1">createSSRApp</span><span class="s2">, </span><span class="s1">createSlots</span><span class="s2">, </span><span class="s1">createStaticVNode</span><span class="s2">, </span><span class="s1">createTextVNode</span><span class="s2">, </span><span class="s1">createVNode</span><span class="s2">, </span><span class="s1">customRef</span><span class="s2">, </span><span class="s1">defineAsyncComponent</span><span class="s2">, </span><span class="s1">defineComponent</span><span class="s2">, </span><span class="s1">defineCustomElement</span><span class="s2">, </span><span class="s1">defineEmits</span><span class="s2">, </span><span class="s1">defineExpose</span><span class="s2">, </span><span class="s1">defineProps</span><span class="s2">, </span><span class="s1">defineSSRCustomElement</span><span class="s2">, </span><span class="s1">devtools</span><span class="s2">, </span><span class="s1">effect</span><span class="s2">, </span><span class="s1">effectScope</span><span class="s2">, </span><span class="s1">getCurrentInstance</span><span class="s2">, </span><span class="s1">getCurrentScope</span><span class="s2">, </span><span class="s1">getTransitionRawChildren</span><span class="s2">, </span><span class="s1">guardReactiveProps</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">handleError</span><span class="s2">, </span><span class="s1">hydrate</span><span class="s2">, </span><span class="s1">initCustomFormatter</span><span class="s2">, </span><span class="s1">initDirectivesForSSR</span><span class="s2">, </span><span class="s1">inject</span><span class="s2">, </span><span class="s1">isMemoSame</span><span class="s2">, </span><span class="s1">isProxy</span><span class="s2">, </span><span class="s1">isReactive</span><span class="s2">, </span><span class="s1">isReadonly</span><span class="s2">, </span><span class="s1">isRef</span><span class="s2">, </span><span class="s1">isRuntimeOnly</span><span class="s2">, </span><span class="s1">isShallow</span><span class="s2">, </span><span class="s1">isVNode</span><span class="s2">, </span><span class="s1">markRaw</span><span class="s2">, </span><span class="s1">mergeDefaults</span><span class="s2">, </span><span class="s1">mergeProps</span><span class="s2">, </span><span class="s1">nextTick</span><span class="s2">, </span><span class="s1">normalizeClass</span><span class="s2">, </span><span class="s1">normalizeProps</span><span class="s2">, </span><span class="s1">normalizeStyle</span><span class="s2">, </span><span class="s1">onActivated</span><span class="s2">, </span><span class="s1">onBeforeMount</span><span class="s2">, </span><span class="s1">onBeforeUnmount</span><span class="s2">, </span><span class="s1">onBeforeUpdate</span><span class="s2">, </span><span class="s1">onDeactivated</span><span class="s2">, </span><span class="s1">onErrorCaptured</span><span class="s2">, </span><span class="s1">onMounted</span><span class="s2">, </span><span class="s1">onRenderTracked</span><span class="s2">, </span><span class="s1">onRenderTriggered</span><span class="s2">, </span><span class="s1">onScopeDispose</span><span class="s2">, </span><span class="s1">onServerPrefetch</span><span class="s2">, </span><span class="s1">onUnmounted</span><span class="s2">, </span><span class="s1">onUpdated</span><span class="s2">, </span><span class="s1">openBlock</span><span class="s2">, </span><span class="s1">popScopeId</span><span class="s2">, </span><span class="s1">provide</span><span class="s2">, </span><span class="s1">proxyRefs</span><span class="s2">, </span><span class="s1">pushScopeId</span><span class="s2">, </span><span class="s1">queuePostFlushCb</span><span class="s2">, </span><span class="s1">reactive</span><span class="s2">, </span><span class="s1">readonly</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">registerRuntimeCompiler</span><span class="s2">, </span><span class="s1">render</span><span class="s2">, </span><span class="s1">renderList</span><span class="s2">, </span><span class="s1">renderSlot</span><span class="s2">, </span><span class="s1">resolveComponent</span><span class="s2">, </span><span class="s1">resolveDirective</span><span class="s2">, </span><span class="s1">resolveDynamicComponent</span><span class="s2">, </span><span class="s1">resolveFilter</span><span class="s2">, </span><span class="s1">resolveTransitionHooks</span><span class="s2">, </span><span class="s1">setBlockTracking</span><span class="s2">, </span><span class="s1">setDevtoolsHook</span><span class="s2">, </span><span class="s1">setTransitionHooks</span><span class="s2">, </span><span class="s1">shallowReactive</span><span class="s2">, </span><span class="s1">shallowReadonly</span><span class="s2">, </span><span class="s1">shallowRef</span><span class="s2">, </span><span class="s1">ssrContextKey</span><span class="s2">, </span><span class="s1">ssrUtils</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">toDisplayString</span><span class="s2">, </span><span class="s1">toHandlerKey</span><span class="s2">, </span><span class="s1">toHandlers</span><span class="s2">, </span><span class="s1">toRaw</span><span class="s2">, </span><span class="s1">toRef</span><span class="s2">, </span><span class="s1">toRefs</span><span class="s2">, </span><span class="s1">transformVNodeArgs</span><span class="s2">, </span><span class="s1">triggerRef</span><span class="s2">, </span><span class="s1">unref</span><span class="s2">, </span><span class="s1">useAttrs</span><span class="s2">, </span><span class="s1">useCssModule</span><span class="s2">, </span><span class="s1">useCssVars</span><span class="s2">, </span><span class="s1">useSSRContext</span><span class="s2">, </span><span class="s1">useSlots</span><span class="s2">, </span><span class="s1">useTransitionState</span><span class="s2">, </span><span class="s1">vModelCheckbox</span><span class="s2">, </span><span class="s1">vModelDynamic</span><span class="s2">, </span><span class="s1">vModelRadio</span><span class="s2">, </span><span class="s1">vModelSelect</span><span class="s2">, </span><span class="s1">vModelText</span><span class="s2">, </span><span class="s1">vShow</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">, </span><span class="s1">watch</span><span class="s2">, </span><span class="s1">watchEffect</span><span class="s2">, </span><span class="s1">watchPostEffect</span><span class="s2">, </span><span class="s1">watchSyncEffect</span><span class="s2">, </span><span class="s1">withAsyncContext</span><span class="s2">, </span><span class="s1">withCtx</span><span class="s2">, </span><span class="s1">withDefaults</span><span class="s2">, </span><span class="s1">withDirectives</span><span class="s2">, </span><span class="s1">withKeys</span><span class="s2">, </span><span class="s1">withMemo</span><span class="s2">, </span><span class="s1">withModifiers</span><span class="s2">, </span><span class="s1">withScopeId }</span><span class="s2">;</span>
</pre>
</body>
</html>