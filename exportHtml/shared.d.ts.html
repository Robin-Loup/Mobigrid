<html>
<head>
<title>shared.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #629755; font-weight: bold; font-style: italic;}
.s2 { color: #a9b7c6;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
shared.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">camelize: (str: string) =&gt; string</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">capitalize: (str: string) =&gt; string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">def: (obj: object</span><span class="s3">, </span><span class="s2">key: string | symbol</span><span class="s3">, </span><span class="s2">value: any) =&gt; </span><span class="s3">void;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">EMPTY_ARR: readonly never[]</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">EMPTY_OBJ: {</span>
    <span class="s2">readonly [key: string]: any</span><span class="s3">;</span>
<span class="s2">}</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">escapeHtml(string: unknown): string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">escapeHtmlComment(src: string): string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">extend: {</span>
    <span class="s2">&lt;T </span><span class="s3">extends </span><span class="s2">{}</span><span class="s3">, </span><span class="s2">U&gt;(target: T</span><span class="s3">, </span><span class="s2">source: U): T &amp; U</span><span class="s3">;</span>
    <span class="s2">&lt;T_1 </span><span class="s3">extends </span><span class="s2">{}</span><span class="s3">, </span><span class="s2">U_1</span><span class="s3">, </span><span class="s2">V&gt;(target: T_1</span><span class="s3">, </span><span class="s2">source1: U_1</span><span class="s3">, </span><span class="s2">source2: V): T_1 &amp; U_1 &amp; V</span><span class="s3">;</span>
    <span class="s2">&lt;T_2 </span><span class="s3">extends </span><span class="s2">{}</span><span class="s3">, </span><span class="s2">U_2</span><span class="s3">, </span><span class="s2">V_1</span><span class="s3">, </span><span class="s2">W&gt;(target: T_2</span><span class="s3">, </span><span class="s2">source1: U_2</span><span class="s3">, </span><span class="s2">source2: V_1</span><span class="s3">, </span><span class="s2">source3: W): T_2 &amp; U_2 &amp; V_1 &amp; W</span><span class="s3">;</span>
    <span class="s2">(target: object</span><span class="s3">, </span><span class="s2">...sources: any[]): any</span><span class="s3">;</span>
<span class="s2">}</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">generateCodeFrame(source: string</span><span class="s3">, </span><span class="s2">start?: number</span><span class="s3">, </span><span class="s2">end?: number): string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">genPropsAccessExp(name: string): string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">getGlobalThis: () =&gt; any</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">hasChanged: (value: any</span><span class="s3">, </span><span class="s2">oldValue: any) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">hasOwn: (val: object</span><span class="s3">, </span><span class="s2">key: string | symbol) =&gt; key is never</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">hyphenate: (str: string) =&gt; string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare type IfAny&lt;T</span><span class="s3">, </span><span class="s2">Y</span><span class="s3">, </span><span class="s2">N&gt; = </span><span class="s4">0 </span><span class="s3">extends </span><span class="s4">1 </span><span class="s2">&amp; T ? Y : N</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Boolean attributes should be included if the value is truthy or ''.</span>
 <span class="s0">* e.g. `&lt;select multiple&gt;` compiles to `{ multiple: '' }`</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">includeBooleanAttr(value: unknown): boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">invokeArrayFns: (fns: Function[]</span><span class="s3">, </span><span class="s2">arg?: any) =&gt; </span><span class="s3">void;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isArray: (arg: any) =&gt; arg is any[]</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* The full list is needed during SSR to produce the correct initial markup.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isBooleanAttr: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isBuiltInDirective: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isDate: (val: unknown) =&gt; val is Date</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isFunction: (val: unknown) =&gt; val is Function</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isGloballyWhitelisted: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `__DEV__` flag.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isHTMLTag: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isIntegerKey: (key: unknown) =&gt; boolean</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Known attributes, this is used for stringification of runtime static nodes</span>
 <span class="s0">* so that we don't stringify bindings that cannot be set from HTML.</span>
 <span class="s0">* Don't also forget to allow `data-*` and `aria-*`!</span>
 <span class="s0">* Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isKnownHtmlAttr: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isKnownSvgAttr: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isMap: (val: unknown) =&gt; val is Map&lt;any</span><span class="s3">, </span><span class="s2">any&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isModelListener: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isObject: (val: unknown) =&gt; val is Record&lt;any</span><span class="s3">, </span><span class="s2">any&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isOn: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isPlainObject: (val: unknown) =&gt; val is object</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isPromise: &lt;T = any&gt;(val: unknown) =&gt; val is Promise&lt;T&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isRegExp: (val: unknown) =&gt; val is RegExp</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isReservedProp: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isSet: (val: unknown) =&gt; val is Set&lt;any&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isSpecialBooleanAttr: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">isSSRSafeAttrName(name: string): boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isString: (val: unknown) =&gt; val is string</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `__DEV__` flag.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isSVGTag: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isSymbol: (val: unknown) =&gt; val is symbol</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Compiler only.</span>
 <span class="s0">* Do NOT use in runtime code paths unless behind `__DEV__` flag.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">isVoidTag: (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">looseEqual(a: any</span><span class="s3">, </span><span class="s2">b: any): boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">looseIndexOf(arr: any[]</span><span class="s3">, </span><span class="s2">val: any): number</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare type LooseRequired&lt;T&gt; = {</span>
    <span class="s2">[P </span><span class="s3">in </span><span class="s2">keyof (T &amp; Required&lt;T&gt;)]: T[P]</span><span class="s3">;</span>
<span class="s2">}</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* &quot;123-foo&quot; will be parsed to 123</span>
 <span class="s0">* This is used for the .number modifier in v-model</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">looseToNumber: (val: any) =&gt; any</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Make a map and return a function for checking if a key</span>
 <span class="s0">* is in that map.</span>
 <span class="s0">* IMPORTANT: all calls of this function must be prefixed with</span>
 <span class="s0">* \/\*#\_\_PURE\_\_\*\/</span>
 <span class="s0">* So that rollup can tree-shake them if necessary.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">makeMap(str: string</span><span class="s3">, </span><span class="s2">expectsLowerCase?: boolean): (key: string) =&gt; boolean</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Always return false.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">NO: () =&gt; boolean</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">NOOP: () =&gt; </span><span class="s3">void;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">normalizeClass(value: unknown): string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare type NormalizedStyle = Record&lt;string</span><span class="s3">, </span><span class="s2">string | number&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">normalizeProps(props: Record&lt;string</span><span class="s3">, </span><span class="s2">any&gt; | </span><span class="s3">null</span><span class="s2">): Record&lt;string</span><span class="s3">, </span><span class="s2">any&gt; | </span><span class="s3">null;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">normalizeStyle(value: unknown): NormalizedStyle | string | undefined</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">objectToString: () =&gt; string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">parseStringStyle(cssText: string): NormalizedStyle</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* dev only flag -&gt; name mapping</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">PatchFlagNames: {</span>
    <span class="s2">[x: number]: string</span><span class="s3">;</span>
<span class="s2">}</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Patch flags are optimization hints generated by the compiler.</span>
 <span class="s0">* when a block with dynamicChildren is encountered during diff, the algorithm</span>
 <span class="s0">* enters &quot;optimized mode&quot;. In this mode, we know that the vdom is produced by</span>
 <span class="s0">* a render function generated by the compiler, so the algorithm only needs to</span>
 <span class="s0">* handle updates explicitly marked by these patch flags.</span>
 <span class="s0">*</span>
 <span class="s0">* Patch flags can be combined using the | bitwise operator and can be checked</span>
 <span class="s0">* using the &amp; operator, e.g.</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* const flag = TEXT | CLASS</span>
 <span class="s0">* if (flag &amp; TEXT) { ... }</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the</span>
 <span class="s0">* flags are handled during diff.</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const enum </span><span class="s2">PatchFlags {</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element with dynamic textContent (children fast path)</span>
     <span class="s0">*/</span>
    <span class="s2">TEXT = </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element with dynamic class binding.</span>
     <span class="s0">*/</span>
    <span class="s2">CLASS = </span><span class="s4">2</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element with dynamic style</span>
     <span class="s0">* The compiler pre-compiles static string styles into static objects</span>
     <span class="s0">* + detects and hoists inline static objects</span>
     <span class="s0">* e.g. `style=&quot;color: red&quot;` and `:style=&quot;{ color: 'red' }&quot;` both get hoisted</span>
     <span class="s0">* as:</span>
     <span class="s0">* ```js</span>
     <span class="s0">* const style = { color: 'red' }</span>
     <span class="s0">* render() { return e('div', { style }) }</span>
     <span class="s0">* ```</span>
     <span class="s0">*/</span>
    <span class="s2">STYLE = </span><span class="s4">4</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element that has non-class/style dynamic props.</span>
     <span class="s0">* Can also be on a component that has any dynamic props (includes</span>
     <span class="s0">* class/style). when this flag is present, the vnode also has a dynamicProps</span>
     <span class="s0">* array that contains the keys of the props that may change so the runtime</span>
     <span class="s0">* can diff them faster (without having to worry about removed props)</span>
     <span class="s0">*/</span>
    <span class="s2">PROPS = </span><span class="s4">8</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element with props with dynamic keys. When keys change, a full</span>
     <span class="s0">* diff is always needed to remove the old key. This flag is mutually</span>
     <span class="s0">* exclusive with CLASS, STYLE and PROPS.</span>
     <span class="s0">*/</span>
    <span class="s2">FULL_PROPS = </span><span class="s4">16</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element with event listeners (which need to be attached</span>
     <span class="s0">* during hydration)</span>
     <span class="s0">*/</span>
    <span class="s2">HYDRATE_EVENTS = </span><span class="s4">32</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a fragment whose children order doesn't change.</span>
     <span class="s0">*/</span>
    <span class="s2">STABLE_FRAGMENT = </span><span class="s4">64</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a fragment with keyed or partially keyed children</span>
     <span class="s0">*/</span>
    <span class="s2">KEYED_FRAGMENT = </span><span class="s4">128</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a fragment with unkeyed children.</span>
     <span class="s0">*/</span>
    <span class="s2">UNKEYED_FRAGMENT = </span><span class="s4">256</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates an element that only needs non-props patching, e.g. ref or</span>
     <span class="s0">* directives (onVnodeXXX hooks). since every patched vnode checks for refs</span>
     <span class="s0">* and onVnodeXXX hooks, it simply marks the vnode so that a parent block</span>
     <span class="s0">* will track it.</span>
     <span class="s0">*/</span>
    <span class="s2">NEED_PATCH = </span><span class="s4">512</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a component with dynamic slots (e.g. slot that references a v-for</span>
     <span class="s0">* iterated value, or dynamic slot names).</span>
     <span class="s0">* Components with this flag are always force updated.</span>
     <span class="s0">*/</span>
    <span class="s2">DYNAMIC_SLOTS = </span><span class="s4">1024</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a fragment that was created only because the user has placed</span>
     <span class="s0">* comments at the root level of a template. This is a dev-only flag since</span>
     <span class="s0">* comments are stripped in production.</span>
     <span class="s0">*/</span>
    <span class="s2">DEV_ROOT_FRAGMENT = </span><span class="s4">2048</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* SPECIAL FLAGS -------------------------------------------------------------</span>
     <span class="s0">* Special flags are negative integers. They are never matched against using</span>
     <span class="s0">* bitwise operators (bitwise matching should only happen in branches where</span>
     <span class="s0">* patchFlag &gt; 0), and are mutually exclusive. When checking for a special</span>
     <span class="s0">* flag, simply check patchFlag === FLAG.</span>
     <span class="s0">*/</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates a hoisted static vnode. This is a hint for hydration to skip</span>
     <span class="s0">* the entire sub tree since static content never needs to be updated.</span>
     <span class="s0">*/</span>
    <span class="s2">HOISTED = -</span><span class="s4">1</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* A special flag that indicates that the diffing algorithm should bail out</span>
     <span class="s0">* of optimized mode. For example, on block fragments created by renderSlot()</span>
     <span class="s0">* when encountering non-compiler generated slots (i.e. manually written</span>
     <span class="s0">* render functions, which should always be fully diffed)</span>
     <span class="s0">* OR manually cloneVNodes</span>
     <span class="s0">*/</span>
    <span class="s2">BAIL = -</span><span class="s4">2</span>
<span class="s2">}</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">propsToAttrMap: Record&lt;string</span><span class="s3">, </span><span class="s2">string | undefined&gt;</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">remove: &lt;T&gt;(arr: T[]</span><span class="s3">, </span><span class="s2">el: T) =&gt; </span><span class="s3">void;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const enum </span><span class="s2">ShapeFlags {</span>
    <span class="s2">ELEMENT = </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s2">FUNCTIONAL_COMPONENT = </span><span class="s4">2</span><span class="s3">,</span>
    <span class="s2">STATEFUL_COMPONENT = </span><span class="s4">4</span><span class="s3">,</span>
    <span class="s2">TEXT_CHILDREN = </span><span class="s4">8</span><span class="s3">,</span>
    <span class="s2">ARRAY_CHILDREN = </span><span class="s4">16</span><span class="s3">,</span>
    <span class="s2">SLOTS_CHILDREN = </span><span class="s4">32</span><span class="s3">,</span>
    <span class="s2">TELEPORT = </span><span class="s4">64</span><span class="s3">,</span>
    <span class="s2">SUSPENSE = </span><span class="s4">128</span><span class="s3">,</span>
    <span class="s2">COMPONENT_SHOULD_KEEP_ALIVE = </span><span class="s4">256</span><span class="s3">,</span>
    <span class="s2">COMPONENT_KEPT_ALIVE = </span><span class="s4">512</span><span class="s3">,</span>
    <span class="s2">COMPONENT = </span><span class="s4">6</span>
<span class="s2">}</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const enum </span><span class="s2">SlotFlags {</span>
    <span class="s0">/**</span>
     <span class="s0">* Stable slots that only reference slot props or context state. The slot</span>
     <span class="s0">* can fully capture its own dependencies so when passed down the parent won't</span>
     <span class="s0">* need to force the child to update.</span>
     <span class="s0">*/</span>
    <span class="s2">STABLE = </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* Slots that reference scope variables (v-for or an outer slot prop), or</span>
     <span class="s0">* has conditional structure (v-if, v-for). The parent will need to force</span>
     <span class="s0">* the child to update because the slot does not fully capture its dependencies.</span>
     <span class="s0">*/</span>
    <span class="s2">DYNAMIC = </span><span class="s4">2</span><span class="s3">,</span>
    <span class="s0">/**</span>
     <span class="s0">* `&lt;slot/&gt;` being forwarded into a child component. Whether the parent needs</span>
     <span class="s0">* to update the child is dependent on what kind of slots the parent itself</span>
     <span class="s0">* received. This has to be refined at runtime, when the child's vnode</span>
     <span class="s0">* is being created (in `normalizeChildren`)</span>
     <span class="s0">*/</span>
    <span class="s2">FORWARDED = </span><span class="s4">3</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Dev only</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">slotFlagsText: {</span>
    <span class="s4">1</span><span class="s2">: string</span><span class="s3">;</span>
    <span class="s4">2</span><span class="s2">: string</span><span class="s3">;</span>
    <span class="s4">3</span><span class="s2">: string</span><span class="s3">;</span>
<span class="s2">}</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">function </span><span class="s2">stringifyStyle(styles: NormalizedStyle | string | undefined): string</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* For converting {{ interpolation }} values to displayed strings.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">toDisplayString: (val: unknown) =&gt; string</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">toHandlerKey: (str: string) =&gt; string</span><span class="s3">;</span>

<span class="s0">/**</span>
 <span class="s0">* Only conerces number-like strings</span>
 <span class="s0">* &quot;123-foo&quot; will be returned as-is</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">toNumber: (val: any) =&gt; any</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">toRawType: (value: unknown) =&gt; string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare </span><span class="s3">const </span><span class="s2">toTypeString: (value: unknown) =&gt; string</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">declare type UnionToIntersection&lt;U&gt; = (U </span><span class="s3">extends </span><span class="s2">any ? (k: U) =&gt; </span><span class="s3">void </span><span class="s2">: never) </span><span class="s3">extends </span><span class="s2">(k: infer I) =&gt; </span><span class="s3">void </span><span class="s2">? I : never</span><span class="s3">;</span>

<span class="s3">export </span><span class="s2">{ }</span>
</pre>
</body>
</html>